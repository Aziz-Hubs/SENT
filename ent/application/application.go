// Code generated by ent, DO NOT EDIT.

package application

import (
	"fmt"
	"time"

	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
)

const (
	// Label holds the string label denoting the application type in the database.
	Label = "application"
	// FieldID holds the string denoting the id field in the database.
	FieldID = "id"
	// FieldStatus holds the string denoting the status field in the database.
	FieldStatus = "status"
	// FieldAppliedAt holds the string denoting the applied_at field in the database.
	FieldAppliedAt = "applied_at"
	// FieldUpdatedAt holds the string denoting the updated_at field in the database.
	FieldUpdatedAt = "updated_at"
	// EdgeTenant holds the string denoting the tenant edge name in mutations.
	EdgeTenant = "tenant"
	// EdgeJobPosting holds the string denoting the job_posting edge name in mutations.
	EdgeJobPosting = "job_posting"
	// EdgeCandidate holds the string denoting the candidate edge name in mutations.
	EdgeCandidate = "candidate"
	// EdgeInterviews holds the string denoting the interviews edge name in mutations.
	EdgeInterviews = "interviews"
	// Table holds the table name of the application in the database.
	Table = "applications"
	// TenantTable is the table that holds the tenant relation/edge.
	TenantTable = "applications"
	// TenantInverseTable is the table name for the Tenant entity.
	// It exists in this package in order to avoid circular dependency with the "tenant" package.
	TenantInverseTable = "tenants"
	// TenantColumn is the table column denoting the tenant relation/edge.
	TenantColumn = "tenant_applications"
	// JobPostingTable is the table that holds the job_posting relation/edge.
	JobPostingTable = "applications"
	// JobPostingInverseTable is the table name for the JobPosting entity.
	// It exists in this package in order to avoid circular dependency with the "jobposting" package.
	JobPostingInverseTable = "job_postings"
	// JobPostingColumn is the table column denoting the job_posting relation/edge.
	JobPostingColumn = "job_posting_applications"
	// CandidateTable is the table that holds the candidate relation/edge.
	CandidateTable = "applications"
	// CandidateInverseTable is the table name for the Candidate entity.
	// It exists in this package in order to avoid circular dependency with the "candidate" package.
	CandidateInverseTable = "candidates"
	// CandidateColumn is the table column denoting the candidate relation/edge.
	CandidateColumn = "candidate_applications"
	// InterviewsTable is the table that holds the interviews relation/edge.
	InterviewsTable = "interviews"
	// InterviewsInverseTable is the table name for the Interview entity.
	// It exists in this package in order to avoid circular dependency with the "interview" package.
	InterviewsInverseTable = "interviews"
	// InterviewsColumn is the table column denoting the interviews relation/edge.
	InterviewsColumn = "application_interviews"
)

// Columns holds all SQL columns for application fields.
var Columns = []string{
	FieldID,
	FieldStatus,
	FieldAppliedAt,
	FieldUpdatedAt,
}

// ForeignKeys holds the SQL foreign-keys that are owned by the "applications"
// table and are not defined as standalone fields in the schema.
var ForeignKeys = []string{
	"candidate_applications",
	"job_posting_applications",
	"tenant_applications",
}

// ValidColumn reports if the column name is valid (part of the table columns).
func ValidColumn(column string) bool {
	for i := range Columns {
		if column == Columns[i] {
			return true
		}
	}
	for i := range ForeignKeys {
		if column == ForeignKeys[i] {
			return true
		}
	}
	return false
}

var (
	// DefaultAppliedAt holds the default value on creation for the "applied_at" field.
	DefaultAppliedAt func() time.Time
	// DefaultUpdatedAt holds the default value on creation for the "updated_at" field.
	DefaultUpdatedAt func() time.Time
	// UpdateDefaultUpdatedAt holds the default value on update for the "updated_at" field.
	UpdateDefaultUpdatedAt func() time.Time
)

// Status defines the type for the "status" enum field.
type Status string

// StatusNEW is the default value of the Status enum.
const DefaultStatus = StatusNEW

// Status values.
const (
	StatusNEW          Status = "NEW"
	StatusSCREENING    Status = "SCREENING"
	StatusINTERVIEWING Status = "INTERVIEWING"
	StatusOFFER        Status = "OFFER"
	StatusHIRED        Status = "HIRED"
	StatusREJECTED     Status = "REJECTED"
)

func (s Status) String() string {
	return string(s)
}

// StatusValidator is a validator for the "status" field enum values. It is called by the builders before save.
func StatusValidator(s Status) error {
	switch s {
	case StatusNEW, StatusSCREENING, StatusINTERVIEWING, StatusOFFER, StatusHIRED, StatusREJECTED:
		return nil
	default:
		return fmt.Errorf("application: invalid enum value for status field: %q", s)
	}
}

// OrderOption defines the ordering options for the Application queries.
type OrderOption func(*sql.Selector)

// ByID orders the results by the id field.
func ByID(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldID, opts...).ToFunc()
}

// ByStatus orders the results by the status field.
func ByStatus(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldStatus, opts...).ToFunc()
}

// ByAppliedAt orders the results by the applied_at field.
func ByAppliedAt(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldAppliedAt, opts...).ToFunc()
}

// ByUpdatedAt orders the results by the updated_at field.
func ByUpdatedAt(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldUpdatedAt, opts...).ToFunc()
}

// ByTenantField orders the results by tenant field.
func ByTenantField(field string, opts ...sql.OrderTermOption) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborTerms(s, newTenantStep(), sql.OrderByField(field, opts...))
	}
}

// ByJobPostingField orders the results by job_posting field.
func ByJobPostingField(field string, opts ...sql.OrderTermOption) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborTerms(s, newJobPostingStep(), sql.OrderByField(field, opts...))
	}
}

// ByCandidateField orders the results by candidate field.
func ByCandidateField(field string, opts ...sql.OrderTermOption) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborTerms(s, newCandidateStep(), sql.OrderByField(field, opts...))
	}
}

// ByInterviewsCount orders the results by interviews count.
func ByInterviewsCount(opts ...sql.OrderTermOption) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborsCount(s, newInterviewsStep(), opts...)
	}
}

// ByInterviews orders the results by interviews terms.
func ByInterviews(term sql.OrderTerm, terms ...sql.OrderTerm) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborTerms(s, newInterviewsStep(), append([]sql.OrderTerm{term}, terms...)...)
	}
}
func newTenantStep() *sqlgraph.Step {
	return sqlgraph.NewStep(
		sqlgraph.From(Table, FieldID),
		sqlgraph.To(TenantInverseTable, FieldID),
		sqlgraph.Edge(sqlgraph.M2O, true, TenantTable, TenantColumn),
	)
}
func newJobPostingStep() *sqlgraph.Step {
	return sqlgraph.NewStep(
		sqlgraph.From(Table, FieldID),
		sqlgraph.To(JobPostingInverseTable, FieldID),
		sqlgraph.Edge(sqlgraph.M2O, true, JobPostingTable, JobPostingColumn),
	)
}
func newCandidateStep() *sqlgraph.Step {
	return sqlgraph.NewStep(
		sqlgraph.From(Table, FieldID),
		sqlgraph.To(CandidateInverseTable, FieldID),
		sqlgraph.Edge(sqlgraph.M2O, true, CandidateTable, CandidateColumn),
	)
}
func newInterviewsStep() *sqlgraph.Step {
	return sqlgraph.NewStep(
		sqlgraph.From(Table, FieldID),
		sqlgraph.To(InterviewsInverseTable, FieldID),
		sqlgraph.Edge(sqlgraph.O2M, false, InterviewsTable, InterviewsColumn),
	)
}
