// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"database/sql/driver"
	"fmt"
	"math"
	"sent/ent/account"
	"sent/ent/agent"
	"sent/ent/application"
	"sent/ent/asset"
	"sent/ent/assetassignment"
	"sent/ent/assettype"
	"sent/ent/auditlog"
	"sent/ent/benefitenrollment"
	"sent/ent/benefitplan"
	"sent/ent/budgetforecast"
	"sent/ent/calllog"
	"sent/ent/camera"
	"sent/ent/candidate"
	"sent/ent/category"
	"sent/ent/compensationagreement"
	"sent/ent/contact"
	"sent/ent/contract"
	"sent/ent/credential"
	"sent/ent/department"
	"sent/ent/detectionevent"
	"sent/ent/discoveryentry"
	"sent/ent/employee"
	"sent/ent/goal"
	"sent/ent/healthscoresnapshot"
	"sent/ent/interview"
	"sent/ent/inventorycount"
	"sent/ent/inventoryreservation"
	"sent/ent/ivrflow"
	"sent/ent/job"
	"sent/ent/jobposting"
	"sent/ent/journalentry"
	"sent/ent/ledgerentry"
	"sent/ent/legalhold"
	"sent/ent/maintenanceschedule"
	"sent/ent/networkbackup"
	"sent/ent/networkdevice"
	"sent/ent/networklink"
	"sent/ent/networkport"
	"sent/ent/nexusaudit"
	"sent/ent/onetimelink"
	"sent/ent/performancereview"
	"sent/ent/permission"
	"sent/ent/predicate"
	"sent/ent/product"
	"sent/ent/purchaseorder"
	"sent/ent/recording"
	"sent/ent/recurringinvoice"
	"sent/ent/retentionpolicy"
	"sent/ent/reviewcycle"
	"sent/ent/saasapp"
	"sent/ent/saasfilter"
	"sent/ent/saasidentity"
	"sent/ent/saasusage"
	"sent/ent/script"
	"sent/ent/servicerate"
	"sent/ent/sop"
	"sent/ent/stockalert"
	"sent/ent/stockauditlog"
	"sent/ent/stockmovement"
	"sent/ent/strategicroadmap"
	"sent/ent/successionmap"
	"sent/ent/supplier"
	"sent/ent/tenant"
	"sent/ent/ticket"
	"sent/ent/timeoffbalance"
	"sent/ent/timeoffpolicy"
	"sent/ent/timeoffrequest"
	"sent/ent/transaction"
	"sent/ent/user"
	"sent/ent/vaultitem"
	"sent/ent/vaultsharelink"
	"sent/ent/vaulttemplate"
	"sent/ent/voicemail"
	"sent/ent/warehouse"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
	"entgo.io/ent/schema/field"
)

// TenantQuery is the builder for querying Tenant entities.
type TenantQuery struct {
	config
	ctx                        *QueryContext
	order                      []tenant.OrderOption
	inters                     []Interceptor
	predicates                 []predicate.Tenant
	withParent                 *TenantQuery
	withChildren               *TenantQuery
	withUsers                  *UserQuery
	withAccounts               *AccountQuery
	withTransactions           *TransactionQuery
	withLedgerEntries          *LedgerEntryQuery
	withProducts               *ProductQuery
	withStockMovements         *StockMovementQuery
	withAuditLogs              *AuditLogQuery
	withAgents                 *AgentQuery
	withDiscoveryEntries       *DiscoveryEntryQuery
	withAssets                 *AssetQuery
	withCredentials            *CredentialQuery
	withOneTimeLinks           *OneTimeLinkQuery
	withSops                   *SOPQuery
	withCameras                *CameraQuery
	withTickets                *TicketQuery
	withContracts              *ContractQuery
	withSaasApps               *SaaSAppQuery
	withSaasFilters            *SaaSFilterQuery
	withCallLogs               *CallLogQuery
	withIvrFlows               *IVRFlowQuery
	withVoicemails             *VoicemailQuery
	withHealthSnapshots        *HealthScoreSnapshotQuery
	withRoadmaps               *StrategicRoadmapQuery
	withServiceRates           *ServiceRateQuery
	withNetworkDevices         *NetworkDeviceQuery
	withNetworkBackups         *NetworkBackupQuery
	withBudgetForecasts        *BudgetForecastQuery
	withEmployees              *EmployeeQuery
	withCompensationAgreements *CompensationAgreementQuery
	withVaultItems             *VaultItemQuery
	withVaultShareLinks        *VaultShareLinkQuery
	withJournalEntries         *JournalEntryQuery
	withRecurringInvoices      *RecurringInvoiceQuery
	withInventoryReservations  *InventoryReservationQuery
	withDepartments            *DepartmentQuery
	withPermissions            *PermissionQuery
	withAssetTypes             *AssetTypeQuery
	withDetectionEvents        *DetectionEventQuery
	withSaasIdentities         *SaaSIdentityQuery
	withSaasUsages             *SaaSUsageQuery
	withRecordings             *RecordingQuery
	withNetworkLinks           *NetworkLinkQuery
	withNetworkPorts           *NetworkPortQuery
	withNexusAudits            *NexusAuditQuery
	withSuccessionMaps         *SuccessionMapQuery
	withCustomerAccount        *AccountQuery
	withScripts                *ScriptQuery
	withJobs                   *JobQuery
	withTimeOffRequests        *TimeOffRequestQuery
	withTimeOffPolicies        *TimeOffPolicyQuery
	withTimeOffBalances        *TimeOffBalanceQuery
	withReviewCycles           *ReviewCycleQuery
	withPerformanceReviews     *PerformanceReviewQuery
	withGoals                  *GoalQuery
	withSuppliers              *SupplierQuery
	withCategories             *CategoryQuery
	withWarehouses             *WarehouseQuery
	withAssetAssignments       *AssetAssignmentQuery
	withContacts               *ContactQuery
	withLegalHolds             *LegalHoldQuery
	withRetentionPolicies      *RetentionPolicyQuery
	withVaultTemplates         *VaultTemplateQuery
	withStockAuditLogs         *StockAuditLogQuery
	withMaintenanceSchedules   *MaintenanceScheduleQuery
	withStockAlerts            *StockAlertQuery
	withPurchaseOrders         *PurchaseOrderQuery
	withInventoryCounts        *InventoryCountQuery
	withJobPostings            *JobPostingQuery
	withCandidates             *CandidateQuery
	withApplications           *ApplicationQuery
	withInterviews             *InterviewQuery
	withBenefitPlans           *BenefitPlanQuery
	withBenefitEnrollments     *BenefitEnrollmentQuery
	withFKs                    bool
	modifiers                  []func(*sql.Selector)
	// intermediate query (i.e. traversal path).
	sql  *sql.Selector
	path func(context.Context) (*sql.Selector, error)
}

// Where adds a new predicate for the TenantQuery builder.
func (_q *TenantQuery) Where(ps ...predicate.Tenant) *TenantQuery {
	_q.predicates = append(_q.predicates, ps...)
	return _q
}

// Limit the number of records to be returned by this query.
func (_q *TenantQuery) Limit(limit int) *TenantQuery {
	_q.ctx.Limit = &limit
	return _q
}

// Offset to start from.
func (_q *TenantQuery) Offset(offset int) *TenantQuery {
	_q.ctx.Offset = &offset
	return _q
}

// Unique configures the query builder to filter duplicate records on query.
// By default, unique is set to true, and can be disabled using this method.
func (_q *TenantQuery) Unique(unique bool) *TenantQuery {
	_q.ctx.Unique = &unique
	return _q
}

// Order specifies how the records should be ordered.
func (_q *TenantQuery) Order(o ...tenant.OrderOption) *TenantQuery {
	_q.order = append(_q.order, o...)
	return _q
}

// QueryParent chains the current query on the "parent" edge.
func (_q *TenantQuery) QueryParent() *TenantQuery {
	query := (&TenantClient{config: _q.config}).Query()
	query.path = func(ctx context.Context) (fromU *sql.Selector, err error) {
		if err := _q.prepareQuery(ctx); err != nil {
			return nil, err
		}
		selector := _q.sqlQuery(ctx)
		if err := selector.Err(); err != nil {
			return nil, err
		}
		step := sqlgraph.NewStep(
			sqlgraph.From(tenant.Table, tenant.FieldID, selector),
			sqlgraph.To(tenant.Table, tenant.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, tenant.ParentTable, tenant.ParentColumn),
		)
		fromU = sqlgraph.SetNeighbors(_q.driver.Dialect(), step)
		return fromU, nil
	}
	return query
}

// QueryChildren chains the current query on the "children" edge.
func (_q *TenantQuery) QueryChildren() *TenantQuery {
	query := (&TenantClient{config: _q.config}).Query()
	query.path = func(ctx context.Context) (fromU *sql.Selector, err error) {
		if err := _q.prepareQuery(ctx); err != nil {
			return nil, err
		}
		selector := _q.sqlQuery(ctx)
		if err := selector.Err(); err != nil {
			return nil, err
		}
		step := sqlgraph.NewStep(
			sqlgraph.From(tenant.Table, tenant.FieldID, selector),
			sqlgraph.To(tenant.Table, tenant.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, tenant.ChildrenTable, tenant.ChildrenColumn),
		)
		fromU = sqlgraph.SetNeighbors(_q.driver.Dialect(), step)
		return fromU, nil
	}
	return query
}

// QueryUsers chains the current query on the "users" edge.
func (_q *TenantQuery) QueryUsers() *UserQuery {
	query := (&UserClient{config: _q.config}).Query()
	query.path = func(ctx context.Context) (fromU *sql.Selector, err error) {
		if err := _q.prepareQuery(ctx); err != nil {
			return nil, err
		}
		selector := _q.sqlQuery(ctx)
		if err := selector.Err(); err != nil {
			return nil, err
		}
		step := sqlgraph.NewStep(
			sqlgraph.From(tenant.Table, tenant.FieldID, selector),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, tenant.UsersTable, tenant.UsersColumn),
		)
		fromU = sqlgraph.SetNeighbors(_q.driver.Dialect(), step)
		return fromU, nil
	}
	return query
}

// QueryAccounts chains the current query on the "accounts" edge.
func (_q *TenantQuery) QueryAccounts() *AccountQuery {
	query := (&AccountClient{config: _q.config}).Query()
	query.path = func(ctx context.Context) (fromU *sql.Selector, err error) {
		if err := _q.prepareQuery(ctx); err != nil {
			return nil, err
		}
		selector := _q.sqlQuery(ctx)
		if err := selector.Err(); err != nil {
			return nil, err
		}
		step := sqlgraph.NewStep(
			sqlgraph.From(tenant.Table, tenant.FieldID, selector),
			sqlgraph.To(account.Table, account.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, tenant.AccountsTable, tenant.AccountsColumn),
		)
		fromU = sqlgraph.SetNeighbors(_q.driver.Dialect(), step)
		return fromU, nil
	}
	return query
}

// QueryTransactions chains the current query on the "transactions" edge.
func (_q *TenantQuery) QueryTransactions() *TransactionQuery {
	query := (&TransactionClient{config: _q.config}).Query()
	query.path = func(ctx context.Context) (fromU *sql.Selector, err error) {
		if err := _q.prepareQuery(ctx); err != nil {
			return nil, err
		}
		selector := _q.sqlQuery(ctx)
		if err := selector.Err(); err != nil {
			return nil, err
		}
		step := sqlgraph.NewStep(
			sqlgraph.From(tenant.Table, tenant.FieldID, selector),
			sqlgraph.To(transaction.Table, transaction.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, tenant.TransactionsTable, tenant.TransactionsColumn),
		)
		fromU = sqlgraph.SetNeighbors(_q.driver.Dialect(), step)
		return fromU, nil
	}
	return query
}

// QueryLedgerEntries chains the current query on the "ledger_entries" edge.
func (_q *TenantQuery) QueryLedgerEntries() *LedgerEntryQuery {
	query := (&LedgerEntryClient{config: _q.config}).Query()
	query.path = func(ctx context.Context) (fromU *sql.Selector, err error) {
		if err := _q.prepareQuery(ctx); err != nil {
			return nil, err
		}
		selector := _q.sqlQuery(ctx)
		if err := selector.Err(); err != nil {
			return nil, err
		}
		step := sqlgraph.NewStep(
			sqlgraph.From(tenant.Table, tenant.FieldID, selector),
			sqlgraph.To(ledgerentry.Table, ledgerentry.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, tenant.LedgerEntriesTable, tenant.LedgerEntriesColumn),
		)
		fromU = sqlgraph.SetNeighbors(_q.driver.Dialect(), step)
		return fromU, nil
	}
	return query
}

// QueryProducts chains the current query on the "products" edge.
func (_q *TenantQuery) QueryProducts() *ProductQuery {
	query := (&ProductClient{config: _q.config}).Query()
	query.path = func(ctx context.Context) (fromU *sql.Selector, err error) {
		if err := _q.prepareQuery(ctx); err != nil {
			return nil, err
		}
		selector := _q.sqlQuery(ctx)
		if err := selector.Err(); err != nil {
			return nil, err
		}
		step := sqlgraph.NewStep(
			sqlgraph.From(tenant.Table, tenant.FieldID, selector),
			sqlgraph.To(product.Table, product.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, tenant.ProductsTable, tenant.ProductsColumn),
		)
		fromU = sqlgraph.SetNeighbors(_q.driver.Dialect(), step)
		return fromU, nil
	}
	return query
}

// QueryStockMovements chains the current query on the "stock_movements" edge.
func (_q *TenantQuery) QueryStockMovements() *StockMovementQuery {
	query := (&StockMovementClient{config: _q.config}).Query()
	query.path = func(ctx context.Context) (fromU *sql.Selector, err error) {
		if err := _q.prepareQuery(ctx); err != nil {
			return nil, err
		}
		selector := _q.sqlQuery(ctx)
		if err := selector.Err(); err != nil {
			return nil, err
		}
		step := sqlgraph.NewStep(
			sqlgraph.From(tenant.Table, tenant.FieldID, selector),
			sqlgraph.To(stockmovement.Table, stockmovement.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, tenant.StockMovementsTable, tenant.StockMovementsColumn),
		)
		fromU = sqlgraph.SetNeighbors(_q.driver.Dialect(), step)
		return fromU, nil
	}
	return query
}

// QueryAuditLogs chains the current query on the "audit_logs" edge.
func (_q *TenantQuery) QueryAuditLogs() *AuditLogQuery {
	query := (&AuditLogClient{config: _q.config}).Query()
	query.path = func(ctx context.Context) (fromU *sql.Selector, err error) {
		if err := _q.prepareQuery(ctx); err != nil {
			return nil, err
		}
		selector := _q.sqlQuery(ctx)
		if err := selector.Err(); err != nil {
			return nil, err
		}
		step := sqlgraph.NewStep(
			sqlgraph.From(tenant.Table, tenant.FieldID, selector),
			sqlgraph.To(auditlog.Table, auditlog.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, tenant.AuditLogsTable, tenant.AuditLogsColumn),
		)
		fromU = sqlgraph.SetNeighbors(_q.driver.Dialect(), step)
		return fromU, nil
	}
	return query
}

// QueryAgents chains the current query on the "agents" edge.
func (_q *TenantQuery) QueryAgents() *AgentQuery {
	query := (&AgentClient{config: _q.config}).Query()
	query.path = func(ctx context.Context) (fromU *sql.Selector, err error) {
		if err := _q.prepareQuery(ctx); err != nil {
			return nil, err
		}
		selector := _q.sqlQuery(ctx)
		if err := selector.Err(); err != nil {
			return nil, err
		}
		step := sqlgraph.NewStep(
			sqlgraph.From(tenant.Table, tenant.FieldID, selector),
			sqlgraph.To(agent.Table, agent.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, tenant.AgentsTable, tenant.AgentsColumn),
		)
		fromU = sqlgraph.SetNeighbors(_q.driver.Dialect(), step)
		return fromU, nil
	}
	return query
}

// QueryDiscoveryEntries chains the current query on the "discovery_entries" edge.
func (_q *TenantQuery) QueryDiscoveryEntries() *DiscoveryEntryQuery {
	query := (&DiscoveryEntryClient{config: _q.config}).Query()
	query.path = func(ctx context.Context) (fromU *sql.Selector, err error) {
		if err := _q.prepareQuery(ctx); err != nil {
			return nil, err
		}
		selector := _q.sqlQuery(ctx)
		if err := selector.Err(); err != nil {
			return nil, err
		}
		step := sqlgraph.NewStep(
			sqlgraph.From(tenant.Table, tenant.FieldID, selector),
			sqlgraph.To(discoveryentry.Table, discoveryentry.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, tenant.DiscoveryEntriesTable, tenant.DiscoveryEntriesColumn),
		)
		fromU = sqlgraph.SetNeighbors(_q.driver.Dialect(), step)
		return fromU, nil
	}
	return query
}

// QueryAssets chains the current query on the "assets" edge.
func (_q *TenantQuery) QueryAssets() *AssetQuery {
	query := (&AssetClient{config: _q.config}).Query()
	query.path = func(ctx context.Context) (fromU *sql.Selector, err error) {
		if err := _q.prepareQuery(ctx); err != nil {
			return nil, err
		}
		selector := _q.sqlQuery(ctx)
		if err := selector.Err(); err != nil {
			return nil, err
		}
		step := sqlgraph.NewStep(
			sqlgraph.From(tenant.Table, tenant.FieldID, selector),
			sqlgraph.To(asset.Table, asset.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, tenant.AssetsTable, tenant.AssetsColumn),
		)
		fromU = sqlgraph.SetNeighbors(_q.driver.Dialect(), step)
		return fromU, nil
	}
	return query
}

// QueryCredentials chains the current query on the "credentials" edge.
func (_q *TenantQuery) QueryCredentials() *CredentialQuery {
	query := (&CredentialClient{config: _q.config}).Query()
	query.path = func(ctx context.Context) (fromU *sql.Selector, err error) {
		if err := _q.prepareQuery(ctx); err != nil {
			return nil, err
		}
		selector := _q.sqlQuery(ctx)
		if err := selector.Err(); err != nil {
			return nil, err
		}
		step := sqlgraph.NewStep(
			sqlgraph.From(tenant.Table, tenant.FieldID, selector),
			sqlgraph.To(credential.Table, credential.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, tenant.CredentialsTable, tenant.CredentialsColumn),
		)
		fromU = sqlgraph.SetNeighbors(_q.driver.Dialect(), step)
		return fromU, nil
	}
	return query
}

// QueryOneTimeLinks chains the current query on the "one_time_links" edge.
func (_q *TenantQuery) QueryOneTimeLinks() *OneTimeLinkQuery {
	query := (&OneTimeLinkClient{config: _q.config}).Query()
	query.path = func(ctx context.Context) (fromU *sql.Selector, err error) {
		if err := _q.prepareQuery(ctx); err != nil {
			return nil, err
		}
		selector := _q.sqlQuery(ctx)
		if err := selector.Err(); err != nil {
			return nil, err
		}
		step := sqlgraph.NewStep(
			sqlgraph.From(tenant.Table, tenant.FieldID, selector),
			sqlgraph.To(onetimelink.Table, onetimelink.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, tenant.OneTimeLinksTable, tenant.OneTimeLinksColumn),
		)
		fromU = sqlgraph.SetNeighbors(_q.driver.Dialect(), step)
		return fromU, nil
	}
	return query
}

// QuerySops chains the current query on the "sops" edge.
func (_q *TenantQuery) QuerySops() *SOPQuery {
	query := (&SOPClient{config: _q.config}).Query()
	query.path = func(ctx context.Context) (fromU *sql.Selector, err error) {
		if err := _q.prepareQuery(ctx); err != nil {
			return nil, err
		}
		selector := _q.sqlQuery(ctx)
		if err := selector.Err(); err != nil {
			return nil, err
		}
		step := sqlgraph.NewStep(
			sqlgraph.From(tenant.Table, tenant.FieldID, selector),
			sqlgraph.To(sop.Table, sop.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, tenant.SopsTable, tenant.SopsColumn),
		)
		fromU = sqlgraph.SetNeighbors(_q.driver.Dialect(), step)
		return fromU, nil
	}
	return query
}

// QueryCameras chains the current query on the "cameras" edge.
func (_q *TenantQuery) QueryCameras() *CameraQuery {
	query := (&CameraClient{config: _q.config}).Query()
	query.path = func(ctx context.Context) (fromU *sql.Selector, err error) {
		if err := _q.prepareQuery(ctx); err != nil {
			return nil, err
		}
		selector := _q.sqlQuery(ctx)
		if err := selector.Err(); err != nil {
			return nil, err
		}
		step := sqlgraph.NewStep(
			sqlgraph.From(tenant.Table, tenant.FieldID, selector),
			sqlgraph.To(camera.Table, camera.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, tenant.CamerasTable, tenant.CamerasColumn),
		)
		fromU = sqlgraph.SetNeighbors(_q.driver.Dialect(), step)
		return fromU, nil
	}
	return query
}

// QueryTickets chains the current query on the "tickets" edge.
func (_q *TenantQuery) QueryTickets() *TicketQuery {
	query := (&TicketClient{config: _q.config}).Query()
	query.path = func(ctx context.Context) (fromU *sql.Selector, err error) {
		if err := _q.prepareQuery(ctx); err != nil {
			return nil, err
		}
		selector := _q.sqlQuery(ctx)
		if err := selector.Err(); err != nil {
			return nil, err
		}
		step := sqlgraph.NewStep(
			sqlgraph.From(tenant.Table, tenant.FieldID, selector),
			sqlgraph.To(ticket.Table, ticket.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, tenant.TicketsTable, tenant.TicketsColumn),
		)
		fromU = sqlgraph.SetNeighbors(_q.driver.Dialect(), step)
		return fromU, nil
	}
	return query
}

// QueryContracts chains the current query on the "contracts" edge.
func (_q *TenantQuery) QueryContracts() *ContractQuery {
	query := (&ContractClient{config: _q.config}).Query()
	query.path = func(ctx context.Context) (fromU *sql.Selector, err error) {
		if err := _q.prepareQuery(ctx); err != nil {
			return nil, err
		}
		selector := _q.sqlQuery(ctx)
		if err := selector.Err(); err != nil {
			return nil, err
		}
		step := sqlgraph.NewStep(
			sqlgraph.From(tenant.Table, tenant.FieldID, selector),
			sqlgraph.To(contract.Table, contract.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, tenant.ContractsTable, tenant.ContractsColumn),
		)
		fromU = sqlgraph.SetNeighbors(_q.driver.Dialect(), step)
		return fromU, nil
	}
	return query
}

// QuerySaasApps chains the current query on the "saas_apps" edge.
func (_q *TenantQuery) QuerySaasApps() *SaaSAppQuery {
	query := (&SaaSAppClient{config: _q.config}).Query()
	query.path = func(ctx context.Context) (fromU *sql.Selector, err error) {
		if err := _q.prepareQuery(ctx); err != nil {
			return nil, err
		}
		selector := _q.sqlQuery(ctx)
		if err := selector.Err(); err != nil {
			return nil, err
		}
		step := sqlgraph.NewStep(
			sqlgraph.From(tenant.Table, tenant.FieldID, selector),
			sqlgraph.To(saasapp.Table, saasapp.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, tenant.SaasAppsTable, tenant.SaasAppsColumn),
		)
		fromU = sqlgraph.SetNeighbors(_q.driver.Dialect(), step)
		return fromU, nil
	}
	return query
}

// QuerySaasFilters chains the current query on the "saas_filters" edge.
func (_q *TenantQuery) QuerySaasFilters() *SaaSFilterQuery {
	query := (&SaaSFilterClient{config: _q.config}).Query()
	query.path = func(ctx context.Context) (fromU *sql.Selector, err error) {
		if err := _q.prepareQuery(ctx); err != nil {
			return nil, err
		}
		selector := _q.sqlQuery(ctx)
		if err := selector.Err(); err != nil {
			return nil, err
		}
		step := sqlgraph.NewStep(
			sqlgraph.From(tenant.Table, tenant.FieldID, selector),
			sqlgraph.To(saasfilter.Table, saasfilter.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, tenant.SaasFiltersTable, tenant.SaasFiltersColumn),
		)
		fromU = sqlgraph.SetNeighbors(_q.driver.Dialect(), step)
		return fromU, nil
	}
	return query
}

// QueryCallLogs chains the current query on the "call_logs" edge.
func (_q *TenantQuery) QueryCallLogs() *CallLogQuery {
	query := (&CallLogClient{config: _q.config}).Query()
	query.path = func(ctx context.Context) (fromU *sql.Selector, err error) {
		if err := _q.prepareQuery(ctx); err != nil {
			return nil, err
		}
		selector := _q.sqlQuery(ctx)
		if err := selector.Err(); err != nil {
			return nil, err
		}
		step := sqlgraph.NewStep(
			sqlgraph.From(tenant.Table, tenant.FieldID, selector),
			sqlgraph.To(calllog.Table, calllog.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, tenant.CallLogsTable, tenant.CallLogsColumn),
		)
		fromU = sqlgraph.SetNeighbors(_q.driver.Dialect(), step)
		return fromU, nil
	}
	return query
}

// QueryIvrFlows chains the current query on the "ivr_flows" edge.
func (_q *TenantQuery) QueryIvrFlows() *IVRFlowQuery {
	query := (&IVRFlowClient{config: _q.config}).Query()
	query.path = func(ctx context.Context) (fromU *sql.Selector, err error) {
		if err := _q.prepareQuery(ctx); err != nil {
			return nil, err
		}
		selector := _q.sqlQuery(ctx)
		if err := selector.Err(); err != nil {
			return nil, err
		}
		step := sqlgraph.NewStep(
			sqlgraph.From(tenant.Table, tenant.FieldID, selector),
			sqlgraph.To(ivrflow.Table, ivrflow.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, tenant.IvrFlowsTable, tenant.IvrFlowsColumn),
		)
		fromU = sqlgraph.SetNeighbors(_q.driver.Dialect(), step)
		return fromU, nil
	}
	return query
}

// QueryVoicemails chains the current query on the "voicemails" edge.
func (_q *TenantQuery) QueryVoicemails() *VoicemailQuery {
	query := (&VoicemailClient{config: _q.config}).Query()
	query.path = func(ctx context.Context) (fromU *sql.Selector, err error) {
		if err := _q.prepareQuery(ctx); err != nil {
			return nil, err
		}
		selector := _q.sqlQuery(ctx)
		if err := selector.Err(); err != nil {
			return nil, err
		}
		step := sqlgraph.NewStep(
			sqlgraph.From(tenant.Table, tenant.FieldID, selector),
			sqlgraph.To(voicemail.Table, voicemail.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, tenant.VoicemailsTable, tenant.VoicemailsColumn),
		)
		fromU = sqlgraph.SetNeighbors(_q.driver.Dialect(), step)
		return fromU, nil
	}
	return query
}

// QueryHealthSnapshots chains the current query on the "health_snapshots" edge.
func (_q *TenantQuery) QueryHealthSnapshots() *HealthScoreSnapshotQuery {
	query := (&HealthScoreSnapshotClient{config: _q.config}).Query()
	query.path = func(ctx context.Context) (fromU *sql.Selector, err error) {
		if err := _q.prepareQuery(ctx); err != nil {
			return nil, err
		}
		selector := _q.sqlQuery(ctx)
		if err := selector.Err(); err != nil {
			return nil, err
		}
		step := sqlgraph.NewStep(
			sqlgraph.From(tenant.Table, tenant.FieldID, selector),
			sqlgraph.To(healthscoresnapshot.Table, healthscoresnapshot.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, tenant.HealthSnapshotsTable, tenant.HealthSnapshotsColumn),
		)
		fromU = sqlgraph.SetNeighbors(_q.driver.Dialect(), step)
		return fromU, nil
	}
	return query
}

// QueryRoadmaps chains the current query on the "roadmaps" edge.
func (_q *TenantQuery) QueryRoadmaps() *StrategicRoadmapQuery {
	query := (&StrategicRoadmapClient{config: _q.config}).Query()
	query.path = func(ctx context.Context) (fromU *sql.Selector, err error) {
		if err := _q.prepareQuery(ctx); err != nil {
			return nil, err
		}
		selector := _q.sqlQuery(ctx)
		if err := selector.Err(); err != nil {
			return nil, err
		}
		step := sqlgraph.NewStep(
			sqlgraph.From(tenant.Table, tenant.FieldID, selector),
			sqlgraph.To(strategicroadmap.Table, strategicroadmap.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, tenant.RoadmapsTable, tenant.RoadmapsColumn),
		)
		fromU = sqlgraph.SetNeighbors(_q.driver.Dialect(), step)
		return fromU, nil
	}
	return query
}

// QueryServiceRates chains the current query on the "service_rates" edge.
func (_q *TenantQuery) QueryServiceRates() *ServiceRateQuery {
	query := (&ServiceRateClient{config: _q.config}).Query()
	query.path = func(ctx context.Context) (fromU *sql.Selector, err error) {
		if err := _q.prepareQuery(ctx); err != nil {
			return nil, err
		}
		selector := _q.sqlQuery(ctx)
		if err := selector.Err(); err != nil {
			return nil, err
		}
		step := sqlgraph.NewStep(
			sqlgraph.From(tenant.Table, tenant.FieldID, selector),
			sqlgraph.To(servicerate.Table, servicerate.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, tenant.ServiceRatesTable, tenant.ServiceRatesColumn),
		)
		fromU = sqlgraph.SetNeighbors(_q.driver.Dialect(), step)
		return fromU, nil
	}
	return query
}

// QueryNetworkDevices chains the current query on the "network_devices" edge.
func (_q *TenantQuery) QueryNetworkDevices() *NetworkDeviceQuery {
	query := (&NetworkDeviceClient{config: _q.config}).Query()
	query.path = func(ctx context.Context) (fromU *sql.Selector, err error) {
		if err := _q.prepareQuery(ctx); err != nil {
			return nil, err
		}
		selector := _q.sqlQuery(ctx)
		if err := selector.Err(); err != nil {
			return nil, err
		}
		step := sqlgraph.NewStep(
			sqlgraph.From(tenant.Table, tenant.FieldID, selector),
			sqlgraph.To(networkdevice.Table, networkdevice.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, tenant.NetworkDevicesTable, tenant.NetworkDevicesColumn),
		)
		fromU = sqlgraph.SetNeighbors(_q.driver.Dialect(), step)
		return fromU, nil
	}
	return query
}

// QueryNetworkBackups chains the current query on the "network_backups" edge.
func (_q *TenantQuery) QueryNetworkBackups() *NetworkBackupQuery {
	query := (&NetworkBackupClient{config: _q.config}).Query()
	query.path = func(ctx context.Context) (fromU *sql.Selector, err error) {
		if err := _q.prepareQuery(ctx); err != nil {
			return nil, err
		}
		selector := _q.sqlQuery(ctx)
		if err := selector.Err(); err != nil {
			return nil, err
		}
		step := sqlgraph.NewStep(
			sqlgraph.From(tenant.Table, tenant.FieldID, selector),
			sqlgraph.To(networkbackup.Table, networkbackup.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, tenant.NetworkBackupsTable, tenant.NetworkBackupsColumn),
		)
		fromU = sqlgraph.SetNeighbors(_q.driver.Dialect(), step)
		return fromU, nil
	}
	return query
}

// QueryBudgetForecasts chains the current query on the "budget_forecasts" edge.
func (_q *TenantQuery) QueryBudgetForecasts() *BudgetForecastQuery {
	query := (&BudgetForecastClient{config: _q.config}).Query()
	query.path = func(ctx context.Context) (fromU *sql.Selector, err error) {
		if err := _q.prepareQuery(ctx); err != nil {
			return nil, err
		}
		selector := _q.sqlQuery(ctx)
		if err := selector.Err(); err != nil {
			return nil, err
		}
		step := sqlgraph.NewStep(
			sqlgraph.From(tenant.Table, tenant.FieldID, selector),
			sqlgraph.To(budgetforecast.Table, budgetforecast.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, tenant.BudgetForecastsTable, tenant.BudgetForecastsColumn),
		)
		fromU = sqlgraph.SetNeighbors(_q.driver.Dialect(), step)
		return fromU, nil
	}
	return query
}

// QueryEmployees chains the current query on the "employees" edge.
func (_q *TenantQuery) QueryEmployees() *EmployeeQuery {
	query := (&EmployeeClient{config: _q.config}).Query()
	query.path = func(ctx context.Context) (fromU *sql.Selector, err error) {
		if err := _q.prepareQuery(ctx); err != nil {
			return nil, err
		}
		selector := _q.sqlQuery(ctx)
		if err := selector.Err(); err != nil {
			return nil, err
		}
		step := sqlgraph.NewStep(
			sqlgraph.From(tenant.Table, tenant.FieldID, selector),
			sqlgraph.To(employee.Table, employee.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, tenant.EmployeesTable, tenant.EmployeesColumn),
		)
		fromU = sqlgraph.SetNeighbors(_q.driver.Dialect(), step)
		return fromU, nil
	}
	return query
}

// QueryCompensationAgreements chains the current query on the "compensation_agreements" edge.
func (_q *TenantQuery) QueryCompensationAgreements() *CompensationAgreementQuery {
	query := (&CompensationAgreementClient{config: _q.config}).Query()
	query.path = func(ctx context.Context) (fromU *sql.Selector, err error) {
		if err := _q.prepareQuery(ctx); err != nil {
			return nil, err
		}
		selector := _q.sqlQuery(ctx)
		if err := selector.Err(); err != nil {
			return nil, err
		}
		step := sqlgraph.NewStep(
			sqlgraph.From(tenant.Table, tenant.FieldID, selector),
			sqlgraph.To(compensationagreement.Table, compensationagreement.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, tenant.CompensationAgreementsTable, tenant.CompensationAgreementsColumn),
		)
		fromU = sqlgraph.SetNeighbors(_q.driver.Dialect(), step)
		return fromU, nil
	}
	return query
}

// QueryVaultItems chains the current query on the "vault_items" edge.
func (_q *TenantQuery) QueryVaultItems() *VaultItemQuery {
	query := (&VaultItemClient{config: _q.config}).Query()
	query.path = func(ctx context.Context) (fromU *sql.Selector, err error) {
		if err := _q.prepareQuery(ctx); err != nil {
			return nil, err
		}
		selector := _q.sqlQuery(ctx)
		if err := selector.Err(); err != nil {
			return nil, err
		}
		step := sqlgraph.NewStep(
			sqlgraph.From(tenant.Table, tenant.FieldID, selector),
			sqlgraph.To(vaultitem.Table, vaultitem.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, tenant.VaultItemsTable, tenant.VaultItemsColumn),
		)
		fromU = sqlgraph.SetNeighbors(_q.driver.Dialect(), step)
		return fromU, nil
	}
	return query
}

// QueryVaultShareLinks chains the current query on the "vault_share_links" edge.
func (_q *TenantQuery) QueryVaultShareLinks() *VaultShareLinkQuery {
	query := (&VaultShareLinkClient{config: _q.config}).Query()
	query.path = func(ctx context.Context) (fromU *sql.Selector, err error) {
		if err := _q.prepareQuery(ctx); err != nil {
			return nil, err
		}
		selector := _q.sqlQuery(ctx)
		if err := selector.Err(); err != nil {
			return nil, err
		}
		step := sqlgraph.NewStep(
			sqlgraph.From(tenant.Table, tenant.FieldID, selector),
			sqlgraph.To(vaultsharelink.Table, vaultsharelink.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, tenant.VaultShareLinksTable, tenant.VaultShareLinksColumn),
		)
		fromU = sqlgraph.SetNeighbors(_q.driver.Dialect(), step)
		return fromU, nil
	}
	return query
}

// QueryJournalEntries chains the current query on the "journal_entries" edge.
func (_q *TenantQuery) QueryJournalEntries() *JournalEntryQuery {
	query := (&JournalEntryClient{config: _q.config}).Query()
	query.path = func(ctx context.Context) (fromU *sql.Selector, err error) {
		if err := _q.prepareQuery(ctx); err != nil {
			return nil, err
		}
		selector := _q.sqlQuery(ctx)
		if err := selector.Err(); err != nil {
			return nil, err
		}
		step := sqlgraph.NewStep(
			sqlgraph.From(tenant.Table, tenant.FieldID, selector),
			sqlgraph.To(journalentry.Table, journalentry.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, tenant.JournalEntriesTable, tenant.JournalEntriesColumn),
		)
		fromU = sqlgraph.SetNeighbors(_q.driver.Dialect(), step)
		return fromU, nil
	}
	return query
}

// QueryRecurringInvoices chains the current query on the "recurring_invoices" edge.
func (_q *TenantQuery) QueryRecurringInvoices() *RecurringInvoiceQuery {
	query := (&RecurringInvoiceClient{config: _q.config}).Query()
	query.path = func(ctx context.Context) (fromU *sql.Selector, err error) {
		if err := _q.prepareQuery(ctx); err != nil {
			return nil, err
		}
		selector := _q.sqlQuery(ctx)
		if err := selector.Err(); err != nil {
			return nil, err
		}
		step := sqlgraph.NewStep(
			sqlgraph.From(tenant.Table, tenant.FieldID, selector),
			sqlgraph.To(recurringinvoice.Table, recurringinvoice.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, tenant.RecurringInvoicesTable, tenant.RecurringInvoicesColumn),
		)
		fromU = sqlgraph.SetNeighbors(_q.driver.Dialect(), step)
		return fromU, nil
	}
	return query
}

// QueryInventoryReservations chains the current query on the "inventory_reservations" edge.
func (_q *TenantQuery) QueryInventoryReservations() *InventoryReservationQuery {
	query := (&InventoryReservationClient{config: _q.config}).Query()
	query.path = func(ctx context.Context) (fromU *sql.Selector, err error) {
		if err := _q.prepareQuery(ctx); err != nil {
			return nil, err
		}
		selector := _q.sqlQuery(ctx)
		if err := selector.Err(); err != nil {
			return nil, err
		}
		step := sqlgraph.NewStep(
			sqlgraph.From(tenant.Table, tenant.FieldID, selector),
			sqlgraph.To(inventoryreservation.Table, inventoryreservation.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, tenant.InventoryReservationsTable, tenant.InventoryReservationsColumn),
		)
		fromU = sqlgraph.SetNeighbors(_q.driver.Dialect(), step)
		return fromU, nil
	}
	return query
}

// QueryDepartments chains the current query on the "departments" edge.
func (_q *TenantQuery) QueryDepartments() *DepartmentQuery {
	query := (&DepartmentClient{config: _q.config}).Query()
	query.path = func(ctx context.Context) (fromU *sql.Selector, err error) {
		if err := _q.prepareQuery(ctx); err != nil {
			return nil, err
		}
		selector := _q.sqlQuery(ctx)
		if err := selector.Err(); err != nil {
			return nil, err
		}
		step := sqlgraph.NewStep(
			sqlgraph.From(tenant.Table, tenant.FieldID, selector),
			sqlgraph.To(department.Table, department.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, tenant.DepartmentsTable, tenant.DepartmentsColumn),
		)
		fromU = sqlgraph.SetNeighbors(_q.driver.Dialect(), step)
		return fromU, nil
	}
	return query
}

// QueryPermissions chains the current query on the "permissions" edge.
func (_q *TenantQuery) QueryPermissions() *PermissionQuery {
	query := (&PermissionClient{config: _q.config}).Query()
	query.path = func(ctx context.Context) (fromU *sql.Selector, err error) {
		if err := _q.prepareQuery(ctx); err != nil {
			return nil, err
		}
		selector := _q.sqlQuery(ctx)
		if err := selector.Err(); err != nil {
			return nil, err
		}
		step := sqlgraph.NewStep(
			sqlgraph.From(tenant.Table, tenant.FieldID, selector),
			sqlgraph.To(permission.Table, permission.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, tenant.PermissionsTable, tenant.PermissionsColumn),
		)
		fromU = sqlgraph.SetNeighbors(_q.driver.Dialect(), step)
		return fromU, nil
	}
	return query
}

// QueryAssetTypes chains the current query on the "asset_types" edge.
func (_q *TenantQuery) QueryAssetTypes() *AssetTypeQuery {
	query := (&AssetTypeClient{config: _q.config}).Query()
	query.path = func(ctx context.Context) (fromU *sql.Selector, err error) {
		if err := _q.prepareQuery(ctx); err != nil {
			return nil, err
		}
		selector := _q.sqlQuery(ctx)
		if err := selector.Err(); err != nil {
			return nil, err
		}
		step := sqlgraph.NewStep(
			sqlgraph.From(tenant.Table, tenant.FieldID, selector),
			sqlgraph.To(assettype.Table, assettype.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, tenant.AssetTypesTable, tenant.AssetTypesColumn),
		)
		fromU = sqlgraph.SetNeighbors(_q.driver.Dialect(), step)
		return fromU, nil
	}
	return query
}

// QueryDetectionEvents chains the current query on the "detection_events" edge.
func (_q *TenantQuery) QueryDetectionEvents() *DetectionEventQuery {
	query := (&DetectionEventClient{config: _q.config}).Query()
	query.path = func(ctx context.Context) (fromU *sql.Selector, err error) {
		if err := _q.prepareQuery(ctx); err != nil {
			return nil, err
		}
		selector := _q.sqlQuery(ctx)
		if err := selector.Err(); err != nil {
			return nil, err
		}
		step := sqlgraph.NewStep(
			sqlgraph.From(tenant.Table, tenant.FieldID, selector),
			sqlgraph.To(detectionevent.Table, detectionevent.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, tenant.DetectionEventsTable, tenant.DetectionEventsColumn),
		)
		fromU = sqlgraph.SetNeighbors(_q.driver.Dialect(), step)
		return fromU, nil
	}
	return query
}

// QuerySaasIdentities chains the current query on the "saas_identities" edge.
func (_q *TenantQuery) QuerySaasIdentities() *SaaSIdentityQuery {
	query := (&SaaSIdentityClient{config: _q.config}).Query()
	query.path = func(ctx context.Context) (fromU *sql.Selector, err error) {
		if err := _q.prepareQuery(ctx); err != nil {
			return nil, err
		}
		selector := _q.sqlQuery(ctx)
		if err := selector.Err(); err != nil {
			return nil, err
		}
		step := sqlgraph.NewStep(
			sqlgraph.From(tenant.Table, tenant.FieldID, selector),
			sqlgraph.To(saasidentity.Table, saasidentity.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, tenant.SaasIdentitiesTable, tenant.SaasIdentitiesColumn),
		)
		fromU = sqlgraph.SetNeighbors(_q.driver.Dialect(), step)
		return fromU, nil
	}
	return query
}

// QuerySaasUsages chains the current query on the "saas_usages" edge.
func (_q *TenantQuery) QuerySaasUsages() *SaaSUsageQuery {
	query := (&SaaSUsageClient{config: _q.config}).Query()
	query.path = func(ctx context.Context) (fromU *sql.Selector, err error) {
		if err := _q.prepareQuery(ctx); err != nil {
			return nil, err
		}
		selector := _q.sqlQuery(ctx)
		if err := selector.Err(); err != nil {
			return nil, err
		}
		step := sqlgraph.NewStep(
			sqlgraph.From(tenant.Table, tenant.FieldID, selector),
			sqlgraph.To(saasusage.Table, saasusage.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, tenant.SaasUsagesTable, tenant.SaasUsagesColumn),
		)
		fromU = sqlgraph.SetNeighbors(_q.driver.Dialect(), step)
		return fromU, nil
	}
	return query
}

// QueryRecordings chains the current query on the "recordings" edge.
func (_q *TenantQuery) QueryRecordings() *RecordingQuery {
	query := (&RecordingClient{config: _q.config}).Query()
	query.path = func(ctx context.Context) (fromU *sql.Selector, err error) {
		if err := _q.prepareQuery(ctx); err != nil {
			return nil, err
		}
		selector := _q.sqlQuery(ctx)
		if err := selector.Err(); err != nil {
			return nil, err
		}
		step := sqlgraph.NewStep(
			sqlgraph.From(tenant.Table, tenant.FieldID, selector),
			sqlgraph.To(recording.Table, recording.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, tenant.RecordingsTable, tenant.RecordingsColumn),
		)
		fromU = sqlgraph.SetNeighbors(_q.driver.Dialect(), step)
		return fromU, nil
	}
	return query
}

// QueryNetworkLinks chains the current query on the "network_links" edge.
func (_q *TenantQuery) QueryNetworkLinks() *NetworkLinkQuery {
	query := (&NetworkLinkClient{config: _q.config}).Query()
	query.path = func(ctx context.Context) (fromU *sql.Selector, err error) {
		if err := _q.prepareQuery(ctx); err != nil {
			return nil, err
		}
		selector := _q.sqlQuery(ctx)
		if err := selector.Err(); err != nil {
			return nil, err
		}
		step := sqlgraph.NewStep(
			sqlgraph.From(tenant.Table, tenant.FieldID, selector),
			sqlgraph.To(networklink.Table, networklink.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, tenant.NetworkLinksTable, tenant.NetworkLinksColumn),
		)
		fromU = sqlgraph.SetNeighbors(_q.driver.Dialect(), step)
		return fromU, nil
	}
	return query
}

// QueryNetworkPorts chains the current query on the "network_ports" edge.
func (_q *TenantQuery) QueryNetworkPorts() *NetworkPortQuery {
	query := (&NetworkPortClient{config: _q.config}).Query()
	query.path = func(ctx context.Context) (fromU *sql.Selector, err error) {
		if err := _q.prepareQuery(ctx); err != nil {
			return nil, err
		}
		selector := _q.sqlQuery(ctx)
		if err := selector.Err(); err != nil {
			return nil, err
		}
		step := sqlgraph.NewStep(
			sqlgraph.From(tenant.Table, tenant.FieldID, selector),
			sqlgraph.To(networkport.Table, networkport.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, tenant.NetworkPortsTable, tenant.NetworkPortsColumn),
		)
		fromU = sqlgraph.SetNeighbors(_q.driver.Dialect(), step)
		return fromU, nil
	}
	return query
}

// QueryNexusAudits chains the current query on the "nexus_audits" edge.
func (_q *TenantQuery) QueryNexusAudits() *NexusAuditQuery {
	query := (&NexusAuditClient{config: _q.config}).Query()
	query.path = func(ctx context.Context) (fromU *sql.Selector, err error) {
		if err := _q.prepareQuery(ctx); err != nil {
			return nil, err
		}
		selector := _q.sqlQuery(ctx)
		if err := selector.Err(); err != nil {
			return nil, err
		}
		step := sqlgraph.NewStep(
			sqlgraph.From(tenant.Table, tenant.FieldID, selector),
			sqlgraph.To(nexusaudit.Table, nexusaudit.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, tenant.NexusAuditsTable, tenant.NexusAuditsColumn),
		)
		fromU = sqlgraph.SetNeighbors(_q.driver.Dialect(), step)
		return fromU, nil
	}
	return query
}

// QuerySuccessionMaps chains the current query on the "succession_maps" edge.
func (_q *TenantQuery) QuerySuccessionMaps() *SuccessionMapQuery {
	query := (&SuccessionMapClient{config: _q.config}).Query()
	query.path = func(ctx context.Context) (fromU *sql.Selector, err error) {
		if err := _q.prepareQuery(ctx); err != nil {
			return nil, err
		}
		selector := _q.sqlQuery(ctx)
		if err := selector.Err(); err != nil {
			return nil, err
		}
		step := sqlgraph.NewStep(
			sqlgraph.From(tenant.Table, tenant.FieldID, selector),
			sqlgraph.To(successionmap.Table, successionmap.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, tenant.SuccessionMapsTable, tenant.SuccessionMapsColumn),
		)
		fromU = sqlgraph.SetNeighbors(_q.driver.Dialect(), step)
		return fromU, nil
	}
	return query
}

// QueryCustomerAccount chains the current query on the "customer_account" edge.
func (_q *TenantQuery) QueryCustomerAccount() *AccountQuery {
	query := (&AccountClient{config: _q.config}).Query()
	query.path = func(ctx context.Context) (fromU *sql.Selector, err error) {
		if err := _q.prepareQuery(ctx); err != nil {
			return nil, err
		}
		selector := _q.sqlQuery(ctx)
		if err := selector.Err(); err != nil {
			return nil, err
		}
		step := sqlgraph.NewStep(
			sqlgraph.From(tenant.Table, tenant.FieldID, selector),
			sqlgraph.To(account.Table, account.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, tenant.CustomerAccountTable, tenant.CustomerAccountColumn),
		)
		fromU = sqlgraph.SetNeighbors(_q.driver.Dialect(), step)
		return fromU, nil
	}
	return query
}

// QueryScripts chains the current query on the "scripts" edge.
func (_q *TenantQuery) QueryScripts() *ScriptQuery {
	query := (&ScriptClient{config: _q.config}).Query()
	query.path = func(ctx context.Context) (fromU *sql.Selector, err error) {
		if err := _q.prepareQuery(ctx); err != nil {
			return nil, err
		}
		selector := _q.sqlQuery(ctx)
		if err := selector.Err(); err != nil {
			return nil, err
		}
		step := sqlgraph.NewStep(
			sqlgraph.From(tenant.Table, tenant.FieldID, selector),
			sqlgraph.To(script.Table, script.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, tenant.ScriptsTable, tenant.ScriptsColumn),
		)
		fromU = sqlgraph.SetNeighbors(_q.driver.Dialect(), step)
		return fromU, nil
	}
	return query
}

// QueryJobs chains the current query on the "jobs" edge.
func (_q *TenantQuery) QueryJobs() *JobQuery {
	query := (&JobClient{config: _q.config}).Query()
	query.path = func(ctx context.Context) (fromU *sql.Selector, err error) {
		if err := _q.prepareQuery(ctx); err != nil {
			return nil, err
		}
		selector := _q.sqlQuery(ctx)
		if err := selector.Err(); err != nil {
			return nil, err
		}
		step := sqlgraph.NewStep(
			sqlgraph.From(tenant.Table, tenant.FieldID, selector),
			sqlgraph.To(job.Table, job.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, tenant.JobsTable, tenant.JobsColumn),
		)
		fromU = sqlgraph.SetNeighbors(_q.driver.Dialect(), step)
		return fromU, nil
	}
	return query
}

// QueryTimeOffRequests chains the current query on the "time_off_requests" edge.
func (_q *TenantQuery) QueryTimeOffRequests() *TimeOffRequestQuery {
	query := (&TimeOffRequestClient{config: _q.config}).Query()
	query.path = func(ctx context.Context) (fromU *sql.Selector, err error) {
		if err := _q.prepareQuery(ctx); err != nil {
			return nil, err
		}
		selector := _q.sqlQuery(ctx)
		if err := selector.Err(); err != nil {
			return nil, err
		}
		step := sqlgraph.NewStep(
			sqlgraph.From(tenant.Table, tenant.FieldID, selector),
			sqlgraph.To(timeoffrequest.Table, timeoffrequest.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, tenant.TimeOffRequestsTable, tenant.TimeOffRequestsColumn),
		)
		fromU = sqlgraph.SetNeighbors(_q.driver.Dialect(), step)
		return fromU, nil
	}
	return query
}

// QueryTimeOffPolicies chains the current query on the "time_off_policies" edge.
func (_q *TenantQuery) QueryTimeOffPolicies() *TimeOffPolicyQuery {
	query := (&TimeOffPolicyClient{config: _q.config}).Query()
	query.path = func(ctx context.Context) (fromU *sql.Selector, err error) {
		if err := _q.prepareQuery(ctx); err != nil {
			return nil, err
		}
		selector := _q.sqlQuery(ctx)
		if err := selector.Err(); err != nil {
			return nil, err
		}
		step := sqlgraph.NewStep(
			sqlgraph.From(tenant.Table, tenant.FieldID, selector),
			sqlgraph.To(timeoffpolicy.Table, timeoffpolicy.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, tenant.TimeOffPoliciesTable, tenant.TimeOffPoliciesColumn),
		)
		fromU = sqlgraph.SetNeighbors(_q.driver.Dialect(), step)
		return fromU, nil
	}
	return query
}

// QueryTimeOffBalances chains the current query on the "time_off_balances" edge.
func (_q *TenantQuery) QueryTimeOffBalances() *TimeOffBalanceQuery {
	query := (&TimeOffBalanceClient{config: _q.config}).Query()
	query.path = func(ctx context.Context) (fromU *sql.Selector, err error) {
		if err := _q.prepareQuery(ctx); err != nil {
			return nil, err
		}
		selector := _q.sqlQuery(ctx)
		if err := selector.Err(); err != nil {
			return nil, err
		}
		step := sqlgraph.NewStep(
			sqlgraph.From(tenant.Table, tenant.FieldID, selector),
			sqlgraph.To(timeoffbalance.Table, timeoffbalance.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, tenant.TimeOffBalancesTable, tenant.TimeOffBalancesColumn),
		)
		fromU = sqlgraph.SetNeighbors(_q.driver.Dialect(), step)
		return fromU, nil
	}
	return query
}

// QueryReviewCycles chains the current query on the "review_cycles" edge.
func (_q *TenantQuery) QueryReviewCycles() *ReviewCycleQuery {
	query := (&ReviewCycleClient{config: _q.config}).Query()
	query.path = func(ctx context.Context) (fromU *sql.Selector, err error) {
		if err := _q.prepareQuery(ctx); err != nil {
			return nil, err
		}
		selector := _q.sqlQuery(ctx)
		if err := selector.Err(); err != nil {
			return nil, err
		}
		step := sqlgraph.NewStep(
			sqlgraph.From(tenant.Table, tenant.FieldID, selector),
			sqlgraph.To(reviewcycle.Table, reviewcycle.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, tenant.ReviewCyclesTable, tenant.ReviewCyclesColumn),
		)
		fromU = sqlgraph.SetNeighbors(_q.driver.Dialect(), step)
		return fromU, nil
	}
	return query
}

// QueryPerformanceReviews chains the current query on the "performance_reviews" edge.
func (_q *TenantQuery) QueryPerformanceReviews() *PerformanceReviewQuery {
	query := (&PerformanceReviewClient{config: _q.config}).Query()
	query.path = func(ctx context.Context) (fromU *sql.Selector, err error) {
		if err := _q.prepareQuery(ctx); err != nil {
			return nil, err
		}
		selector := _q.sqlQuery(ctx)
		if err := selector.Err(); err != nil {
			return nil, err
		}
		step := sqlgraph.NewStep(
			sqlgraph.From(tenant.Table, tenant.FieldID, selector),
			sqlgraph.To(performancereview.Table, performancereview.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, tenant.PerformanceReviewsTable, tenant.PerformanceReviewsColumn),
		)
		fromU = sqlgraph.SetNeighbors(_q.driver.Dialect(), step)
		return fromU, nil
	}
	return query
}

// QueryGoals chains the current query on the "goals" edge.
func (_q *TenantQuery) QueryGoals() *GoalQuery {
	query := (&GoalClient{config: _q.config}).Query()
	query.path = func(ctx context.Context) (fromU *sql.Selector, err error) {
		if err := _q.prepareQuery(ctx); err != nil {
			return nil, err
		}
		selector := _q.sqlQuery(ctx)
		if err := selector.Err(); err != nil {
			return nil, err
		}
		step := sqlgraph.NewStep(
			sqlgraph.From(tenant.Table, tenant.FieldID, selector),
			sqlgraph.To(goal.Table, goal.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, tenant.GoalsTable, tenant.GoalsColumn),
		)
		fromU = sqlgraph.SetNeighbors(_q.driver.Dialect(), step)
		return fromU, nil
	}
	return query
}

// QuerySuppliers chains the current query on the "suppliers" edge.
func (_q *TenantQuery) QuerySuppliers() *SupplierQuery {
	query := (&SupplierClient{config: _q.config}).Query()
	query.path = func(ctx context.Context) (fromU *sql.Selector, err error) {
		if err := _q.prepareQuery(ctx); err != nil {
			return nil, err
		}
		selector := _q.sqlQuery(ctx)
		if err := selector.Err(); err != nil {
			return nil, err
		}
		step := sqlgraph.NewStep(
			sqlgraph.From(tenant.Table, tenant.FieldID, selector),
			sqlgraph.To(supplier.Table, supplier.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, tenant.SuppliersTable, tenant.SuppliersColumn),
		)
		fromU = sqlgraph.SetNeighbors(_q.driver.Dialect(), step)
		return fromU, nil
	}
	return query
}

// QueryCategories chains the current query on the "categories" edge.
func (_q *TenantQuery) QueryCategories() *CategoryQuery {
	query := (&CategoryClient{config: _q.config}).Query()
	query.path = func(ctx context.Context) (fromU *sql.Selector, err error) {
		if err := _q.prepareQuery(ctx); err != nil {
			return nil, err
		}
		selector := _q.sqlQuery(ctx)
		if err := selector.Err(); err != nil {
			return nil, err
		}
		step := sqlgraph.NewStep(
			sqlgraph.From(tenant.Table, tenant.FieldID, selector),
			sqlgraph.To(category.Table, category.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, tenant.CategoriesTable, tenant.CategoriesColumn),
		)
		fromU = sqlgraph.SetNeighbors(_q.driver.Dialect(), step)
		return fromU, nil
	}
	return query
}

// QueryWarehouses chains the current query on the "warehouses" edge.
func (_q *TenantQuery) QueryWarehouses() *WarehouseQuery {
	query := (&WarehouseClient{config: _q.config}).Query()
	query.path = func(ctx context.Context) (fromU *sql.Selector, err error) {
		if err := _q.prepareQuery(ctx); err != nil {
			return nil, err
		}
		selector := _q.sqlQuery(ctx)
		if err := selector.Err(); err != nil {
			return nil, err
		}
		step := sqlgraph.NewStep(
			sqlgraph.From(tenant.Table, tenant.FieldID, selector),
			sqlgraph.To(warehouse.Table, warehouse.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, tenant.WarehousesTable, tenant.WarehousesColumn),
		)
		fromU = sqlgraph.SetNeighbors(_q.driver.Dialect(), step)
		return fromU, nil
	}
	return query
}

// QueryAssetAssignments chains the current query on the "asset_assignments" edge.
func (_q *TenantQuery) QueryAssetAssignments() *AssetAssignmentQuery {
	query := (&AssetAssignmentClient{config: _q.config}).Query()
	query.path = func(ctx context.Context) (fromU *sql.Selector, err error) {
		if err := _q.prepareQuery(ctx); err != nil {
			return nil, err
		}
		selector := _q.sqlQuery(ctx)
		if err := selector.Err(); err != nil {
			return nil, err
		}
		step := sqlgraph.NewStep(
			sqlgraph.From(tenant.Table, tenant.FieldID, selector),
			sqlgraph.To(assetassignment.Table, assetassignment.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, tenant.AssetAssignmentsTable, tenant.AssetAssignmentsColumn),
		)
		fromU = sqlgraph.SetNeighbors(_q.driver.Dialect(), step)
		return fromU, nil
	}
	return query
}

// QueryContacts chains the current query on the "contacts" edge.
func (_q *TenantQuery) QueryContacts() *ContactQuery {
	query := (&ContactClient{config: _q.config}).Query()
	query.path = func(ctx context.Context) (fromU *sql.Selector, err error) {
		if err := _q.prepareQuery(ctx); err != nil {
			return nil, err
		}
		selector := _q.sqlQuery(ctx)
		if err := selector.Err(); err != nil {
			return nil, err
		}
		step := sqlgraph.NewStep(
			sqlgraph.From(tenant.Table, tenant.FieldID, selector),
			sqlgraph.To(contact.Table, contact.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, tenant.ContactsTable, tenant.ContactsColumn),
		)
		fromU = sqlgraph.SetNeighbors(_q.driver.Dialect(), step)
		return fromU, nil
	}
	return query
}

// QueryLegalHolds chains the current query on the "legal_holds" edge.
func (_q *TenantQuery) QueryLegalHolds() *LegalHoldQuery {
	query := (&LegalHoldClient{config: _q.config}).Query()
	query.path = func(ctx context.Context) (fromU *sql.Selector, err error) {
		if err := _q.prepareQuery(ctx); err != nil {
			return nil, err
		}
		selector := _q.sqlQuery(ctx)
		if err := selector.Err(); err != nil {
			return nil, err
		}
		step := sqlgraph.NewStep(
			sqlgraph.From(tenant.Table, tenant.FieldID, selector),
			sqlgraph.To(legalhold.Table, legalhold.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, tenant.LegalHoldsTable, tenant.LegalHoldsColumn),
		)
		fromU = sqlgraph.SetNeighbors(_q.driver.Dialect(), step)
		return fromU, nil
	}
	return query
}

// QueryRetentionPolicies chains the current query on the "retention_policies" edge.
func (_q *TenantQuery) QueryRetentionPolicies() *RetentionPolicyQuery {
	query := (&RetentionPolicyClient{config: _q.config}).Query()
	query.path = func(ctx context.Context) (fromU *sql.Selector, err error) {
		if err := _q.prepareQuery(ctx); err != nil {
			return nil, err
		}
		selector := _q.sqlQuery(ctx)
		if err := selector.Err(); err != nil {
			return nil, err
		}
		step := sqlgraph.NewStep(
			sqlgraph.From(tenant.Table, tenant.FieldID, selector),
			sqlgraph.To(retentionpolicy.Table, retentionpolicy.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, tenant.RetentionPoliciesTable, tenant.RetentionPoliciesColumn),
		)
		fromU = sqlgraph.SetNeighbors(_q.driver.Dialect(), step)
		return fromU, nil
	}
	return query
}

// QueryVaultTemplates chains the current query on the "vault_templates" edge.
func (_q *TenantQuery) QueryVaultTemplates() *VaultTemplateQuery {
	query := (&VaultTemplateClient{config: _q.config}).Query()
	query.path = func(ctx context.Context) (fromU *sql.Selector, err error) {
		if err := _q.prepareQuery(ctx); err != nil {
			return nil, err
		}
		selector := _q.sqlQuery(ctx)
		if err := selector.Err(); err != nil {
			return nil, err
		}
		step := sqlgraph.NewStep(
			sqlgraph.From(tenant.Table, tenant.FieldID, selector),
			sqlgraph.To(vaulttemplate.Table, vaulttemplate.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, tenant.VaultTemplatesTable, tenant.VaultTemplatesColumn),
		)
		fromU = sqlgraph.SetNeighbors(_q.driver.Dialect(), step)
		return fromU, nil
	}
	return query
}

// QueryStockAuditLogs chains the current query on the "stock_audit_logs" edge.
func (_q *TenantQuery) QueryStockAuditLogs() *StockAuditLogQuery {
	query := (&StockAuditLogClient{config: _q.config}).Query()
	query.path = func(ctx context.Context) (fromU *sql.Selector, err error) {
		if err := _q.prepareQuery(ctx); err != nil {
			return nil, err
		}
		selector := _q.sqlQuery(ctx)
		if err := selector.Err(); err != nil {
			return nil, err
		}
		step := sqlgraph.NewStep(
			sqlgraph.From(tenant.Table, tenant.FieldID, selector),
			sqlgraph.To(stockauditlog.Table, stockauditlog.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, tenant.StockAuditLogsTable, tenant.StockAuditLogsColumn),
		)
		fromU = sqlgraph.SetNeighbors(_q.driver.Dialect(), step)
		return fromU, nil
	}
	return query
}

// QueryMaintenanceSchedules chains the current query on the "maintenance_schedules" edge.
func (_q *TenantQuery) QueryMaintenanceSchedules() *MaintenanceScheduleQuery {
	query := (&MaintenanceScheduleClient{config: _q.config}).Query()
	query.path = func(ctx context.Context) (fromU *sql.Selector, err error) {
		if err := _q.prepareQuery(ctx); err != nil {
			return nil, err
		}
		selector := _q.sqlQuery(ctx)
		if err := selector.Err(); err != nil {
			return nil, err
		}
		step := sqlgraph.NewStep(
			sqlgraph.From(tenant.Table, tenant.FieldID, selector),
			sqlgraph.To(maintenanceschedule.Table, maintenanceschedule.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, tenant.MaintenanceSchedulesTable, tenant.MaintenanceSchedulesColumn),
		)
		fromU = sqlgraph.SetNeighbors(_q.driver.Dialect(), step)
		return fromU, nil
	}
	return query
}

// QueryStockAlerts chains the current query on the "stock_alerts" edge.
func (_q *TenantQuery) QueryStockAlerts() *StockAlertQuery {
	query := (&StockAlertClient{config: _q.config}).Query()
	query.path = func(ctx context.Context) (fromU *sql.Selector, err error) {
		if err := _q.prepareQuery(ctx); err != nil {
			return nil, err
		}
		selector := _q.sqlQuery(ctx)
		if err := selector.Err(); err != nil {
			return nil, err
		}
		step := sqlgraph.NewStep(
			sqlgraph.From(tenant.Table, tenant.FieldID, selector),
			sqlgraph.To(stockalert.Table, stockalert.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, tenant.StockAlertsTable, tenant.StockAlertsColumn),
		)
		fromU = sqlgraph.SetNeighbors(_q.driver.Dialect(), step)
		return fromU, nil
	}
	return query
}

// QueryPurchaseOrders chains the current query on the "purchase_orders" edge.
func (_q *TenantQuery) QueryPurchaseOrders() *PurchaseOrderQuery {
	query := (&PurchaseOrderClient{config: _q.config}).Query()
	query.path = func(ctx context.Context) (fromU *sql.Selector, err error) {
		if err := _q.prepareQuery(ctx); err != nil {
			return nil, err
		}
		selector := _q.sqlQuery(ctx)
		if err := selector.Err(); err != nil {
			return nil, err
		}
		step := sqlgraph.NewStep(
			sqlgraph.From(tenant.Table, tenant.FieldID, selector),
			sqlgraph.To(purchaseorder.Table, purchaseorder.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, tenant.PurchaseOrdersTable, tenant.PurchaseOrdersColumn),
		)
		fromU = sqlgraph.SetNeighbors(_q.driver.Dialect(), step)
		return fromU, nil
	}
	return query
}

// QueryInventoryCounts chains the current query on the "inventory_counts" edge.
func (_q *TenantQuery) QueryInventoryCounts() *InventoryCountQuery {
	query := (&InventoryCountClient{config: _q.config}).Query()
	query.path = func(ctx context.Context) (fromU *sql.Selector, err error) {
		if err := _q.prepareQuery(ctx); err != nil {
			return nil, err
		}
		selector := _q.sqlQuery(ctx)
		if err := selector.Err(); err != nil {
			return nil, err
		}
		step := sqlgraph.NewStep(
			sqlgraph.From(tenant.Table, tenant.FieldID, selector),
			sqlgraph.To(inventorycount.Table, inventorycount.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, tenant.InventoryCountsTable, tenant.InventoryCountsColumn),
		)
		fromU = sqlgraph.SetNeighbors(_q.driver.Dialect(), step)
		return fromU, nil
	}
	return query
}

// QueryJobPostings chains the current query on the "job_postings" edge.
func (_q *TenantQuery) QueryJobPostings() *JobPostingQuery {
	query := (&JobPostingClient{config: _q.config}).Query()
	query.path = func(ctx context.Context) (fromU *sql.Selector, err error) {
		if err := _q.prepareQuery(ctx); err != nil {
			return nil, err
		}
		selector := _q.sqlQuery(ctx)
		if err := selector.Err(); err != nil {
			return nil, err
		}
		step := sqlgraph.NewStep(
			sqlgraph.From(tenant.Table, tenant.FieldID, selector),
			sqlgraph.To(jobposting.Table, jobposting.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, tenant.JobPostingsTable, tenant.JobPostingsColumn),
		)
		fromU = sqlgraph.SetNeighbors(_q.driver.Dialect(), step)
		return fromU, nil
	}
	return query
}

// QueryCandidates chains the current query on the "candidates" edge.
func (_q *TenantQuery) QueryCandidates() *CandidateQuery {
	query := (&CandidateClient{config: _q.config}).Query()
	query.path = func(ctx context.Context) (fromU *sql.Selector, err error) {
		if err := _q.prepareQuery(ctx); err != nil {
			return nil, err
		}
		selector := _q.sqlQuery(ctx)
		if err := selector.Err(); err != nil {
			return nil, err
		}
		step := sqlgraph.NewStep(
			sqlgraph.From(tenant.Table, tenant.FieldID, selector),
			sqlgraph.To(candidate.Table, candidate.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, tenant.CandidatesTable, tenant.CandidatesColumn),
		)
		fromU = sqlgraph.SetNeighbors(_q.driver.Dialect(), step)
		return fromU, nil
	}
	return query
}

// QueryApplications chains the current query on the "applications" edge.
func (_q *TenantQuery) QueryApplications() *ApplicationQuery {
	query := (&ApplicationClient{config: _q.config}).Query()
	query.path = func(ctx context.Context) (fromU *sql.Selector, err error) {
		if err := _q.prepareQuery(ctx); err != nil {
			return nil, err
		}
		selector := _q.sqlQuery(ctx)
		if err := selector.Err(); err != nil {
			return nil, err
		}
		step := sqlgraph.NewStep(
			sqlgraph.From(tenant.Table, tenant.FieldID, selector),
			sqlgraph.To(application.Table, application.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, tenant.ApplicationsTable, tenant.ApplicationsColumn),
		)
		fromU = sqlgraph.SetNeighbors(_q.driver.Dialect(), step)
		return fromU, nil
	}
	return query
}

// QueryInterviews chains the current query on the "interviews" edge.
func (_q *TenantQuery) QueryInterviews() *InterviewQuery {
	query := (&InterviewClient{config: _q.config}).Query()
	query.path = func(ctx context.Context) (fromU *sql.Selector, err error) {
		if err := _q.prepareQuery(ctx); err != nil {
			return nil, err
		}
		selector := _q.sqlQuery(ctx)
		if err := selector.Err(); err != nil {
			return nil, err
		}
		step := sqlgraph.NewStep(
			sqlgraph.From(tenant.Table, tenant.FieldID, selector),
			sqlgraph.To(interview.Table, interview.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, tenant.InterviewsTable, tenant.InterviewsColumn),
		)
		fromU = sqlgraph.SetNeighbors(_q.driver.Dialect(), step)
		return fromU, nil
	}
	return query
}

// QueryBenefitPlans chains the current query on the "benefit_plans" edge.
func (_q *TenantQuery) QueryBenefitPlans() *BenefitPlanQuery {
	query := (&BenefitPlanClient{config: _q.config}).Query()
	query.path = func(ctx context.Context) (fromU *sql.Selector, err error) {
		if err := _q.prepareQuery(ctx); err != nil {
			return nil, err
		}
		selector := _q.sqlQuery(ctx)
		if err := selector.Err(); err != nil {
			return nil, err
		}
		step := sqlgraph.NewStep(
			sqlgraph.From(tenant.Table, tenant.FieldID, selector),
			sqlgraph.To(benefitplan.Table, benefitplan.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, tenant.BenefitPlansTable, tenant.BenefitPlansColumn),
		)
		fromU = sqlgraph.SetNeighbors(_q.driver.Dialect(), step)
		return fromU, nil
	}
	return query
}

// QueryBenefitEnrollments chains the current query on the "benefit_enrollments" edge.
func (_q *TenantQuery) QueryBenefitEnrollments() *BenefitEnrollmentQuery {
	query := (&BenefitEnrollmentClient{config: _q.config}).Query()
	query.path = func(ctx context.Context) (fromU *sql.Selector, err error) {
		if err := _q.prepareQuery(ctx); err != nil {
			return nil, err
		}
		selector := _q.sqlQuery(ctx)
		if err := selector.Err(); err != nil {
			return nil, err
		}
		step := sqlgraph.NewStep(
			sqlgraph.From(tenant.Table, tenant.FieldID, selector),
			sqlgraph.To(benefitenrollment.Table, benefitenrollment.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, tenant.BenefitEnrollmentsTable, tenant.BenefitEnrollmentsColumn),
		)
		fromU = sqlgraph.SetNeighbors(_q.driver.Dialect(), step)
		return fromU, nil
	}
	return query
}

// First returns the first Tenant entity from the query.
// Returns a *NotFoundError when no Tenant was found.
func (_q *TenantQuery) First(ctx context.Context) (*Tenant, error) {
	nodes, err := _q.Limit(1).All(setContextOp(ctx, _q.ctx, ent.OpQueryFirst))
	if err != nil {
		return nil, err
	}
	if len(nodes) == 0 {
		return nil, &NotFoundError{tenant.Label}
	}
	return nodes[0], nil
}

// FirstX is like First, but panics if an error occurs.
func (_q *TenantQuery) FirstX(ctx context.Context) *Tenant {
	node, err := _q.First(ctx)
	if err != nil && !IsNotFound(err) {
		panic(err)
	}
	return node
}

// FirstID returns the first Tenant ID from the query.
// Returns a *NotFoundError when no Tenant ID was found.
func (_q *TenantQuery) FirstID(ctx context.Context) (id int, err error) {
	var ids []int
	if ids, err = _q.Limit(1).IDs(setContextOp(ctx, _q.ctx, ent.OpQueryFirstID)); err != nil {
		return
	}
	if len(ids) == 0 {
		err = &NotFoundError{tenant.Label}
		return
	}
	return ids[0], nil
}

// FirstIDX is like FirstID, but panics if an error occurs.
func (_q *TenantQuery) FirstIDX(ctx context.Context) int {
	id, err := _q.FirstID(ctx)
	if err != nil && !IsNotFound(err) {
		panic(err)
	}
	return id
}

// Only returns a single Tenant entity found by the query, ensuring it only returns one.
// Returns a *NotSingularError when more than one Tenant entity is found.
// Returns a *NotFoundError when no Tenant entities are found.
func (_q *TenantQuery) Only(ctx context.Context) (*Tenant, error) {
	nodes, err := _q.Limit(2).All(setContextOp(ctx, _q.ctx, ent.OpQueryOnly))
	if err != nil {
		return nil, err
	}
	switch len(nodes) {
	case 1:
		return nodes[0], nil
	case 0:
		return nil, &NotFoundError{tenant.Label}
	default:
		return nil, &NotSingularError{tenant.Label}
	}
}

// OnlyX is like Only, but panics if an error occurs.
func (_q *TenantQuery) OnlyX(ctx context.Context) *Tenant {
	node, err := _q.Only(ctx)
	if err != nil {
		panic(err)
	}
	return node
}

// OnlyID is like Only, but returns the only Tenant ID in the query.
// Returns a *NotSingularError when more than one Tenant ID is found.
// Returns a *NotFoundError when no entities are found.
func (_q *TenantQuery) OnlyID(ctx context.Context) (id int, err error) {
	var ids []int
	if ids, err = _q.Limit(2).IDs(setContextOp(ctx, _q.ctx, ent.OpQueryOnlyID)); err != nil {
		return
	}
	switch len(ids) {
	case 1:
		id = ids[0]
	case 0:
		err = &NotFoundError{tenant.Label}
	default:
		err = &NotSingularError{tenant.Label}
	}
	return
}

// OnlyIDX is like OnlyID, but panics if an error occurs.
func (_q *TenantQuery) OnlyIDX(ctx context.Context) int {
	id, err := _q.OnlyID(ctx)
	if err != nil {
		panic(err)
	}
	return id
}

// All executes the query and returns a list of Tenants.
func (_q *TenantQuery) All(ctx context.Context) ([]*Tenant, error) {
	ctx = setContextOp(ctx, _q.ctx, ent.OpQueryAll)
	if err := _q.prepareQuery(ctx); err != nil {
		return nil, err
	}
	qr := querierAll[[]*Tenant, *TenantQuery]()
	return withInterceptors[[]*Tenant](ctx, _q, qr, _q.inters)
}

// AllX is like All, but panics if an error occurs.
func (_q *TenantQuery) AllX(ctx context.Context) []*Tenant {
	nodes, err := _q.All(ctx)
	if err != nil {
		panic(err)
	}
	return nodes
}

// IDs executes the query and returns a list of Tenant IDs.
func (_q *TenantQuery) IDs(ctx context.Context) (ids []int, err error) {
	if _q.ctx.Unique == nil && _q.path != nil {
		_q.Unique(true)
	}
	ctx = setContextOp(ctx, _q.ctx, ent.OpQueryIDs)
	if err = _q.Select(tenant.FieldID).Scan(ctx, &ids); err != nil {
		return nil, err
	}
	return ids, nil
}

// IDsX is like IDs, but panics if an error occurs.
func (_q *TenantQuery) IDsX(ctx context.Context) []int {
	ids, err := _q.IDs(ctx)
	if err != nil {
		panic(err)
	}
	return ids
}

// Count returns the count of the given query.
func (_q *TenantQuery) Count(ctx context.Context) (int, error) {
	ctx = setContextOp(ctx, _q.ctx, ent.OpQueryCount)
	if err := _q.prepareQuery(ctx); err != nil {
		return 0, err
	}
	return withInterceptors[int](ctx, _q, querierCount[*TenantQuery](), _q.inters)
}

// CountX is like Count, but panics if an error occurs.
func (_q *TenantQuery) CountX(ctx context.Context) int {
	count, err := _q.Count(ctx)
	if err != nil {
		panic(err)
	}
	return count
}

// Exist returns true if the query has elements in the graph.
func (_q *TenantQuery) Exist(ctx context.Context) (bool, error) {
	ctx = setContextOp(ctx, _q.ctx, ent.OpQueryExist)
	switch _, err := _q.FirstID(ctx); {
	case IsNotFound(err):
		return false, nil
	case err != nil:
		return false, fmt.Errorf("ent: check existence: %w", err)
	default:
		return true, nil
	}
}

// ExistX is like Exist, but panics if an error occurs.
func (_q *TenantQuery) ExistX(ctx context.Context) bool {
	exist, err := _q.Exist(ctx)
	if err != nil {
		panic(err)
	}
	return exist
}

// Clone returns a duplicate of the TenantQuery builder, including all associated steps. It can be
// used to prepare common query builders and use them differently after the clone is made.
func (_q *TenantQuery) Clone() *TenantQuery {
	if _q == nil {
		return nil
	}
	return &TenantQuery{
		config:                     _q.config,
		ctx:                        _q.ctx.Clone(),
		order:                      append([]tenant.OrderOption{}, _q.order...),
		inters:                     append([]Interceptor{}, _q.inters...),
		predicates:                 append([]predicate.Tenant{}, _q.predicates...),
		withParent:                 _q.withParent.Clone(),
		withChildren:               _q.withChildren.Clone(),
		withUsers:                  _q.withUsers.Clone(),
		withAccounts:               _q.withAccounts.Clone(),
		withTransactions:           _q.withTransactions.Clone(),
		withLedgerEntries:          _q.withLedgerEntries.Clone(),
		withProducts:               _q.withProducts.Clone(),
		withStockMovements:         _q.withStockMovements.Clone(),
		withAuditLogs:              _q.withAuditLogs.Clone(),
		withAgents:                 _q.withAgents.Clone(),
		withDiscoveryEntries:       _q.withDiscoveryEntries.Clone(),
		withAssets:                 _q.withAssets.Clone(),
		withCredentials:            _q.withCredentials.Clone(),
		withOneTimeLinks:           _q.withOneTimeLinks.Clone(),
		withSops:                   _q.withSops.Clone(),
		withCameras:                _q.withCameras.Clone(),
		withTickets:                _q.withTickets.Clone(),
		withContracts:              _q.withContracts.Clone(),
		withSaasApps:               _q.withSaasApps.Clone(),
		withSaasFilters:            _q.withSaasFilters.Clone(),
		withCallLogs:               _q.withCallLogs.Clone(),
		withIvrFlows:               _q.withIvrFlows.Clone(),
		withVoicemails:             _q.withVoicemails.Clone(),
		withHealthSnapshots:        _q.withHealthSnapshots.Clone(),
		withRoadmaps:               _q.withRoadmaps.Clone(),
		withServiceRates:           _q.withServiceRates.Clone(),
		withNetworkDevices:         _q.withNetworkDevices.Clone(),
		withNetworkBackups:         _q.withNetworkBackups.Clone(),
		withBudgetForecasts:        _q.withBudgetForecasts.Clone(),
		withEmployees:              _q.withEmployees.Clone(),
		withCompensationAgreements: _q.withCompensationAgreements.Clone(),
		withVaultItems:             _q.withVaultItems.Clone(),
		withVaultShareLinks:        _q.withVaultShareLinks.Clone(),
		withJournalEntries:         _q.withJournalEntries.Clone(),
		withRecurringInvoices:      _q.withRecurringInvoices.Clone(),
		withInventoryReservations:  _q.withInventoryReservations.Clone(),
		withDepartments:            _q.withDepartments.Clone(),
		withPermissions:            _q.withPermissions.Clone(),
		withAssetTypes:             _q.withAssetTypes.Clone(),
		withDetectionEvents:        _q.withDetectionEvents.Clone(),
		withSaasIdentities:         _q.withSaasIdentities.Clone(),
		withSaasUsages:             _q.withSaasUsages.Clone(),
		withRecordings:             _q.withRecordings.Clone(),
		withNetworkLinks:           _q.withNetworkLinks.Clone(),
		withNetworkPorts:           _q.withNetworkPorts.Clone(),
		withNexusAudits:            _q.withNexusAudits.Clone(),
		withSuccessionMaps:         _q.withSuccessionMaps.Clone(),
		withCustomerAccount:        _q.withCustomerAccount.Clone(),
		withScripts:                _q.withScripts.Clone(),
		withJobs:                   _q.withJobs.Clone(),
		withTimeOffRequests:        _q.withTimeOffRequests.Clone(),
		withTimeOffPolicies:        _q.withTimeOffPolicies.Clone(),
		withTimeOffBalances:        _q.withTimeOffBalances.Clone(),
		withReviewCycles:           _q.withReviewCycles.Clone(),
		withPerformanceReviews:     _q.withPerformanceReviews.Clone(),
		withGoals:                  _q.withGoals.Clone(),
		withSuppliers:              _q.withSuppliers.Clone(),
		withCategories:             _q.withCategories.Clone(),
		withWarehouses:             _q.withWarehouses.Clone(),
		withAssetAssignments:       _q.withAssetAssignments.Clone(),
		withContacts:               _q.withContacts.Clone(),
		withLegalHolds:             _q.withLegalHolds.Clone(),
		withRetentionPolicies:      _q.withRetentionPolicies.Clone(),
		withVaultTemplates:         _q.withVaultTemplates.Clone(),
		withStockAuditLogs:         _q.withStockAuditLogs.Clone(),
		withMaintenanceSchedules:   _q.withMaintenanceSchedules.Clone(),
		withStockAlerts:            _q.withStockAlerts.Clone(),
		withPurchaseOrders:         _q.withPurchaseOrders.Clone(),
		withInventoryCounts:        _q.withInventoryCounts.Clone(),
		withJobPostings:            _q.withJobPostings.Clone(),
		withCandidates:             _q.withCandidates.Clone(),
		withApplications:           _q.withApplications.Clone(),
		withInterviews:             _q.withInterviews.Clone(),
		withBenefitPlans:           _q.withBenefitPlans.Clone(),
		withBenefitEnrollments:     _q.withBenefitEnrollments.Clone(),
		// clone intermediate query.
		sql:       _q.sql.Clone(),
		path:      _q.path,
		modifiers: append([]func(*sql.Selector){}, _q.modifiers...),
	}
}

// WithParent tells the query-builder to eager-load the nodes that are connected to
// the "parent" edge. The optional arguments are used to configure the query builder of the edge.
func (_q *TenantQuery) WithParent(opts ...func(*TenantQuery)) *TenantQuery {
	query := (&TenantClient{config: _q.config}).Query()
	for _, opt := range opts {
		opt(query)
	}
	_q.withParent = query
	return _q
}

// WithChildren tells the query-builder to eager-load the nodes that are connected to
// the "children" edge. The optional arguments are used to configure the query builder of the edge.
func (_q *TenantQuery) WithChildren(opts ...func(*TenantQuery)) *TenantQuery {
	query := (&TenantClient{config: _q.config}).Query()
	for _, opt := range opts {
		opt(query)
	}
	_q.withChildren = query
	return _q
}

// WithUsers tells the query-builder to eager-load the nodes that are connected to
// the "users" edge. The optional arguments are used to configure the query builder of the edge.
func (_q *TenantQuery) WithUsers(opts ...func(*UserQuery)) *TenantQuery {
	query := (&UserClient{config: _q.config}).Query()
	for _, opt := range opts {
		opt(query)
	}
	_q.withUsers = query
	return _q
}

// WithAccounts tells the query-builder to eager-load the nodes that are connected to
// the "accounts" edge. The optional arguments are used to configure the query builder of the edge.
func (_q *TenantQuery) WithAccounts(opts ...func(*AccountQuery)) *TenantQuery {
	query := (&AccountClient{config: _q.config}).Query()
	for _, opt := range opts {
		opt(query)
	}
	_q.withAccounts = query
	return _q
}

// WithTransactions tells the query-builder to eager-load the nodes that are connected to
// the "transactions" edge. The optional arguments are used to configure the query builder of the edge.
func (_q *TenantQuery) WithTransactions(opts ...func(*TransactionQuery)) *TenantQuery {
	query := (&TransactionClient{config: _q.config}).Query()
	for _, opt := range opts {
		opt(query)
	}
	_q.withTransactions = query
	return _q
}

// WithLedgerEntries tells the query-builder to eager-load the nodes that are connected to
// the "ledger_entries" edge. The optional arguments are used to configure the query builder of the edge.
func (_q *TenantQuery) WithLedgerEntries(opts ...func(*LedgerEntryQuery)) *TenantQuery {
	query := (&LedgerEntryClient{config: _q.config}).Query()
	for _, opt := range opts {
		opt(query)
	}
	_q.withLedgerEntries = query
	return _q
}

// WithProducts tells the query-builder to eager-load the nodes that are connected to
// the "products" edge. The optional arguments are used to configure the query builder of the edge.
func (_q *TenantQuery) WithProducts(opts ...func(*ProductQuery)) *TenantQuery {
	query := (&ProductClient{config: _q.config}).Query()
	for _, opt := range opts {
		opt(query)
	}
	_q.withProducts = query
	return _q
}

// WithStockMovements tells the query-builder to eager-load the nodes that are connected to
// the "stock_movements" edge. The optional arguments are used to configure the query builder of the edge.
func (_q *TenantQuery) WithStockMovements(opts ...func(*StockMovementQuery)) *TenantQuery {
	query := (&StockMovementClient{config: _q.config}).Query()
	for _, opt := range opts {
		opt(query)
	}
	_q.withStockMovements = query
	return _q
}

// WithAuditLogs tells the query-builder to eager-load the nodes that are connected to
// the "audit_logs" edge. The optional arguments are used to configure the query builder of the edge.
func (_q *TenantQuery) WithAuditLogs(opts ...func(*AuditLogQuery)) *TenantQuery {
	query := (&AuditLogClient{config: _q.config}).Query()
	for _, opt := range opts {
		opt(query)
	}
	_q.withAuditLogs = query
	return _q
}

// WithAgents tells the query-builder to eager-load the nodes that are connected to
// the "agents" edge. The optional arguments are used to configure the query builder of the edge.
func (_q *TenantQuery) WithAgents(opts ...func(*AgentQuery)) *TenantQuery {
	query := (&AgentClient{config: _q.config}).Query()
	for _, opt := range opts {
		opt(query)
	}
	_q.withAgents = query
	return _q
}

// WithDiscoveryEntries tells the query-builder to eager-load the nodes that are connected to
// the "discovery_entries" edge. The optional arguments are used to configure the query builder of the edge.
func (_q *TenantQuery) WithDiscoveryEntries(opts ...func(*DiscoveryEntryQuery)) *TenantQuery {
	query := (&DiscoveryEntryClient{config: _q.config}).Query()
	for _, opt := range opts {
		opt(query)
	}
	_q.withDiscoveryEntries = query
	return _q
}

// WithAssets tells the query-builder to eager-load the nodes that are connected to
// the "assets" edge. The optional arguments are used to configure the query builder of the edge.
func (_q *TenantQuery) WithAssets(opts ...func(*AssetQuery)) *TenantQuery {
	query := (&AssetClient{config: _q.config}).Query()
	for _, opt := range opts {
		opt(query)
	}
	_q.withAssets = query
	return _q
}

// WithCredentials tells the query-builder to eager-load the nodes that are connected to
// the "credentials" edge. The optional arguments are used to configure the query builder of the edge.
func (_q *TenantQuery) WithCredentials(opts ...func(*CredentialQuery)) *TenantQuery {
	query := (&CredentialClient{config: _q.config}).Query()
	for _, opt := range opts {
		opt(query)
	}
	_q.withCredentials = query
	return _q
}

// WithOneTimeLinks tells the query-builder to eager-load the nodes that are connected to
// the "one_time_links" edge. The optional arguments are used to configure the query builder of the edge.
func (_q *TenantQuery) WithOneTimeLinks(opts ...func(*OneTimeLinkQuery)) *TenantQuery {
	query := (&OneTimeLinkClient{config: _q.config}).Query()
	for _, opt := range opts {
		opt(query)
	}
	_q.withOneTimeLinks = query
	return _q
}

// WithSops tells the query-builder to eager-load the nodes that are connected to
// the "sops" edge. The optional arguments are used to configure the query builder of the edge.
func (_q *TenantQuery) WithSops(opts ...func(*SOPQuery)) *TenantQuery {
	query := (&SOPClient{config: _q.config}).Query()
	for _, opt := range opts {
		opt(query)
	}
	_q.withSops = query
	return _q
}

// WithCameras tells the query-builder to eager-load the nodes that are connected to
// the "cameras" edge. The optional arguments are used to configure the query builder of the edge.
func (_q *TenantQuery) WithCameras(opts ...func(*CameraQuery)) *TenantQuery {
	query := (&CameraClient{config: _q.config}).Query()
	for _, opt := range opts {
		opt(query)
	}
	_q.withCameras = query
	return _q
}

// WithTickets tells the query-builder to eager-load the nodes that are connected to
// the "tickets" edge. The optional arguments are used to configure the query builder of the edge.
func (_q *TenantQuery) WithTickets(opts ...func(*TicketQuery)) *TenantQuery {
	query := (&TicketClient{config: _q.config}).Query()
	for _, opt := range opts {
		opt(query)
	}
	_q.withTickets = query
	return _q
}

// WithContracts tells the query-builder to eager-load the nodes that are connected to
// the "contracts" edge. The optional arguments are used to configure the query builder of the edge.
func (_q *TenantQuery) WithContracts(opts ...func(*ContractQuery)) *TenantQuery {
	query := (&ContractClient{config: _q.config}).Query()
	for _, opt := range opts {
		opt(query)
	}
	_q.withContracts = query
	return _q
}

// WithSaasApps tells the query-builder to eager-load the nodes that are connected to
// the "saas_apps" edge. The optional arguments are used to configure the query builder of the edge.
func (_q *TenantQuery) WithSaasApps(opts ...func(*SaaSAppQuery)) *TenantQuery {
	query := (&SaaSAppClient{config: _q.config}).Query()
	for _, opt := range opts {
		opt(query)
	}
	_q.withSaasApps = query
	return _q
}

// WithSaasFilters tells the query-builder to eager-load the nodes that are connected to
// the "saas_filters" edge. The optional arguments are used to configure the query builder of the edge.
func (_q *TenantQuery) WithSaasFilters(opts ...func(*SaaSFilterQuery)) *TenantQuery {
	query := (&SaaSFilterClient{config: _q.config}).Query()
	for _, opt := range opts {
		opt(query)
	}
	_q.withSaasFilters = query
	return _q
}

// WithCallLogs tells the query-builder to eager-load the nodes that are connected to
// the "call_logs" edge. The optional arguments are used to configure the query builder of the edge.
func (_q *TenantQuery) WithCallLogs(opts ...func(*CallLogQuery)) *TenantQuery {
	query := (&CallLogClient{config: _q.config}).Query()
	for _, opt := range opts {
		opt(query)
	}
	_q.withCallLogs = query
	return _q
}

// WithIvrFlows tells the query-builder to eager-load the nodes that are connected to
// the "ivr_flows" edge. The optional arguments are used to configure the query builder of the edge.
func (_q *TenantQuery) WithIvrFlows(opts ...func(*IVRFlowQuery)) *TenantQuery {
	query := (&IVRFlowClient{config: _q.config}).Query()
	for _, opt := range opts {
		opt(query)
	}
	_q.withIvrFlows = query
	return _q
}

// WithVoicemails tells the query-builder to eager-load the nodes that are connected to
// the "voicemails" edge. The optional arguments are used to configure the query builder of the edge.
func (_q *TenantQuery) WithVoicemails(opts ...func(*VoicemailQuery)) *TenantQuery {
	query := (&VoicemailClient{config: _q.config}).Query()
	for _, opt := range opts {
		opt(query)
	}
	_q.withVoicemails = query
	return _q
}

// WithHealthSnapshots tells the query-builder to eager-load the nodes that are connected to
// the "health_snapshots" edge. The optional arguments are used to configure the query builder of the edge.
func (_q *TenantQuery) WithHealthSnapshots(opts ...func(*HealthScoreSnapshotQuery)) *TenantQuery {
	query := (&HealthScoreSnapshotClient{config: _q.config}).Query()
	for _, opt := range opts {
		opt(query)
	}
	_q.withHealthSnapshots = query
	return _q
}

// WithRoadmaps tells the query-builder to eager-load the nodes that are connected to
// the "roadmaps" edge. The optional arguments are used to configure the query builder of the edge.
func (_q *TenantQuery) WithRoadmaps(opts ...func(*StrategicRoadmapQuery)) *TenantQuery {
	query := (&StrategicRoadmapClient{config: _q.config}).Query()
	for _, opt := range opts {
		opt(query)
	}
	_q.withRoadmaps = query
	return _q
}

// WithServiceRates tells the query-builder to eager-load the nodes that are connected to
// the "service_rates" edge. The optional arguments are used to configure the query builder of the edge.
func (_q *TenantQuery) WithServiceRates(opts ...func(*ServiceRateQuery)) *TenantQuery {
	query := (&ServiceRateClient{config: _q.config}).Query()
	for _, opt := range opts {
		opt(query)
	}
	_q.withServiceRates = query
	return _q
}

// WithNetworkDevices tells the query-builder to eager-load the nodes that are connected to
// the "network_devices" edge. The optional arguments are used to configure the query builder of the edge.
func (_q *TenantQuery) WithNetworkDevices(opts ...func(*NetworkDeviceQuery)) *TenantQuery {
	query := (&NetworkDeviceClient{config: _q.config}).Query()
	for _, opt := range opts {
		opt(query)
	}
	_q.withNetworkDevices = query
	return _q
}

// WithNetworkBackups tells the query-builder to eager-load the nodes that are connected to
// the "network_backups" edge. The optional arguments are used to configure the query builder of the edge.
func (_q *TenantQuery) WithNetworkBackups(opts ...func(*NetworkBackupQuery)) *TenantQuery {
	query := (&NetworkBackupClient{config: _q.config}).Query()
	for _, opt := range opts {
		opt(query)
	}
	_q.withNetworkBackups = query
	return _q
}

// WithBudgetForecasts tells the query-builder to eager-load the nodes that are connected to
// the "budget_forecasts" edge. The optional arguments are used to configure the query builder of the edge.
func (_q *TenantQuery) WithBudgetForecasts(opts ...func(*BudgetForecastQuery)) *TenantQuery {
	query := (&BudgetForecastClient{config: _q.config}).Query()
	for _, opt := range opts {
		opt(query)
	}
	_q.withBudgetForecasts = query
	return _q
}

// WithEmployees tells the query-builder to eager-load the nodes that are connected to
// the "employees" edge. The optional arguments are used to configure the query builder of the edge.
func (_q *TenantQuery) WithEmployees(opts ...func(*EmployeeQuery)) *TenantQuery {
	query := (&EmployeeClient{config: _q.config}).Query()
	for _, opt := range opts {
		opt(query)
	}
	_q.withEmployees = query
	return _q
}

// WithCompensationAgreements tells the query-builder to eager-load the nodes that are connected to
// the "compensation_agreements" edge. The optional arguments are used to configure the query builder of the edge.
func (_q *TenantQuery) WithCompensationAgreements(opts ...func(*CompensationAgreementQuery)) *TenantQuery {
	query := (&CompensationAgreementClient{config: _q.config}).Query()
	for _, opt := range opts {
		opt(query)
	}
	_q.withCompensationAgreements = query
	return _q
}

// WithVaultItems tells the query-builder to eager-load the nodes that are connected to
// the "vault_items" edge. The optional arguments are used to configure the query builder of the edge.
func (_q *TenantQuery) WithVaultItems(opts ...func(*VaultItemQuery)) *TenantQuery {
	query := (&VaultItemClient{config: _q.config}).Query()
	for _, opt := range opts {
		opt(query)
	}
	_q.withVaultItems = query
	return _q
}

// WithVaultShareLinks tells the query-builder to eager-load the nodes that are connected to
// the "vault_share_links" edge. The optional arguments are used to configure the query builder of the edge.
func (_q *TenantQuery) WithVaultShareLinks(opts ...func(*VaultShareLinkQuery)) *TenantQuery {
	query := (&VaultShareLinkClient{config: _q.config}).Query()
	for _, opt := range opts {
		opt(query)
	}
	_q.withVaultShareLinks = query
	return _q
}

// WithJournalEntries tells the query-builder to eager-load the nodes that are connected to
// the "journal_entries" edge. The optional arguments are used to configure the query builder of the edge.
func (_q *TenantQuery) WithJournalEntries(opts ...func(*JournalEntryQuery)) *TenantQuery {
	query := (&JournalEntryClient{config: _q.config}).Query()
	for _, opt := range opts {
		opt(query)
	}
	_q.withJournalEntries = query
	return _q
}

// WithRecurringInvoices tells the query-builder to eager-load the nodes that are connected to
// the "recurring_invoices" edge. The optional arguments are used to configure the query builder of the edge.
func (_q *TenantQuery) WithRecurringInvoices(opts ...func(*RecurringInvoiceQuery)) *TenantQuery {
	query := (&RecurringInvoiceClient{config: _q.config}).Query()
	for _, opt := range opts {
		opt(query)
	}
	_q.withRecurringInvoices = query
	return _q
}

// WithInventoryReservations tells the query-builder to eager-load the nodes that are connected to
// the "inventory_reservations" edge. The optional arguments are used to configure the query builder of the edge.
func (_q *TenantQuery) WithInventoryReservations(opts ...func(*InventoryReservationQuery)) *TenantQuery {
	query := (&InventoryReservationClient{config: _q.config}).Query()
	for _, opt := range opts {
		opt(query)
	}
	_q.withInventoryReservations = query
	return _q
}

// WithDepartments tells the query-builder to eager-load the nodes that are connected to
// the "departments" edge. The optional arguments are used to configure the query builder of the edge.
func (_q *TenantQuery) WithDepartments(opts ...func(*DepartmentQuery)) *TenantQuery {
	query := (&DepartmentClient{config: _q.config}).Query()
	for _, opt := range opts {
		opt(query)
	}
	_q.withDepartments = query
	return _q
}

// WithPermissions tells the query-builder to eager-load the nodes that are connected to
// the "permissions" edge. The optional arguments are used to configure the query builder of the edge.
func (_q *TenantQuery) WithPermissions(opts ...func(*PermissionQuery)) *TenantQuery {
	query := (&PermissionClient{config: _q.config}).Query()
	for _, opt := range opts {
		opt(query)
	}
	_q.withPermissions = query
	return _q
}

// WithAssetTypes tells the query-builder to eager-load the nodes that are connected to
// the "asset_types" edge. The optional arguments are used to configure the query builder of the edge.
func (_q *TenantQuery) WithAssetTypes(opts ...func(*AssetTypeQuery)) *TenantQuery {
	query := (&AssetTypeClient{config: _q.config}).Query()
	for _, opt := range opts {
		opt(query)
	}
	_q.withAssetTypes = query
	return _q
}

// WithDetectionEvents tells the query-builder to eager-load the nodes that are connected to
// the "detection_events" edge. The optional arguments are used to configure the query builder of the edge.
func (_q *TenantQuery) WithDetectionEvents(opts ...func(*DetectionEventQuery)) *TenantQuery {
	query := (&DetectionEventClient{config: _q.config}).Query()
	for _, opt := range opts {
		opt(query)
	}
	_q.withDetectionEvents = query
	return _q
}

// WithSaasIdentities tells the query-builder to eager-load the nodes that are connected to
// the "saas_identities" edge. The optional arguments are used to configure the query builder of the edge.
func (_q *TenantQuery) WithSaasIdentities(opts ...func(*SaaSIdentityQuery)) *TenantQuery {
	query := (&SaaSIdentityClient{config: _q.config}).Query()
	for _, opt := range opts {
		opt(query)
	}
	_q.withSaasIdentities = query
	return _q
}

// WithSaasUsages tells the query-builder to eager-load the nodes that are connected to
// the "saas_usages" edge. The optional arguments are used to configure the query builder of the edge.
func (_q *TenantQuery) WithSaasUsages(opts ...func(*SaaSUsageQuery)) *TenantQuery {
	query := (&SaaSUsageClient{config: _q.config}).Query()
	for _, opt := range opts {
		opt(query)
	}
	_q.withSaasUsages = query
	return _q
}

// WithRecordings tells the query-builder to eager-load the nodes that are connected to
// the "recordings" edge. The optional arguments are used to configure the query builder of the edge.
func (_q *TenantQuery) WithRecordings(opts ...func(*RecordingQuery)) *TenantQuery {
	query := (&RecordingClient{config: _q.config}).Query()
	for _, opt := range opts {
		opt(query)
	}
	_q.withRecordings = query
	return _q
}

// WithNetworkLinks tells the query-builder to eager-load the nodes that are connected to
// the "network_links" edge. The optional arguments are used to configure the query builder of the edge.
func (_q *TenantQuery) WithNetworkLinks(opts ...func(*NetworkLinkQuery)) *TenantQuery {
	query := (&NetworkLinkClient{config: _q.config}).Query()
	for _, opt := range opts {
		opt(query)
	}
	_q.withNetworkLinks = query
	return _q
}

// WithNetworkPorts tells the query-builder to eager-load the nodes that are connected to
// the "network_ports" edge. The optional arguments are used to configure the query builder of the edge.
func (_q *TenantQuery) WithNetworkPorts(opts ...func(*NetworkPortQuery)) *TenantQuery {
	query := (&NetworkPortClient{config: _q.config}).Query()
	for _, opt := range opts {
		opt(query)
	}
	_q.withNetworkPorts = query
	return _q
}

// WithNexusAudits tells the query-builder to eager-load the nodes that are connected to
// the "nexus_audits" edge. The optional arguments are used to configure the query builder of the edge.
func (_q *TenantQuery) WithNexusAudits(opts ...func(*NexusAuditQuery)) *TenantQuery {
	query := (&NexusAuditClient{config: _q.config}).Query()
	for _, opt := range opts {
		opt(query)
	}
	_q.withNexusAudits = query
	return _q
}

// WithSuccessionMaps tells the query-builder to eager-load the nodes that are connected to
// the "succession_maps" edge. The optional arguments are used to configure the query builder of the edge.
func (_q *TenantQuery) WithSuccessionMaps(opts ...func(*SuccessionMapQuery)) *TenantQuery {
	query := (&SuccessionMapClient{config: _q.config}).Query()
	for _, opt := range opts {
		opt(query)
	}
	_q.withSuccessionMaps = query
	return _q
}

// WithCustomerAccount tells the query-builder to eager-load the nodes that are connected to
// the "customer_account" edge. The optional arguments are used to configure the query builder of the edge.
func (_q *TenantQuery) WithCustomerAccount(opts ...func(*AccountQuery)) *TenantQuery {
	query := (&AccountClient{config: _q.config}).Query()
	for _, opt := range opts {
		opt(query)
	}
	_q.withCustomerAccount = query
	return _q
}

// WithScripts tells the query-builder to eager-load the nodes that are connected to
// the "scripts" edge. The optional arguments are used to configure the query builder of the edge.
func (_q *TenantQuery) WithScripts(opts ...func(*ScriptQuery)) *TenantQuery {
	query := (&ScriptClient{config: _q.config}).Query()
	for _, opt := range opts {
		opt(query)
	}
	_q.withScripts = query
	return _q
}

// WithJobs tells the query-builder to eager-load the nodes that are connected to
// the "jobs" edge. The optional arguments are used to configure the query builder of the edge.
func (_q *TenantQuery) WithJobs(opts ...func(*JobQuery)) *TenantQuery {
	query := (&JobClient{config: _q.config}).Query()
	for _, opt := range opts {
		opt(query)
	}
	_q.withJobs = query
	return _q
}

// WithTimeOffRequests tells the query-builder to eager-load the nodes that are connected to
// the "time_off_requests" edge. The optional arguments are used to configure the query builder of the edge.
func (_q *TenantQuery) WithTimeOffRequests(opts ...func(*TimeOffRequestQuery)) *TenantQuery {
	query := (&TimeOffRequestClient{config: _q.config}).Query()
	for _, opt := range opts {
		opt(query)
	}
	_q.withTimeOffRequests = query
	return _q
}

// WithTimeOffPolicies tells the query-builder to eager-load the nodes that are connected to
// the "time_off_policies" edge. The optional arguments are used to configure the query builder of the edge.
func (_q *TenantQuery) WithTimeOffPolicies(opts ...func(*TimeOffPolicyQuery)) *TenantQuery {
	query := (&TimeOffPolicyClient{config: _q.config}).Query()
	for _, opt := range opts {
		opt(query)
	}
	_q.withTimeOffPolicies = query
	return _q
}

// WithTimeOffBalances tells the query-builder to eager-load the nodes that are connected to
// the "time_off_balances" edge. The optional arguments are used to configure the query builder of the edge.
func (_q *TenantQuery) WithTimeOffBalances(opts ...func(*TimeOffBalanceQuery)) *TenantQuery {
	query := (&TimeOffBalanceClient{config: _q.config}).Query()
	for _, opt := range opts {
		opt(query)
	}
	_q.withTimeOffBalances = query
	return _q
}

// WithReviewCycles tells the query-builder to eager-load the nodes that are connected to
// the "review_cycles" edge. The optional arguments are used to configure the query builder of the edge.
func (_q *TenantQuery) WithReviewCycles(opts ...func(*ReviewCycleQuery)) *TenantQuery {
	query := (&ReviewCycleClient{config: _q.config}).Query()
	for _, opt := range opts {
		opt(query)
	}
	_q.withReviewCycles = query
	return _q
}

// WithPerformanceReviews tells the query-builder to eager-load the nodes that are connected to
// the "performance_reviews" edge. The optional arguments are used to configure the query builder of the edge.
func (_q *TenantQuery) WithPerformanceReviews(opts ...func(*PerformanceReviewQuery)) *TenantQuery {
	query := (&PerformanceReviewClient{config: _q.config}).Query()
	for _, opt := range opts {
		opt(query)
	}
	_q.withPerformanceReviews = query
	return _q
}

// WithGoals tells the query-builder to eager-load the nodes that are connected to
// the "goals" edge. The optional arguments are used to configure the query builder of the edge.
func (_q *TenantQuery) WithGoals(opts ...func(*GoalQuery)) *TenantQuery {
	query := (&GoalClient{config: _q.config}).Query()
	for _, opt := range opts {
		opt(query)
	}
	_q.withGoals = query
	return _q
}

// WithSuppliers tells the query-builder to eager-load the nodes that are connected to
// the "suppliers" edge. The optional arguments are used to configure the query builder of the edge.
func (_q *TenantQuery) WithSuppliers(opts ...func(*SupplierQuery)) *TenantQuery {
	query := (&SupplierClient{config: _q.config}).Query()
	for _, opt := range opts {
		opt(query)
	}
	_q.withSuppliers = query
	return _q
}

// WithCategories tells the query-builder to eager-load the nodes that are connected to
// the "categories" edge. The optional arguments are used to configure the query builder of the edge.
func (_q *TenantQuery) WithCategories(opts ...func(*CategoryQuery)) *TenantQuery {
	query := (&CategoryClient{config: _q.config}).Query()
	for _, opt := range opts {
		opt(query)
	}
	_q.withCategories = query
	return _q
}

// WithWarehouses tells the query-builder to eager-load the nodes that are connected to
// the "warehouses" edge. The optional arguments are used to configure the query builder of the edge.
func (_q *TenantQuery) WithWarehouses(opts ...func(*WarehouseQuery)) *TenantQuery {
	query := (&WarehouseClient{config: _q.config}).Query()
	for _, opt := range opts {
		opt(query)
	}
	_q.withWarehouses = query
	return _q
}

// WithAssetAssignments tells the query-builder to eager-load the nodes that are connected to
// the "asset_assignments" edge. The optional arguments are used to configure the query builder of the edge.
func (_q *TenantQuery) WithAssetAssignments(opts ...func(*AssetAssignmentQuery)) *TenantQuery {
	query := (&AssetAssignmentClient{config: _q.config}).Query()
	for _, opt := range opts {
		opt(query)
	}
	_q.withAssetAssignments = query
	return _q
}

// WithContacts tells the query-builder to eager-load the nodes that are connected to
// the "contacts" edge. The optional arguments are used to configure the query builder of the edge.
func (_q *TenantQuery) WithContacts(opts ...func(*ContactQuery)) *TenantQuery {
	query := (&ContactClient{config: _q.config}).Query()
	for _, opt := range opts {
		opt(query)
	}
	_q.withContacts = query
	return _q
}

// WithLegalHolds tells the query-builder to eager-load the nodes that are connected to
// the "legal_holds" edge. The optional arguments are used to configure the query builder of the edge.
func (_q *TenantQuery) WithLegalHolds(opts ...func(*LegalHoldQuery)) *TenantQuery {
	query := (&LegalHoldClient{config: _q.config}).Query()
	for _, opt := range opts {
		opt(query)
	}
	_q.withLegalHolds = query
	return _q
}

// WithRetentionPolicies tells the query-builder to eager-load the nodes that are connected to
// the "retention_policies" edge. The optional arguments are used to configure the query builder of the edge.
func (_q *TenantQuery) WithRetentionPolicies(opts ...func(*RetentionPolicyQuery)) *TenantQuery {
	query := (&RetentionPolicyClient{config: _q.config}).Query()
	for _, opt := range opts {
		opt(query)
	}
	_q.withRetentionPolicies = query
	return _q
}

// WithVaultTemplates tells the query-builder to eager-load the nodes that are connected to
// the "vault_templates" edge. The optional arguments are used to configure the query builder of the edge.
func (_q *TenantQuery) WithVaultTemplates(opts ...func(*VaultTemplateQuery)) *TenantQuery {
	query := (&VaultTemplateClient{config: _q.config}).Query()
	for _, opt := range opts {
		opt(query)
	}
	_q.withVaultTemplates = query
	return _q
}

// WithStockAuditLogs tells the query-builder to eager-load the nodes that are connected to
// the "stock_audit_logs" edge. The optional arguments are used to configure the query builder of the edge.
func (_q *TenantQuery) WithStockAuditLogs(opts ...func(*StockAuditLogQuery)) *TenantQuery {
	query := (&StockAuditLogClient{config: _q.config}).Query()
	for _, opt := range opts {
		opt(query)
	}
	_q.withStockAuditLogs = query
	return _q
}

// WithMaintenanceSchedules tells the query-builder to eager-load the nodes that are connected to
// the "maintenance_schedules" edge. The optional arguments are used to configure the query builder of the edge.
func (_q *TenantQuery) WithMaintenanceSchedules(opts ...func(*MaintenanceScheduleQuery)) *TenantQuery {
	query := (&MaintenanceScheduleClient{config: _q.config}).Query()
	for _, opt := range opts {
		opt(query)
	}
	_q.withMaintenanceSchedules = query
	return _q
}

// WithStockAlerts tells the query-builder to eager-load the nodes that are connected to
// the "stock_alerts" edge. The optional arguments are used to configure the query builder of the edge.
func (_q *TenantQuery) WithStockAlerts(opts ...func(*StockAlertQuery)) *TenantQuery {
	query := (&StockAlertClient{config: _q.config}).Query()
	for _, opt := range opts {
		opt(query)
	}
	_q.withStockAlerts = query
	return _q
}

// WithPurchaseOrders tells the query-builder to eager-load the nodes that are connected to
// the "purchase_orders" edge. The optional arguments are used to configure the query builder of the edge.
func (_q *TenantQuery) WithPurchaseOrders(opts ...func(*PurchaseOrderQuery)) *TenantQuery {
	query := (&PurchaseOrderClient{config: _q.config}).Query()
	for _, opt := range opts {
		opt(query)
	}
	_q.withPurchaseOrders = query
	return _q
}

// WithInventoryCounts tells the query-builder to eager-load the nodes that are connected to
// the "inventory_counts" edge. The optional arguments are used to configure the query builder of the edge.
func (_q *TenantQuery) WithInventoryCounts(opts ...func(*InventoryCountQuery)) *TenantQuery {
	query := (&InventoryCountClient{config: _q.config}).Query()
	for _, opt := range opts {
		opt(query)
	}
	_q.withInventoryCounts = query
	return _q
}

// WithJobPostings tells the query-builder to eager-load the nodes that are connected to
// the "job_postings" edge. The optional arguments are used to configure the query builder of the edge.
func (_q *TenantQuery) WithJobPostings(opts ...func(*JobPostingQuery)) *TenantQuery {
	query := (&JobPostingClient{config: _q.config}).Query()
	for _, opt := range opts {
		opt(query)
	}
	_q.withJobPostings = query
	return _q
}

// WithCandidates tells the query-builder to eager-load the nodes that are connected to
// the "candidates" edge. The optional arguments are used to configure the query builder of the edge.
func (_q *TenantQuery) WithCandidates(opts ...func(*CandidateQuery)) *TenantQuery {
	query := (&CandidateClient{config: _q.config}).Query()
	for _, opt := range opts {
		opt(query)
	}
	_q.withCandidates = query
	return _q
}

// WithApplications tells the query-builder to eager-load the nodes that are connected to
// the "applications" edge. The optional arguments are used to configure the query builder of the edge.
func (_q *TenantQuery) WithApplications(opts ...func(*ApplicationQuery)) *TenantQuery {
	query := (&ApplicationClient{config: _q.config}).Query()
	for _, opt := range opts {
		opt(query)
	}
	_q.withApplications = query
	return _q
}

// WithInterviews tells the query-builder to eager-load the nodes that are connected to
// the "interviews" edge. The optional arguments are used to configure the query builder of the edge.
func (_q *TenantQuery) WithInterviews(opts ...func(*InterviewQuery)) *TenantQuery {
	query := (&InterviewClient{config: _q.config}).Query()
	for _, opt := range opts {
		opt(query)
	}
	_q.withInterviews = query
	return _q
}

// WithBenefitPlans tells the query-builder to eager-load the nodes that are connected to
// the "benefit_plans" edge. The optional arguments are used to configure the query builder of the edge.
func (_q *TenantQuery) WithBenefitPlans(opts ...func(*BenefitPlanQuery)) *TenantQuery {
	query := (&BenefitPlanClient{config: _q.config}).Query()
	for _, opt := range opts {
		opt(query)
	}
	_q.withBenefitPlans = query
	return _q
}

// WithBenefitEnrollments tells the query-builder to eager-load the nodes that are connected to
// the "benefit_enrollments" edge. The optional arguments are used to configure the query builder of the edge.
func (_q *TenantQuery) WithBenefitEnrollments(opts ...func(*BenefitEnrollmentQuery)) *TenantQuery {
	query := (&BenefitEnrollmentClient{config: _q.config}).Query()
	for _, opt := range opts {
		opt(query)
	}
	_q.withBenefitEnrollments = query
	return _q
}

// GroupBy is used to group vertices by one or more fields/columns.
// It is often used with aggregate functions, like: count, max, mean, min, sum.
//
// Example:
//
//	var v []struct {
//		Name string `json:"name,omitempty"`
//		Count int `json:"count,omitempty"`
//	}
//
//	client.Tenant.Query().
//		GroupBy(tenant.FieldName).
//		Aggregate(ent.Count()).
//		Scan(ctx, &v)
func (_q *TenantQuery) GroupBy(field string, fields ...string) *TenantGroupBy {
	_q.ctx.Fields = append([]string{field}, fields...)
	grbuild := &TenantGroupBy{build: _q}
	grbuild.flds = &_q.ctx.Fields
	grbuild.label = tenant.Label
	grbuild.scan = grbuild.Scan
	return grbuild
}

// Select allows the selection one or more fields/columns for the given query,
// instead of selecting all fields in the entity.
//
// Example:
//
//	var v []struct {
//		Name string `json:"name,omitempty"`
//	}
//
//	client.Tenant.Query().
//		Select(tenant.FieldName).
//		Scan(ctx, &v)
func (_q *TenantQuery) Select(fields ...string) *TenantSelect {
	_q.ctx.Fields = append(_q.ctx.Fields, fields...)
	sbuild := &TenantSelect{TenantQuery: _q}
	sbuild.label = tenant.Label
	sbuild.flds, sbuild.scan = &_q.ctx.Fields, sbuild.Scan
	return sbuild
}

// Aggregate returns a TenantSelect configured with the given aggregations.
func (_q *TenantQuery) Aggregate(fns ...AggregateFunc) *TenantSelect {
	return _q.Select().Aggregate(fns...)
}

func (_q *TenantQuery) prepareQuery(ctx context.Context) error {
	for _, inter := range _q.inters {
		if inter == nil {
			return fmt.Errorf("ent: uninitialized interceptor (forgotten import ent/runtime?)")
		}
		if trv, ok := inter.(Traverser); ok {
			if err := trv.Traverse(ctx, _q); err != nil {
				return err
			}
		}
	}
	for _, f := range _q.ctx.Fields {
		if !tenant.ValidColumn(f) {
			return &ValidationError{Name: f, err: fmt.Errorf("ent: invalid field %q for query", f)}
		}
	}
	if _q.path != nil {
		prev, err := _q.path(ctx)
		if err != nil {
			return err
		}
		_q.sql = prev
	}
	return nil
}

func (_q *TenantQuery) sqlAll(ctx context.Context, hooks ...queryHook) ([]*Tenant, error) {
	var (
		nodes       = []*Tenant{}
		withFKs     = _q.withFKs
		_spec       = _q.querySpec()
		loadedTypes = [75]bool{
			_q.withParent != nil,
			_q.withChildren != nil,
			_q.withUsers != nil,
			_q.withAccounts != nil,
			_q.withTransactions != nil,
			_q.withLedgerEntries != nil,
			_q.withProducts != nil,
			_q.withStockMovements != nil,
			_q.withAuditLogs != nil,
			_q.withAgents != nil,
			_q.withDiscoveryEntries != nil,
			_q.withAssets != nil,
			_q.withCredentials != nil,
			_q.withOneTimeLinks != nil,
			_q.withSops != nil,
			_q.withCameras != nil,
			_q.withTickets != nil,
			_q.withContracts != nil,
			_q.withSaasApps != nil,
			_q.withSaasFilters != nil,
			_q.withCallLogs != nil,
			_q.withIvrFlows != nil,
			_q.withVoicemails != nil,
			_q.withHealthSnapshots != nil,
			_q.withRoadmaps != nil,
			_q.withServiceRates != nil,
			_q.withNetworkDevices != nil,
			_q.withNetworkBackups != nil,
			_q.withBudgetForecasts != nil,
			_q.withEmployees != nil,
			_q.withCompensationAgreements != nil,
			_q.withVaultItems != nil,
			_q.withVaultShareLinks != nil,
			_q.withJournalEntries != nil,
			_q.withRecurringInvoices != nil,
			_q.withInventoryReservations != nil,
			_q.withDepartments != nil,
			_q.withPermissions != nil,
			_q.withAssetTypes != nil,
			_q.withDetectionEvents != nil,
			_q.withSaasIdentities != nil,
			_q.withSaasUsages != nil,
			_q.withRecordings != nil,
			_q.withNetworkLinks != nil,
			_q.withNetworkPorts != nil,
			_q.withNexusAudits != nil,
			_q.withSuccessionMaps != nil,
			_q.withCustomerAccount != nil,
			_q.withScripts != nil,
			_q.withJobs != nil,
			_q.withTimeOffRequests != nil,
			_q.withTimeOffPolicies != nil,
			_q.withTimeOffBalances != nil,
			_q.withReviewCycles != nil,
			_q.withPerformanceReviews != nil,
			_q.withGoals != nil,
			_q.withSuppliers != nil,
			_q.withCategories != nil,
			_q.withWarehouses != nil,
			_q.withAssetAssignments != nil,
			_q.withContacts != nil,
			_q.withLegalHolds != nil,
			_q.withRetentionPolicies != nil,
			_q.withVaultTemplates != nil,
			_q.withStockAuditLogs != nil,
			_q.withMaintenanceSchedules != nil,
			_q.withStockAlerts != nil,
			_q.withPurchaseOrders != nil,
			_q.withInventoryCounts != nil,
			_q.withJobPostings != nil,
			_q.withCandidates != nil,
			_q.withApplications != nil,
			_q.withInterviews != nil,
			_q.withBenefitPlans != nil,
			_q.withBenefitEnrollments != nil,
		}
	)
	if _q.withParent != nil || _q.withCustomerAccount != nil {
		withFKs = true
	}
	if withFKs {
		_spec.Node.Columns = append(_spec.Node.Columns, tenant.ForeignKeys...)
	}
	_spec.ScanValues = func(columns []string) ([]any, error) {
		return (*Tenant).scanValues(nil, columns)
	}
	_spec.Assign = func(columns []string, values []any) error {
		node := &Tenant{config: _q.config}
		nodes = append(nodes, node)
		node.Edges.loadedTypes = loadedTypes
		return node.assignValues(columns, values)
	}
	if len(_q.modifiers) > 0 {
		_spec.Modifiers = _q.modifiers
	}
	for i := range hooks {
		hooks[i](ctx, _spec)
	}
	if err := sqlgraph.QueryNodes(ctx, _q.driver, _spec); err != nil {
		return nil, err
	}
	if len(nodes) == 0 {
		return nodes, nil
	}
	if query := _q.withParent; query != nil {
		if err := _q.loadParent(ctx, query, nodes, nil,
			func(n *Tenant, e *Tenant) { n.Edges.Parent = e }); err != nil {
			return nil, err
		}
	}
	if query := _q.withChildren; query != nil {
		if err := _q.loadChildren(ctx, query, nodes,
			func(n *Tenant) { n.Edges.Children = []*Tenant{} },
			func(n *Tenant, e *Tenant) { n.Edges.Children = append(n.Edges.Children, e) }); err != nil {
			return nil, err
		}
	}
	if query := _q.withUsers; query != nil {
		if err := _q.loadUsers(ctx, query, nodes,
			func(n *Tenant) { n.Edges.Users = []*User{} },
			func(n *Tenant, e *User) { n.Edges.Users = append(n.Edges.Users, e) }); err != nil {
			return nil, err
		}
	}
	if query := _q.withAccounts; query != nil {
		if err := _q.loadAccounts(ctx, query, nodes,
			func(n *Tenant) { n.Edges.Accounts = []*Account{} },
			func(n *Tenant, e *Account) { n.Edges.Accounts = append(n.Edges.Accounts, e) }); err != nil {
			return nil, err
		}
	}
	if query := _q.withTransactions; query != nil {
		if err := _q.loadTransactions(ctx, query, nodes,
			func(n *Tenant) { n.Edges.Transactions = []*Transaction{} },
			func(n *Tenant, e *Transaction) { n.Edges.Transactions = append(n.Edges.Transactions, e) }); err != nil {
			return nil, err
		}
	}
	if query := _q.withLedgerEntries; query != nil {
		if err := _q.loadLedgerEntries(ctx, query, nodes,
			func(n *Tenant) { n.Edges.LedgerEntries = []*LedgerEntry{} },
			func(n *Tenant, e *LedgerEntry) { n.Edges.LedgerEntries = append(n.Edges.LedgerEntries, e) }); err != nil {
			return nil, err
		}
	}
	if query := _q.withProducts; query != nil {
		if err := _q.loadProducts(ctx, query, nodes,
			func(n *Tenant) { n.Edges.Products = []*Product{} },
			func(n *Tenant, e *Product) { n.Edges.Products = append(n.Edges.Products, e) }); err != nil {
			return nil, err
		}
	}
	if query := _q.withStockMovements; query != nil {
		if err := _q.loadStockMovements(ctx, query, nodes,
			func(n *Tenant) { n.Edges.StockMovements = []*StockMovement{} },
			func(n *Tenant, e *StockMovement) { n.Edges.StockMovements = append(n.Edges.StockMovements, e) }); err != nil {
			return nil, err
		}
	}
	if query := _q.withAuditLogs; query != nil {
		if err := _q.loadAuditLogs(ctx, query, nodes,
			func(n *Tenant) { n.Edges.AuditLogs = []*AuditLog{} },
			func(n *Tenant, e *AuditLog) { n.Edges.AuditLogs = append(n.Edges.AuditLogs, e) }); err != nil {
			return nil, err
		}
	}
	if query := _q.withAgents; query != nil {
		if err := _q.loadAgents(ctx, query, nodes,
			func(n *Tenant) { n.Edges.Agents = []*Agent{} },
			func(n *Tenant, e *Agent) { n.Edges.Agents = append(n.Edges.Agents, e) }); err != nil {
			return nil, err
		}
	}
	if query := _q.withDiscoveryEntries; query != nil {
		if err := _q.loadDiscoveryEntries(ctx, query, nodes,
			func(n *Tenant) { n.Edges.DiscoveryEntries = []*DiscoveryEntry{} },
			func(n *Tenant, e *DiscoveryEntry) { n.Edges.DiscoveryEntries = append(n.Edges.DiscoveryEntries, e) }); err != nil {
			return nil, err
		}
	}
	if query := _q.withAssets; query != nil {
		if err := _q.loadAssets(ctx, query, nodes,
			func(n *Tenant) { n.Edges.Assets = []*Asset{} },
			func(n *Tenant, e *Asset) { n.Edges.Assets = append(n.Edges.Assets, e) }); err != nil {
			return nil, err
		}
	}
	if query := _q.withCredentials; query != nil {
		if err := _q.loadCredentials(ctx, query, nodes,
			func(n *Tenant) { n.Edges.Credentials = []*Credential{} },
			func(n *Tenant, e *Credential) { n.Edges.Credentials = append(n.Edges.Credentials, e) }); err != nil {
			return nil, err
		}
	}
	if query := _q.withOneTimeLinks; query != nil {
		if err := _q.loadOneTimeLinks(ctx, query, nodes,
			func(n *Tenant) { n.Edges.OneTimeLinks = []*OneTimeLink{} },
			func(n *Tenant, e *OneTimeLink) { n.Edges.OneTimeLinks = append(n.Edges.OneTimeLinks, e) }); err != nil {
			return nil, err
		}
	}
	if query := _q.withSops; query != nil {
		if err := _q.loadSops(ctx, query, nodes,
			func(n *Tenant) { n.Edges.Sops = []*SOP{} },
			func(n *Tenant, e *SOP) { n.Edges.Sops = append(n.Edges.Sops, e) }); err != nil {
			return nil, err
		}
	}
	if query := _q.withCameras; query != nil {
		if err := _q.loadCameras(ctx, query, nodes,
			func(n *Tenant) { n.Edges.Cameras = []*Camera{} },
			func(n *Tenant, e *Camera) { n.Edges.Cameras = append(n.Edges.Cameras, e) }); err != nil {
			return nil, err
		}
	}
	if query := _q.withTickets; query != nil {
		if err := _q.loadTickets(ctx, query, nodes,
			func(n *Tenant) { n.Edges.Tickets = []*Ticket{} },
			func(n *Tenant, e *Ticket) { n.Edges.Tickets = append(n.Edges.Tickets, e) }); err != nil {
			return nil, err
		}
	}
	if query := _q.withContracts; query != nil {
		if err := _q.loadContracts(ctx, query, nodes,
			func(n *Tenant) { n.Edges.Contracts = []*Contract{} },
			func(n *Tenant, e *Contract) { n.Edges.Contracts = append(n.Edges.Contracts, e) }); err != nil {
			return nil, err
		}
	}
	if query := _q.withSaasApps; query != nil {
		if err := _q.loadSaasApps(ctx, query, nodes,
			func(n *Tenant) { n.Edges.SaasApps = []*SaaSApp{} },
			func(n *Tenant, e *SaaSApp) { n.Edges.SaasApps = append(n.Edges.SaasApps, e) }); err != nil {
			return nil, err
		}
	}
	if query := _q.withSaasFilters; query != nil {
		if err := _q.loadSaasFilters(ctx, query, nodes,
			func(n *Tenant) { n.Edges.SaasFilters = []*SaaSFilter{} },
			func(n *Tenant, e *SaaSFilter) { n.Edges.SaasFilters = append(n.Edges.SaasFilters, e) }); err != nil {
			return nil, err
		}
	}
	if query := _q.withCallLogs; query != nil {
		if err := _q.loadCallLogs(ctx, query, nodes,
			func(n *Tenant) { n.Edges.CallLogs = []*CallLog{} },
			func(n *Tenant, e *CallLog) { n.Edges.CallLogs = append(n.Edges.CallLogs, e) }); err != nil {
			return nil, err
		}
	}
	if query := _q.withIvrFlows; query != nil {
		if err := _q.loadIvrFlows(ctx, query, nodes,
			func(n *Tenant) { n.Edges.IvrFlows = []*IVRFlow{} },
			func(n *Tenant, e *IVRFlow) { n.Edges.IvrFlows = append(n.Edges.IvrFlows, e) }); err != nil {
			return nil, err
		}
	}
	if query := _q.withVoicemails; query != nil {
		if err := _q.loadVoicemails(ctx, query, nodes,
			func(n *Tenant) { n.Edges.Voicemails = []*Voicemail{} },
			func(n *Tenant, e *Voicemail) { n.Edges.Voicemails = append(n.Edges.Voicemails, e) }); err != nil {
			return nil, err
		}
	}
	if query := _q.withHealthSnapshots; query != nil {
		if err := _q.loadHealthSnapshots(ctx, query, nodes,
			func(n *Tenant) { n.Edges.HealthSnapshots = []*HealthScoreSnapshot{} },
			func(n *Tenant, e *HealthScoreSnapshot) { n.Edges.HealthSnapshots = append(n.Edges.HealthSnapshots, e) }); err != nil {
			return nil, err
		}
	}
	if query := _q.withRoadmaps; query != nil {
		if err := _q.loadRoadmaps(ctx, query, nodes,
			func(n *Tenant) { n.Edges.Roadmaps = []*StrategicRoadmap{} },
			func(n *Tenant, e *StrategicRoadmap) { n.Edges.Roadmaps = append(n.Edges.Roadmaps, e) }); err != nil {
			return nil, err
		}
	}
	if query := _q.withServiceRates; query != nil {
		if err := _q.loadServiceRates(ctx, query, nodes,
			func(n *Tenant) { n.Edges.ServiceRates = []*ServiceRate{} },
			func(n *Tenant, e *ServiceRate) { n.Edges.ServiceRates = append(n.Edges.ServiceRates, e) }); err != nil {
			return nil, err
		}
	}
	if query := _q.withNetworkDevices; query != nil {
		if err := _q.loadNetworkDevices(ctx, query, nodes,
			func(n *Tenant) { n.Edges.NetworkDevices = []*NetworkDevice{} },
			func(n *Tenant, e *NetworkDevice) { n.Edges.NetworkDevices = append(n.Edges.NetworkDevices, e) }); err != nil {
			return nil, err
		}
	}
	if query := _q.withNetworkBackups; query != nil {
		if err := _q.loadNetworkBackups(ctx, query, nodes,
			func(n *Tenant) { n.Edges.NetworkBackups = []*NetworkBackup{} },
			func(n *Tenant, e *NetworkBackup) { n.Edges.NetworkBackups = append(n.Edges.NetworkBackups, e) }); err != nil {
			return nil, err
		}
	}
	if query := _q.withBudgetForecasts; query != nil {
		if err := _q.loadBudgetForecasts(ctx, query, nodes,
			func(n *Tenant) { n.Edges.BudgetForecasts = []*BudgetForecast{} },
			func(n *Tenant, e *BudgetForecast) { n.Edges.BudgetForecasts = append(n.Edges.BudgetForecasts, e) }); err != nil {
			return nil, err
		}
	}
	if query := _q.withEmployees; query != nil {
		if err := _q.loadEmployees(ctx, query, nodes,
			func(n *Tenant) { n.Edges.Employees = []*Employee{} },
			func(n *Tenant, e *Employee) { n.Edges.Employees = append(n.Edges.Employees, e) }); err != nil {
			return nil, err
		}
	}
	if query := _q.withCompensationAgreements; query != nil {
		if err := _q.loadCompensationAgreements(ctx, query, nodes,
			func(n *Tenant) { n.Edges.CompensationAgreements = []*CompensationAgreement{} },
			func(n *Tenant, e *CompensationAgreement) {
				n.Edges.CompensationAgreements = append(n.Edges.CompensationAgreements, e)
			}); err != nil {
			return nil, err
		}
	}
	if query := _q.withVaultItems; query != nil {
		if err := _q.loadVaultItems(ctx, query, nodes,
			func(n *Tenant) { n.Edges.VaultItems = []*VaultItem{} },
			func(n *Tenant, e *VaultItem) { n.Edges.VaultItems = append(n.Edges.VaultItems, e) }); err != nil {
			return nil, err
		}
	}
	if query := _q.withVaultShareLinks; query != nil {
		if err := _q.loadVaultShareLinks(ctx, query, nodes,
			func(n *Tenant) { n.Edges.VaultShareLinks = []*VaultShareLink{} },
			func(n *Tenant, e *VaultShareLink) { n.Edges.VaultShareLinks = append(n.Edges.VaultShareLinks, e) }); err != nil {
			return nil, err
		}
	}
	if query := _q.withJournalEntries; query != nil {
		if err := _q.loadJournalEntries(ctx, query, nodes,
			func(n *Tenant) { n.Edges.JournalEntries = []*JournalEntry{} },
			func(n *Tenant, e *JournalEntry) { n.Edges.JournalEntries = append(n.Edges.JournalEntries, e) }); err != nil {
			return nil, err
		}
	}
	if query := _q.withRecurringInvoices; query != nil {
		if err := _q.loadRecurringInvoices(ctx, query, nodes,
			func(n *Tenant) { n.Edges.RecurringInvoices = []*RecurringInvoice{} },
			func(n *Tenant, e *RecurringInvoice) { n.Edges.RecurringInvoices = append(n.Edges.RecurringInvoices, e) }); err != nil {
			return nil, err
		}
	}
	if query := _q.withInventoryReservations; query != nil {
		if err := _q.loadInventoryReservations(ctx, query, nodes,
			func(n *Tenant) { n.Edges.InventoryReservations = []*InventoryReservation{} },
			func(n *Tenant, e *InventoryReservation) {
				n.Edges.InventoryReservations = append(n.Edges.InventoryReservations, e)
			}); err != nil {
			return nil, err
		}
	}
	if query := _q.withDepartments; query != nil {
		if err := _q.loadDepartments(ctx, query, nodes,
			func(n *Tenant) { n.Edges.Departments = []*Department{} },
			func(n *Tenant, e *Department) { n.Edges.Departments = append(n.Edges.Departments, e) }); err != nil {
			return nil, err
		}
	}
	if query := _q.withPermissions; query != nil {
		if err := _q.loadPermissions(ctx, query, nodes,
			func(n *Tenant) { n.Edges.Permissions = []*Permission{} },
			func(n *Tenant, e *Permission) { n.Edges.Permissions = append(n.Edges.Permissions, e) }); err != nil {
			return nil, err
		}
	}
	if query := _q.withAssetTypes; query != nil {
		if err := _q.loadAssetTypes(ctx, query, nodes,
			func(n *Tenant) { n.Edges.AssetTypes = []*AssetType{} },
			func(n *Tenant, e *AssetType) { n.Edges.AssetTypes = append(n.Edges.AssetTypes, e) }); err != nil {
			return nil, err
		}
	}
	if query := _q.withDetectionEvents; query != nil {
		if err := _q.loadDetectionEvents(ctx, query, nodes,
			func(n *Tenant) { n.Edges.DetectionEvents = []*DetectionEvent{} },
			func(n *Tenant, e *DetectionEvent) { n.Edges.DetectionEvents = append(n.Edges.DetectionEvents, e) }); err != nil {
			return nil, err
		}
	}
	if query := _q.withSaasIdentities; query != nil {
		if err := _q.loadSaasIdentities(ctx, query, nodes,
			func(n *Tenant) { n.Edges.SaasIdentities = []*SaaSIdentity{} },
			func(n *Tenant, e *SaaSIdentity) { n.Edges.SaasIdentities = append(n.Edges.SaasIdentities, e) }); err != nil {
			return nil, err
		}
	}
	if query := _q.withSaasUsages; query != nil {
		if err := _q.loadSaasUsages(ctx, query, nodes,
			func(n *Tenant) { n.Edges.SaasUsages = []*SaaSUsage{} },
			func(n *Tenant, e *SaaSUsage) { n.Edges.SaasUsages = append(n.Edges.SaasUsages, e) }); err != nil {
			return nil, err
		}
	}
	if query := _q.withRecordings; query != nil {
		if err := _q.loadRecordings(ctx, query, nodes,
			func(n *Tenant) { n.Edges.Recordings = []*Recording{} },
			func(n *Tenant, e *Recording) { n.Edges.Recordings = append(n.Edges.Recordings, e) }); err != nil {
			return nil, err
		}
	}
	if query := _q.withNetworkLinks; query != nil {
		if err := _q.loadNetworkLinks(ctx, query, nodes,
			func(n *Tenant) { n.Edges.NetworkLinks = []*NetworkLink{} },
			func(n *Tenant, e *NetworkLink) { n.Edges.NetworkLinks = append(n.Edges.NetworkLinks, e) }); err != nil {
			return nil, err
		}
	}
	if query := _q.withNetworkPorts; query != nil {
		if err := _q.loadNetworkPorts(ctx, query, nodes,
			func(n *Tenant) { n.Edges.NetworkPorts = []*NetworkPort{} },
			func(n *Tenant, e *NetworkPort) { n.Edges.NetworkPorts = append(n.Edges.NetworkPorts, e) }); err != nil {
			return nil, err
		}
	}
	if query := _q.withNexusAudits; query != nil {
		if err := _q.loadNexusAudits(ctx, query, nodes,
			func(n *Tenant) { n.Edges.NexusAudits = []*NexusAudit{} },
			func(n *Tenant, e *NexusAudit) { n.Edges.NexusAudits = append(n.Edges.NexusAudits, e) }); err != nil {
			return nil, err
		}
	}
	if query := _q.withSuccessionMaps; query != nil {
		if err := _q.loadSuccessionMaps(ctx, query, nodes,
			func(n *Tenant) { n.Edges.SuccessionMaps = []*SuccessionMap{} },
			func(n *Tenant, e *SuccessionMap) { n.Edges.SuccessionMaps = append(n.Edges.SuccessionMaps, e) }); err != nil {
			return nil, err
		}
	}
	if query := _q.withCustomerAccount; query != nil {
		if err := _q.loadCustomerAccount(ctx, query, nodes, nil,
			func(n *Tenant, e *Account) { n.Edges.CustomerAccount = e }); err != nil {
			return nil, err
		}
	}
	if query := _q.withScripts; query != nil {
		if err := _q.loadScripts(ctx, query, nodes,
			func(n *Tenant) { n.Edges.Scripts = []*Script{} },
			func(n *Tenant, e *Script) { n.Edges.Scripts = append(n.Edges.Scripts, e) }); err != nil {
			return nil, err
		}
	}
	if query := _q.withJobs; query != nil {
		if err := _q.loadJobs(ctx, query, nodes,
			func(n *Tenant) { n.Edges.Jobs = []*Job{} },
			func(n *Tenant, e *Job) { n.Edges.Jobs = append(n.Edges.Jobs, e) }); err != nil {
			return nil, err
		}
	}
	if query := _q.withTimeOffRequests; query != nil {
		if err := _q.loadTimeOffRequests(ctx, query, nodes,
			func(n *Tenant) { n.Edges.TimeOffRequests = []*TimeOffRequest{} },
			func(n *Tenant, e *TimeOffRequest) { n.Edges.TimeOffRequests = append(n.Edges.TimeOffRequests, e) }); err != nil {
			return nil, err
		}
	}
	if query := _q.withTimeOffPolicies; query != nil {
		if err := _q.loadTimeOffPolicies(ctx, query, nodes,
			func(n *Tenant) { n.Edges.TimeOffPolicies = []*TimeOffPolicy{} },
			func(n *Tenant, e *TimeOffPolicy) { n.Edges.TimeOffPolicies = append(n.Edges.TimeOffPolicies, e) }); err != nil {
			return nil, err
		}
	}
	if query := _q.withTimeOffBalances; query != nil {
		if err := _q.loadTimeOffBalances(ctx, query, nodes,
			func(n *Tenant) { n.Edges.TimeOffBalances = []*TimeOffBalance{} },
			func(n *Tenant, e *TimeOffBalance) { n.Edges.TimeOffBalances = append(n.Edges.TimeOffBalances, e) }); err != nil {
			return nil, err
		}
	}
	if query := _q.withReviewCycles; query != nil {
		if err := _q.loadReviewCycles(ctx, query, nodes,
			func(n *Tenant) { n.Edges.ReviewCycles = []*ReviewCycle{} },
			func(n *Tenant, e *ReviewCycle) { n.Edges.ReviewCycles = append(n.Edges.ReviewCycles, e) }); err != nil {
			return nil, err
		}
	}
	if query := _q.withPerformanceReviews; query != nil {
		if err := _q.loadPerformanceReviews(ctx, query, nodes,
			func(n *Tenant) { n.Edges.PerformanceReviews = []*PerformanceReview{} },
			func(n *Tenant, e *PerformanceReview) {
				n.Edges.PerformanceReviews = append(n.Edges.PerformanceReviews, e)
			}); err != nil {
			return nil, err
		}
	}
	if query := _q.withGoals; query != nil {
		if err := _q.loadGoals(ctx, query, nodes,
			func(n *Tenant) { n.Edges.Goals = []*Goal{} },
			func(n *Tenant, e *Goal) { n.Edges.Goals = append(n.Edges.Goals, e) }); err != nil {
			return nil, err
		}
	}
	if query := _q.withSuppliers; query != nil {
		if err := _q.loadSuppliers(ctx, query, nodes,
			func(n *Tenant) { n.Edges.Suppliers = []*Supplier{} },
			func(n *Tenant, e *Supplier) { n.Edges.Suppliers = append(n.Edges.Suppliers, e) }); err != nil {
			return nil, err
		}
	}
	if query := _q.withCategories; query != nil {
		if err := _q.loadCategories(ctx, query, nodes,
			func(n *Tenant) { n.Edges.Categories = []*Category{} },
			func(n *Tenant, e *Category) { n.Edges.Categories = append(n.Edges.Categories, e) }); err != nil {
			return nil, err
		}
	}
	if query := _q.withWarehouses; query != nil {
		if err := _q.loadWarehouses(ctx, query, nodes,
			func(n *Tenant) { n.Edges.Warehouses = []*Warehouse{} },
			func(n *Tenant, e *Warehouse) { n.Edges.Warehouses = append(n.Edges.Warehouses, e) }); err != nil {
			return nil, err
		}
	}
	if query := _q.withAssetAssignments; query != nil {
		if err := _q.loadAssetAssignments(ctx, query, nodes,
			func(n *Tenant) { n.Edges.AssetAssignments = []*AssetAssignment{} },
			func(n *Tenant, e *AssetAssignment) { n.Edges.AssetAssignments = append(n.Edges.AssetAssignments, e) }); err != nil {
			return nil, err
		}
	}
	if query := _q.withContacts; query != nil {
		if err := _q.loadContacts(ctx, query, nodes,
			func(n *Tenant) { n.Edges.Contacts = []*Contact{} },
			func(n *Tenant, e *Contact) { n.Edges.Contacts = append(n.Edges.Contacts, e) }); err != nil {
			return nil, err
		}
	}
	if query := _q.withLegalHolds; query != nil {
		if err := _q.loadLegalHolds(ctx, query, nodes,
			func(n *Tenant) { n.Edges.LegalHolds = []*LegalHold{} },
			func(n *Tenant, e *LegalHold) { n.Edges.LegalHolds = append(n.Edges.LegalHolds, e) }); err != nil {
			return nil, err
		}
	}
	if query := _q.withRetentionPolicies; query != nil {
		if err := _q.loadRetentionPolicies(ctx, query, nodes,
			func(n *Tenant) { n.Edges.RetentionPolicies = []*RetentionPolicy{} },
			func(n *Tenant, e *RetentionPolicy) { n.Edges.RetentionPolicies = append(n.Edges.RetentionPolicies, e) }); err != nil {
			return nil, err
		}
	}
	if query := _q.withVaultTemplates; query != nil {
		if err := _q.loadVaultTemplates(ctx, query, nodes,
			func(n *Tenant) { n.Edges.VaultTemplates = []*VaultTemplate{} },
			func(n *Tenant, e *VaultTemplate) { n.Edges.VaultTemplates = append(n.Edges.VaultTemplates, e) }); err != nil {
			return nil, err
		}
	}
	if query := _q.withStockAuditLogs; query != nil {
		if err := _q.loadStockAuditLogs(ctx, query, nodes,
			func(n *Tenant) { n.Edges.StockAuditLogs = []*StockAuditLog{} },
			func(n *Tenant, e *StockAuditLog) { n.Edges.StockAuditLogs = append(n.Edges.StockAuditLogs, e) }); err != nil {
			return nil, err
		}
	}
	if query := _q.withMaintenanceSchedules; query != nil {
		if err := _q.loadMaintenanceSchedules(ctx, query, nodes,
			func(n *Tenant) { n.Edges.MaintenanceSchedules = []*MaintenanceSchedule{} },
			func(n *Tenant, e *MaintenanceSchedule) {
				n.Edges.MaintenanceSchedules = append(n.Edges.MaintenanceSchedules, e)
			}); err != nil {
			return nil, err
		}
	}
	if query := _q.withStockAlerts; query != nil {
		if err := _q.loadStockAlerts(ctx, query, nodes,
			func(n *Tenant) { n.Edges.StockAlerts = []*StockAlert{} },
			func(n *Tenant, e *StockAlert) { n.Edges.StockAlerts = append(n.Edges.StockAlerts, e) }); err != nil {
			return nil, err
		}
	}
	if query := _q.withPurchaseOrders; query != nil {
		if err := _q.loadPurchaseOrders(ctx, query, nodes,
			func(n *Tenant) { n.Edges.PurchaseOrders = []*PurchaseOrder{} },
			func(n *Tenant, e *PurchaseOrder) { n.Edges.PurchaseOrders = append(n.Edges.PurchaseOrders, e) }); err != nil {
			return nil, err
		}
	}
	if query := _q.withInventoryCounts; query != nil {
		if err := _q.loadInventoryCounts(ctx, query, nodes,
			func(n *Tenant) { n.Edges.InventoryCounts = []*InventoryCount{} },
			func(n *Tenant, e *InventoryCount) { n.Edges.InventoryCounts = append(n.Edges.InventoryCounts, e) }); err != nil {
			return nil, err
		}
	}
	if query := _q.withJobPostings; query != nil {
		if err := _q.loadJobPostings(ctx, query, nodes,
			func(n *Tenant) { n.Edges.JobPostings = []*JobPosting{} },
			func(n *Tenant, e *JobPosting) { n.Edges.JobPostings = append(n.Edges.JobPostings, e) }); err != nil {
			return nil, err
		}
	}
	if query := _q.withCandidates; query != nil {
		if err := _q.loadCandidates(ctx, query, nodes,
			func(n *Tenant) { n.Edges.Candidates = []*Candidate{} },
			func(n *Tenant, e *Candidate) { n.Edges.Candidates = append(n.Edges.Candidates, e) }); err != nil {
			return nil, err
		}
	}
	if query := _q.withApplications; query != nil {
		if err := _q.loadApplications(ctx, query, nodes,
			func(n *Tenant) { n.Edges.Applications = []*Application{} },
			func(n *Tenant, e *Application) { n.Edges.Applications = append(n.Edges.Applications, e) }); err != nil {
			return nil, err
		}
	}
	if query := _q.withInterviews; query != nil {
		if err := _q.loadInterviews(ctx, query, nodes,
			func(n *Tenant) { n.Edges.Interviews = []*Interview{} },
			func(n *Tenant, e *Interview) { n.Edges.Interviews = append(n.Edges.Interviews, e) }); err != nil {
			return nil, err
		}
	}
	if query := _q.withBenefitPlans; query != nil {
		if err := _q.loadBenefitPlans(ctx, query, nodes,
			func(n *Tenant) { n.Edges.BenefitPlans = []*BenefitPlan{} },
			func(n *Tenant, e *BenefitPlan) { n.Edges.BenefitPlans = append(n.Edges.BenefitPlans, e) }); err != nil {
			return nil, err
		}
	}
	if query := _q.withBenefitEnrollments; query != nil {
		if err := _q.loadBenefitEnrollments(ctx, query, nodes,
			func(n *Tenant) { n.Edges.BenefitEnrollments = []*BenefitEnrollment{} },
			func(n *Tenant, e *BenefitEnrollment) {
				n.Edges.BenefitEnrollments = append(n.Edges.BenefitEnrollments, e)
			}); err != nil {
			return nil, err
		}
	}
	return nodes, nil
}

func (_q *TenantQuery) loadParent(ctx context.Context, query *TenantQuery, nodes []*Tenant, init func(*Tenant), assign func(*Tenant, *Tenant)) error {
	ids := make([]int, 0, len(nodes))
	nodeids := make(map[int][]*Tenant)
	for i := range nodes {
		if nodes[i].tenant_children == nil {
			continue
		}
		fk := *nodes[i].tenant_children
		if _, ok := nodeids[fk]; !ok {
			ids = append(ids, fk)
		}
		nodeids[fk] = append(nodeids[fk], nodes[i])
	}
	if len(ids) == 0 {
		return nil
	}
	query.Where(tenant.IDIn(ids...))
	neighbors, err := query.All(ctx)
	if err != nil {
		return err
	}
	for _, n := range neighbors {
		nodes, ok := nodeids[n.ID]
		if !ok {
			return fmt.Errorf(`unexpected foreign-key "tenant_children" returned %v`, n.ID)
		}
		for i := range nodes {
			assign(nodes[i], n)
		}
	}
	return nil
}
func (_q *TenantQuery) loadChildren(ctx context.Context, query *TenantQuery, nodes []*Tenant, init func(*Tenant), assign func(*Tenant, *Tenant)) error {
	fks := make([]driver.Value, 0, len(nodes))
	nodeids := make(map[int]*Tenant)
	for i := range nodes {
		fks = append(fks, nodes[i].ID)
		nodeids[nodes[i].ID] = nodes[i]
		if init != nil {
			init(nodes[i])
		}
	}
	query.withFKs = true
	query.Where(predicate.Tenant(func(s *sql.Selector) {
		s.Where(sql.InValues(s.C(tenant.ChildrenColumn), fks...))
	}))
	neighbors, err := query.All(ctx)
	if err != nil {
		return err
	}
	for _, n := range neighbors {
		fk := n.tenant_children
		if fk == nil {
			return fmt.Errorf(`foreign-key "tenant_children" is nil for node %v`, n.ID)
		}
		node, ok := nodeids[*fk]
		if !ok {
			return fmt.Errorf(`unexpected referenced foreign-key "tenant_children" returned %v for node %v`, *fk, n.ID)
		}
		assign(node, n)
	}
	return nil
}
func (_q *TenantQuery) loadUsers(ctx context.Context, query *UserQuery, nodes []*Tenant, init func(*Tenant), assign func(*Tenant, *User)) error {
	fks := make([]driver.Value, 0, len(nodes))
	nodeids := make(map[int]*Tenant)
	for i := range nodes {
		fks = append(fks, nodes[i].ID)
		nodeids[nodes[i].ID] = nodes[i]
		if init != nil {
			init(nodes[i])
		}
	}
	query.withFKs = true
	query.Where(predicate.User(func(s *sql.Selector) {
		s.Where(sql.InValues(s.C(tenant.UsersColumn), fks...))
	}))
	neighbors, err := query.All(ctx)
	if err != nil {
		return err
	}
	for _, n := range neighbors {
		fk := n.tenant_users
		if fk == nil {
			return fmt.Errorf(`foreign-key "tenant_users" is nil for node %v`, n.ID)
		}
		node, ok := nodeids[*fk]
		if !ok {
			return fmt.Errorf(`unexpected referenced foreign-key "tenant_users" returned %v for node %v`, *fk, n.ID)
		}
		assign(node, n)
	}
	return nil
}
func (_q *TenantQuery) loadAccounts(ctx context.Context, query *AccountQuery, nodes []*Tenant, init func(*Tenant), assign func(*Tenant, *Account)) error {
	fks := make([]driver.Value, 0, len(nodes))
	nodeids := make(map[int]*Tenant)
	for i := range nodes {
		fks = append(fks, nodes[i].ID)
		nodeids[nodes[i].ID] = nodes[i]
		if init != nil {
			init(nodes[i])
		}
	}
	query.withFKs = true
	query.Where(predicate.Account(func(s *sql.Selector) {
		s.Where(sql.InValues(s.C(tenant.AccountsColumn), fks...))
	}))
	neighbors, err := query.All(ctx)
	if err != nil {
		return err
	}
	for _, n := range neighbors {
		fk := n.tenant_accounts
		if fk == nil {
			return fmt.Errorf(`foreign-key "tenant_accounts" is nil for node %v`, n.ID)
		}
		node, ok := nodeids[*fk]
		if !ok {
			return fmt.Errorf(`unexpected referenced foreign-key "tenant_accounts" returned %v for node %v`, *fk, n.ID)
		}
		assign(node, n)
	}
	return nil
}
func (_q *TenantQuery) loadTransactions(ctx context.Context, query *TransactionQuery, nodes []*Tenant, init func(*Tenant), assign func(*Tenant, *Transaction)) error {
	fks := make([]driver.Value, 0, len(nodes))
	nodeids := make(map[int]*Tenant)
	for i := range nodes {
		fks = append(fks, nodes[i].ID)
		nodeids[nodes[i].ID] = nodes[i]
		if init != nil {
			init(nodes[i])
		}
	}
	query.withFKs = true
	query.Where(predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.InValues(s.C(tenant.TransactionsColumn), fks...))
	}))
	neighbors, err := query.All(ctx)
	if err != nil {
		return err
	}
	for _, n := range neighbors {
		fk := n.tenant_transactions
		if fk == nil {
			return fmt.Errorf(`foreign-key "tenant_transactions" is nil for node %v`, n.ID)
		}
		node, ok := nodeids[*fk]
		if !ok {
			return fmt.Errorf(`unexpected referenced foreign-key "tenant_transactions" returned %v for node %v`, *fk, n.ID)
		}
		assign(node, n)
	}
	return nil
}
func (_q *TenantQuery) loadLedgerEntries(ctx context.Context, query *LedgerEntryQuery, nodes []*Tenant, init func(*Tenant), assign func(*Tenant, *LedgerEntry)) error {
	fks := make([]driver.Value, 0, len(nodes))
	nodeids := make(map[int]*Tenant)
	for i := range nodes {
		fks = append(fks, nodes[i].ID)
		nodeids[nodes[i].ID] = nodes[i]
		if init != nil {
			init(nodes[i])
		}
	}
	query.withFKs = true
	query.Where(predicate.LedgerEntry(func(s *sql.Selector) {
		s.Where(sql.InValues(s.C(tenant.LedgerEntriesColumn), fks...))
	}))
	neighbors, err := query.All(ctx)
	if err != nil {
		return err
	}
	for _, n := range neighbors {
		fk := n.tenant_ledger_entries
		if fk == nil {
			return fmt.Errorf(`foreign-key "tenant_ledger_entries" is nil for node %v`, n.ID)
		}
		node, ok := nodeids[*fk]
		if !ok {
			return fmt.Errorf(`unexpected referenced foreign-key "tenant_ledger_entries" returned %v for node %v`, *fk, n.ID)
		}
		assign(node, n)
	}
	return nil
}
func (_q *TenantQuery) loadProducts(ctx context.Context, query *ProductQuery, nodes []*Tenant, init func(*Tenant), assign func(*Tenant, *Product)) error {
	fks := make([]driver.Value, 0, len(nodes))
	nodeids := make(map[int]*Tenant)
	for i := range nodes {
		fks = append(fks, nodes[i].ID)
		nodeids[nodes[i].ID] = nodes[i]
		if init != nil {
			init(nodes[i])
		}
	}
	query.withFKs = true
	query.Where(predicate.Product(func(s *sql.Selector) {
		s.Where(sql.InValues(s.C(tenant.ProductsColumn), fks...))
	}))
	neighbors, err := query.All(ctx)
	if err != nil {
		return err
	}
	for _, n := range neighbors {
		fk := n.tenant_products
		if fk == nil {
			return fmt.Errorf(`foreign-key "tenant_products" is nil for node %v`, n.ID)
		}
		node, ok := nodeids[*fk]
		if !ok {
			return fmt.Errorf(`unexpected referenced foreign-key "tenant_products" returned %v for node %v`, *fk, n.ID)
		}
		assign(node, n)
	}
	return nil
}
func (_q *TenantQuery) loadStockMovements(ctx context.Context, query *StockMovementQuery, nodes []*Tenant, init func(*Tenant), assign func(*Tenant, *StockMovement)) error {
	fks := make([]driver.Value, 0, len(nodes))
	nodeids := make(map[int]*Tenant)
	for i := range nodes {
		fks = append(fks, nodes[i].ID)
		nodeids[nodes[i].ID] = nodes[i]
		if init != nil {
			init(nodes[i])
		}
	}
	query.withFKs = true
	query.Where(predicate.StockMovement(func(s *sql.Selector) {
		s.Where(sql.InValues(s.C(tenant.StockMovementsColumn), fks...))
	}))
	neighbors, err := query.All(ctx)
	if err != nil {
		return err
	}
	for _, n := range neighbors {
		fk := n.tenant_stock_movements
		if fk == nil {
			return fmt.Errorf(`foreign-key "tenant_stock_movements" is nil for node %v`, n.ID)
		}
		node, ok := nodeids[*fk]
		if !ok {
			return fmt.Errorf(`unexpected referenced foreign-key "tenant_stock_movements" returned %v for node %v`, *fk, n.ID)
		}
		assign(node, n)
	}
	return nil
}
func (_q *TenantQuery) loadAuditLogs(ctx context.Context, query *AuditLogQuery, nodes []*Tenant, init func(*Tenant), assign func(*Tenant, *AuditLog)) error {
	fks := make([]driver.Value, 0, len(nodes))
	nodeids := make(map[int]*Tenant)
	for i := range nodes {
		fks = append(fks, nodes[i].ID)
		nodeids[nodes[i].ID] = nodes[i]
		if init != nil {
			init(nodes[i])
		}
	}
	query.withFKs = true
	query.Where(predicate.AuditLog(func(s *sql.Selector) {
		s.Where(sql.InValues(s.C(tenant.AuditLogsColumn), fks...))
	}))
	neighbors, err := query.All(ctx)
	if err != nil {
		return err
	}
	for _, n := range neighbors {
		fk := n.tenant_audit_logs
		if fk == nil {
			return fmt.Errorf(`foreign-key "tenant_audit_logs" is nil for node %v`, n.ID)
		}
		node, ok := nodeids[*fk]
		if !ok {
			return fmt.Errorf(`unexpected referenced foreign-key "tenant_audit_logs" returned %v for node %v`, *fk, n.ID)
		}
		assign(node, n)
	}
	return nil
}
func (_q *TenantQuery) loadAgents(ctx context.Context, query *AgentQuery, nodes []*Tenant, init func(*Tenant), assign func(*Tenant, *Agent)) error {
	fks := make([]driver.Value, 0, len(nodes))
	nodeids := make(map[int]*Tenant)
	for i := range nodes {
		fks = append(fks, nodes[i].ID)
		nodeids[nodes[i].ID] = nodes[i]
		if init != nil {
			init(nodes[i])
		}
	}
	query.withFKs = true
	query.Where(predicate.Agent(func(s *sql.Selector) {
		s.Where(sql.InValues(s.C(tenant.AgentsColumn), fks...))
	}))
	neighbors, err := query.All(ctx)
	if err != nil {
		return err
	}
	for _, n := range neighbors {
		fk := n.tenant_agents
		if fk == nil {
			return fmt.Errorf(`foreign-key "tenant_agents" is nil for node %v`, n.ID)
		}
		node, ok := nodeids[*fk]
		if !ok {
			return fmt.Errorf(`unexpected referenced foreign-key "tenant_agents" returned %v for node %v`, *fk, n.ID)
		}
		assign(node, n)
	}
	return nil
}
func (_q *TenantQuery) loadDiscoveryEntries(ctx context.Context, query *DiscoveryEntryQuery, nodes []*Tenant, init func(*Tenant), assign func(*Tenant, *DiscoveryEntry)) error {
	fks := make([]driver.Value, 0, len(nodes))
	nodeids := make(map[int]*Tenant)
	for i := range nodes {
		fks = append(fks, nodes[i].ID)
		nodeids[nodes[i].ID] = nodes[i]
		if init != nil {
			init(nodes[i])
		}
	}
	query.withFKs = true
	query.Where(predicate.DiscoveryEntry(func(s *sql.Selector) {
		s.Where(sql.InValues(s.C(tenant.DiscoveryEntriesColumn), fks...))
	}))
	neighbors, err := query.All(ctx)
	if err != nil {
		return err
	}
	for _, n := range neighbors {
		fk := n.tenant_discovery_entries
		if fk == nil {
			return fmt.Errorf(`foreign-key "tenant_discovery_entries" is nil for node %v`, n.ID)
		}
		node, ok := nodeids[*fk]
		if !ok {
			return fmt.Errorf(`unexpected referenced foreign-key "tenant_discovery_entries" returned %v for node %v`, *fk, n.ID)
		}
		assign(node, n)
	}
	return nil
}
func (_q *TenantQuery) loadAssets(ctx context.Context, query *AssetQuery, nodes []*Tenant, init func(*Tenant), assign func(*Tenant, *Asset)) error {
	fks := make([]driver.Value, 0, len(nodes))
	nodeids := make(map[int]*Tenant)
	for i := range nodes {
		fks = append(fks, nodes[i].ID)
		nodeids[nodes[i].ID] = nodes[i]
		if init != nil {
			init(nodes[i])
		}
	}
	query.withFKs = true
	query.Where(predicate.Asset(func(s *sql.Selector) {
		s.Where(sql.InValues(s.C(tenant.AssetsColumn), fks...))
	}))
	neighbors, err := query.All(ctx)
	if err != nil {
		return err
	}
	for _, n := range neighbors {
		fk := n.tenant_assets
		if fk == nil {
			return fmt.Errorf(`foreign-key "tenant_assets" is nil for node %v`, n.ID)
		}
		node, ok := nodeids[*fk]
		if !ok {
			return fmt.Errorf(`unexpected referenced foreign-key "tenant_assets" returned %v for node %v`, *fk, n.ID)
		}
		assign(node, n)
	}
	return nil
}
func (_q *TenantQuery) loadCredentials(ctx context.Context, query *CredentialQuery, nodes []*Tenant, init func(*Tenant), assign func(*Tenant, *Credential)) error {
	fks := make([]driver.Value, 0, len(nodes))
	nodeids := make(map[int]*Tenant)
	for i := range nodes {
		fks = append(fks, nodes[i].ID)
		nodeids[nodes[i].ID] = nodes[i]
		if init != nil {
			init(nodes[i])
		}
	}
	query.withFKs = true
	query.Where(predicate.Credential(func(s *sql.Selector) {
		s.Where(sql.InValues(s.C(tenant.CredentialsColumn), fks...))
	}))
	neighbors, err := query.All(ctx)
	if err != nil {
		return err
	}
	for _, n := range neighbors {
		fk := n.tenant_credentials
		if fk == nil {
			return fmt.Errorf(`foreign-key "tenant_credentials" is nil for node %v`, n.ID)
		}
		node, ok := nodeids[*fk]
		if !ok {
			return fmt.Errorf(`unexpected referenced foreign-key "tenant_credentials" returned %v for node %v`, *fk, n.ID)
		}
		assign(node, n)
	}
	return nil
}
func (_q *TenantQuery) loadOneTimeLinks(ctx context.Context, query *OneTimeLinkQuery, nodes []*Tenant, init func(*Tenant), assign func(*Tenant, *OneTimeLink)) error {
	fks := make([]driver.Value, 0, len(nodes))
	nodeids := make(map[int]*Tenant)
	for i := range nodes {
		fks = append(fks, nodes[i].ID)
		nodeids[nodes[i].ID] = nodes[i]
		if init != nil {
			init(nodes[i])
		}
	}
	query.withFKs = true
	query.Where(predicate.OneTimeLink(func(s *sql.Selector) {
		s.Where(sql.InValues(s.C(tenant.OneTimeLinksColumn), fks...))
	}))
	neighbors, err := query.All(ctx)
	if err != nil {
		return err
	}
	for _, n := range neighbors {
		fk := n.tenant_one_time_links
		if fk == nil {
			return fmt.Errorf(`foreign-key "tenant_one_time_links" is nil for node %v`, n.ID)
		}
		node, ok := nodeids[*fk]
		if !ok {
			return fmt.Errorf(`unexpected referenced foreign-key "tenant_one_time_links" returned %v for node %v`, *fk, n.ID)
		}
		assign(node, n)
	}
	return nil
}
func (_q *TenantQuery) loadSops(ctx context.Context, query *SOPQuery, nodes []*Tenant, init func(*Tenant), assign func(*Tenant, *SOP)) error {
	fks := make([]driver.Value, 0, len(nodes))
	nodeids := make(map[int]*Tenant)
	for i := range nodes {
		fks = append(fks, nodes[i].ID)
		nodeids[nodes[i].ID] = nodes[i]
		if init != nil {
			init(nodes[i])
		}
	}
	query.withFKs = true
	query.Where(predicate.SOP(func(s *sql.Selector) {
		s.Where(sql.InValues(s.C(tenant.SopsColumn), fks...))
	}))
	neighbors, err := query.All(ctx)
	if err != nil {
		return err
	}
	for _, n := range neighbors {
		fk := n.tenant_sops
		if fk == nil {
			return fmt.Errorf(`foreign-key "tenant_sops" is nil for node %v`, n.ID)
		}
		node, ok := nodeids[*fk]
		if !ok {
			return fmt.Errorf(`unexpected referenced foreign-key "tenant_sops" returned %v for node %v`, *fk, n.ID)
		}
		assign(node, n)
	}
	return nil
}
func (_q *TenantQuery) loadCameras(ctx context.Context, query *CameraQuery, nodes []*Tenant, init func(*Tenant), assign func(*Tenant, *Camera)) error {
	fks := make([]driver.Value, 0, len(nodes))
	nodeids := make(map[int]*Tenant)
	for i := range nodes {
		fks = append(fks, nodes[i].ID)
		nodeids[nodes[i].ID] = nodes[i]
		if init != nil {
			init(nodes[i])
		}
	}
	query.withFKs = true
	query.Where(predicate.Camera(func(s *sql.Selector) {
		s.Where(sql.InValues(s.C(tenant.CamerasColumn), fks...))
	}))
	neighbors, err := query.All(ctx)
	if err != nil {
		return err
	}
	for _, n := range neighbors {
		fk := n.tenant_cameras
		if fk == nil {
			return fmt.Errorf(`foreign-key "tenant_cameras" is nil for node %v`, n.ID)
		}
		node, ok := nodeids[*fk]
		if !ok {
			return fmt.Errorf(`unexpected referenced foreign-key "tenant_cameras" returned %v for node %v`, *fk, n.ID)
		}
		assign(node, n)
	}
	return nil
}
func (_q *TenantQuery) loadTickets(ctx context.Context, query *TicketQuery, nodes []*Tenant, init func(*Tenant), assign func(*Tenant, *Ticket)) error {
	fks := make([]driver.Value, 0, len(nodes))
	nodeids := make(map[int]*Tenant)
	for i := range nodes {
		fks = append(fks, nodes[i].ID)
		nodeids[nodes[i].ID] = nodes[i]
		if init != nil {
			init(nodes[i])
		}
	}
	query.withFKs = true
	query.Where(predicate.Ticket(func(s *sql.Selector) {
		s.Where(sql.InValues(s.C(tenant.TicketsColumn), fks...))
	}))
	neighbors, err := query.All(ctx)
	if err != nil {
		return err
	}
	for _, n := range neighbors {
		fk := n.tenant_tickets
		if fk == nil {
			return fmt.Errorf(`foreign-key "tenant_tickets" is nil for node %v`, n.ID)
		}
		node, ok := nodeids[*fk]
		if !ok {
			return fmt.Errorf(`unexpected referenced foreign-key "tenant_tickets" returned %v for node %v`, *fk, n.ID)
		}
		assign(node, n)
	}
	return nil
}
func (_q *TenantQuery) loadContracts(ctx context.Context, query *ContractQuery, nodes []*Tenant, init func(*Tenant), assign func(*Tenant, *Contract)) error {
	fks := make([]driver.Value, 0, len(nodes))
	nodeids := make(map[int]*Tenant)
	for i := range nodes {
		fks = append(fks, nodes[i].ID)
		nodeids[nodes[i].ID] = nodes[i]
		if init != nil {
			init(nodes[i])
		}
	}
	query.withFKs = true
	query.Where(predicate.Contract(func(s *sql.Selector) {
		s.Where(sql.InValues(s.C(tenant.ContractsColumn), fks...))
	}))
	neighbors, err := query.All(ctx)
	if err != nil {
		return err
	}
	for _, n := range neighbors {
		fk := n.tenant_contracts
		if fk == nil {
			return fmt.Errorf(`foreign-key "tenant_contracts" is nil for node %v`, n.ID)
		}
		node, ok := nodeids[*fk]
		if !ok {
			return fmt.Errorf(`unexpected referenced foreign-key "tenant_contracts" returned %v for node %v`, *fk, n.ID)
		}
		assign(node, n)
	}
	return nil
}
func (_q *TenantQuery) loadSaasApps(ctx context.Context, query *SaaSAppQuery, nodes []*Tenant, init func(*Tenant), assign func(*Tenant, *SaaSApp)) error {
	fks := make([]driver.Value, 0, len(nodes))
	nodeids := make(map[int]*Tenant)
	for i := range nodes {
		fks = append(fks, nodes[i].ID)
		nodeids[nodes[i].ID] = nodes[i]
		if init != nil {
			init(nodes[i])
		}
	}
	query.withFKs = true
	query.Where(predicate.SaaSApp(func(s *sql.Selector) {
		s.Where(sql.InValues(s.C(tenant.SaasAppsColumn), fks...))
	}))
	neighbors, err := query.All(ctx)
	if err != nil {
		return err
	}
	for _, n := range neighbors {
		fk := n.tenant_saas_apps
		if fk == nil {
			return fmt.Errorf(`foreign-key "tenant_saas_apps" is nil for node %v`, n.ID)
		}
		node, ok := nodeids[*fk]
		if !ok {
			return fmt.Errorf(`unexpected referenced foreign-key "tenant_saas_apps" returned %v for node %v`, *fk, n.ID)
		}
		assign(node, n)
	}
	return nil
}
func (_q *TenantQuery) loadSaasFilters(ctx context.Context, query *SaaSFilterQuery, nodes []*Tenant, init func(*Tenant), assign func(*Tenant, *SaaSFilter)) error {
	fks := make([]driver.Value, 0, len(nodes))
	nodeids := make(map[int]*Tenant)
	for i := range nodes {
		fks = append(fks, nodes[i].ID)
		nodeids[nodes[i].ID] = nodes[i]
		if init != nil {
			init(nodes[i])
		}
	}
	query.withFKs = true
	query.Where(predicate.SaaSFilter(func(s *sql.Selector) {
		s.Where(sql.InValues(s.C(tenant.SaasFiltersColumn), fks...))
	}))
	neighbors, err := query.All(ctx)
	if err != nil {
		return err
	}
	for _, n := range neighbors {
		fk := n.tenant_saas_filters
		if fk == nil {
			return fmt.Errorf(`foreign-key "tenant_saas_filters" is nil for node %v`, n.ID)
		}
		node, ok := nodeids[*fk]
		if !ok {
			return fmt.Errorf(`unexpected referenced foreign-key "tenant_saas_filters" returned %v for node %v`, *fk, n.ID)
		}
		assign(node, n)
	}
	return nil
}
func (_q *TenantQuery) loadCallLogs(ctx context.Context, query *CallLogQuery, nodes []*Tenant, init func(*Tenant), assign func(*Tenant, *CallLog)) error {
	fks := make([]driver.Value, 0, len(nodes))
	nodeids := make(map[int]*Tenant)
	for i := range nodes {
		fks = append(fks, nodes[i].ID)
		nodeids[nodes[i].ID] = nodes[i]
		if init != nil {
			init(nodes[i])
		}
	}
	query.withFKs = true
	query.Where(predicate.CallLog(func(s *sql.Selector) {
		s.Where(sql.InValues(s.C(tenant.CallLogsColumn), fks...))
	}))
	neighbors, err := query.All(ctx)
	if err != nil {
		return err
	}
	for _, n := range neighbors {
		fk := n.tenant_call_logs
		if fk == nil {
			return fmt.Errorf(`foreign-key "tenant_call_logs" is nil for node %v`, n.ID)
		}
		node, ok := nodeids[*fk]
		if !ok {
			return fmt.Errorf(`unexpected referenced foreign-key "tenant_call_logs" returned %v for node %v`, *fk, n.ID)
		}
		assign(node, n)
	}
	return nil
}
func (_q *TenantQuery) loadIvrFlows(ctx context.Context, query *IVRFlowQuery, nodes []*Tenant, init func(*Tenant), assign func(*Tenant, *IVRFlow)) error {
	fks := make([]driver.Value, 0, len(nodes))
	nodeids := make(map[int]*Tenant)
	for i := range nodes {
		fks = append(fks, nodes[i].ID)
		nodeids[nodes[i].ID] = nodes[i]
		if init != nil {
			init(nodes[i])
		}
	}
	query.withFKs = true
	query.Where(predicate.IVRFlow(func(s *sql.Selector) {
		s.Where(sql.InValues(s.C(tenant.IvrFlowsColumn), fks...))
	}))
	neighbors, err := query.All(ctx)
	if err != nil {
		return err
	}
	for _, n := range neighbors {
		fk := n.tenant_ivr_flows
		if fk == nil {
			return fmt.Errorf(`foreign-key "tenant_ivr_flows" is nil for node %v`, n.ID)
		}
		node, ok := nodeids[*fk]
		if !ok {
			return fmt.Errorf(`unexpected referenced foreign-key "tenant_ivr_flows" returned %v for node %v`, *fk, n.ID)
		}
		assign(node, n)
	}
	return nil
}
func (_q *TenantQuery) loadVoicemails(ctx context.Context, query *VoicemailQuery, nodes []*Tenant, init func(*Tenant), assign func(*Tenant, *Voicemail)) error {
	fks := make([]driver.Value, 0, len(nodes))
	nodeids := make(map[int]*Tenant)
	for i := range nodes {
		fks = append(fks, nodes[i].ID)
		nodeids[nodes[i].ID] = nodes[i]
		if init != nil {
			init(nodes[i])
		}
	}
	query.withFKs = true
	query.Where(predicate.Voicemail(func(s *sql.Selector) {
		s.Where(sql.InValues(s.C(tenant.VoicemailsColumn), fks...))
	}))
	neighbors, err := query.All(ctx)
	if err != nil {
		return err
	}
	for _, n := range neighbors {
		fk := n.tenant_voicemails
		if fk == nil {
			return fmt.Errorf(`foreign-key "tenant_voicemails" is nil for node %v`, n.ID)
		}
		node, ok := nodeids[*fk]
		if !ok {
			return fmt.Errorf(`unexpected referenced foreign-key "tenant_voicemails" returned %v for node %v`, *fk, n.ID)
		}
		assign(node, n)
	}
	return nil
}
func (_q *TenantQuery) loadHealthSnapshots(ctx context.Context, query *HealthScoreSnapshotQuery, nodes []*Tenant, init func(*Tenant), assign func(*Tenant, *HealthScoreSnapshot)) error {
	fks := make([]driver.Value, 0, len(nodes))
	nodeids := make(map[int]*Tenant)
	for i := range nodes {
		fks = append(fks, nodes[i].ID)
		nodeids[nodes[i].ID] = nodes[i]
		if init != nil {
			init(nodes[i])
		}
	}
	query.withFKs = true
	query.Where(predicate.HealthScoreSnapshot(func(s *sql.Selector) {
		s.Where(sql.InValues(s.C(tenant.HealthSnapshotsColumn), fks...))
	}))
	neighbors, err := query.All(ctx)
	if err != nil {
		return err
	}
	for _, n := range neighbors {
		fk := n.tenant_health_snapshots
		if fk == nil {
			return fmt.Errorf(`foreign-key "tenant_health_snapshots" is nil for node %v`, n.ID)
		}
		node, ok := nodeids[*fk]
		if !ok {
			return fmt.Errorf(`unexpected referenced foreign-key "tenant_health_snapshots" returned %v for node %v`, *fk, n.ID)
		}
		assign(node, n)
	}
	return nil
}
func (_q *TenantQuery) loadRoadmaps(ctx context.Context, query *StrategicRoadmapQuery, nodes []*Tenant, init func(*Tenant), assign func(*Tenant, *StrategicRoadmap)) error {
	fks := make([]driver.Value, 0, len(nodes))
	nodeids := make(map[int]*Tenant)
	for i := range nodes {
		fks = append(fks, nodes[i].ID)
		nodeids[nodes[i].ID] = nodes[i]
		if init != nil {
			init(nodes[i])
		}
	}
	query.withFKs = true
	query.Where(predicate.StrategicRoadmap(func(s *sql.Selector) {
		s.Where(sql.InValues(s.C(tenant.RoadmapsColumn), fks...))
	}))
	neighbors, err := query.All(ctx)
	if err != nil {
		return err
	}
	for _, n := range neighbors {
		fk := n.tenant_roadmaps
		if fk == nil {
			return fmt.Errorf(`foreign-key "tenant_roadmaps" is nil for node %v`, n.ID)
		}
		node, ok := nodeids[*fk]
		if !ok {
			return fmt.Errorf(`unexpected referenced foreign-key "tenant_roadmaps" returned %v for node %v`, *fk, n.ID)
		}
		assign(node, n)
	}
	return nil
}
func (_q *TenantQuery) loadServiceRates(ctx context.Context, query *ServiceRateQuery, nodes []*Tenant, init func(*Tenant), assign func(*Tenant, *ServiceRate)) error {
	fks := make([]driver.Value, 0, len(nodes))
	nodeids := make(map[int]*Tenant)
	for i := range nodes {
		fks = append(fks, nodes[i].ID)
		nodeids[nodes[i].ID] = nodes[i]
		if init != nil {
			init(nodes[i])
		}
	}
	query.withFKs = true
	query.Where(predicate.ServiceRate(func(s *sql.Selector) {
		s.Where(sql.InValues(s.C(tenant.ServiceRatesColumn), fks...))
	}))
	neighbors, err := query.All(ctx)
	if err != nil {
		return err
	}
	for _, n := range neighbors {
		fk := n.tenant_service_rates
		if fk == nil {
			return fmt.Errorf(`foreign-key "tenant_service_rates" is nil for node %v`, n.ID)
		}
		node, ok := nodeids[*fk]
		if !ok {
			return fmt.Errorf(`unexpected referenced foreign-key "tenant_service_rates" returned %v for node %v`, *fk, n.ID)
		}
		assign(node, n)
	}
	return nil
}
func (_q *TenantQuery) loadNetworkDevices(ctx context.Context, query *NetworkDeviceQuery, nodes []*Tenant, init func(*Tenant), assign func(*Tenant, *NetworkDevice)) error {
	fks := make([]driver.Value, 0, len(nodes))
	nodeids := make(map[int]*Tenant)
	for i := range nodes {
		fks = append(fks, nodes[i].ID)
		nodeids[nodes[i].ID] = nodes[i]
		if init != nil {
			init(nodes[i])
		}
	}
	query.withFKs = true
	query.Where(predicate.NetworkDevice(func(s *sql.Selector) {
		s.Where(sql.InValues(s.C(tenant.NetworkDevicesColumn), fks...))
	}))
	neighbors, err := query.All(ctx)
	if err != nil {
		return err
	}
	for _, n := range neighbors {
		fk := n.tenant_network_devices
		if fk == nil {
			return fmt.Errorf(`foreign-key "tenant_network_devices" is nil for node %v`, n.ID)
		}
		node, ok := nodeids[*fk]
		if !ok {
			return fmt.Errorf(`unexpected referenced foreign-key "tenant_network_devices" returned %v for node %v`, *fk, n.ID)
		}
		assign(node, n)
	}
	return nil
}
func (_q *TenantQuery) loadNetworkBackups(ctx context.Context, query *NetworkBackupQuery, nodes []*Tenant, init func(*Tenant), assign func(*Tenant, *NetworkBackup)) error {
	fks := make([]driver.Value, 0, len(nodes))
	nodeids := make(map[int]*Tenant)
	for i := range nodes {
		fks = append(fks, nodes[i].ID)
		nodeids[nodes[i].ID] = nodes[i]
		if init != nil {
			init(nodes[i])
		}
	}
	query.withFKs = true
	query.Where(predicate.NetworkBackup(func(s *sql.Selector) {
		s.Where(sql.InValues(s.C(tenant.NetworkBackupsColumn), fks...))
	}))
	neighbors, err := query.All(ctx)
	if err != nil {
		return err
	}
	for _, n := range neighbors {
		fk := n.tenant_network_backups
		if fk == nil {
			return fmt.Errorf(`foreign-key "tenant_network_backups" is nil for node %v`, n.ID)
		}
		node, ok := nodeids[*fk]
		if !ok {
			return fmt.Errorf(`unexpected referenced foreign-key "tenant_network_backups" returned %v for node %v`, *fk, n.ID)
		}
		assign(node, n)
	}
	return nil
}
func (_q *TenantQuery) loadBudgetForecasts(ctx context.Context, query *BudgetForecastQuery, nodes []*Tenant, init func(*Tenant), assign func(*Tenant, *BudgetForecast)) error {
	fks := make([]driver.Value, 0, len(nodes))
	nodeids := make(map[int]*Tenant)
	for i := range nodes {
		fks = append(fks, nodes[i].ID)
		nodeids[nodes[i].ID] = nodes[i]
		if init != nil {
			init(nodes[i])
		}
	}
	query.withFKs = true
	query.Where(predicate.BudgetForecast(func(s *sql.Selector) {
		s.Where(sql.InValues(s.C(tenant.BudgetForecastsColumn), fks...))
	}))
	neighbors, err := query.All(ctx)
	if err != nil {
		return err
	}
	for _, n := range neighbors {
		fk := n.tenant_budget_forecasts
		if fk == nil {
			return fmt.Errorf(`foreign-key "tenant_budget_forecasts" is nil for node %v`, n.ID)
		}
		node, ok := nodeids[*fk]
		if !ok {
			return fmt.Errorf(`unexpected referenced foreign-key "tenant_budget_forecasts" returned %v for node %v`, *fk, n.ID)
		}
		assign(node, n)
	}
	return nil
}
func (_q *TenantQuery) loadEmployees(ctx context.Context, query *EmployeeQuery, nodes []*Tenant, init func(*Tenant), assign func(*Tenant, *Employee)) error {
	fks := make([]driver.Value, 0, len(nodes))
	nodeids := make(map[int]*Tenant)
	for i := range nodes {
		fks = append(fks, nodes[i].ID)
		nodeids[nodes[i].ID] = nodes[i]
		if init != nil {
			init(nodes[i])
		}
	}
	query.withFKs = true
	query.Where(predicate.Employee(func(s *sql.Selector) {
		s.Where(sql.InValues(s.C(tenant.EmployeesColumn), fks...))
	}))
	neighbors, err := query.All(ctx)
	if err != nil {
		return err
	}
	for _, n := range neighbors {
		fk := n.tenant_employees
		if fk == nil {
			return fmt.Errorf(`foreign-key "tenant_employees" is nil for node %v`, n.ID)
		}
		node, ok := nodeids[*fk]
		if !ok {
			return fmt.Errorf(`unexpected referenced foreign-key "tenant_employees" returned %v for node %v`, *fk, n.ID)
		}
		assign(node, n)
	}
	return nil
}
func (_q *TenantQuery) loadCompensationAgreements(ctx context.Context, query *CompensationAgreementQuery, nodes []*Tenant, init func(*Tenant), assign func(*Tenant, *CompensationAgreement)) error {
	fks := make([]driver.Value, 0, len(nodes))
	nodeids := make(map[int]*Tenant)
	for i := range nodes {
		fks = append(fks, nodes[i].ID)
		nodeids[nodes[i].ID] = nodes[i]
		if init != nil {
			init(nodes[i])
		}
	}
	query.withFKs = true
	query.Where(predicate.CompensationAgreement(func(s *sql.Selector) {
		s.Where(sql.InValues(s.C(tenant.CompensationAgreementsColumn), fks...))
	}))
	neighbors, err := query.All(ctx)
	if err != nil {
		return err
	}
	for _, n := range neighbors {
		fk := n.tenant_compensation_agreements
		if fk == nil {
			return fmt.Errorf(`foreign-key "tenant_compensation_agreements" is nil for node %v`, n.ID)
		}
		node, ok := nodeids[*fk]
		if !ok {
			return fmt.Errorf(`unexpected referenced foreign-key "tenant_compensation_agreements" returned %v for node %v`, *fk, n.ID)
		}
		assign(node, n)
	}
	return nil
}
func (_q *TenantQuery) loadVaultItems(ctx context.Context, query *VaultItemQuery, nodes []*Tenant, init func(*Tenant), assign func(*Tenant, *VaultItem)) error {
	fks := make([]driver.Value, 0, len(nodes))
	nodeids := make(map[int]*Tenant)
	for i := range nodes {
		fks = append(fks, nodes[i].ID)
		nodeids[nodes[i].ID] = nodes[i]
		if init != nil {
			init(nodes[i])
		}
	}
	query.withFKs = true
	query.Where(predicate.VaultItem(func(s *sql.Selector) {
		s.Where(sql.InValues(s.C(tenant.VaultItemsColumn), fks...))
	}))
	neighbors, err := query.All(ctx)
	if err != nil {
		return err
	}
	for _, n := range neighbors {
		fk := n.tenant_vault_items
		if fk == nil {
			return fmt.Errorf(`foreign-key "tenant_vault_items" is nil for node %v`, n.ID)
		}
		node, ok := nodeids[*fk]
		if !ok {
			return fmt.Errorf(`unexpected referenced foreign-key "tenant_vault_items" returned %v for node %v`, *fk, n.ID)
		}
		assign(node, n)
	}
	return nil
}
func (_q *TenantQuery) loadVaultShareLinks(ctx context.Context, query *VaultShareLinkQuery, nodes []*Tenant, init func(*Tenant), assign func(*Tenant, *VaultShareLink)) error {
	fks := make([]driver.Value, 0, len(nodes))
	nodeids := make(map[int]*Tenant)
	for i := range nodes {
		fks = append(fks, nodes[i].ID)
		nodeids[nodes[i].ID] = nodes[i]
		if init != nil {
			init(nodes[i])
		}
	}
	query.withFKs = true
	query.Where(predicate.VaultShareLink(func(s *sql.Selector) {
		s.Where(sql.InValues(s.C(tenant.VaultShareLinksColumn), fks...))
	}))
	neighbors, err := query.All(ctx)
	if err != nil {
		return err
	}
	for _, n := range neighbors {
		fk := n.tenant_vault_share_links
		if fk == nil {
			return fmt.Errorf(`foreign-key "tenant_vault_share_links" is nil for node %v`, n.ID)
		}
		node, ok := nodeids[*fk]
		if !ok {
			return fmt.Errorf(`unexpected referenced foreign-key "tenant_vault_share_links" returned %v for node %v`, *fk, n.ID)
		}
		assign(node, n)
	}
	return nil
}
func (_q *TenantQuery) loadJournalEntries(ctx context.Context, query *JournalEntryQuery, nodes []*Tenant, init func(*Tenant), assign func(*Tenant, *JournalEntry)) error {
	fks := make([]driver.Value, 0, len(nodes))
	nodeids := make(map[int]*Tenant)
	for i := range nodes {
		fks = append(fks, nodes[i].ID)
		nodeids[nodes[i].ID] = nodes[i]
		if init != nil {
			init(nodes[i])
		}
	}
	query.withFKs = true
	query.Where(predicate.JournalEntry(func(s *sql.Selector) {
		s.Where(sql.InValues(s.C(tenant.JournalEntriesColumn), fks...))
	}))
	neighbors, err := query.All(ctx)
	if err != nil {
		return err
	}
	for _, n := range neighbors {
		fk := n.tenant_journal_entries
		if fk == nil {
			return fmt.Errorf(`foreign-key "tenant_journal_entries" is nil for node %v`, n.ID)
		}
		node, ok := nodeids[*fk]
		if !ok {
			return fmt.Errorf(`unexpected referenced foreign-key "tenant_journal_entries" returned %v for node %v`, *fk, n.ID)
		}
		assign(node, n)
	}
	return nil
}
func (_q *TenantQuery) loadRecurringInvoices(ctx context.Context, query *RecurringInvoiceQuery, nodes []*Tenant, init func(*Tenant), assign func(*Tenant, *RecurringInvoice)) error {
	fks := make([]driver.Value, 0, len(nodes))
	nodeids := make(map[int]*Tenant)
	for i := range nodes {
		fks = append(fks, nodes[i].ID)
		nodeids[nodes[i].ID] = nodes[i]
		if init != nil {
			init(nodes[i])
		}
	}
	query.withFKs = true
	query.Where(predicate.RecurringInvoice(func(s *sql.Selector) {
		s.Where(sql.InValues(s.C(tenant.RecurringInvoicesColumn), fks...))
	}))
	neighbors, err := query.All(ctx)
	if err != nil {
		return err
	}
	for _, n := range neighbors {
		fk := n.tenant_recurring_invoices
		if fk == nil {
			return fmt.Errorf(`foreign-key "tenant_recurring_invoices" is nil for node %v`, n.ID)
		}
		node, ok := nodeids[*fk]
		if !ok {
			return fmt.Errorf(`unexpected referenced foreign-key "tenant_recurring_invoices" returned %v for node %v`, *fk, n.ID)
		}
		assign(node, n)
	}
	return nil
}
func (_q *TenantQuery) loadInventoryReservations(ctx context.Context, query *InventoryReservationQuery, nodes []*Tenant, init func(*Tenant), assign func(*Tenant, *InventoryReservation)) error {
	fks := make([]driver.Value, 0, len(nodes))
	nodeids := make(map[int]*Tenant)
	for i := range nodes {
		fks = append(fks, nodes[i].ID)
		nodeids[nodes[i].ID] = nodes[i]
		if init != nil {
			init(nodes[i])
		}
	}
	query.withFKs = true
	query.Where(predicate.InventoryReservation(func(s *sql.Selector) {
		s.Where(sql.InValues(s.C(tenant.InventoryReservationsColumn), fks...))
	}))
	neighbors, err := query.All(ctx)
	if err != nil {
		return err
	}
	for _, n := range neighbors {
		fk := n.tenant_inventory_reservations
		if fk == nil {
			return fmt.Errorf(`foreign-key "tenant_inventory_reservations" is nil for node %v`, n.ID)
		}
		node, ok := nodeids[*fk]
		if !ok {
			return fmt.Errorf(`unexpected referenced foreign-key "tenant_inventory_reservations" returned %v for node %v`, *fk, n.ID)
		}
		assign(node, n)
	}
	return nil
}
func (_q *TenantQuery) loadDepartments(ctx context.Context, query *DepartmentQuery, nodes []*Tenant, init func(*Tenant), assign func(*Tenant, *Department)) error {
	fks := make([]driver.Value, 0, len(nodes))
	nodeids := make(map[int]*Tenant)
	for i := range nodes {
		fks = append(fks, nodes[i].ID)
		nodeids[nodes[i].ID] = nodes[i]
		if init != nil {
			init(nodes[i])
		}
	}
	query.withFKs = true
	query.Where(predicate.Department(func(s *sql.Selector) {
		s.Where(sql.InValues(s.C(tenant.DepartmentsColumn), fks...))
	}))
	neighbors, err := query.All(ctx)
	if err != nil {
		return err
	}
	for _, n := range neighbors {
		fk := n.tenant_departments
		if fk == nil {
			return fmt.Errorf(`foreign-key "tenant_departments" is nil for node %v`, n.ID)
		}
		node, ok := nodeids[*fk]
		if !ok {
			return fmt.Errorf(`unexpected referenced foreign-key "tenant_departments" returned %v for node %v`, *fk, n.ID)
		}
		assign(node, n)
	}
	return nil
}
func (_q *TenantQuery) loadPermissions(ctx context.Context, query *PermissionQuery, nodes []*Tenant, init func(*Tenant), assign func(*Tenant, *Permission)) error {
	fks := make([]driver.Value, 0, len(nodes))
	nodeids := make(map[int]*Tenant)
	for i := range nodes {
		fks = append(fks, nodes[i].ID)
		nodeids[nodes[i].ID] = nodes[i]
		if init != nil {
			init(nodes[i])
		}
	}
	query.withFKs = true
	query.Where(predicate.Permission(func(s *sql.Selector) {
		s.Where(sql.InValues(s.C(tenant.PermissionsColumn), fks...))
	}))
	neighbors, err := query.All(ctx)
	if err != nil {
		return err
	}
	for _, n := range neighbors {
		fk := n.tenant_permissions
		if fk == nil {
			return fmt.Errorf(`foreign-key "tenant_permissions" is nil for node %v`, n.ID)
		}
		node, ok := nodeids[*fk]
		if !ok {
			return fmt.Errorf(`unexpected referenced foreign-key "tenant_permissions" returned %v for node %v`, *fk, n.ID)
		}
		assign(node, n)
	}
	return nil
}
func (_q *TenantQuery) loadAssetTypes(ctx context.Context, query *AssetTypeQuery, nodes []*Tenant, init func(*Tenant), assign func(*Tenant, *AssetType)) error {
	fks := make([]driver.Value, 0, len(nodes))
	nodeids := make(map[int]*Tenant)
	for i := range nodes {
		fks = append(fks, nodes[i].ID)
		nodeids[nodes[i].ID] = nodes[i]
		if init != nil {
			init(nodes[i])
		}
	}
	query.withFKs = true
	query.Where(predicate.AssetType(func(s *sql.Selector) {
		s.Where(sql.InValues(s.C(tenant.AssetTypesColumn), fks...))
	}))
	neighbors, err := query.All(ctx)
	if err != nil {
		return err
	}
	for _, n := range neighbors {
		fk := n.tenant_asset_types
		if fk == nil {
			return fmt.Errorf(`foreign-key "tenant_asset_types" is nil for node %v`, n.ID)
		}
		node, ok := nodeids[*fk]
		if !ok {
			return fmt.Errorf(`unexpected referenced foreign-key "tenant_asset_types" returned %v for node %v`, *fk, n.ID)
		}
		assign(node, n)
	}
	return nil
}
func (_q *TenantQuery) loadDetectionEvents(ctx context.Context, query *DetectionEventQuery, nodes []*Tenant, init func(*Tenant), assign func(*Tenant, *DetectionEvent)) error {
	fks := make([]driver.Value, 0, len(nodes))
	nodeids := make(map[int]*Tenant)
	for i := range nodes {
		fks = append(fks, nodes[i].ID)
		nodeids[nodes[i].ID] = nodes[i]
		if init != nil {
			init(nodes[i])
		}
	}
	query.withFKs = true
	query.Where(predicate.DetectionEvent(func(s *sql.Selector) {
		s.Where(sql.InValues(s.C(tenant.DetectionEventsColumn), fks...))
	}))
	neighbors, err := query.All(ctx)
	if err != nil {
		return err
	}
	for _, n := range neighbors {
		fk := n.tenant_detection_events
		if fk == nil {
			return fmt.Errorf(`foreign-key "tenant_detection_events" is nil for node %v`, n.ID)
		}
		node, ok := nodeids[*fk]
		if !ok {
			return fmt.Errorf(`unexpected referenced foreign-key "tenant_detection_events" returned %v for node %v`, *fk, n.ID)
		}
		assign(node, n)
	}
	return nil
}
func (_q *TenantQuery) loadSaasIdentities(ctx context.Context, query *SaaSIdentityQuery, nodes []*Tenant, init func(*Tenant), assign func(*Tenant, *SaaSIdentity)) error {
	fks := make([]driver.Value, 0, len(nodes))
	nodeids := make(map[int]*Tenant)
	for i := range nodes {
		fks = append(fks, nodes[i].ID)
		nodeids[nodes[i].ID] = nodes[i]
		if init != nil {
			init(nodes[i])
		}
	}
	query.withFKs = true
	query.Where(predicate.SaaSIdentity(func(s *sql.Selector) {
		s.Where(sql.InValues(s.C(tenant.SaasIdentitiesColumn), fks...))
	}))
	neighbors, err := query.All(ctx)
	if err != nil {
		return err
	}
	for _, n := range neighbors {
		fk := n.tenant_saas_identities
		if fk == nil {
			return fmt.Errorf(`foreign-key "tenant_saas_identities" is nil for node %v`, n.ID)
		}
		node, ok := nodeids[*fk]
		if !ok {
			return fmt.Errorf(`unexpected referenced foreign-key "tenant_saas_identities" returned %v for node %v`, *fk, n.ID)
		}
		assign(node, n)
	}
	return nil
}
func (_q *TenantQuery) loadSaasUsages(ctx context.Context, query *SaaSUsageQuery, nodes []*Tenant, init func(*Tenant), assign func(*Tenant, *SaaSUsage)) error {
	fks := make([]driver.Value, 0, len(nodes))
	nodeids := make(map[int]*Tenant)
	for i := range nodes {
		fks = append(fks, nodes[i].ID)
		nodeids[nodes[i].ID] = nodes[i]
		if init != nil {
			init(nodes[i])
		}
	}
	query.withFKs = true
	query.Where(predicate.SaaSUsage(func(s *sql.Selector) {
		s.Where(sql.InValues(s.C(tenant.SaasUsagesColumn), fks...))
	}))
	neighbors, err := query.All(ctx)
	if err != nil {
		return err
	}
	for _, n := range neighbors {
		fk := n.tenant_saas_usages
		if fk == nil {
			return fmt.Errorf(`foreign-key "tenant_saas_usages" is nil for node %v`, n.ID)
		}
		node, ok := nodeids[*fk]
		if !ok {
			return fmt.Errorf(`unexpected referenced foreign-key "tenant_saas_usages" returned %v for node %v`, *fk, n.ID)
		}
		assign(node, n)
	}
	return nil
}
func (_q *TenantQuery) loadRecordings(ctx context.Context, query *RecordingQuery, nodes []*Tenant, init func(*Tenant), assign func(*Tenant, *Recording)) error {
	fks := make([]driver.Value, 0, len(nodes))
	nodeids := make(map[int]*Tenant)
	for i := range nodes {
		fks = append(fks, nodes[i].ID)
		nodeids[nodes[i].ID] = nodes[i]
		if init != nil {
			init(nodes[i])
		}
	}
	query.withFKs = true
	query.Where(predicate.Recording(func(s *sql.Selector) {
		s.Where(sql.InValues(s.C(tenant.RecordingsColumn), fks...))
	}))
	neighbors, err := query.All(ctx)
	if err != nil {
		return err
	}
	for _, n := range neighbors {
		fk := n.tenant_recordings
		if fk == nil {
			return fmt.Errorf(`foreign-key "tenant_recordings" is nil for node %v`, n.ID)
		}
		node, ok := nodeids[*fk]
		if !ok {
			return fmt.Errorf(`unexpected referenced foreign-key "tenant_recordings" returned %v for node %v`, *fk, n.ID)
		}
		assign(node, n)
	}
	return nil
}
func (_q *TenantQuery) loadNetworkLinks(ctx context.Context, query *NetworkLinkQuery, nodes []*Tenant, init func(*Tenant), assign func(*Tenant, *NetworkLink)) error {
	fks := make([]driver.Value, 0, len(nodes))
	nodeids := make(map[int]*Tenant)
	for i := range nodes {
		fks = append(fks, nodes[i].ID)
		nodeids[nodes[i].ID] = nodes[i]
		if init != nil {
			init(nodes[i])
		}
	}
	query.withFKs = true
	query.Where(predicate.NetworkLink(func(s *sql.Selector) {
		s.Where(sql.InValues(s.C(tenant.NetworkLinksColumn), fks...))
	}))
	neighbors, err := query.All(ctx)
	if err != nil {
		return err
	}
	for _, n := range neighbors {
		fk := n.tenant_network_links
		if fk == nil {
			return fmt.Errorf(`foreign-key "tenant_network_links" is nil for node %v`, n.ID)
		}
		node, ok := nodeids[*fk]
		if !ok {
			return fmt.Errorf(`unexpected referenced foreign-key "tenant_network_links" returned %v for node %v`, *fk, n.ID)
		}
		assign(node, n)
	}
	return nil
}
func (_q *TenantQuery) loadNetworkPorts(ctx context.Context, query *NetworkPortQuery, nodes []*Tenant, init func(*Tenant), assign func(*Tenant, *NetworkPort)) error {
	fks := make([]driver.Value, 0, len(nodes))
	nodeids := make(map[int]*Tenant)
	for i := range nodes {
		fks = append(fks, nodes[i].ID)
		nodeids[nodes[i].ID] = nodes[i]
		if init != nil {
			init(nodes[i])
		}
	}
	query.withFKs = true
	query.Where(predicate.NetworkPort(func(s *sql.Selector) {
		s.Where(sql.InValues(s.C(tenant.NetworkPortsColumn), fks...))
	}))
	neighbors, err := query.All(ctx)
	if err != nil {
		return err
	}
	for _, n := range neighbors {
		fk := n.tenant_network_ports
		if fk == nil {
			return fmt.Errorf(`foreign-key "tenant_network_ports" is nil for node %v`, n.ID)
		}
		node, ok := nodeids[*fk]
		if !ok {
			return fmt.Errorf(`unexpected referenced foreign-key "tenant_network_ports" returned %v for node %v`, *fk, n.ID)
		}
		assign(node, n)
	}
	return nil
}
func (_q *TenantQuery) loadNexusAudits(ctx context.Context, query *NexusAuditQuery, nodes []*Tenant, init func(*Tenant), assign func(*Tenant, *NexusAudit)) error {
	fks := make([]driver.Value, 0, len(nodes))
	nodeids := make(map[int]*Tenant)
	for i := range nodes {
		fks = append(fks, nodes[i].ID)
		nodeids[nodes[i].ID] = nodes[i]
		if init != nil {
			init(nodes[i])
		}
	}
	query.withFKs = true
	query.Where(predicate.NexusAudit(func(s *sql.Selector) {
		s.Where(sql.InValues(s.C(tenant.NexusAuditsColumn), fks...))
	}))
	neighbors, err := query.All(ctx)
	if err != nil {
		return err
	}
	for _, n := range neighbors {
		fk := n.tenant_nexus_audits
		if fk == nil {
			return fmt.Errorf(`foreign-key "tenant_nexus_audits" is nil for node %v`, n.ID)
		}
		node, ok := nodeids[*fk]
		if !ok {
			return fmt.Errorf(`unexpected referenced foreign-key "tenant_nexus_audits" returned %v for node %v`, *fk, n.ID)
		}
		assign(node, n)
	}
	return nil
}
func (_q *TenantQuery) loadSuccessionMaps(ctx context.Context, query *SuccessionMapQuery, nodes []*Tenant, init func(*Tenant), assign func(*Tenant, *SuccessionMap)) error {
	fks := make([]driver.Value, 0, len(nodes))
	nodeids := make(map[int]*Tenant)
	for i := range nodes {
		fks = append(fks, nodes[i].ID)
		nodeids[nodes[i].ID] = nodes[i]
		if init != nil {
			init(nodes[i])
		}
	}
	query.withFKs = true
	query.Where(predicate.SuccessionMap(func(s *sql.Selector) {
		s.Where(sql.InValues(s.C(tenant.SuccessionMapsColumn), fks...))
	}))
	neighbors, err := query.All(ctx)
	if err != nil {
		return err
	}
	for _, n := range neighbors {
		fk := n.tenant_succession_maps
		if fk == nil {
			return fmt.Errorf(`foreign-key "tenant_succession_maps" is nil for node %v`, n.ID)
		}
		node, ok := nodeids[*fk]
		if !ok {
			return fmt.Errorf(`unexpected referenced foreign-key "tenant_succession_maps" returned %v for node %v`, *fk, n.ID)
		}
		assign(node, n)
	}
	return nil
}
func (_q *TenantQuery) loadCustomerAccount(ctx context.Context, query *AccountQuery, nodes []*Tenant, init func(*Tenant), assign func(*Tenant, *Account)) error {
	ids := make([]int, 0, len(nodes))
	nodeids := make(map[int][]*Tenant)
	for i := range nodes {
		if nodes[i].tenant_customer_account == nil {
			continue
		}
		fk := *nodes[i].tenant_customer_account
		if _, ok := nodeids[fk]; !ok {
			ids = append(ids, fk)
		}
		nodeids[fk] = append(nodeids[fk], nodes[i])
	}
	if len(ids) == 0 {
		return nil
	}
	query.Where(account.IDIn(ids...))
	neighbors, err := query.All(ctx)
	if err != nil {
		return err
	}
	for _, n := range neighbors {
		nodes, ok := nodeids[n.ID]
		if !ok {
			return fmt.Errorf(`unexpected foreign-key "tenant_customer_account" returned %v`, n.ID)
		}
		for i := range nodes {
			assign(nodes[i], n)
		}
	}
	return nil
}
func (_q *TenantQuery) loadScripts(ctx context.Context, query *ScriptQuery, nodes []*Tenant, init func(*Tenant), assign func(*Tenant, *Script)) error {
	fks := make([]driver.Value, 0, len(nodes))
	nodeids := make(map[int]*Tenant)
	for i := range nodes {
		fks = append(fks, nodes[i].ID)
		nodeids[nodes[i].ID] = nodes[i]
		if init != nil {
			init(nodes[i])
		}
	}
	query.withFKs = true
	query.Where(predicate.Script(func(s *sql.Selector) {
		s.Where(sql.InValues(s.C(tenant.ScriptsColumn), fks...))
	}))
	neighbors, err := query.All(ctx)
	if err != nil {
		return err
	}
	for _, n := range neighbors {
		fk := n.tenant_scripts
		if fk == nil {
			return fmt.Errorf(`foreign-key "tenant_scripts" is nil for node %v`, n.ID)
		}
		node, ok := nodeids[*fk]
		if !ok {
			return fmt.Errorf(`unexpected referenced foreign-key "tenant_scripts" returned %v for node %v`, *fk, n.ID)
		}
		assign(node, n)
	}
	return nil
}
func (_q *TenantQuery) loadJobs(ctx context.Context, query *JobQuery, nodes []*Tenant, init func(*Tenant), assign func(*Tenant, *Job)) error {
	fks := make([]driver.Value, 0, len(nodes))
	nodeids := make(map[int]*Tenant)
	for i := range nodes {
		fks = append(fks, nodes[i].ID)
		nodeids[nodes[i].ID] = nodes[i]
		if init != nil {
			init(nodes[i])
		}
	}
	query.withFKs = true
	query.Where(predicate.Job(func(s *sql.Selector) {
		s.Where(sql.InValues(s.C(tenant.JobsColumn), fks...))
	}))
	neighbors, err := query.All(ctx)
	if err != nil {
		return err
	}
	for _, n := range neighbors {
		fk := n.tenant_jobs
		if fk == nil {
			return fmt.Errorf(`foreign-key "tenant_jobs" is nil for node %v`, n.ID)
		}
		node, ok := nodeids[*fk]
		if !ok {
			return fmt.Errorf(`unexpected referenced foreign-key "tenant_jobs" returned %v for node %v`, *fk, n.ID)
		}
		assign(node, n)
	}
	return nil
}
func (_q *TenantQuery) loadTimeOffRequests(ctx context.Context, query *TimeOffRequestQuery, nodes []*Tenant, init func(*Tenant), assign func(*Tenant, *TimeOffRequest)) error {
	fks := make([]driver.Value, 0, len(nodes))
	nodeids := make(map[int]*Tenant)
	for i := range nodes {
		fks = append(fks, nodes[i].ID)
		nodeids[nodes[i].ID] = nodes[i]
		if init != nil {
			init(nodes[i])
		}
	}
	query.withFKs = true
	query.Where(predicate.TimeOffRequest(func(s *sql.Selector) {
		s.Where(sql.InValues(s.C(tenant.TimeOffRequestsColumn), fks...))
	}))
	neighbors, err := query.All(ctx)
	if err != nil {
		return err
	}
	for _, n := range neighbors {
		fk := n.tenant_time_off_requests
		if fk == nil {
			return fmt.Errorf(`foreign-key "tenant_time_off_requests" is nil for node %v`, n.ID)
		}
		node, ok := nodeids[*fk]
		if !ok {
			return fmt.Errorf(`unexpected referenced foreign-key "tenant_time_off_requests" returned %v for node %v`, *fk, n.ID)
		}
		assign(node, n)
	}
	return nil
}
func (_q *TenantQuery) loadTimeOffPolicies(ctx context.Context, query *TimeOffPolicyQuery, nodes []*Tenant, init func(*Tenant), assign func(*Tenant, *TimeOffPolicy)) error {
	fks := make([]driver.Value, 0, len(nodes))
	nodeids := make(map[int]*Tenant)
	for i := range nodes {
		fks = append(fks, nodes[i].ID)
		nodeids[nodes[i].ID] = nodes[i]
		if init != nil {
			init(nodes[i])
		}
	}
	query.withFKs = true
	query.Where(predicate.TimeOffPolicy(func(s *sql.Selector) {
		s.Where(sql.InValues(s.C(tenant.TimeOffPoliciesColumn), fks...))
	}))
	neighbors, err := query.All(ctx)
	if err != nil {
		return err
	}
	for _, n := range neighbors {
		fk := n.tenant_time_off_policies
		if fk == nil {
			return fmt.Errorf(`foreign-key "tenant_time_off_policies" is nil for node %v`, n.ID)
		}
		node, ok := nodeids[*fk]
		if !ok {
			return fmt.Errorf(`unexpected referenced foreign-key "tenant_time_off_policies" returned %v for node %v`, *fk, n.ID)
		}
		assign(node, n)
	}
	return nil
}
func (_q *TenantQuery) loadTimeOffBalances(ctx context.Context, query *TimeOffBalanceQuery, nodes []*Tenant, init func(*Tenant), assign func(*Tenant, *TimeOffBalance)) error {
	fks := make([]driver.Value, 0, len(nodes))
	nodeids := make(map[int]*Tenant)
	for i := range nodes {
		fks = append(fks, nodes[i].ID)
		nodeids[nodes[i].ID] = nodes[i]
		if init != nil {
			init(nodes[i])
		}
	}
	query.withFKs = true
	query.Where(predicate.TimeOffBalance(func(s *sql.Selector) {
		s.Where(sql.InValues(s.C(tenant.TimeOffBalancesColumn), fks...))
	}))
	neighbors, err := query.All(ctx)
	if err != nil {
		return err
	}
	for _, n := range neighbors {
		fk := n.tenant_time_off_balances
		if fk == nil {
			return fmt.Errorf(`foreign-key "tenant_time_off_balances" is nil for node %v`, n.ID)
		}
		node, ok := nodeids[*fk]
		if !ok {
			return fmt.Errorf(`unexpected referenced foreign-key "tenant_time_off_balances" returned %v for node %v`, *fk, n.ID)
		}
		assign(node, n)
	}
	return nil
}
func (_q *TenantQuery) loadReviewCycles(ctx context.Context, query *ReviewCycleQuery, nodes []*Tenant, init func(*Tenant), assign func(*Tenant, *ReviewCycle)) error {
	fks := make([]driver.Value, 0, len(nodes))
	nodeids := make(map[int]*Tenant)
	for i := range nodes {
		fks = append(fks, nodes[i].ID)
		nodeids[nodes[i].ID] = nodes[i]
		if init != nil {
			init(nodes[i])
		}
	}
	query.withFKs = true
	query.Where(predicate.ReviewCycle(func(s *sql.Selector) {
		s.Where(sql.InValues(s.C(tenant.ReviewCyclesColumn), fks...))
	}))
	neighbors, err := query.All(ctx)
	if err != nil {
		return err
	}
	for _, n := range neighbors {
		fk := n.tenant_review_cycles
		if fk == nil {
			return fmt.Errorf(`foreign-key "tenant_review_cycles" is nil for node %v`, n.ID)
		}
		node, ok := nodeids[*fk]
		if !ok {
			return fmt.Errorf(`unexpected referenced foreign-key "tenant_review_cycles" returned %v for node %v`, *fk, n.ID)
		}
		assign(node, n)
	}
	return nil
}
func (_q *TenantQuery) loadPerformanceReviews(ctx context.Context, query *PerformanceReviewQuery, nodes []*Tenant, init func(*Tenant), assign func(*Tenant, *PerformanceReview)) error {
	fks := make([]driver.Value, 0, len(nodes))
	nodeids := make(map[int]*Tenant)
	for i := range nodes {
		fks = append(fks, nodes[i].ID)
		nodeids[nodes[i].ID] = nodes[i]
		if init != nil {
			init(nodes[i])
		}
	}
	query.withFKs = true
	query.Where(predicate.PerformanceReview(func(s *sql.Selector) {
		s.Where(sql.InValues(s.C(tenant.PerformanceReviewsColumn), fks...))
	}))
	neighbors, err := query.All(ctx)
	if err != nil {
		return err
	}
	for _, n := range neighbors {
		fk := n.tenant_performance_reviews
		if fk == nil {
			return fmt.Errorf(`foreign-key "tenant_performance_reviews" is nil for node %v`, n.ID)
		}
		node, ok := nodeids[*fk]
		if !ok {
			return fmt.Errorf(`unexpected referenced foreign-key "tenant_performance_reviews" returned %v for node %v`, *fk, n.ID)
		}
		assign(node, n)
	}
	return nil
}
func (_q *TenantQuery) loadGoals(ctx context.Context, query *GoalQuery, nodes []*Tenant, init func(*Tenant), assign func(*Tenant, *Goal)) error {
	fks := make([]driver.Value, 0, len(nodes))
	nodeids := make(map[int]*Tenant)
	for i := range nodes {
		fks = append(fks, nodes[i].ID)
		nodeids[nodes[i].ID] = nodes[i]
		if init != nil {
			init(nodes[i])
		}
	}
	query.withFKs = true
	query.Where(predicate.Goal(func(s *sql.Selector) {
		s.Where(sql.InValues(s.C(tenant.GoalsColumn), fks...))
	}))
	neighbors, err := query.All(ctx)
	if err != nil {
		return err
	}
	for _, n := range neighbors {
		fk := n.tenant_goals
		if fk == nil {
			return fmt.Errorf(`foreign-key "tenant_goals" is nil for node %v`, n.ID)
		}
		node, ok := nodeids[*fk]
		if !ok {
			return fmt.Errorf(`unexpected referenced foreign-key "tenant_goals" returned %v for node %v`, *fk, n.ID)
		}
		assign(node, n)
	}
	return nil
}
func (_q *TenantQuery) loadSuppliers(ctx context.Context, query *SupplierQuery, nodes []*Tenant, init func(*Tenant), assign func(*Tenant, *Supplier)) error {
	fks := make([]driver.Value, 0, len(nodes))
	nodeids := make(map[int]*Tenant)
	for i := range nodes {
		fks = append(fks, nodes[i].ID)
		nodeids[nodes[i].ID] = nodes[i]
		if init != nil {
			init(nodes[i])
		}
	}
	query.withFKs = true
	query.Where(predicate.Supplier(func(s *sql.Selector) {
		s.Where(sql.InValues(s.C(tenant.SuppliersColumn), fks...))
	}))
	neighbors, err := query.All(ctx)
	if err != nil {
		return err
	}
	for _, n := range neighbors {
		fk := n.tenant_suppliers
		if fk == nil {
			return fmt.Errorf(`foreign-key "tenant_suppliers" is nil for node %v`, n.ID)
		}
		node, ok := nodeids[*fk]
		if !ok {
			return fmt.Errorf(`unexpected referenced foreign-key "tenant_suppliers" returned %v for node %v`, *fk, n.ID)
		}
		assign(node, n)
	}
	return nil
}
func (_q *TenantQuery) loadCategories(ctx context.Context, query *CategoryQuery, nodes []*Tenant, init func(*Tenant), assign func(*Tenant, *Category)) error {
	fks := make([]driver.Value, 0, len(nodes))
	nodeids := make(map[int]*Tenant)
	for i := range nodes {
		fks = append(fks, nodes[i].ID)
		nodeids[nodes[i].ID] = nodes[i]
		if init != nil {
			init(nodes[i])
		}
	}
	query.withFKs = true
	query.Where(predicate.Category(func(s *sql.Selector) {
		s.Where(sql.InValues(s.C(tenant.CategoriesColumn), fks...))
	}))
	neighbors, err := query.All(ctx)
	if err != nil {
		return err
	}
	for _, n := range neighbors {
		fk := n.tenant_categories
		if fk == nil {
			return fmt.Errorf(`foreign-key "tenant_categories" is nil for node %v`, n.ID)
		}
		node, ok := nodeids[*fk]
		if !ok {
			return fmt.Errorf(`unexpected referenced foreign-key "tenant_categories" returned %v for node %v`, *fk, n.ID)
		}
		assign(node, n)
	}
	return nil
}
func (_q *TenantQuery) loadWarehouses(ctx context.Context, query *WarehouseQuery, nodes []*Tenant, init func(*Tenant), assign func(*Tenant, *Warehouse)) error {
	fks := make([]driver.Value, 0, len(nodes))
	nodeids := make(map[int]*Tenant)
	for i := range nodes {
		fks = append(fks, nodes[i].ID)
		nodeids[nodes[i].ID] = nodes[i]
		if init != nil {
			init(nodes[i])
		}
	}
	query.withFKs = true
	query.Where(predicate.Warehouse(func(s *sql.Selector) {
		s.Where(sql.InValues(s.C(tenant.WarehousesColumn), fks...))
	}))
	neighbors, err := query.All(ctx)
	if err != nil {
		return err
	}
	for _, n := range neighbors {
		fk := n.tenant_warehouses
		if fk == nil {
			return fmt.Errorf(`foreign-key "tenant_warehouses" is nil for node %v`, n.ID)
		}
		node, ok := nodeids[*fk]
		if !ok {
			return fmt.Errorf(`unexpected referenced foreign-key "tenant_warehouses" returned %v for node %v`, *fk, n.ID)
		}
		assign(node, n)
	}
	return nil
}
func (_q *TenantQuery) loadAssetAssignments(ctx context.Context, query *AssetAssignmentQuery, nodes []*Tenant, init func(*Tenant), assign func(*Tenant, *AssetAssignment)) error {
	fks := make([]driver.Value, 0, len(nodes))
	nodeids := make(map[int]*Tenant)
	for i := range nodes {
		fks = append(fks, nodes[i].ID)
		nodeids[nodes[i].ID] = nodes[i]
		if init != nil {
			init(nodes[i])
		}
	}
	query.withFKs = true
	query.Where(predicate.AssetAssignment(func(s *sql.Selector) {
		s.Where(sql.InValues(s.C(tenant.AssetAssignmentsColumn), fks...))
	}))
	neighbors, err := query.All(ctx)
	if err != nil {
		return err
	}
	for _, n := range neighbors {
		fk := n.tenant_asset_assignments
		if fk == nil {
			return fmt.Errorf(`foreign-key "tenant_asset_assignments" is nil for node %v`, n.ID)
		}
		node, ok := nodeids[*fk]
		if !ok {
			return fmt.Errorf(`unexpected referenced foreign-key "tenant_asset_assignments" returned %v for node %v`, *fk, n.ID)
		}
		assign(node, n)
	}
	return nil
}
func (_q *TenantQuery) loadContacts(ctx context.Context, query *ContactQuery, nodes []*Tenant, init func(*Tenant), assign func(*Tenant, *Contact)) error {
	fks := make([]driver.Value, 0, len(nodes))
	nodeids := make(map[int]*Tenant)
	for i := range nodes {
		fks = append(fks, nodes[i].ID)
		nodeids[nodes[i].ID] = nodes[i]
		if init != nil {
			init(nodes[i])
		}
	}
	query.withFKs = true
	query.Where(predicate.Contact(func(s *sql.Selector) {
		s.Where(sql.InValues(s.C(tenant.ContactsColumn), fks...))
	}))
	neighbors, err := query.All(ctx)
	if err != nil {
		return err
	}
	for _, n := range neighbors {
		fk := n.tenant_contacts
		if fk == nil {
			return fmt.Errorf(`foreign-key "tenant_contacts" is nil for node %v`, n.ID)
		}
		node, ok := nodeids[*fk]
		if !ok {
			return fmt.Errorf(`unexpected referenced foreign-key "tenant_contacts" returned %v for node %v`, *fk, n.ID)
		}
		assign(node, n)
	}
	return nil
}
func (_q *TenantQuery) loadLegalHolds(ctx context.Context, query *LegalHoldQuery, nodes []*Tenant, init func(*Tenant), assign func(*Tenant, *LegalHold)) error {
	fks := make([]driver.Value, 0, len(nodes))
	nodeids := make(map[int]*Tenant)
	for i := range nodes {
		fks = append(fks, nodes[i].ID)
		nodeids[nodes[i].ID] = nodes[i]
		if init != nil {
			init(nodes[i])
		}
	}
	query.withFKs = true
	query.Where(predicate.LegalHold(func(s *sql.Selector) {
		s.Where(sql.InValues(s.C(tenant.LegalHoldsColumn), fks...))
	}))
	neighbors, err := query.All(ctx)
	if err != nil {
		return err
	}
	for _, n := range neighbors {
		fk := n.tenant_legal_holds
		if fk == nil {
			return fmt.Errorf(`foreign-key "tenant_legal_holds" is nil for node %v`, n.ID)
		}
		node, ok := nodeids[*fk]
		if !ok {
			return fmt.Errorf(`unexpected referenced foreign-key "tenant_legal_holds" returned %v for node %v`, *fk, n.ID)
		}
		assign(node, n)
	}
	return nil
}
func (_q *TenantQuery) loadRetentionPolicies(ctx context.Context, query *RetentionPolicyQuery, nodes []*Tenant, init func(*Tenant), assign func(*Tenant, *RetentionPolicy)) error {
	fks := make([]driver.Value, 0, len(nodes))
	nodeids := make(map[int]*Tenant)
	for i := range nodes {
		fks = append(fks, nodes[i].ID)
		nodeids[nodes[i].ID] = nodes[i]
		if init != nil {
			init(nodes[i])
		}
	}
	query.withFKs = true
	query.Where(predicate.RetentionPolicy(func(s *sql.Selector) {
		s.Where(sql.InValues(s.C(tenant.RetentionPoliciesColumn), fks...))
	}))
	neighbors, err := query.All(ctx)
	if err != nil {
		return err
	}
	for _, n := range neighbors {
		fk := n.tenant_retention_policies
		if fk == nil {
			return fmt.Errorf(`foreign-key "tenant_retention_policies" is nil for node %v`, n.ID)
		}
		node, ok := nodeids[*fk]
		if !ok {
			return fmt.Errorf(`unexpected referenced foreign-key "tenant_retention_policies" returned %v for node %v`, *fk, n.ID)
		}
		assign(node, n)
	}
	return nil
}
func (_q *TenantQuery) loadVaultTemplates(ctx context.Context, query *VaultTemplateQuery, nodes []*Tenant, init func(*Tenant), assign func(*Tenant, *VaultTemplate)) error {
	fks := make([]driver.Value, 0, len(nodes))
	nodeids := make(map[int]*Tenant)
	for i := range nodes {
		fks = append(fks, nodes[i].ID)
		nodeids[nodes[i].ID] = nodes[i]
		if init != nil {
			init(nodes[i])
		}
	}
	query.withFKs = true
	query.Where(predicate.VaultTemplate(func(s *sql.Selector) {
		s.Where(sql.InValues(s.C(tenant.VaultTemplatesColumn), fks...))
	}))
	neighbors, err := query.All(ctx)
	if err != nil {
		return err
	}
	for _, n := range neighbors {
		fk := n.tenant_vault_templates
		if fk == nil {
			return fmt.Errorf(`foreign-key "tenant_vault_templates" is nil for node %v`, n.ID)
		}
		node, ok := nodeids[*fk]
		if !ok {
			return fmt.Errorf(`unexpected referenced foreign-key "tenant_vault_templates" returned %v for node %v`, *fk, n.ID)
		}
		assign(node, n)
	}
	return nil
}
func (_q *TenantQuery) loadStockAuditLogs(ctx context.Context, query *StockAuditLogQuery, nodes []*Tenant, init func(*Tenant), assign func(*Tenant, *StockAuditLog)) error {
	fks := make([]driver.Value, 0, len(nodes))
	nodeids := make(map[int]*Tenant)
	for i := range nodes {
		fks = append(fks, nodes[i].ID)
		nodeids[nodes[i].ID] = nodes[i]
		if init != nil {
			init(nodes[i])
		}
	}
	query.withFKs = true
	query.Where(predicate.StockAuditLog(func(s *sql.Selector) {
		s.Where(sql.InValues(s.C(tenant.StockAuditLogsColumn), fks...))
	}))
	neighbors, err := query.All(ctx)
	if err != nil {
		return err
	}
	for _, n := range neighbors {
		fk := n.tenant_stock_audit_logs
		if fk == nil {
			return fmt.Errorf(`foreign-key "tenant_stock_audit_logs" is nil for node %v`, n.ID)
		}
		node, ok := nodeids[*fk]
		if !ok {
			return fmt.Errorf(`unexpected referenced foreign-key "tenant_stock_audit_logs" returned %v for node %v`, *fk, n.ID)
		}
		assign(node, n)
	}
	return nil
}
func (_q *TenantQuery) loadMaintenanceSchedules(ctx context.Context, query *MaintenanceScheduleQuery, nodes []*Tenant, init func(*Tenant), assign func(*Tenant, *MaintenanceSchedule)) error {
	fks := make([]driver.Value, 0, len(nodes))
	nodeids := make(map[int]*Tenant)
	for i := range nodes {
		fks = append(fks, nodes[i].ID)
		nodeids[nodes[i].ID] = nodes[i]
		if init != nil {
			init(nodes[i])
		}
	}
	query.withFKs = true
	query.Where(predicate.MaintenanceSchedule(func(s *sql.Selector) {
		s.Where(sql.InValues(s.C(tenant.MaintenanceSchedulesColumn), fks...))
	}))
	neighbors, err := query.All(ctx)
	if err != nil {
		return err
	}
	for _, n := range neighbors {
		fk := n.tenant_maintenance_schedules
		if fk == nil {
			return fmt.Errorf(`foreign-key "tenant_maintenance_schedules" is nil for node %v`, n.ID)
		}
		node, ok := nodeids[*fk]
		if !ok {
			return fmt.Errorf(`unexpected referenced foreign-key "tenant_maintenance_schedules" returned %v for node %v`, *fk, n.ID)
		}
		assign(node, n)
	}
	return nil
}
func (_q *TenantQuery) loadStockAlerts(ctx context.Context, query *StockAlertQuery, nodes []*Tenant, init func(*Tenant), assign func(*Tenant, *StockAlert)) error {
	fks := make([]driver.Value, 0, len(nodes))
	nodeids := make(map[int]*Tenant)
	for i := range nodes {
		fks = append(fks, nodes[i].ID)
		nodeids[nodes[i].ID] = nodes[i]
		if init != nil {
			init(nodes[i])
		}
	}
	query.withFKs = true
	query.Where(predicate.StockAlert(func(s *sql.Selector) {
		s.Where(sql.InValues(s.C(tenant.StockAlertsColumn), fks...))
	}))
	neighbors, err := query.All(ctx)
	if err != nil {
		return err
	}
	for _, n := range neighbors {
		fk := n.tenant_stock_alerts
		if fk == nil {
			return fmt.Errorf(`foreign-key "tenant_stock_alerts" is nil for node %v`, n.ID)
		}
		node, ok := nodeids[*fk]
		if !ok {
			return fmt.Errorf(`unexpected referenced foreign-key "tenant_stock_alerts" returned %v for node %v`, *fk, n.ID)
		}
		assign(node, n)
	}
	return nil
}
func (_q *TenantQuery) loadPurchaseOrders(ctx context.Context, query *PurchaseOrderQuery, nodes []*Tenant, init func(*Tenant), assign func(*Tenant, *PurchaseOrder)) error {
	fks := make([]driver.Value, 0, len(nodes))
	nodeids := make(map[int]*Tenant)
	for i := range nodes {
		fks = append(fks, nodes[i].ID)
		nodeids[nodes[i].ID] = nodes[i]
		if init != nil {
			init(nodes[i])
		}
	}
	query.withFKs = true
	query.Where(predicate.PurchaseOrder(func(s *sql.Selector) {
		s.Where(sql.InValues(s.C(tenant.PurchaseOrdersColumn), fks...))
	}))
	neighbors, err := query.All(ctx)
	if err != nil {
		return err
	}
	for _, n := range neighbors {
		fk := n.tenant_purchase_orders
		if fk == nil {
			return fmt.Errorf(`foreign-key "tenant_purchase_orders" is nil for node %v`, n.ID)
		}
		node, ok := nodeids[*fk]
		if !ok {
			return fmt.Errorf(`unexpected referenced foreign-key "tenant_purchase_orders" returned %v for node %v`, *fk, n.ID)
		}
		assign(node, n)
	}
	return nil
}
func (_q *TenantQuery) loadInventoryCounts(ctx context.Context, query *InventoryCountQuery, nodes []*Tenant, init func(*Tenant), assign func(*Tenant, *InventoryCount)) error {
	fks := make([]driver.Value, 0, len(nodes))
	nodeids := make(map[int]*Tenant)
	for i := range nodes {
		fks = append(fks, nodes[i].ID)
		nodeids[nodes[i].ID] = nodes[i]
		if init != nil {
			init(nodes[i])
		}
	}
	query.withFKs = true
	query.Where(predicate.InventoryCount(func(s *sql.Selector) {
		s.Where(sql.InValues(s.C(tenant.InventoryCountsColumn), fks...))
	}))
	neighbors, err := query.All(ctx)
	if err != nil {
		return err
	}
	for _, n := range neighbors {
		fk := n.tenant_inventory_counts
		if fk == nil {
			return fmt.Errorf(`foreign-key "tenant_inventory_counts" is nil for node %v`, n.ID)
		}
		node, ok := nodeids[*fk]
		if !ok {
			return fmt.Errorf(`unexpected referenced foreign-key "tenant_inventory_counts" returned %v for node %v`, *fk, n.ID)
		}
		assign(node, n)
	}
	return nil
}
func (_q *TenantQuery) loadJobPostings(ctx context.Context, query *JobPostingQuery, nodes []*Tenant, init func(*Tenant), assign func(*Tenant, *JobPosting)) error {
	fks := make([]driver.Value, 0, len(nodes))
	nodeids := make(map[int]*Tenant)
	for i := range nodes {
		fks = append(fks, nodes[i].ID)
		nodeids[nodes[i].ID] = nodes[i]
		if init != nil {
			init(nodes[i])
		}
	}
	query.withFKs = true
	query.Where(predicate.JobPosting(func(s *sql.Selector) {
		s.Where(sql.InValues(s.C(tenant.JobPostingsColumn), fks...))
	}))
	neighbors, err := query.All(ctx)
	if err != nil {
		return err
	}
	for _, n := range neighbors {
		fk := n.tenant_job_postings
		if fk == nil {
			return fmt.Errorf(`foreign-key "tenant_job_postings" is nil for node %v`, n.ID)
		}
		node, ok := nodeids[*fk]
		if !ok {
			return fmt.Errorf(`unexpected referenced foreign-key "tenant_job_postings" returned %v for node %v`, *fk, n.ID)
		}
		assign(node, n)
	}
	return nil
}
func (_q *TenantQuery) loadCandidates(ctx context.Context, query *CandidateQuery, nodes []*Tenant, init func(*Tenant), assign func(*Tenant, *Candidate)) error {
	fks := make([]driver.Value, 0, len(nodes))
	nodeids := make(map[int]*Tenant)
	for i := range nodes {
		fks = append(fks, nodes[i].ID)
		nodeids[nodes[i].ID] = nodes[i]
		if init != nil {
			init(nodes[i])
		}
	}
	query.withFKs = true
	query.Where(predicate.Candidate(func(s *sql.Selector) {
		s.Where(sql.InValues(s.C(tenant.CandidatesColumn), fks...))
	}))
	neighbors, err := query.All(ctx)
	if err != nil {
		return err
	}
	for _, n := range neighbors {
		fk := n.tenant_candidates
		if fk == nil {
			return fmt.Errorf(`foreign-key "tenant_candidates" is nil for node %v`, n.ID)
		}
		node, ok := nodeids[*fk]
		if !ok {
			return fmt.Errorf(`unexpected referenced foreign-key "tenant_candidates" returned %v for node %v`, *fk, n.ID)
		}
		assign(node, n)
	}
	return nil
}
func (_q *TenantQuery) loadApplications(ctx context.Context, query *ApplicationQuery, nodes []*Tenant, init func(*Tenant), assign func(*Tenant, *Application)) error {
	fks := make([]driver.Value, 0, len(nodes))
	nodeids := make(map[int]*Tenant)
	for i := range nodes {
		fks = append(fks, nodes[i].ID)
		nodeids[nodes[i].ID] = nodes[i]
		if init != nil {
			init(nodes[i])
		}
	}
	query.withFKs = true
	query.Where(predicate.Application(func(s *sql.Selector) {
		s.Where(sql.InValues(s.C(tenant.ApplicationsColumn), fks...))
	}))
	neighbors, err := query.All(ctx)
	if err != nil {
		return err
	}
	for _, n := range neighbors {
		fk := n.tenant_applications
		if fk == nil {
			return fmt.Errorf(`foreign-key "tenant_applications" is nil for node %v`, n.ID)
		}
		node, ok := nodeids[*fk]
		if !ok {
			return fmt.Errorf(`unexpected referenced foreign-key "tenant_applications" returned %v for node %v`, *fk, n.ID)
		}
		assign(node, n)
	}
	return nil
}
func (_q *TenantQuery) loadInterviews(ctx context.Context, query *InterviewQuery, nodes []*Tenant, init func(*Tenant), assign func(*Tenant, *Interview)) error {
	fks := make([]driver.Value, 0, len(nodes))
	nodeids := make(map[int]*Tenant)
	for i := range nodes {
		fks = append(fks, nodes[i].ID)
		nodeids[nodes[i].ID] = nodes[i]
		if init != nil {
			init(nodes[i])
		}
	}
	query.withFKs = true
	query.Where(predicate.Interview(func(s *sql.Selector) {
		s.Where(sql.InValues(s.C(tenant.InterviewsColumn), fks...))
	}))
	neighbors, err := query.All(ctx)
	if err != nil {
		return err
	}
	for _, n := range neighbors {
		fk := n.tenant_interviews
		if fk == nil {
			return fmt.Errorf(`foreign-key "tenant_interviews" is nil for node %v`, n.ID)
		}
		node, ok := nodeids[*fk]
		if !ok {
			return fmt.Errorf(`unexpected referenced foreign-key "tenant_interviews" returned %v for node %v`, *fk, n.ID)
		}
		assign(node, n)
	}
	return nil
}
func (_q *TenantQuery) loadBenefitPlans(ctx context.Context, query *BenefitPlanQuery, nodes []*Tenant, init func(*Tenant), assign func(*Tenant, *BenefitPlan)) error {
	fks := make([]driver.Value, 0, len(nodes))
	nodeids := make(map[int]*Tenant)
	for i := range nodes {
		fks = append(fks, nodes[i].ID)
		nodeids[nodes[i].ID] = nodes[i]
		if init != nil {
			init(nodes[i])
		}
	}
	query.withFKs = true
	query.Where(predicate.BenefitPlan(func(s *sql.Selector) {
		s.Where(sql.InValues(s.C(tenant.BenefitPlansColumn), fks...))
	}))
	neighbors, err := query.All(ctx)
	if err != nil {
		return err
	}
	for _, n := range neighbors {
		fk := n.tenant_benefit_plans
		if fk == nil {
			return fmt.Errorf(`foreign-key "tenant_benefit_plans" is nil for node %v`, n.ID)
		}
		node, ok := nodeids[*fk]
		if !ok {
			return fmt.Errorf(`unexpected referenced foreign-key "tenant_benefit_plans" returned %v for node %v`, *fk, n.ID)
		}
		assign(node, n)
	}
	return nil
}
func (_q *TenantQuery) loadBenefitEnrollments(ctx context.Context, query *BenefitEnrollmentQuery, nodes []*Tenant, init func(*Tenant), assign func(*Tenant, *BenefitEnrollment)) error {
	fks := make([]driver.Value, 0, len(nodes))
	nodeids := make(map[int]*Tenant)
	for i := range nodes {
		fks = append(fks, nodes[i].ID)
		nodeids[nodes[i].ID] = nodes[i]
		if init != nil {
			init(nodes[i])
		}
	}
	query.withFKs = true
	query.Where(predicate.BenefitEnrollment(func(s *sql.Selector) {
		s.Where(sql.InValues(s.C(tenant.BenefitEnrollmentsColumn), fks...))
	}))
	neighbors, err := query.All(ctx)
	if err != nil {
		return err
	}
	for _, n := range neighbors {
		fk := n.tenant_benefit_enrollments
		if fk == nil {
			return fmt.Errorf(`foreign-key "tenant_benefit_enrollments" is nil for node %v`, n.ID)
		}
		node, ok := nodeids[*fk]
		if !ok {
			return fmt.Errorf(`unexpected referenced foreign-key "tenant_benefit_enrollments" returned %v for node %v`, *fk, n.ID)
		}
		assign(node, n)
	}
	return nil
}

func (_q *TenantQuery) sqlCount(ctx context.Context) (int, error) {
	_spec := _q.querySpec()
	if len(_q.modifiers) > 0 {
		_spec.Modifiers = _q.modifiers
	}
	_spec.Node.Columns = _q.ctx.Fields
	if len(_q.ctx.Fields) > 0 {
		_spec.Unique = _q.ctx.Unique != nil && *_q.ctx.Unique
	}
	return sqlgraph.CountNodes(ctx, _q.driver, _spec)
}

func (_q *TenantQuery) querySpec() *sqlgraph.QuerySpec {
	_spec := sqlgraph.NewQuerySpec(tenant.Table, tenant.Columns, sqlgraph.NewFieldSpec(tenant.FieldID, field.TypeInt))
	_spec.From = _q.sql
	if unique := _q.ctx.Unique; unique != nil {
		_spec.Unique = *unique
	} else if _q.path != nil {
		_spec.Unique = true
	}
	if fields := _q.ctx.Fields; len(fields) > 0 {
		_spec.Node.Columns = make([]string, 0, len(fields))
		_spec.Node.Columns = append(_spec.Node.Columns, tenant.FieldID)
		for i := range fields {
			if fields[i] != tenant.FieldID {
				_spec.Node.Columns = append(_spec.Node.Columns, fields[i])
			}
		}
	}
	if ps := _q.predicates; len(ps) > 0 {
		_spec.Predicate = func(selector *sql.Selector) {
			for i := range ps {
				ps[i](selector)
			}
		}
	}
	if limit := _q.ctx.Limit; limit != nil {
		_spec.Limit = *limit
	}
	if offset := _q.ctx.Offset; offset != nil {
		_spec.Offset = *offset
	}
	if ps := _q.order; len(ps) > 0 {
		_spec.Order = func(selector *sql.Selector) {
			for i := range ps {
				ps[i](selector)
			}
		}
	}
	return _spec
}

func (_q *TenantQuery) sqlQuery(ctx context.Context) *sql.Selector {
	builder := sql.Dialect(_q.driver.Dialect())
	t1 := builder.Table(tenant.Table)
	columns := _q.ctx.Fields
	if len(columns) == 0 {
		columns = tenant.Columns
	}
	selector := builder.Select(t1.Columns(columns...)...).From(t1)
	if _q.sql != nil {
		selector = _q.sql
		selector.Select(selector.Columns(columns...)...)
	}
	if _q.ctx.Unique != nil && *_q.ctx.Unique {
		selector.Distinct()
	}
	for _, m := range _q.modifiers {
		m(selector)
	}
	for _, p := range _q.predicates {
		p(selector)
	}
	for _, p := range _q.order {
		p(selector)
	}
	if offset := _q.ctx.Offset; offset != nil {
		// limit is mandatory for offset clause. We start
		// with default value, and override it below if needed.
		selector.Offset(*offset).Limit(math.MaxInt32)
	}
	if limit := _q.ctx.Limit; limit != nil {
		selector.Limit(*limit)
	}
	return selector
}

// Modify adds a query modifier for attaching custom logic to queries.
func (_q *TenantQuery) Modify(modifiers ...func(s *sql.Selector)) *TenantSelect {
	_q.modifiers = append(_q.modifiers, modifiers...)
	return _q.Select()
}

// TenantGroupBy is the group-by builder for Tenant entities.
type TenantGroupBy struct {
	selector
	build *TenantQuery
}

// Aggregate adds the given aggregation functions to the group-by query.
func (_g *TenantGroupBy) Aggregate(fns ...AggregateFunc) *TenantGroupBy {
	_g.fns = append(_g.fns, fns...)
	return _g
}

// Scan applies the selector query and scans the result into the given value.
func (_g *TenantGroupBy) Scan(ctx context.Context, v any) error {
	ctx = setContextOp(ctx, _g.build.ctx, ent.OpQueryGroupBy)
	if err := _g.build.prepareQuery(ctx); err != nil {
		return err
	}
	return scanWithInterceptors[*TenantQuery, *TenantGroupBy](ctx, _g.build, _g, _g.build.inters, v)
}

func (_g *TenantGroupBy) sqlScan(ctx context.Context, root *TenantQuery, v any) error {
	selector := root.sqlQuery(ctx).Select()
	aggregation := make([]string, 0, len(_g.fns))
	for _, fn := range _g.fns {
		aggregation = append(aggregation, fn(selector))
	}
	if len(selector.SelectedColumns()) == 0 {
		columns := make([]string, 0, len(*_g.flds)+len(_g.fns))
		for _, f := range *_g.flds {
			columns = append(columns, selector.C(f))
		}
		columns = append(columns, aggregation...)
		selector.Select(columns...)
	}
	selector.GroupBy(selector.Columns(*_g.flds...)...)
	if err := selector.Err(); err != nil {
		return err
	}
	rows := &sql.Rows{}
	query, args := selector.Query()
	if err := _g.build.driver.Query(ctx, query, args, rows); err != nil {
		return err
	}
	defer rows.Close()
	return sql.ScanSlice(rows, v)
}

// TenantSelect is the builder for selecting fields of Tenant entities.
type TenantSelect struct {
	*TenantQuery
	selector
}

// Aggregate adds the given aggregation functions to the selector query.
func (_s *TenantSelect) Aggregate(fns ...AggregateFunc) *TenantSelect {
	_s.fns = append(_s.fns, fns...)
	return _s
}

// Scan applies the selector query and scans the result into the given value.
func (_s *TenantSelect) Scan(ctx context.Context, v any) error {
	ctx = setContextOp(ctx, _s.ctx, ent.OpQuerySelect)
	if err := _s.prepareQuery(ctx); err != nil {
		return err
	}
	return scanWithInterceptors[*TenantQuery, *TenantSelect](ctx, _s.TenantQuery, _s, _s.inters, v)
}

func (_s *TenantSelect) sqlScan(ctx context.Context, root *TenantQuery, v any) error {
	selector := root.sqlQuery(ctx)
	aggregation := make([]string, 0, len(_s.fns))
	for _, fn := range _s.fns {
		aggregation = append(aggregation, fn(selector))
	}
	switch n := len(*_s.selector.flds); {
	case n == 0 && len(aggregation) > 0:
		selector.Select(aggregation...)
	case n != 0 && len(aggregation) > 0:
		selector.AppendSelect(aggregation...)
	}
	rows := &sql.Rows{}
	query, args := selector.Query()
	if err := _s.driver.Query(ctx, query, args, rows); err != nil {
		return err
	}
	defer rows.Close()
	return sql.ScanSlice(rows, v)
}

// Modify adds a query modifier for attaching custom logic to queries.
func (_s *TenantSelect) Modify(modifiers ...func(s *sql.Selector)) *TenantSelect {
	_s.modifiers = append(_s.modifiers, modifiers...)
	return _s
}
