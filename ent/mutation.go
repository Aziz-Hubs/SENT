// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"sent/ent/account"
	"sent/ent/agent"
	"sent/ent/asset"
	"sent/ent/assettype"
	"sent/ent/auditlog"
	"sent/ent/budgetforecast"
	"sent/ent/calllog"
	"sent/ent/camera"
	"sent/ent/compensationagreement"
	"sent/ent/contract"
	"sent/ent/credential"
	"sent/ent/department"
	"sent/ent/detectionevent"
	"sent/ent/discoveryentry"
	"sent/ent/employee"
	"sent/ent/healthscoresnapshot"
	"sent/ent/inventoryreservation"
	"sent/ent/ivrflow"
	"sent/ent/journalentry"
	"sent/ent/ledgerentry"
	"sent/ent/networkbackup"
	"sent/ent/networkdevice"
	"sent/ent/networklink"
	"sent/ent/networkport"
	"sent/ent/nexusaudit"
	"sent/ent/onetimelink"
	"sent/ent/permission"
	"sent/ent/predicate"
	"sent/ent/product"
	"sent/ent/recording"
	"sent/ent/recurringinvoice"
	"sent/ent/remediationstep"
	"sent/ent/saasapp"
	"sent/ent/saasfilter"
	"sent/ent/saasidentity"
	"sent/ent/saasusage"
	"sent/ent/servicerate"
	"sent/ent/sop"
	"sent/ent/stockmovement"
	"sent/ent/strategicroadmap"
	"sent/ent/successionmap"
	"sent/ent/tenant"
	"sent/ent/ticket"
	"sent/ent/timeentry"
	"sent/ent/transaction"
	"sent/ent/user"
	"sent/ent/vaultitem"
	"sent/ent/voicemail"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeAccount               = "Account"
	TypeAgent                 = "Agent"
	TypeAsset                 = "Asset"
	TypeAssetType             = "AssetType"
	TypeAuditLog              = "AuditLog"
	TypeBudgetForecast        = "BudgetForecast"
	TypeCallLog               = "CallLog"
	TypeCamera                = "Camera"
	TypeCompensationAgreement = "CompensationAgreement"
	TypeContract              = "Contract"
	TypeCredential            = "Credential"
	TypeDepartment            = "Department"
	TypeDetectionEvent        = "DetectionEvent"
	TypeDiscoveryEntry        = "DiscoveryEntry"
	TypeEmployee              = "Employee"
	TypeHealthScoreSnapshot   = "HealthScoreSnapshot"
	TypeIVRFlow               = "IVRFlow"
	TypeInventoryReservation  = "InventoryReservation"
	TypeJournalEntry          = "JournalEntry"
	TypeLedgerEntry           = "LedgerEntry"
	TypeNetworkBackup         = "NetworkBackup"
	TypeNetworkDevice         = "NetworkDevice"
	TypeNetworkLink           = "NetworkLink"
	TypeNetworkPort           = "NetworkPort"
	TypeNexusAudit            = "NexusAudit"
	TypeOneTimeLink           = "OneTimeLink"
	TypePermission            = "Permission"
	TypeProduct               = "Product"
	TypeRecording             = "Recording"
	TypeRecurringInvoice      = "RecurringInvoice"
	TypeRemediationStep       = "RemediationStep"
	TypeSOP                   = "SOP"
	TypeSaaSApp               = "SaaSApp"
	TypeSaaSFilter            = "SaaSFilter"
	TypeSaaSIdentity          = "SaaSIdentity"
	TypeSaaSUsage             = "SaaSUsage"
	TypeServiceRate           = "ServiceRate"
	TypeStockMovement         = "StockMovement"
	TypeStrategicRoadmap      = "StrategicRoadmap"
	TypeSuccessionMap         = "SuccessionMap"
	TypeTenant                = "Tenant"
	TypeTicket                = "Ticket"
	TypeTimeEntry             = "TimeEntry"
	TypeTransaction           = "Transaction"
	TypeUser                  = "User"
	TypeVaultItem             = "VaultItem"
	TypeVoicemail             = "Voicemail"
)

// AccountMutation represents an operation that mutates the Account nodes in the graph.
type AccountMutation struct {
	config
	op                        Op
	typ                       string
	id                        *int
	name                      *string
	number                    *string
	_type                     *account.Type
	balance                   *float64
	addbalance                *float64
	is_intercompany           *bool
	created_at                *time.Time
	clearedFields             map[string]struct{}
	tenant                    *int
	clearedtenant             bool
	entries                   map[int]struct{}
	removedentries            map[int]struct{}
	clearedentries            bool
	journal_entries           map[int]struct{}
	removedjournal_entries    map[int]struct{}
	clearedjournal_entries    bool
	recurring_invoices        map[int]struct{}
	removedrecurring_invoices map[int]struct{}
	clearedrecurring_invoices bool
	done                      bool
	oldValue                  func(context.Context) (*Account, error)
	predicates                []predicate.Account
}

var _ ent.Mutation = (*AccountMutation)(nil)

// accountOption allows management of the mutation configuration using functional options.
type accountOption func(*AccountMutation)

// newAccountMutation creates new mutation for the Account entity.
func newAccountMutation(c config, op Op, opts ...accountOption) *AccountMutation {
	m := &AccountMutation{
		config:        c,
		op:            op,
		typ:           TypeAccount,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAccountID sets the ID field of the mutation.
func withAccountID(id int) accountOption {
	return func(m *AccountMutation) {
		var (
			err   error
			once  sync.Once
			value *Account
		)
		m.oldValue = func(ctx context.Context) (*Account, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Account.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAccount sets the old Account of the mutation.
func withAccount(node *Account) accountOption {
	return func(m *AccountMutation) {
		m.oldValue = func(context.Context) (*Account, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AccountMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AccountMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AccountMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AccountMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Account.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *AccountMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *AccountMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *AccountMutation) ResetName() {
	m.name = nil
}

// SetNumber sets the "number" field.
func (m *AccountMutation) SetNumber(s string) {
	m.number = &s
}

// Number returns the value of the "number" field in the mutation.
func (m *AccountMutation) Number() (r string, exists bool) {
	v := m.number
	if v == nil {
		return
	}
	return *v, true
}

// OldNumber returns the old "number" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNumber: %w", err)
	}
	return oldValue.Number, nil
}

// ResetNumber resets all changes to the "number" field.
func (m *AccountMutation) ResetNumber() {
	m.number = nil
}

// SetType sets the "type" field.
func (m *AccountMutation) SetType(a account.Type) {
	m._type = &a
}

// GetType returns the value of the "type" field in the mutation.
func (m *AccountMutation) GetType() (r account.Type, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldType(ctx context.Context) (v account.Type, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *AccountMutation) ResetType() {
	m._type = nil
}

// SetBalance sets the "balance" field.
func (m *AccountMutation) SetBalance(f float64) {
	m.balance = &f
	m.addbalance = nil
}

// Balance returns the value of the "balance" field in the mutation.
func (m *AccountMutation) Balance() (r float64, exists bool) {
	v := m.balance
	if v == nil {
		return
	}
	return *v, true
}

// OldBalance returns the old "balance" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldBalance(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBalance is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBalance requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBalance: %w", err)
	}
	return oldValue.Balance, nil
}

// AddBalance adds f to the "balance" field.
func (m *AccountMutation) AddBalance(f float64) {
	if m.addbalance != nil {
		*m.addbalance += f
	} else {
		m.addbalance = &f
	}
}

// AddedBalance returns the value that was added to the "balance" field in this mutation.
func (m *AccountMutation) AddedBalance() (r float64, exists bool) {
	v := m.addbalance
	if v == nil {
		return
	}
	return *v, true
}

// ResetBalance resets all changes to the "balance" field.
func (m *AccountMutation) ResetBalance() {
	m.balance = nil
	m.addbalance = nil
}

// SetIsIntercompany sets the "is_intercompany" field.
func (m *AccountMutation) SetIsIntercompany(b bool) {
	m.is_intercompany = &b
}

// IsIntercompany returns the value of the "is_intercompany" field in the mutation.
func (m *AccountMutation) IsIntercompany() (r bool, exists bool) {
	v := m.is_intercompany
	if v == nil {
		return
	}
	return *v, true
}

// OldIsIntercompany returns the old "is_intercompany" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldIsIntercompany(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsIntercompany is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsIntercompany requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsIntercompany: %w", err)
	}
	return oldValue.IsIntercompany, nil
}

// ResetIsIntercompany resets all changes to the "is_intercompany" field.
func (m *AccountMutation) ResetIsIntercompany() {
	m.is_intercompany = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *AccountMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AccountMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AccountMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetTenantID sets the "tenant" edge to the Tenant entity by id.
func (m *AccountMutation) SetTenantID(id int) {
	m.tenant = &id
}

// ClearTenant clears the "tenant" edge to the Tenant entity.
func (m *AccountMutation) ClearTenant() {
	m.clearedtenant = true
}

// TenantCleared reports if the "tenant" edge to the Tenant entity was cleared.
func (m *AccountMutation) TenantCleared() bool {
	return m.clearedtenant
}

// TenantID returns the "tenant" edge ID in the mutation.
func (m *AccountMutation) TenantID() (id int, exists bool) {
	if m.tenant != nil {
		return *m.tenant, true
	}
	return
}

// TenantIDs returns the "tenant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TenantID instead. It exists only for internal usage by the builders.
func (m *AccountMutation) TenantIDs() (ids []int) {
	if id := m.tenant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTenant resets all changes to the "tenant" edge.
func (m *AccountMutation) ResetTenant() {
	m.tenant = nil
	m.clearedtenant = false
}

// AddEntryIDs adds the "entries" edge to the LedgerEntry entity by ids.
func (m *AccountMutation) AddEntryIDs(ids ...int) {
	if m.entries == nil {
		m.entries = make(map[int]struct{})
	}
	for i := range ids {
		m.entries[ids[i]] = struct{}{}
	}
}

// ClearEntries clears the "entries" edge to the LedgerEntry entity.
func (m *AccountMutation) ClearEntries() {
	m.clearedentries = true
}

// EntriesCleared reports if the "entries" edge to the LedgerEntry entity was cleared.
func (m *AccountMutation) EntriesCleared() bool {
	return m.clearedentries
}

// RemoveEntryIDs removes the "entries" edge to the LedgerEntry entity by IDs.
func (m *AccountMutation) RemoveEntryIDs(ids ...int) {
	if m.removedentries == nil {
		m.removedentries = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.entries, ids[i])
		m.removedentries[ids[i]] = struct{}{}
	}
}

// RemovedEntries returns the removed IDs of the "entries" edge to the LedgerEntry entity.
func (m *AccountMutation) RemovedEntriesIDs() (ids []int) {
	for id := range m.removedentries {
		ids = append(ids, id)
	}
	return
}

// EntriesIDs returns the "entries" edge IDs in the mutation.
func (m *AccountMutation) EntriesIDs() (ids []int) {
	for id := range m.entries {
		ids = append(ids, id)
	}
	return
}

// ResetEntries resets all changes to the "entries" edge.
func (m *AccountMutation) ResetEntries() {
	m.entries = nil
	m.clearedentries = false
	m.removedentries = nil
}

// AddJournalEntryIDs adds the "journal_entries" edge to the JournalEntry entity by ids.
func (m *AccountMutation) AddJournalEntryIDs(ids ...int) {
	if m.journal_entries == nil {
		m.journal_entries = make(map[int]struct{})
	}
	for i := range ids {
		m.journal_entries[ids[i]] = struct{}{}
	}
}

// ClearJournalEntries clears the "journal_entries" edge to the JournalEntry entity.
func (m *AccountMutation) ClearJournalEntries() {
	m.clearedjournal_entries = true
}

// JournalEntriesCleared reports if the "journal_entries" edge to the JournalEntry entity was cleared.
func (m *AccountMutation) JournalEntriesCleared() bool {
	return m.clearedjournal_entries
}

// RemoveJournalEntryIDs removes the "journal_entries" edge to the JournalEntry entity by IDs.
func (m *AccountMutation) RemoveJournalEntryIDs(ids ...int) {
	if m.removedjournal_entries == nil {
		m.removedjournal_entries = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.journal_entries, ids[i])
		m.removedjournal_entries[ids[i]] = struct{}{}
	}
}

// RemovedJournalEntries returns the removed IDs of the "journal_entries" edge to the JournalEntry entity.
func (m *AccountMutation) RemovedJournalEntriesIDs() (ids []int) {
	for id := range m.removedjournal_entries {
		ids = append(ids, id)
	}
	return
}

// JournalEntriesIDs returns the "journal_entries" edge IDs in the mutation.
func (m *AccountMutation) JournalEntriesIDs() (ids []int) {
	for id := range m.journal_entries {
		ids = append(ids, id)
	}
	return
}

// ResetJournalEntries resets all changes to the "journal_entries" edge.
func (m *AccountMutation) ResetJournalEntries() {
	m.journal_entries = nil
	m.clearedjournal_entries = false
	m.removedjournal_entries = nil
}

// AddRecurringInvoiceIDs adds the "recurring_invoices" edge to the RecurringInvoice entity by ids.
func (m *AccountMutation) AddRecurringInvoiceIDs(ids ...int) {
	if m.recurring_invoices == nil {
		m.recurring_invoices = make(map[int]struct{})
	}
	for i := range ids {
		m.recurring_invoices[ids[i]] = struct{}{}
	}
}

// ClearRecurringInvoices clears the "recurring_invoices" edge to the RecurringInvoice entity.
func (m *AccountMutation) ClearRecurringInvoices() {
	m.clearedrecurring_invoices = true
}

// RecurringInvoicesCleared reports if the "recurring_invoices" edge to the RecurringInvoice entity was cleared.
func (m *AccountMutation) RecurringInvoicesCleared() bool {
	return m.clearedrecurring_invoices
}

// RemoveRecurringInvoiceIDs removes the "recurring_invoices" edge to the RecurringInvoice entity by IDs.
func (m *AccountMutation) RemoveRecurringInvoiceIDs(ids ...int) {
	if m.removedrecurring_invoices == nil {
		m.removedrecurring_invoices = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.recurring_invoices, ids[i])
		m.removedrecurring_invoices[ids[i]] = struct{}{}
	}
}

// RemovedRecurringInvoices returns the removed IDs of the "recurring_invoices" edge to the RecurringInvoice entity.
func (m *AccountMutation) RemovedRecurringInvoicesIDs() (ids []int) {
	for id := range m.removedrecurring_invoices {
		ids = append(ids, id)
	}
	return
}

// RecurringInvoicesIDs returns the "recurring_invoices" edge IDs in the mutation.
func (m *AccountMutation) RecurringInvoicesIDs() (ids []int) {
	for id := range m.recurring_invoices {
		ids = append(ids, id)
	}
	return
}

// ResetRecurringInvoices resets all changes to the "recurring_invoices" edge.
func (m *AccountMutation) ResetRecurringInvoices() {
	m.recurring_invoices = nil
	m.clearedrecurring_invoices = false
	m.removedrecurring_invoices = nil
}

// Where appends a list predicates to the AccountMutation builder.
func (m *AccountMutation) Where(ps ...predicate.Account) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AccountMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AccountMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Account, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AccountMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AccountMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Account).
func (m *AccountMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AccountMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.name != nil {
		fields = append(fields, account.FieldName)
	}
	if m.number != nil {
		fields = append(fields, account.FieldNumber)
	}
	if m._type != nil {
		fields = append(fields, account.FieldType)
	}
	if m.balance != nil {
		fields = append(fields, account.FieldBalance)
	}
	if m.is_intercompany != nil {
		fields = append(fields, account.FieldIsIntercompany)
	}
	if m.created_at != nil {
		fields = append(fields, account.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AccountMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case account.FieldName:
		return m.Name()
	case account.FieldNumber:
		return m.Number()
	case account.FieldType:
		return m.GetType()
	case account.FieldBalance:
		return m.Balance()
	case account.FieldIsIntercompany:
		return m.IsIntercompany()
	case account.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AccountMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case account.FieldName:
		return m.OldName(ctx)
	case account.FieldNumber:
		return m.OldNumber(ctx)
	case account.FieldType:
		return m.OldType(ctx)
	case account.FieldBalance:
		return m.OldBalance(ctx)
	case account.FieldIsIntercompany:
		return m.OldIsIntercompany(ctx)
	case account.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Account field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AccountMutation) SetField(name string, value ent.Value) error {
	switch name {
	case account.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case account.FieldNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNumber(v)
		return nil
	case account.FieldType:
		v, ok := value.(account.Type)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case account.FieldBalance:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBalance(v)
		return nil
	case account.FieldIsIntercompany:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsIntercompany(v)
		return nil
	case account.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Account field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AccountMutation) AddedFields() []string {
	var fields []string
	if m.addbalance != nil {
		fields = append(fields, account.FieldBalance)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AccountMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case account.FieldBalance:
		return m.AddedBalance()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AccountMutation) AddField(name string, value ent.Value) error {
	switch name {
	case account.FieldBalance:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddBalance(v)
		return nil
	}
	return fmt.Errorf("unknown Account numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AccountMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AccountMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AccountMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Account nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AccountMutation) ResetField(name string) error {
	switch name {
	case account.FieldName:
		m.ResetName()
		return nil
	case account.FieldNumber:
		m.ResetNumber()
		return nil
	case account.FieldType:
		m.ResetType()
		return nil
	case account.FieldBalance:
		m.ResetBalance()
		return nil
	case account.FieldIsIntercompany:
		m.ResetIsIntercompany()
		return nil
	case account.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown Account field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AccountMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.tenant != nil {
		edges = append(edges, account.EdgeTenant)
	}
	if m.entries != nil {
		edges = append(edges, account.EdgeEntries)
	}
	if m.journal_entries != nil {
		edges = append(edges, account.EdgeJournalEntries)
	}
	if m.recurring_invoices != nil {
		edges = append(edges, account.EdgeRecurringInvoices)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AccountMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case account.EdgeTenant:
		if id := m.tenant; id != nil {
			return []ent.Value{*id}
		}
	case account.EdgeEntries:
		ids := make([]ent.Value, 0, len(m.entries))
		for id := range m.entries {
			ids = append(ids, id)
		}
		return ids
	case account.EdgeJournalEntries:
		ids := make([]ent.Value, 0, len(m.journal_entries))
		for id := range m.journal_entries {
			ids = append(ids, id)
		}
		return ids
	case account.EdgeRecurringInvoices:
		ids := make([]ent.Value, 0, len(m.recurring_invoices))
		for id := range m.recurring_invoices {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AccountMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedentries != nil {
		edges = append(edges, account.EdgeEntries)
	}
	if m.removedjournal_entries != nil {
		edges = append(edges, account.EdgeJournalEntries)
	}
	if m.removedrecurring_invoices != nil {
		edges = append(edges, account.EdgeRecurringInvoices)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AccountMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case account.EdgeEntries:
		ids := make([]ent.Value, 0, len(m.removedentries))
		for id := range m.removedentries {
			ids = append(ids, id)
		}
		return ids
	case account.EdgeJournalEntries:
		ids := make([]ent.Value, 0, len(m.removedjournal_entries))
		for id := range m.removedjournal_entries {
			ids = append(ids, id)
		}
		return ids
	case account.EdgeRecurringInvoices:
		ids := make([]ent.Value, 0, len(m.removedrecurring_invoices))
		for id := range m.removedrecurring_invoices {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AccountMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedtenant {
		edges = append(edges, account.EdgeTenant)
	}
	if m.clearedentries {
		edges = append(edges, account.EdgeEntries)
	}
	if m.clearedjournal_entries {
		edges = append(edges, account.EdgeJournalEntries)
	}
	if m.clearedrecurring_invoices {
		edges = append(edges, account.EdgeRecurringInvoices)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AccountMutation) EdgeCleared(name string) bool {
	switch name {
	case account.EdgeTenant:
		return m.clearedtenant
	case account.EdgeEntries:
		return m.clearedentries
	case account.EdgeJournalEntries:
		return m.clearedjournal_entries
	case account.EdgeRecurringInvoices:
		return m.clearedrecurring_invoices
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AccountMutation) ClearEdge(name string) error {
	switch name {
	case account.EdgeTenant:
		m.ClearTenant()
		return nil
	}
	return fmt.Errorf("unknown Account unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AccountMutation) ResetEdge(name string) error {
	switch name {
	case account.EdgeTenant:
		m.ResetTenant()
		return nil
	case account.EdgeEntries:
		m.ResetEntries()
		return nil
	case account.EdgeJournalEntries:
		m.ResetJournalEntries()
		return nil
	case account.EdgeRecurringInvoices:
		m.ResetRecurringInvoices()
		return nil
	}
	return fmt.Errorf("unknown Account edge %s", name)
}

// AgentMutation represents an operation that mutates the Agent nodes in the graph.
type AgentMutation struct {
	config
	op            Op
	typ           string
	id            *int
	hostname      *string
	os            *string
	arch          *string
	ip            *string
	mac           *string
	version       *string
	status        *agent.Status
	last_seen     *time.Time
	created_at    *time.Time
	updated_at    *time.Time
	clearedFields map[string]struct{}
	tenant        *int
	clearedtenant bool
	done          bool
	oldValue      func(context.Context) (*Agent, error)
	predicates    []predicate.Agent
}

var _ ent.Mutation = (*AgentMutation)(nil)

// agentOption allows management of the mutation configuration using functional options.
type agentOption func(*AgentMutation)

// newAgentMutation creates new mutation for the Agent entity.
func newAgentMutation(c config, op Op, opts ...agentOption) *AgentMutation {
	m := &AgentMutation{
		config:        c,
		op:            op,
		typ:           TypeAgent,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAgentID sets the ID field of the mutation.
func withAgentID(id int) agentOption {
	return func(m *AgentMutation) {
		var (
			err   error
			once  sync.Once
			value *Agent
		)
		m.oldValue = func(ctx context.Context) (*Agent, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Agent.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAgent sets the old Agent of the mutation.
func withAgent(node *Agent) agentOption {
	return func(m *AgentMutation) {
		m.oldValue = func(context.Context) (*Agent, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AgentMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AgentMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AgentMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AgentMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Agent.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetHostname sets the "hostname" field.
func (m *AgentMutation) SetHostname(s string) {
	m.hostname = &s
}

// Hostname returns the value of the "hostname" field in the mutation.
func (m *AgentMutation) Hostname() (r string, exists bool) {
	v := m.hostname
	if v == nil {
		return
	}
	return *v, true
}

// OldHostname returns the old "hostname" field's value of the Agent entity.
// If the Agent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentMutation) OldHostname(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHostname is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHostname requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHostname: %w", err)
	}
	return oldValue.Hostname, nil
}

// ResetHostname resets all changes to the "hostname" field.
func (m *AgentMutation) ResetHostname() {
	m.hostname = nil
}

// SetOs sets the "os" field.
func (m *AgentMutation) SetOs(s string) {
	m.os = &s
}

// Os returns the value of the "os" field in the mutation.
func (m *AgentMutation) Os() (r string, exists bool) {
	v := m.os
	if v == nil {
		return
	}
	return *v, true
}

// OldOs returns the old "os" field's value of the Agent entity.
// If the Agent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentMutation) OldOs(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOs is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOs requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOs: %w", err)
	}
	return oldValue.Os, nil
}

// ResetOs resets all changes to the "os" field.
func (m *AgentMutation) ResetOs() {
	m.os = nil
}

// SetArch sets the "arch" field.
func (m *AgentMutation) SetArch(s string) {
	m.arch = &s
}

// Arch returns the value of the "arch" field in the mutation.
func (m *AgentMutation) Arch() (r string, exists bool) {
	v := m.arch
	if v == nil {
		return
	}
	return *v, true
}

// OldArch returns the old "arch" field's value of the Agent entity.
// If the Agent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentMutation) OldArch(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldArch is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldArch requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldArch: %w", err)
	}
	return oldValue.Arch, nil
}

// ResetArch resets all changes to the "arch" field.
func (m *AgentMutation) ResetArch() {
	m.arch = nil
}

// SetIP sets the "ip" field.
func (m *AgentMutation) SetIP(s string) {
	m.ip = &s
}

// IP returns the value of the "ip" field in the mutation.
func (m *AgentMutation) IP() (r string, exists bool) {
	v := m.ip
	if v == nil {
		return
	}
	return *v, true
}

// OldIP returns the old "ip" field's value of the Agent entity.
// If the Agent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentMutation) OldIP(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIP is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIP requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIP: %w", err)
	}
	return oldValue.IP, nil
}

// ResetIP resets all changes to the "ip" field.
func (m *AgentMutation) ResetIP() {
	m.ip = nil
}

// SetMAC sets the "mac" field.
func (m *AgentMutation) SetMAC(s string) {
	m.mac = &s
}

// MAC returns the value of the "mac" field in the mutation.
func (m *AgentMutation) MAC() (r string, exists bool) {
	v := m.mac
	if v == nil {
		return
	}
	return *v, true
}

// OldMAC returns the old "mac" field's value of the Agent entity.
// If the Agent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentMutation) OldMAC(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMAC is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMAC requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMAC: %w", err)
	}
	return oldValue.MAC, nil
}

// ResetMAC resets all changes to the "mac" field.
func (m *AgentMutation) ResetMAC() {
	m.mac = nil
}

// SetVersion sets the "version" field.
func (m *AgentMutation) SetVersion(s string) {
	m.version = &s
}

// Version returns the value of the "version" field in the mutation.
func (m *AgentMutation) Version() (r string, exists bool) {
	v := m.version
	if v == nil {
		return
	}
	return *v, true
}

// OldVersion returns the old "version" field's value of the Agent entity.
// If the Agent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentMutation) OldVersion(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVersion: %w", err)
	}
	return oldValue.Version, nil
}

// ResetVersion resets all changes to the "version" field.
func (m *AgentMutation) ResetVersion() {
	m.version = nil
}

// SetStatus sets the "status" field.
func (m *AgentMutation) SetStatus(a agent.Status) {
	m.status = &a
}

// Status returns the value of the "status" field in the mutation.
func (m *AgentMutation) Status() (r agent.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Agent entity.
// If the Agent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentMutation) OldStatus(ctx context.Context) (v agent.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *AgentMutation) ResetStatus() {
	m.status = nil
}

// SetLastSeen sets the "last_seen" field.
func (m *AgentMutation) SetLastSeen(t time.Time) {
	m.last_seen = &t
}

// LastSeen returns the value of the "last_seen" field in the mutation.
func (m *AgentMutation) LastSeen() (r time.Time, exists bool) {
	v := m.last_seen
	if v == nil {
		return
	}
	return *v, true
}

// OldLastSeen returns the old "last_seen" field's value of the Agent entity.
// If the Agent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentMutation) OldLastSeen(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastSeen is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastSeen requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastSeen: %w", err)
	}
	return oldValue.LastSeen, nil
}

// ResetLastSeen resets all changes to the "last_seen" field.
func (m *AgentMutation) ResetLastSeen() {
	m.last_seen = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *AgentMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AgentMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Agent entity.
// If the Agent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AgentMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AgentMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AgentMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Agent entity.
// If the Agent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AgentMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetTenantID sets the "tenant" edge to the Tenant entity by id.
func (m *AgentMutation) SetTenantID(id int) {
	m.tenant = &id
}

// ClearTenant clears the "tenant" edge to the Tenant entity.
func (m *AgentMutation) ClearTenant() {
	m.clearedtenant = true
}

// TenantCleared reports if the "tenant" edge to the Tenant entity was cleared.
func (m *AgentMutation) TenantCleared() bool {
	return m.clearedtenant
}

// TenantID returns the "tenant" edge ID in the mutation.
func (m *AgentMutation) TenantID() (id int, exists bool) {
	if m.tenant != nil {
		return *m.tenant, true
	}
	return
}

// TenantIDs returns the "tenant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TenantID instead. It exists only for internal usage by the builders.
func (m *AgentMutation) TenantIDs() (ids []int) {
	if id := m.tenant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTenant resets all changes to the "tenant" edge.
func (m *AgentMutation) ResetTenant() {
	m.tenant = nil
	m.clearedtenant = false
}

// Where appends a list predicates to the AgentMutation builder.
func (m *AgentMutation) Where(ps ...predicate.Agent) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AgentMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AgentMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Agent, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AgentMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AgentMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Agent).
func (m *AgentMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AgentMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.hostname != nil {
		fields = append(fields, agent.FieldHostname)
	}
	if m.os != nil {
		fields = append(fields, agent.FieldOs)
	}
	if m.arch != nil {
		fields = append(fields, agent.FieldArch)
	}
	if m.ip != nil {
		fields = append(fields, agent.FieldIP)
	}
	if m.mac != nil {
		fields = append(fields, agent.FieldMAC)
	}
	if m.version != nil {
		fields = append(fields, agent.FieldVersion)
	}
	if m.status != nil {
		fields = append(fields, agent.FieldStatus)
	}
	if m.last_seen != nil {
		fields = append(fields, agent.FieldLastSeen)
	}
	if m.created_at != nil {
		fields = append(fields, agent.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, agent.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AgentMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case agent.FieldHostname:
		return m.Hostname()
	case agent.FieldOs:
		return m.Os()
	case agent.FieldArch:
		return m.Arch()
	case agent.FieldIP:
		return m.IP()
	case agent.FieldMAC:
		return m.MAC()
	case agent.FieldVersion:
		return m.Version()
	case agent.FieldStatus:
		return m.Status()
	case agent.FieldLastSeen:
		return m.LastSeen()
	case agent.FieldCreatedAt:
		return m.CreatedAt()
	case agent.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AgentMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case agent.FieldHostname:
		return m.OldHostname(ctx)
	case agent.FieldOs:
		return m.OldOs(ctx)
	case agent.FieldArch:
		return m.OldArch(ctx)
	case agent.FieldIP:
		return m.OldIP(ctx)
	case agent.FieldMAC:
		return m.OldMAC(ctx)
	case agent.FieldVersion:
		return m.OldVersion(ctx)
	case agent.FieldStatus:
		return m.OldStatus(ctx)
	case agent.FieldLastSeen:
		return m.OldLastSeen(ctx)
	case agent.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case agent.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Agent field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AgentMutation) SetField(name string, value ent.Value) error {
	switch name {
	case agent.FieldHostname:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHostname(v)
		return nil
	case agent.FieldOs:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOs(v)
		return nil
	case agent.FieldArch:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetArch(v)
		return nil
	case agent.FieldIP:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIP(v)
		return nil
	case agent.FieldMAC:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMAC(v)
		return nil
	case agent.FieldVersion:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVersion(v)
		return nil
	case agent.FieldStatus:
		v, ok := value.(agent.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case agent.FieldLastSeen:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastSeen(v)
		return nil
	case agent.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case agent.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Agent field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AgentMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AgentMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AgentMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Agent numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AgentMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AgentMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AgentMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Agent nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AgentMutation) ResetField(name string) error {
	switch name {
	case agent.FieldHostname:
		m.ResetHostname()
		return nil
	case agent.FieldOs:
		m.ResetOs()
		return nil
	case agent.FieldArch:
		m.ResetArch()
		return nil
	case agent.FieldIP:
		m.ResetIP()
		return nil
	case agent.FieldMAC:
		m.ResetMAC()
		return nil
	case agent.FieldVersion:
		m.ResetVersion()
		return nil
	case agent.FieldStatus:
		m.ResetStatus()
		return nil
	case agent.FieldLastSeen:
		m.ResetLastSeen()
		return nil
	case agent.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case agent.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Agent field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AgentMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.tenant != nil {
		edges = append(edges, agent.EdgeTenant)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AgentMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case agent.EdgeTenant:
		if id := m.tenant; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AgentMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AgentMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AgentMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedtenant {
		edges = append(edges, agent.EdgeTenant)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AgentMutation) EdgeCleared(name string) bool {
	switch name {
	case agent.EdgeTenant:
		return m.clearedtenant
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AgentMutation) ClearEdge(name string) error {
	switch name {
	case agent.EdgeTenant:
		m.ClearTenant()
		return nil
	}
	return fmt.Errorf("unknown Agent unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AgentMutation) ResetEdge(name string) error {
	switch name {
	case agent.EdgeTenant:
		m.ResetTenant()
		return nil
	}
	return fmt.Errorf("unknown Agent edge %s", name)
}

// AssetMutation represents an operation that mutates the Asset nodes in the graph.
type AssetMutation struct {
	config
	op                   Op
	typ                  string
	id                   *int
	name                 *string
	hardware_id          *string
	serial_number        *string
	manufacturer         *string
	vendor_support_phone *string
	status               *asset.Status
	metadata             *map[string]interface{}
	last_certified_at    *time.Time
	created_at           *time.Time
	updated_at           *time.Time
	clearedFields        map[string]struct{}
	tenant               *int
	clearedtenant        bool
	_type                *int
	cleared_type         bool
	hosted_at            *int
	clearedhosted_at     bool
	hosted_assets        map[int]struct{}
	removedhosted_assets map[int]struct{}
	clearedhosted_assets bool
	dependency_of        map[int]struct{}
	removeddependency_of map[int]struct{}
	cleareddependency_of bool
	depends_on           map[int]struct{}
	removeddepends_on    map[int]struct{}
	cleareddepends_on    bool
	owner                *int
	clearedowner         bool
	credentials          map[int]struct{}
	removedcredentials   map[int]struct{}
	clearedcredentials   bool
	sops                 map[int]struct{}
	removedsops          map[int]struct{}
	clearedsops          bool
	tickets              map[int]struct{}
	removedtickets       map[int]struct{}
	clearedtickets       bool
	product              *int
	clearedproduct       bool
	done                 bool
	oldValue             func(context.Context) (*Asset, error)
	predicates           []predicate.Asset
}

var _ ent.Mutation = (*AssetMutation)(nil)

// assetOption allows management of the mutation configuration using functional options.
type assetOption func(*AssetMutation)

// newAssetMutation creates new mutation for the Asset entity.
func newAssetMutation(c config, op Op, opts ...assetOption) *AssetMutation {
	m := &AssetMutation{
		config:        c,
		op:            op,
		typ:           TypeAsset,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAssetID sets the ID field of the mutation.
func withAssetID(id int) assetOption {
	return func(m *AssetMutation) {
		var (
			err   error
			once  sync.Once
			value *Asset
		)
		m.oldValue = func(ctx context.Context) (*Asset, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Asset.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAsset sets the old Asset of the mutation.
func withAsset(node *Asset) assetOption {
	return func(m *AssetMutation) {
		m.oldValue = func(context.Context) (*Asset, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AssetMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AssetMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AssetMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AssetMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Asset.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *AssetMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *AssetMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Asset entity.
// If the Asset object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AssetMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *AssetMutation) ResetName() {
	m.name = nil
}

// SetHardwareID sets the "hardware_id" field.
func (m *AssetMutation) SetHardwareID(s string) {
	m.hardware_id = &s
}

// HardwareID returns the value of the "hardware_id" field in the mutation.
func (m *AssetMutation) HardwareID() (r string, exists bool) {
	v := m.hardware_id
	if v == nil {
		return
	}
	return *v, true
}

// OldHardwareID returns the old "hardware_id" field's value of the Asset entity.
// If the Asset object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AssetMutation) OldHardwareID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHardwareID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHardwareID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHardwareID: %w", err)
	}
	return oldValue.HardwareID, nil
}

// ClearHardwareID clears the value of the "hardware_id" field.
func (m *AssetMutation) ClearHardwareID() {
	m.hardware_id = nil
	m.clearedFields[asset.FieldHardwareID] = struct{}{}
}

// HardwareIDCleared returns if the "hardware_id" field was cleared in this mutation.
func (m *AssetMutation) HardwareIDCleared() bool {
	_, ok := m.clearedFields[asset.FieldHardwareID]
	return ok
}

// ResetHardwareID resets all changes to the "hardware_id" field.
func (m *AssetMutation) ResetHardwareID() {
	m.hardware_id = nil
	delete(m.clearedFields, asset.FieldHardwareID)
}

// SetSerialNumber sets the "serial_number" field.
func (m *AssetMutation) SetSerialNumber(s string) {
	m.serial_number = &s
}

// SerialNumber returns the value of the "serial_number" field in the mutation.
func (m *AssetMutation) SerialNumber() (r string, exists bool) {
	v := m.serial_number
	if v == nil {
		return
	}
	return *v, true
}

// OldSerialNumber returns the old "serial_number" field's value of the Asset entity.
// If the Asset object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AssetMutation) OldSerialNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSerialNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSerialNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSerialNumber: %w", err)
	}
	return oldValue.SerialNumber, nil
}

// ClearSerialNumber clears the value of the "serial_number" field.
func (m *AssetMutation) ClearSerialNumber() {
	m.serial_number = nil
	m.clearedFields[asset.FieldSerialNumber] = struct{}{}
}

// SerialNumberCleared returns if the "serial_number" field was cleared in this mutation.
func (m *AssetMutation) SerialNumberCleared() bool {
	_, ok := m.clearedFields[asset.FieldSerialNumber]
	return ok
}

// ResetSerialNumber resets all changes to the "serial_number" field.
func (m *AssetMutation) ResetSerialNumber() {
	m.serial_number = nil
	delete(m.clearedFields, asset.FieldSerialNumber)
}

// SetManufacturer sets the "manufacturer" field.
func (m *AssetMutation) SetManufacturer(s string) {
	m.manufacturer = &s
}

// Manufacturer returns the value of the "manufacturer" field in the mutation.
func (m *AssetMutation) Manufacturer() (r string, exists bool) {
	v := m.manufacturer
	if v == nil {
		return
	}
	return *v, true
}

// OldManufacturer returns the old "manufacturer" field's value of the Asset entity.
// If the Asset object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AssetMutation) OldManufacturer(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldManufacturer is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldManufacturer requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldManufacturer: %w", err)
	}
	return oldValue.Manufacturer, nil
}

// ClearManufacturer clears the value of the "manufacturer" field.
func (m *AssetMutation) ClearManufacturer() {
	m.manufacturer = nil
	m.clearedFields[asset.FieldManufacturer] = struct{}{}
}

// ManufacturerCleared returns if the "manufacturer" field was cleared in this mutation.
func (m *AssetMutation) ManufacturerCleared() bool {
	_, ok := m.clearedFields[asset.FieldManufacturer]
	return ok
}

// ResetManufacturer resets all changes to the "manufacturer" field.
func (m *AssetMutation) ResetManufacturer() {
	m.manufacturer = nil
	delete(m.clearedFields, asset.FieldManufacturer)
}

// SetVendorSupportPhone sets the "vendor_support_phone" field.
func (m *AssetMutation) SetVendorSupportPhone(s string) {
	m.vendor_support_phone = &s
}

// VendorSupportPhone returns the value of the "vendor_support_phone" field in the mutation.
func (m *AssetMutation) VendorSupportPhone() (r string, exists bool) {
	v := m.vendor_support_phone
	if v == nil {
		return
	}
	return *v, true
}

// OldVendorSupportPhone returns the old "vendor_support_phone" field's value of the Asset entity.
// If the Asset object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AssetMutation) OldVendorSupportPhone(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVendorSupportPhone is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVendorSupportPhone requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVendorSupportPhone: %w", err)
	}
	return oldValue.VendorSupportPhone, nil
}

// ClearVendorSupportPhone clears the value of the "vendor_support_phone" field.
func (m *AssetMutation) ClearVendorSupportPhone() {
	m.vendor_support_phone = nil
	m.clearedFields[asset.FieldVendorSupportPhone] = struct{}{}
}

// VendorSupportPhoneCleared returns if the "vendor_support_phone" field was cleared in this mutation.
func (m *AssetMutation) VendorSupportPhoneCleared() bool {
	_, ok := m.clearedFields[asset.FieldVendorSupportPhone]
	return ok
}

// ResetVendorSupportPhone resets all changes to the "vendor_support_phone" field.
func (m *AssetMutation) ResetVendorSupportPhone() {
	m.vendor_support_phone = nil
	delete(m.clearedFields, asset.FieldVendorSupportPhone)
}

// SetStatus sets the "status" field.
func (m *AssetMutation) SetStatus(a asset.Status) {
	m.status = &a
}

// Status returns the value of the "status" field in the mutation.
func (m *AssetMutation) Status() (r asset.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Asset entity.
// If the Asset object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AssetMutation) OldStatus(ctx context.Context) (v asset.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *AssetMutation) ResetStatus() {
	m.status = nil
}

// SetMetadata sets the "metadata" field.
func (m *AssetMutation) SetMetadata(value map[string]interface{}) {
	m.metadata = &value
}

// Metadata returns the value of the "metadata" field in the mutation.
func (m *AssetMutation) Metadata() (r map[string]interface{}, exists bool) {
	v := m.metadata
	if v == nil {
		return
	}
	return *v, true
}

// OldMetadata returns the old "metadata" field's value of the Asset entity.
// If the Asset object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AssetMutation) OldMetadata(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMetadata is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMetadata requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetadata: %w", err)
	}
	return oldValue.Metadata, nil
}

// ResetMetadata resets all changes to the "metadata" field.
func (m *AssetMutation) ResetMetadata() {
	m.metadata = nil
}

// SetLastCertifiedAt sets the "last_certified_at" field.
func (m *AssetMutation) SetLastCertifiedAt(t time.Time) {
	m.last_certified_at = &t
}

// LastCertifiedAt returns the value of the "last_certified_at" field in the mutation.
func (m *AssetMutation) LastCertifiedAt() (r time.Time, exists bool) {
	v := m.last_certified_at
	if v == nil {
		return
	}
	return *v, true
}

// OldLastCertifiedAt returns the old "last_certified_at" field's value of the Asset entity.
// If the Asset object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AssetMutation) OldLastCertifiedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastCertifiedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastCertifiedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastCertifiedAt: %w", err)
	}
	return oldValue.LastCertifiedAt, nil
}

// ClearLastCertifiedAt clears the value of the "last_certified_at" field.
func (m *AssetMutation) ClearLastCertifiedAt() {
	m.last_certified_at = nil
	m.clearedFields[asset.FieldLastCertifiedAt] = struct{}{}
}

// LastCertifiedAtCleared returns if the "last_certified_at" field was cleared in this mutation.
func (m *AssetMutation) LastCertifiedAtCleared() bool {
	_, ok := m.clearedFields[asset.FieldLastCertifiedAt]
	return ok
}

// ResetLastCertifiedAt resets all changes to the "last_certified_at" field.
func (m *AssetMutation) ResetLastCertifiedAt() {
	m.last_certified_at = nil
	delete(m.clearedFields, asset.FieldLastCertifiedAt)
}

// SetCreatedAt sets the "created_at" field.
func (m *AssetMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AssetMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Asset entity.
// If the Asset object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AssetMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AssetMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AssetMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AssetMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Asset entity.
// If the Asset object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AssetMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AssetMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetTenantID sets the "tenant" edge to the Tenant entity by id.
func (m *AssetMutation) SetTenantID(id int) {
	m.tenant = &id
}

// ClearTenant clears the "tenant" edge to the Tenant entity.
func (m *AssetMutation) ClearTenant() {
	m.clearedtenant = true
}

// TenantCleared reports if the "tenant" edge to the Tenant entity was cleared.
func (m *AssetMutation) TenantCleared() bool {
	return m.clearedtenant
}

// TenantID returns the "tenant" edge ID in the mutation.
func (m *AssetMutation) TenantID() (id int, exists bool) {
	if m.tenant != nil {
		return *m.tenant, true
	}
	return
}

// TenantIDs returns the "tenant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TenantID instead. It exists only for internal usage by the builders.
func (m *AssetMutation) TenantIDs() (ids []int) {
	if id := m.tenant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTenant resets all changes to the "tenant" edge.
func (m *AssetMutation) ResetTenant() {
	m.tenant = nil
	m.clearedtenant = false
}

// SetTypeID sets the "type" edge to the AssetType entity by id.
func (m *AssetMutation) SetTypeID(id int) {
	m._type = &id
}

// ClearType clears the "type" edge to the AssetType entity.
func (m *AssetMutation) ClearType() {
	m.cleared_type = true
}

// TypeCleared reports if the "type" edge to the AssetType entity was cleared.
func (m *AssetMutation) TypeCleared() bool {
	return m.cleared_type
}

// TypeID returns the "type" edge ID in the mutation.
func (m *AssetMutation) TypeID() (id int, exists bool) {
	if m._type != nil {
		return *m._type, true
	}
	return
}

// TypeIDs returns the "type" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TypeID instead. It exists only for internal usage by the builders.
func (m *AssetMutation) TypeIDs() (ids []int) {
	if id := m._type; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetType resets all changes to the "type" edge.
func (m *AssetMutation) ResetType() {
	m._type = nil
	m.cleared_type = false
}

// SetHostedAtID sets the "hosted_at" edge to the Asset entity by id.
func (m *AssetMutation) SetHostedAtID(id int) {
	m.hosted_at = &id
}

// ClearHostedAt clears the "hosted_at" edge to the Asset entity.
func (m *AssetMutation) ClearHostedAt() {
	m.clearedhosted_at = true
}

// HostedAtCleared reports if the "hosted_at" edge to the Asset entity was cleared.
func (m *AssetMutation) HostedAtCleared() bool {
	return m.clearedhosted_at
}

// HostedAtID returns the "hosted_at" edge ID in the mutation.
func (m *AssetMutation) HostedAtID() (id int, exists bool) {
	if m.hosted_at != nil {
		return *m.hosted_at, true
	}
	return
}

// HostedAtIDs returns the "hosted_at" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// HostedAtID instead. It exists only for internal usage by the builders.
func (m *AssetMutation) HostedAtIDs() (ids []int) {
	if id := m.hosted_at; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetHostedAt resets all changes to the "hosted_at" edge.
func (m *AssetMutation) ResetHostedAt() {
	m.hosted_at = nil
	m.clearedhosted_at = false
}

// AddHostedAssetIDs adds the "hosted_assets" edge to the Asset entity by ids.
func (m *AssetMutation) AddHostedAssetIDs(ids ...int) {
	if m.hosted_assets == nil {
		m.hosted_assets = make(map[int]struct{})
	}
	for i := range ids {
		m.hosted_assets[ids[i]] = struct{}{}
	}
}

// ClearHostedAssets clears the "hosted_assets" edge to the Asset entity.
func (m *AssetMutation) ClearHostedAssets() {
	m.clearedhosted_assets = true
}

// HostedAssetsCleared reports if the "hosted_assets" edge to the Asset entity was cleared.
func (m *AssetMutation) HostedAssetsCleared() bool {
	return m.clearedhosted_assets
}

// RemoveHostedAssetIDs removes the "hosted_assets" edge to the Asset entity by IDs.
func (m *AssetMutation) RemoveHostedAssetIDs(ids ...int) {
	if m.removedhosted_assets == nil {
		m.removedhosted_assets = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.hosted_assets, ids[i])
		m.removedhosted_assets[ids[i]] = struct{}{}
	}
}

// RemovedHostedAssets returns the removed IDs of the "hosted_assets" edge to the Asset entity.
func (m *AssetMutation) RemovedHostedAssetsIDs() (ids []int) {
	for id := range m.removedhosted_assets {
		ids = append(ids, id)
	}
	return
}

// HostedAssetsIDs returns the "hosted_assets" edge IDs in the mutation.
func (m *AssetMutation) HostedAssetsIDs() (ids []int) {
	for id := range m.hosted_assets {
		ids = append(ids, id)
	}
	return
}

// ResetHostedAssets resets all changes to the "hosted_assets" edge.
func (m *AssetMutation) ResetHostedAssets() {
	m.hosted_assets = nil
	m.clearedhosted_assets = false
	m.removedhosted_assets = nil
}

// AddDependencyOfIDs adds the "dependency_of" edge to the Asset entity by ids.
func (m *AssetMutation) AddDependencyOfIDs(ids ...int) {
	if m.dependency_of == nil {
		m.dependency_of = make(map[int]struct{})
	}
	for i := range ids {
		m.dependency_of[ids[i]] = struct{}{}
	}
}

// ClearDependencyOf clears the "dependency_of" edge to the Asset entity.
func (m *AssetMutation) ClearDependencyOf() {
	m.cleareddependency_of = true
}

// DependencyOfCleared reports if the "dependency_of" edge to the Asset entity was cleared.
func (m *AssetMutation) DependencyOfCleared() bool {
	return m.cleareddependency_of
}

// RemoveDependencyOfIDs removes the "dependency_of" edge to the Asset entity by IDs.
func (m *AssetMutation) RemoveDependencyOfIDs(ids ...int) {
	if m.removeddependency_of == nil {
		m.removeddependency_of = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.dependency_of, ids[i])
		m.removeddependency_of[ids[i]] = struct{}{}
	}
}

// RemovedDependencyOf returns the removed IDs of the "dependency_of" edge to the Asset entity.
func (m *AssetMutation) RemovedDependencyOfIDs() (ids []int) {
	for id := range m.removeddependency_of {
		ids = append(ids, id)
	}
	return
}

// DependencyOfIDs returns the "dependency_of" edge IDs in the mutation.
func (m *AssetMutation) DependencyOfIDs() (ids []int) {
	for id := range m.dependency_of {
		ids = append(ids, id)
	}
	return
}

// ResetDependencyOf resets all changes to the "dependency_of" edge.
func (m *AssetMutation) ResetDependencyOf() {
	m.dependency_of = nil
	m.cleareddependency_of = false
	m.removeddependency_of = nil
}

// AddDependsOnIDs adds the "depends_on" edge to the Asset entity by ids.
func (m *AssetMutation) AddDependsOnIDs(ids ...int) {
	if m.depends_on == nil {
		m.depends_on = make(map[int]struct{})
	}
	for i := range ids {
		m.depends_on[ids[i]] = struct{}{}
	}
}

// ClearDependsOn clears the "depends_on" edge to the Asset entity.
func (m *AssetMutation) ClearDependsOn() {
	m.cleareddepends_on = true
}

// DependsOnCleared reports if the "depends_on" edge to the Asset entity was cleared.
func (m *AssetMutation) DependsOnCleared() bool {
	return m.cleareddepends_on
}

// RemoveDependsOnIDs removes the "depends_on" edge to the Asset entity by IDs.
func (m *AssetMutation) RemoveDependsOnIDs(ids ...int) {
	if m.removeddepends_on == nil {
		m.removeddepends_on = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.depends_on, ids[i])
		m.removeddepends_on[ids[i]] = struct{}{}
	}
}

// RemovedDependsOn returns the removed IDs of the "depends_on" edge to the Asset entity.
func (m *AssetMutation) RemovedDependsOnIDs() (ids []int) {
	for id := range m.removeddepends_on {
		ids = append(ids, id)
	}
	return
}

// DependsOnIDs returns the "depends_on" edge IDs in the mutation.
func (m *AssetMutation) DependsOnIDs() (ids []int) {
	for id := range m.depends_on {
		ids = append(ids, id)
	}
	return
}

// ResetDependsOn resets all changes to the "depends_on" edge.
func (m *AssetMutation) ResetDependsOn() {
	m.depends_on = nil
	m.cleareddepends_on = false
	m.removeddepends_on = nil
}

// SetOwnerID sets the "owner" edge to the User entity by id.
func (m *AssetMutation) SetOwnerID(id int) {
	m.owner = &id
}

// ClearOwner clears the "owner" edge to the User entity.
func (m *AssetMutation) ClearOwner() {
	m.clearedowner = true
}

// OwnerCleared reports if the "owner" edge to the User entity was cleared.
func (m *AssetMutation) OwnerCleared() bool {
	return m.clearedowner
}

// OwnerID returns the "owner" edge ID in the mutation.
func (m *AssetMutation) OwnerID() (id int, exists bool) {
	if m.owner != nil {
		return *m.owner, true
	}
	return
}

// OwnerIDs returns the "owner" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OwnerID instead. It exists only for internal usage by the builders.
func (m *AssetMutation) OwnerIDs() (ids []int) {
	if id := m.owner; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOwner resets all changes to the "owner" edge.
func (m *AssetMutation) ResetOwner() {
	m.owner = nil
	m.clearedowner = false
}

// AddCredentialIDs adds the "credentials" edge to the Credential entity by ids.
func (m *AssetMutation) AddCredentialIDs(ids ...int) {
	if m.credentials == nil {
		m.credentials = make(map[int]struct{})
	}
	for i := range ids {
		m.credentials[ids[i]] = struct{}{}
	}
}

// ClearCredentials clears the "credentials" edge to the Credential entity.
func (m *AssetMutation) ClearCredentials() {
	m.clearedcredentials = true
}

// CredentialsCleared reports if the "credentials" edge to the Credential entity was cleared.
func (m *AssetMutation) CredentialsCleared() bool {
	return m.clearedcredentials
}

// RemoveCredentialIDs removes the "credentials" edge to the Credential entity by IDs.
func (m *AssetMutation) RemoveCredentialIDs(ids ...int) {
	if m.removedcredentials == nil {
		m.removedcredentials = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.credentials, ids[i])
		m.removedcredentials[ids[i]] = struct{}{}
	}
}

// RemovedCredentials returns the removed IDs of the "credentials" edge to the Credential entity.
func (m *AssetMutation) RemovedCredentialsIDs() (ids []int) {
	for id := range m.removedcredentials {
		ids = append(ids, id)
	}
	return
}

// CredentialsIDs returns the "credentials" edge IDs in the mutation.
func (m *AssetMutation) CredentialsIDs() (ids []int) {
	for id := range m.credentials {
		ids = append(ids, id)
	}
	return
}

// ResetCredentials resets all changes to the "credentials" edge.
func (m *AssetMutation) ResetCredentials() {
	m.credentials = nil
	m.clearedcredentials = false
	m.removedcredentials = nil
}

// AddSopIDs adds the "sops" edge to the SOP entity by ids.
func (m *AssetMutation) AddSopIDs(ids ...int) {
	if m.sops == nil {
		m.sops = make(map[int]struct{})
	}
	for i := range ids {
		m.sops[ids[i]] = struct{}{}
	}
}

// ClearSops clears the "sops" edge to the SOP entity.
func (m *AssetMutation) ClearSops() {
	m.clearedsops = true
}

// SopsCleared reports if the "sops" edge to the SOP entity was cleared.
func (m *AssetMutation) SopsCleared() bool {
	return m.clearedsops
}

// RemoveSopIDs removes the "sops" edge to the SOP entity by IDs.
func (m *AssetMutation) RemoveSopIDs(ids ...int) {
	if m.removedsops == nil {
		m.removedsops = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.sops, ids[i])
		m.removedsops[ids[i]] = struct{}{}
	}
}

// RemovedSops returns the removed IDs of the "sops" edge to the SOP entity.
func (m *AssetMutation) RemovedSopsIDs() (ids []int) {
	for id := range m.removedsops {
		ids = append(ids, id)
	}
	return
}

// SopsIDs returns the "sops" edge IDs in the mutation.
func (m *AssetMutation) SopsIDs() (ids []int) {
	for id := range m.sops {
		ids = append(ids, id)
	}
	return
}

// ResetSops resets all changes to the "sops" edge.
func (m *AssetMutation) ResetSops() {
	m.sops = nil
	m.clearedsops = false
	m.removedsops = nil
}

// AddTicketIDs adds the "tickets" edge to the Ticket entity by ids.
func (m *AssetMutation) AddTicketIDs(ids ...int) {
	if m.tickets == nil {
		m.tickets = make(map[int]struct{})
	}
	for i := range ids {
		m.tickets[ids[i]] = struct{}{}
	}
}

// ClearTickets clears the "tickets" edge to the Ticket entity.
func (m *AssetMutation) ClearTickets() {
	m.clearedtickets = true
}

// TicketsCleared reports if the "tickets" edge to the Ticket entity was cleared.
func (m *AssetMutation) TicketsCleared() bool {
	return m.clearedtickets
}

// RemoveTicketIDs removes the "tickets" edge to the Ticket entity by IDs.
func (m *AssetMutation) RemoveTicketIDs(ids ...int) {
	if m.removedtickets == nil {
		m.removedtickets = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.tickets, ids[i])
		m.removedtickets[ids[i]] = struct{}{}
	}
}

// RemovedTickets returns the removed IDs of the "tickets" edge to the Ticket entity.
func (m *AssetMutation) RemovedTicketsIDs() (ids []int) {
	for id := range m.removedtickets {
		ids = append(ids, id)
	}
	return
}

// TicketsIDs returns the "tickets" edge IDs in the mutation.
func (m *AssetMutation) TicketsIDs() (ids []int) {
	for id := range m.tickets {
		ids = append(ids, id)
	}
	return
}

// ResetTickets resets all changes to the "tickets" edge.
func (m *AssetMutation) ResetTickets() {
	m.tickets = nil
	m.clearedtickets = false
	m.removedtickets = nil
}

// SetProductID sets the "product" edge to the Product entity by id.
func (m *AssetMutation) SetProductID(id int) {
	m.product = &id
}

// ClearProduct clears the "product" edge to the Product entity.
func (m *AssetMutation) ClearProduct() {
	m.clearedproduct = true
}

// ProductCleared reports if the "product" edge to the Product entity was cleared.
func (m *AssetMutation) ProductCleared() bool {
	return m.clearedproduct
}

// ProductID returns the "product" edge ID in the mutation.
func (m *AssetMutation) ProductID() (id int, exists bool) {
	if m.product != nil {
		return *m.product, true
	}
	return
}

// ProductIDs returns the "product" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProductID instead. It exists only for internal usage by the builders.
func (m *AssetMutation) ProductIDs() (ids []int) {
	if id := m.product; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProduct resets all changes to the "product" edge.
func (m *AssetMutation) ResetProduct() {
	m.product = nil
	m.clearedproduct = false
}

// Where appends a list predicates to the AssetMutation builder.
func (m *AssetMutation) Where(ps ...predicate.Asset) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AssetMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AssetMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Asset, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AssetMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AssetMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Asset).
func (m *AssetMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AssetMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.name != nil {
		fields = append(fields, asset.FieldName)
	}
	if m.hardware_id != nil {
		fields = append(fields, asset.FieldHardwareID)
	}
	if m.serial_number != nil {
		fields = append(fields, asset.FieldSerialNumber)
	}
	if m.manufacturer != nil {
		fields = append(fields, asset.FieldManufacturer)
	}
	if m.vendor_support_phone != nil {
		fields = append(fields, asset.FieldVendorSupportPhone)
	}
	if m.status != nil {
		fields = append(fields, asset.FieldStatus)
	}
	if m.metadata != nil {
		fields = append(fields, asset.FieldMetadata)
	}
	if m.last_certified_at != nil {
		fields = append(fields, asset.FieldLastCertifiedAt)
	}
	if m.created_at != nil {
		fields = append(fields, asset.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, asset.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AssetMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case asset.FieldName:
		return m.Name()
	case asset.FieldHardwareID:
		return m.HardwareID()
	case asset.FieldSerialNumber:
		return m.SerialNumber()
	case asset.FieldManufacturer:
		return m.Manufacturer()
	case asset.FieldVendorSupportPhone:
		return m.VendorSupportPhone()
	case asset.FieldStatus:
		return m.Status()
	case asset.FieldMetadata:
		return m.Metadata()
	case asset.FieldLastCertifiedAt:
		return m.LastCertifiedAt()
	case asset.FieldCreatedAt:
		return m.CreatedAt()
	case asset.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AssetMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case asset.FieldName:
		return m.OldName(ctx)
	case asset.FieldHardwareID:
		return m.OldHardwareID(ctx)
	case asset.FieldSerialNumber:
		return m.OldSerialNumber(ctx)
	case asset.FieldManufacturer:
		return m.OldManufacturer(ctx)
	case asset.FieldVendorSupportPhone:
		return m.OldVendorSupportPhone(ctx)
	case asset.FieldStatus:
		return m.OldStatus(ctx)
	case asset.FieldMetadata:
		return m.OldMetadata(ctx)
	case asset.FieldLastCertifiedAt:
		return m.OldLastCertifiedAt(ctx)
	case asset.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case asset.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Asset field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AssetMutation) SetField(name string, value ent.Value) error {
	switch name {
	case asset.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case asset.FieldHardwareID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHardwareID(v)
		return nil
	case asset.FieldSerialNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSerialNumber(v)
		return nil
	case asset.FieldManufacturer:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetManufacturer(v)
		return nil
	case asset.FieldVendorSupportPhone:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVendorSupportPhone(v)
		return nil
	case asset.FieldStatus:
		v, ok := value.(asset.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case asset.FieldMetadata:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetadata(v)
		return nil
	case asset.FieldLastCertifiedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastCertifiedAt(v)
		return nil
	case asset.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case asset.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Asset field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AssetMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AssetMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AssetMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Asset numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AssetMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(asset.FieldHardwareID) {
		fields = append(fields, asset.FieldHardwareID)
	}
	if m.FieldCleared(asset.FieldSerialNumber) {
		fields = append(fields, asset.FieldSerialNumber)
	}
	if m.FieldCleared(asset.FieldManufacturer) {
		fields = append(fields, asset.FieldManufacturer)
	}
	if m.FieldCleared(asset.FieldVendorSupportPhone) {
		fields = append(fields, asset.FieldVendorSupportPhone)
	}
	if m.FieldCleared(asset.FieldLastCertifiedAt) {
		fields = append(fields, asset.FieldLastCertifiedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AssetMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AssetMutation) ClearField(name string) error {
	switch name {
	case asset.FieldHardwareID:
		m.ClearHardwareID()
		return nil
	case asset.FieldSerialNumber:
		m.ClearSerialNumber()
		return nil
	case asset.FieldManufacturer:
		m.ClearManufacturer()
		return nil
	case asset.FieldVendorSupportPhone:
		m.ClearVendorSupportPhone()
		return nil
	case asset.FieldLastCertifiedAt:
		m.ClearLastCertifiedAt()
		return nil
	}
	return fmt.Errorf("unknown Asset nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AssetMutation) ResetField(name string) error {
	switch name {
	case asset.FieldName:
		m.ResetName()
		return nil
	case asset.FieldHardwareID:
		m.ResetHardwareID()
		return nil
	case asset.FieldSerialNumber:
		m.ResetSerialNumber()
		return nil
	case asset.FieldManufacturer:
		m.ResetManufacturer()
		return nil
	case asset.FieldVendorSupportPhone:
		m.ResetVendorSupportPhone()
		return nil
	case asset.FieldStatus:
		m.ResetStatus()
		return nil
	case asset.FieldMetadata:
		m.ResetMetadata()
		return nil
	case asset.FieldLastCertifiedAt:
		m.ResetLastCertifiedAt()
		return nil
	case asset.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case asset.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Asset field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AssetMutation) AddedEdges() []string {
	edges := make([]string, 0, 11)
	if m.tenant != nil {
		edges = append(edges, asset.EdgeTenant)
	}
	if m._type != nil {
		edges = append(edges, asset.EdgeType)
	}
	if m.hosted_at != nil {
		edges = append(edges, asset.EdgeHostedAt)
	}
	if m.hosted_assets != nil {
		edges = append(edges, asset.EdgeHostedAssets)
	}
	if m.dependency_of != nil {
		edges = append(edges, asset.EdgeDependencyOf)
	}
	if m.depends_on != nil {
		edges = append(edges, asset.EdgeDependsOn)
	}
	if m.owner != nil {
		edges = append(edges, asset.EdgeOwner)
	}
	if m.credentials != nil {
		edges = append(edges, asset.EdgeCredentials)
	}
	if m.sops != nil {
		edges = append(edges, asset.EdgeSops)
	}
	if m.tickets != nil {
		edges = append(edges, asset.EdgeTickets)
	}
	if m.product != nil {
		edges = append(edges, asset.EdgeProduct)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AssetMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case asset.EdgeTenant:
		if id := m.tenant; id != nil {
			return []ent.Value{*id}
		}
	case asset.EdgeType:
		if id := m._type; id != nil {
			return []ent.Value{*id}
		}
	case asset.EdgeHostedAt:
		if id := m.hosted_at; id != nil {
			return []ent.Value{*id}
		}
	case asset.EdgeHostedAssets:
		ids := make([]ent.Value, 0, len(m.hosted_assets))
		for id := range m.hosted_assets {
			ids = append(ids, id)
		}
		return ids
	case asset.EdgeDependencyOf:
		ids := make([]ent.Value, 0, len(m.dependency_of))
		for id := range m.dependency_of {
			ids = append(ids, id)
		}
		return ids
	case asset.EdgeDependsOn:
		ids := make([]ent.Value, 0, len(m.depends_on))
		for id := range m.depends_on {
			ids = append(ids, id)
		}
		return ids
	case asset.EdgeOwner:
		if id := m.owner; id != nil {
			return []ent.Value{*id}
		}
	case asset.EdgeCredentials:
		ids := make([]ent.Value, 0, len(m.credentials))
		for id := range m.credentials {
			ids = append(ids, id)
		}
		return ids
	case asset.EdgeSops:
		ids := make([]ent.Value, 0, len(m.sops))
		for id := range m.sops {
			ids = append(ids, id)
		}
		return ids
	case asset.EdgeTickets:
		ids := make([]ent.Value, 0, len(m.tickets))
		for id := range m.tickets {
			ids = append(ids, id)
		}
		return ids
	case asset.EdgeProduct:
		if id := m.product; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AssetMutation) RemovedEdges() []string {
	edges := make([]string, 0, 11)
	if m.removedhosted_assets != nil {
		edges = append(edges, asset.EdgeHostedAssets)
	}
	if m.removeddependency_of != nil {
		edges = append(edges, asset.EdgeDependencyOf)
	}
	if m.removeddepends_on != nil {
		edges = append(edges, asset.EdgeDependsOn)
	}
	if m.removedcredentials != nil {
		edges = append(edges, asset.EdgeCredentials)
	}
	if m.removedsops != nil {
		edges = append(edges, asset.EdgeSops)
	}
	if m.removedtickets != nil {
		edges = append(edges, asset.EdgeTickets)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AssetMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case asset.EdgeHostedAssets:
		ids := make([]ent.Value, 0, len(m.removedhosted_assets))
		for id := range m.removedhosted_assets {
			ids = append(ids, id)
		}
		return ids
	case asset.EdgeDependencyOf:
		ids := make([]ent.Value, 0, len(m.removeddependency_of))
		for id := range m.removeddependency_of {
			ids = append(ids, id)
		}
		return ids
	case asset.EdgeDependsOn:
		ids := make([]ent.Value, 0, len(m.removeddepends_on))
		for id := range m.removeddepends_on {
			ids = append(ids, id)
		}
		return ids
	case asset.EdgeCredentials:
		ids := make([]ent.Value, 0, len(m.removedcredentials))
		for id := range m.removedcredentials {
			ids = append(ids, id)
		}
		return ids
	case asset.EdgeSops:
		ids := make([]ent.Value, 0, len(m.removedsops))
		for id := range m.removedsops {
			ids = append(ids, id)
		}
		return ids
	case asset.EdgeTickets:
		ids := make([]ent.Value, 0, len(m.removedtickets))
		for id := range m.removedtickets {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AssetMutation) ClearedEdges() []string {
	edges := make([]string, 0, 11)
	if m.clearedtenant {
		edges = append(edges, asset.EdgeTenant)
	}
	if m.cleared_type {
		edges = append(edges, asset.EdgeType)
	}
	if m.clearedhosted_at {
		edges = append(edges, asset.EdgeHostedAt)
	}
	if m.clearedhosted_assets {
		edges = append(edges, asset.EdgeHostedAssets)
	}
	if m.cleareddependency_of {
		edges = append(edges, asset.EdgeDependencyOf)
	}
	if m.cleareddepends_on {
		edges = append(edges, asset.EdgeDependsOn)
	}
	if m.clearedowner {
		edges = append(edges, asset.EdgeOwner)
	}
	if m.clearedcredentials {
		edges = append(edges, asset.EdgeCredentials)
	}
	if m.clearedsops {
		edges = append(edges, asset.EdgeSops)
	}
	if m.clearedtickets {
		edges = append(edges, asset.EdgeTickets)
	}
	if m.clearedproduct {
		edges = append(edges, asset.EdgeProduct)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AssetMutation) EdgeCleared(name string) bool {
	switch name {
	case asset.EdgeTenant:
		return m.clearedtenant
	case asset.EdgeType:
		return m.cleared_type
	case asset.EdgeHostedAt:
		return m.clearedhosted_at
	case asset.EdgeHostedAssets:
		return m.clearedhosted_assets
	case asset.EdgeDependencyOf:
		return m.cleareddependency_of
	case asset.EdgeDependsOn:
		return m.cleareddepends_on
	case asset.EdgeOwner:
		return m.clearedowner
	case asset.EdgeCredentials:
		return m.clearedcredentials
	case asset.EdgeSops:
		return m.clearedsops
	case asset.EdgeTickets:
		return m.clearedtickets
	case asset.EdgeProduct:
		return m.clearedproduct
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AssetMutation) ClearEdge(name string) error {
	switch name {
	case asset.EdgeTenant:
		m.ClearTenant()
		return nil
	case asset.EdgeType:
		m.ClearType()
		return nil
	case asset.EdgeHostedAt:
		m.ClearHostedAt()
		return nil
	case asset.EdgeOwner:
		m.ClearOwner()
		return nil
	case asset.EdgeProduct:
		m.ClearProduct()
		return nil
	}
	return fmt.Errorf("unknown Asset unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AssetMutation) ResetEdge(name string) error {
	switch name {
	case asset.EdgeTenant:
		m.ResetTenant()
		return nil
	case asset.EdgeType:
		m.ResetType()
		return nil
	case asset.EdgeHostedAt:
		m.ResetHostedAt()
		return nil
	case asset.EdgeHostedAssets:
		m.ResetHostedAssets()
		return nil
	case asset.EdgeDependencyOf:
		m.ResetDependencyOf()
		return nil
	case asset.EdgeDependsOn:
		m.ResetDependsOn()
		return nil
	case asset.EdgeOwner:
		m.ResetOwner()
		return nil
	case asset.EdgeCredentials:
		m.ResetCredentials()
		return nil
	case asset.EdgeSops:
		m.ResetSops()
		return nil
	case asset.EdgeTickets:
		m.ResetTickets()
		return nil
	case asset.EdgeProduct:
		m.ResetProduct()
		return nil
	}
	return fmt.Errorf("unknown Asset edge %s", name)
}

// AssetTypeMutation represents an operation that mutates the AssetType nodes in the graph.
type AssetTypeMutation struct {
	config
	op            Op
	typ           string
	id            *int
	name          *string
	description   *string
	clearedFields map[string]struct{}
	assets        map[int]struct{}
	removedassets map[int]struct{}
	clearedassets bool
	done          bool
	oldValue      func(context.Context) (*AssetType, error)
	predicates    []predicate.AssetType
}

var _ ent.Mutation = (*AssetTypeMutation)(nil)

// assettypeOption allows management of the mutation configuration using functional options.
type assettypeOption func(*AssetTypeMutation)

// newAssetTypeMutation creates new mutation for the AssetType entity.
func newAssetTypeMutation(c config, op Op, opts ...assettypeOption) *AssetTypeMutation {
	m := &AssetTypeMutation{
		config:        c,
		op:            op,
		typ:           TypeAssetType,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAssetTypeID sets the ID field of the mutation.
func withAssetTypeID(id int) assettypeOption {
	return func(m *AssetTypeMutation) {
		var (
			err   error
			once  sync.Once
			value *AssetType
		)
		m.oldValue = func(ctx context.Context) (*AssetType, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AssetType.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAssetType sets the old AssetType of the mutation.
func withAssetType(node *AssetType) assettypeOption {
	return func(m *AssetTypeMutation) {
		m.oldValue = func(context.Context) (*AssetType, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AssetTypeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AssetTypeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AssetTypeMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AssetTypeMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AssetType.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *AssetTypeMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *AssetTypeMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the AssetType entity.
// If the AssetType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AssetTypeMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *AssetTypeMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *AssetTypeMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *AssetTypeMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the AssetType entity.
// If the AssetType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AssetTypeMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *AssetTypeMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[assettype.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *AssetTypeMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[assettype.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *AssetTypeMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, assettype.FieldDescription)
}

// AddAssetIDs adds the "assets" edge to the Asset entity by ids.
func (m *AssetTypeMutation) AddAssetIDs(ids ...int) {
	if m.assets == nil {
		m.assets = make(map[int]struct{})
	}
	for i := range ids {
		m.assets[ids[i]] = struct{}{}
	}
}

// ClearAssets clears the "assets" edge to the Asset entity.
func (m *AssetTypeMutation) ClearAssets() {
	m.clearedassets = true
}

// AssetsCleared reports if the "assets" edge to the Asset entity was cleared.
func (m *AssetTypeMutation) AssetsCleared() bool {
	return m.clearedassets
}

// RemoveAssetIDs removes the "assets" edge to the Asset entity by IDs.
func (m *AssetTypeMutation) RemoveAssetIDs(ids ...int) {
	if m.removedassets == nil {
		m.removedassets = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.assets, ids[i])
		m.removedassets[ids[i]] = struct{}{}
	}
}

// RemovedAssets returns the removed IDs of the "assets" edge to the Asset entity.
func (m *AssetTypeMutation) RemovedAssetsIDs() (ids []int) {
	for id := range m.removedassets {
		ids = append(ids, id)
	}
	return
}

// AssetsIDs returns the "assets" edge IDs in the mutation.
func (m *AssetTypeMutation) AssetsIDs() (ids []int) {
	for id := range m.assets {
		ids = append(ids, id)
	}
	return
}

// ResetAssets resets all changes to the "assets" edge.
func (m *AssetTypeMutation) ResetAssets() {
	m.assets = nil
	m.clearedassets = false
	m.removedassets = nil
}

// Where appends a list predicates to the AssetTypeMutation builder.
func (m *AssetTypeMutation) Where(ps ...predicate.AssetType) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AssetTypeMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AssetTypeMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.AssetType, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AssetTypeMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AssetTypeMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (AssetType).
func (m *AssetTypeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AssetTypeMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.name != nil {
		fields = append(fields, assettype.FieldName)
	}
	if m.description != nil {
		fields = append(fields, assettype.FieldDescription)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AssetTypeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case assettype.FieldName:
		return m.Name()
	case assettype.FieldDescription:
		return m.Description()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AssetTypeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case assettype.FieldName:
		return m.OldName(ctx)
	case assettype.FieldDescription:
		return m.OldDescription(ctx)
	}
	return nil, fmt.Errorf("unknown AssetType field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AssetTypeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case assettype.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case assettype.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	}
	return fmt.Errorf("unknown AssetType field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AssetTypeMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AssetTypeMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AssetTypeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown AssetType numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AssetTypeMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(assettype.FieldDescription) {
		fields = append(fields, assettype.FieldDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AssetTypeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AssetTypeMutation) ClearField(name string) error {
	switch name {
	case assettype.FieldDescription:
		m.ClearDescription()
		return nil
	}
	return fmt.Errorf("unknown AssetType nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AssetTypeMutation) ResetField(name string) error {
	switch name {
	case assettype.FieldName:
		m.ResetName()
		return nil
	case assettype.FieldDescription:
		m.ResetDescription()
		return nil
	}
	return fmt.Errorf("unknown AssetType field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AssetTypeMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.assets != nil {
		edges = append(edges, assettype.EdgeAssets)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AssetTypeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case assettype.EdgeAssets:
		ids := make([]ent.Value, 0, len(m.assets))
		for id := range m.assets {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AssetTypeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedassets != nil {
		edges = append(edges, assettype.EdgeAssets)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AssetTypeMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case assettype.EdgeAssets:
		ids := make([]ent.Value, 0, len(m.removedassets))
		for id := range m.removedassets {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AssetTypeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedassets {
		edges = append(edges, assettype.EdgeAssets)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AssetTypeMutation) EdgeCleared(name string) bool {
	switch name {
	case assettype.EdgeAssets:
		return m.clearedassets
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AssetTypeMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown AssetType unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AssetTypeMutation) ResetEdge(name string) error {
	switch name {
	case assettype.EdgeAssets:
		m.ResetAssets()
		return nil
	}
	return fmt.Errorf("unknown AssetType edge %s", name)
}

// AuditLogMutation represents an operation that mutates the AuditLog nodes in the graph.
type AuditLogMutation struct {
	config
	op            Op
	typ           string
	id            *int
	app_name      *string
	action        *string
	actor_id      *string
	remote_ip     *string
	payload       *map[string]interface{}
	timestamp     *time.Time
	clearedFields map[string]struct{}
	tenant        *int
	clearedtenant bool
	done          bool
	oldValue      func(context.Context) (*AuditLog, error)
	predicates    []predicate.AuditLog
}

var _ ent.Mutation = (*AuditLogMutation)(nil)

// auditlogOption allows management of the mutation configuration using functional options.
type auditlogOption func(*AuditLogMutation)

// newAuditLogMutation creates new mutation for the AuditLog entity.
func newAuditLogMutation(c config, op Op, opts ...auditlogOption) *AuditLogMutation {
	m := &AuditLogMutation{
		config:        c,
		op:            op,
		typ:           TypeAuditLog,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAuditLogID sets the ID field of the mutation.
func withAuditLogID(id int) auditlogOption {
	return func(m *AuditLogMutation) {
		var (
			err   error
			once  sync.Once
			value *AuditLog
		)
		m.oldValue = func(ctx context.Context) (*AuditLog, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AuditLog.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAuditLog sets the old AuditLog of the mutation.
func withAuditLog(node *AuditLog) auditlogOption {
	return func(m *AuditLogMutation) {
		m.oldValue = func(context.Context) (*AuditLog, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AuditLogMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AuditLogMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AuditLogMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AuditLogMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AuditLog.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetAppName sets the "app_name" field.
func (m *AuditLogMutation) SetAppName(s string) {
	m.app_name = &s
}

// AppName returns the value of the "app_name" field in the mutation.
func (m *AuditLogMutation) AppName() (r string, exists bool) {
	v := m.app_name
	if v == nil {
		return
	}
	return *v, true
}

// OldAppName returns the old "app_name" field's value of the AuditLog entity.
// If the AuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditLogMutation) OldAppName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppName: %w", err)
	}
	return oldValue.AppName, nil
}

// ResetAppName resets all changes to the "app_name" field.
func (m *AuditLogMutation) ResetAppName() {
	m.app_name = nil
}

// SetAction sets the "action" field.
func (m *AuditLogMutation) SetAction(s string) {
	m.action = &s
}

// Action returns the value of the "action" field in the mutation.
func (m *AuditLogMutation) Action() (r string, exists bool) {
	v := m.action
	if v == nil {
		return
	}
	return *v, true
}

// OldAction returns the old "action" field's value of the AuditLog entity.
// If the AuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditLogMutation) OldAction(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAction is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAction requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAction: %w", err)
	}
	return oldValue.Action, nil
}

// ResetAction resets all changes to the "action" field.
func (m *AuditLogMutation) ResetAction() {
	m.action = nil
}

// SetActorID sets the "actor_id" field.
func (m *AuditLogMutation) SetActorID(s string) {
	m.actor_id = &s
}

// ActorID returns the value of the "actor_id" field in the mutation.
func (m *AuditLogMutation) ActorID() (r string, exists bool) {
	v := m.actor_id
	if v == nil {
		return
	}
	return *v, true
}

// OldActorID returns the old "actor_id" field's value of the AuditLog entity.
// If the AuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditLogMutation) OldActorID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldActorID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldActorID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldActorID: %w", err)
	}
	return oldValue.ActorID, nil
}

// ResetActorID resets all changes to the "actor_id" field.
func (m *AuditLogMutation) ResetActorID() {
	m.actor_id = nil
}

// SetRemoteIP sets the "remote_ip" field.
func (m *AuditLogMutation) SetRemoteIP(s string) {
	m.remote_ip = &s
}

// RemoteIP returns the value of the "remote_ip" field in the mutation.
func (m *AuditLogMutation) RemoteIP() (r string, exists bool) {
	v := m.remote_ip
	if v == nil {
		return
	}
	return *v, true
}

// OldRemoteIP returns the old "remote_ip" field's value of the AuditLog entity.
// If the AuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditLogMutation) OldRemoteIP(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRemoteIP is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRemoteIP requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemoteIP: %w", err)
	}
	return oldValue.RemoteIP, nil
}

// ClearRemoteIP clears the value of the "remote_ip" field.
func (m *AuditLogMutation) ClearRemoteIP() {
	m.remote_ip = nil
	m.clearedFields[auditlog.FieldRemoteIP] = struct{}{}
}

// RemoteIPCleared returns if the "remote_ip" field was cleared in this mutation.
func (m *AuditLogMutation) RemoteIPCleared() bool {
	_, ok := m.clearedFields[auditlog.FieldRemoteIP]
	return ok
}

// ResetRemoteIP resets all changes to the "remote_ip" field.
func (m *AuditLogMutation) ResetRemoteIP() {
	m.remote_ip = nil
	delete(m.clearedFields, auditlog.FieldRemoteIP)
}

// SetPayload sets the "payload" field.
func (m *AuditLogMutation) SetPayload(value map[string]interface{}) {
	m.payload = &value
}

// Payload returns the value of the "payload" field in the mutation.
func (m *AuditLogMutation) Payload() (r map[string]interface{}, exists bool) {
	v := m.payload
	if v == nil {
		return
	}
	return *v, true
}

// OldPayload returns the old "payload" field's value of the AuditLog entity.
// If the AuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditLogMutation) OldPayload(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPayload is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPayload requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPayload: %w", err)
	}
	return oldValue.Payload, nil
}

// ClearPayload clears the value of the "payload" field.
func (m *AuditLogMutation) ClearPayload() {
	m.payload = nil
	m.clearedFields[auditlog.FieldPayload] = struct{}{}
}

// PayloadCleared returns if the "payload" field was cleared in this mutation.
func (m *AuditLogMutation) PayloadCleared() bool {
	_, ok := m.clearedFields[auditlog.FieldPayload]
	return ok
}

// ResetPayload resets all changes to the "payload" field.
func (m *AuditLogMutation) ResetPayload() {
	m.payload = nil
	delete(m.clearedFields, auditlog.FieldPayload)
}

// SetTimestamp sets the "timestamp" field.
func (m *AuditLogMutation) SetTimestamp(t time.Time) {
	m.timestamp = &t
}

// Timestamp returns the value of the "timestamp" field in the mutation.
func (m *AuditLogMutation) Timestamp() (r time.Time, exists bool) {
	v := m.timestamp
	if v == nil {
		return
	}
	return *v, true
}

// OldTimestamp returns the old "timestamp" field's value of the AuditLog entity.
// If the AuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditLogMutation) OldTimestamp(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTimestamp is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTimestamp requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTimestamp: %w", err)
	}
	return oldValue.Timestamp, nil
}

// ResetTimestamp resets all changes to the "timestamp" field.
func (m *AuditLogMutation) ResetTimestamp() {
	m.timestamp = nil
}

// SetTenantID sets the "tenant" edge to the Tenant entity by id.
func (m *AuditLogMutation) SetTenantID(id int) {
	m.tenant = &id
}

// ClearTenant clears the "tenant" edge to the Tenant entity.
func (m *AuditLogMutation) ClearTenant() {
	m.clearedtenant = true
}

// TenantCleared reports if the "tenant" edge to the Tenant entity was cleared.
func (m *AuditLogMutation) TenantCleared() bool {
	return m.clearedtenant
}

// TenantID returns the "tenant" edge ID in the mutation.
func (m *AuditLogMutation) TenantID() (id int, exists bool) {
	if m.tenant != nil {
		return *m.tenant, true
	}
	return
}

// TenantIDs returns the "tenant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TenantID instead. It exists only for internal usage by the builders.
func (m *AuditLogMutation) TenantIDs() (ids []int) {
	if id := m.tenant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTenant resets all changes to the "tenant" edge.
func (m *AuditLogMutation) ResetTenant() {
	m.tenant = nil
	m.clearedtenant = false
}

// Where appends a list predicates to the AuditLogMutation builder.
func (m *AuditLogMutation) Where(ps ...predicate.AuditLog) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AuditLogMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AuditLogMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.AuditLog, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AuditLogMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AuditLogMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (AuditLog).
func (m *AuditLogMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AuditLogMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.app_name != nil {
		fields = append(fields, auditlog.FieldAppName)
	}
	if m.action != nil {
		fields = append(fields, auditlog.FieldAction)
	}
	if m.actor_id != nil {
		fields = append(fields, auditlog.FieldActorID)
	}
	if m.remote_ip != nil {
		fields = append(fields, auditlog.FieldRemoteIP)
	}
	if m.payload != nil {
		fields = append(fields, auditlog.FieldPayload)
	}
	if m.timestamp != nil {
		fields = append(fields, auditlog.FieldTimestamp)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AuditLogMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case auditlog.FieldAppName:
		return m.AppName()
	case auditlog.FieldAction:
		return m.Action()
	case auditlog.FieldActorID:
		return m.ActorID()
	case auditlog.FieldRemoteIP:
		return m.RemoteIP()
	case auditlog.FieldPayload:
		return m.Payload()
	case auditlog.FieldTimestamp:
		return m.Timestamp()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AuditLogMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case auditlog.FieldAppName:
		return m.OldAppName(ctx)
	case auditlog.FieldAction:
		return m.OldAction(ctx)
	case auditlog.FieldActorID:
		return m.OldActorID(ctx)
	case auditlog.FieldRemoteIP:
		return m.OldRemoteIP(ctx)
	case auditlog.FieldPayload:
		return m.OldPayload(ctx)
	case auditlog.FieldTimestamp:
		return m.OldTimestamp(ctx)
	}
	return nil, fmt.Errorf("unknown AuditLog field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AuditLogMutation) SetField(name string, value ent.Value) error {
	switch name {
	case auditlog.FieldAppName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppName(v)
		return nil
	case auditlog.FieldAction:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAction(v)
		return nil
	case auditlog.FieldActorID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetActorID(v)
		return nil
	case auditlog.FieldRemoteIP:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemoteIP(v)
		return nil
	case auditlog.FieldPayload:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPayload(v)
		return nil
	case auditlog.FieldTimestamp:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTimestamp(v)
		return nil
	}
	return fmt.Errorf("unknown AuditLog field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AuditLogMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AuditLogMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AuditLogMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown AuditLog numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AuditLogMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(auditlog.FieldRemoteIP) {
		fields = append(fields, auditlog.FieldRemoteIP)
	}
	if m.FieldCleared(auditlog.FieldPayload) {
		fields = append(fields, auditlog.FieldPayload)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AuditLogMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AuditLogMutation) ClearField(name string) error {
	switch name {
	case auditlog.FieldRemoteIP:
		m.ClearRemoteIP()
		return nil
	case auditlog.FieldPayload:
		m.ClearPayload()
		return nil
	}
	return fmt.Errorf("unknown AuditLog nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AuditLogMutation) ResetField(name string) error {
	switch name {
	case auditlog.FieldAppName:
		m.ResetAppName()
		return nil
	case auditlog.FieldAction:
		m.ResetAction()
		return nil
	case auditlog.FieldActorID:
		m.ResetActorID()
		return nil
	case auditlog.FieldRemoteIP:
		m.ResetRemoteIP()
		return nil
	case auditlog.FieldPayload:
		m.ResetPayload()
		return nil
	case auditlog.FieldTimestamp:
		m.ResetTimestamp()
		return nil
	}
	return fmt.Errorf("unknown AuditLog field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AuditLogMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.tenant != nil {
		edges = append(edges, auditlog.EdgeTenant)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AuditLogMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case auditlog.EdgeTenant:
		if id := m.tenant; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AuditLogMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AuditLogMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AuditLogMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedtenant {
		edges = append(edges, auditlog.EdgeTenant)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AuditLogMutation) EdgeCleared(name string) bool {
	switch name {
	case auditlog.EdgeTenant:
		return m.clearedtenant
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AuditLogMutation) ClearEdge(name string) error {
	switch name {
	case auditlog.EdgeTenant:
		m.ClearTenant()
		return nil
	}
	return fmt.Errorf("unknown AuditLog unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AuditLogMutation) ResetEdge(name string) error {
	switch name {
	case auditlog.EdgeTenant:
		m.ResetTenant()
		return nil
	}
	return fmt.Errorf("unknown AuditLog edge %s", name)
}

// BudgetForecastMutation represents an operation that mutates the BudgetForecast nodes in the graph.
type BudgetForecastMutation struct {
	config
	op                  Op
	typ                 string
	id                  *int
	year                *int
	addyear             *int
	month               *int
	addmonth            *int
	projected_amount    *float64
	addprojected_amount *float64
	actual_spent        *float64
	addactual_spent     *float64
	forecast_data       *map[string]interface{}
	created_at          *time.Time
	clearedFields       map[string]struct{}
	tenant              *int
	clearedtenant       bool
	done                bool
	oldValue            func(context.Context) (*BudgetForecast, error)
	predicates          []predicate.BudgetForecast
}

var _ ent.Mutation = (*BudgetForecastMutation)(nil)

// budgetforecastOption allows management of the mutation configuration using functional options.
type budgetforecastOption func(*BudgetForecastMutation)

// newBudgetForecastMutation creates new mutation for the BudgetForecast entity.
func newBudgetForecastMutation(c config, op Op, opts ...budgetforecastOption) *BudgetForecastMutation {
	m := &BudgetForecastMutation{
		config:        c,
		op:            op,
		typ:           TypeBudgetForecast,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBudgetForecastID sets the ID field of the mutation.
func withBudgetForecastID(id int) budgetforecastOption {
	return func(m *BudgetForecastMutation) {
		var (
			err   error
			once  sync.Once
			value *BudgetForecast
		)
		m.oldValue = func(ctx context.Context) (*BudgetForecast, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().BudgetForecast.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBudgetForecast sets the old BudgetForecast of the mutation.
func withBudgetForecast(node *BudgetForecast) budgetforecastOption {
	return func(m *BudgetForecastMutation) {
		m.oldValue = func(context.Context) (*BudgetForecast, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BudgetForecastMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BudgetForecastMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *BudgetForecastMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *BudgetForecastMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().BudgetForecast.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetYear sets the "year" field.
func (m *BudgetForecastMutation) SetYear(i int) {
	m.year = &i
	m.addyear = nil
}

// Year returns the value of the "year" field in the mutation.
func (m *BudgetForecastMutation) Year() (r int, exists bool) {
	v := m.year
	if v == nil {
		return
	}
	return *v, true
}

// OldYear returns the old "year" field's value of the BudgetForecast entity.
// If the BudgetForecast object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BudgetForecastMutation) OldYear(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldYear is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldYear requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldYear: %w", err)
	}
	return oldValue.Year, nil
}

// AddYear adds i to the "year" field.
func (m *BudgetForecastMutation) AddYear(i int) {
	if m.addyear != nil {
		*m.addyear += i
	} else {
		m.addyear = &i
	}
}

// AddedYear returns the value that was added to the "year" field in this mutation.
func (m *BudgetForecastMutation) AddedYear() (r int, exists bool) {
	v := m.addyear
	if v == nil {
		return
	}
	return *v, true
}

// ResetYear resets all changes to the "year" field.
func (m *BudgetForecastMutation) ResetYear() {
	m.year = nil
	m.addyear = nil
}

// SetMonth sets the "month" field.
func (m *BudgetForecastMutation) SetMonth(i int) {
	m.month = &i
	m.addmonth = nil
}

// Month returns the value of the "month" field in the mutation.
func (m *BudgetForecastMutation) Month() (r int, exists bool) {
	v := m.month
	if v == nil {
		return
	}
	return *v, true
}

// OldMonth returns the old "month" field's value of the BudgetForecast entity.
// If the BudgetForecast object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BudgetForecastMutation) OldMonth(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMonth is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMonth requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMonth: %w", err)
	}
	return oldValue.Month, nil
}

// AddMonth adds i to the "month" field.
func (m *BudgetForecastMutation) AddMonth(i int) {
	if m.addmonth != nil {
		*m.addmonth += i
	} else {
		m.addmonth = &i
	}
}

// AddedMonth returns the value that was added to the "month" field in this mutation.
func (m *BudgetForecastMutation) AddedMonth() (r int, exists bool) {
	v := m.addmonth
	if v == nil {
		return
	}
	return *v, true
}

// ResetMonth resets all changes to the "month" field.
func (m *BudgetForecastMutation) ResetMonth() {
	m.month = nil
	m.addmonth = nil
}

// SetProjectedAmount sets the "projected_amount" field.
func (m *BudgetForecastMutation) SetProjectedAmount(f float64) {
	m.projected_amount = &f
	m.addprojected_amount = nil
}

// ProjectedAmount returns the value of the "projected_amount" field in the mutation.
func (m *BudgetForecastMutation) ProjectedAmount() (r float64, exists bool) {
	v := m.projected_amount
	if v == nil {
		return
	}
	return *v, true
}

// OldProjectedAmount returns the old "projected_amount" field's value of the BudgetForecast entity.
// If the BudgetForecast object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BudgetForecastMutation) OldProjectedAmount(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProjectedAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProjectedAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProjectedAmount: %w", err)
	}
	return oldValue.ProjectedAmount, nil
}

// AddProjectedAmount adds f to the "projected_amount" field.
func (m *BudgetForecastMutation) AddProjectedAmount(f float64) {
	if m.addprojected_amount != nil {
		*m.addprojected_amount += f
	} else {
		m.addprojected_amount = &f
	}
}

// AddedProjectedAmount returns the value that was added to the "projected_amount" field in this mutation.
func (m *BudgetForecastMutation) AddedProjectedAmount() (r float64, exists bool) {
	v := m.addprojected_amount
	if v == nil {
		return
	}
	return *v, true
}

// ResetProjectedAmount resets all changes to the "projected_amount" field.
func (m *BudgetForecastMutation) ResetProjectedAmount() {
	m.projected_amount = nil
	m.addprojected_amount = nil
}

// SetActualSpent sets the "actual_spent" field.
func (m *BudgetForecastMutation) SetActualSpent(f float64) {
	m.actual_spent = &f
	m.addactual_spent = nil
}

// ActualSpent returns the value of the "actual_spent" field in the mutation.
func (m *BudgetForecastMutation) ActualSpent() (r float64, exists bool) {
	v := m.actual_spent
	if v == nil {
		return
	}
	return *v, true
}

// OldActualSpent returns the old "actual_spent" field's value of the BudgetForecast entity.
// If the BudgetForecast object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BudgetForecastMutation) OldActualSpent(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldActualSpent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldActualSpent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldActualSpent: %w", err)
	}
	return oldValue.ActualSpent, nil
}

// AddActualSpent adds f to the "actual_spent" field.
func (m *BudgetForecastMutation) AddActualSpent(f float64) {
	if m.addactual_spent != nil {
		*m.addactual_spent += f
	} else {
		m.addactual_spent = &f
	}
}

// AddedActualSpent returns the value that was added to the "actual_spent" field in this mutation.
func (m *BudgetForecastMutation) AddedActualSpent() (r float64, exists bool) {
	v := m.addactual_spent
	if v == nil {
		return
	}
	return *v, true
}

// ResetActualSpent resets all changes to the "actual_spent" field.
func (m *BudgetForecastMutation) ResetActualSpent() {
	m.actual_spent = nil
	m.addactual_spent = nil
}

// SetForecastData sets the "forecast_data" field.
func (m *BudgetForecastMutation) SetForecastData(value map[string]interface{}) {
	m.forecast_data = &value
}

// ForecastData returns the value of the "forecast_data" field in the mutation.
func (m *BudgetForecastMutation) ForecastData() (r map[string]interface{}, exists bool) {
	v := m.forecast_data
	if v == nil {
		return
	}
	return *v, true
}

// OldForecastData returns the old "forecast_data" field's value of the BudgetForecast entity.
// If the BudgetForecast object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BudgetForecastMutation) OldForecastData(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldForecastData is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldForecastData requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldForecastData: %w", err)
	}
	return oldValue.ForecastData, nil
}

// ClearForecastData clears the value of the "forecast_data" field.
func (m *BudgetForecastMutation) ClearForecastData() {
	m.forecast_data = nil
	m.clearedFields[budgetforecast.FieldForecastData] = struct{}{}
}

// ForecastDataCleared returns if the "forecast_data" field was cleared in this mutation.
func (m *BudgetForecastMutation) ForecastDataCleared() bool {
	_, ok := m.clearedFields[budgetforecast.FieldForecastData]
	return ok
}

// ResetForecastData resets all changes to the "forecast_data" field.
func (m *BudgetForecastMutation) ResetForecastData() {
	m.forecast_data = nil
	delete(m.clearedFields, budgetforecast.FieldForecastData)
}

// SetCreatedAt sets the "created_at" field.
func (m *BudgetForecastMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *BudgetForecastMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the BudgetForecast entity.
// If the BudgetForecast object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BudgetForecastMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *BudgetForecastMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetTenantID sets the "tenant" edge to the Tenant entity by id.
func (m *BudgetForecastMutation) SetTenantID(id int) {
	m.tenant = &id
}

// ClearTenant clears the "tenant" edge to the Tenant entity.
func (m *BudgetForecastMutation) ClearTenant() {
	m.clearedtenant = true
}

// TenantCleared reports if the "tenant" edge to the Tenant entity was cleared.
func (m *BudgetForecastMutation) TenantCleared() bool {
	return m.clearedtenant
}

// TenantID returns the "tenant" edge ID in the mutation.
func (m *BudgetForecastMutation) TenantID() (id int, exists bool) {
	if m.tenant != nil {
		return *m.tenant, true
	}
	return
}

// TenantIDs returns the "tenant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TenantID instead. It exists only for internal usage by the builders.
func (m *BudgetForecastMutation) TenantIDs() (ids []int) {
	if id := m.tenant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTenant resets all changes to the "tenant" edge.
func (m *BudgetForecastMutation) ResetTenant() {
	m.tenant = nil
	m.clearedtenant = false
}

// Where appends a list predicates to the BudgetForecastMutation builder.
func (m *BudgetForecastMutation) Where(ps ...predicate.BudgetForecast) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the BudgetForecastMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *BudgetForecastMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.BudgetForecast, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *BudgetForecastMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *BudgetForecastMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (BudgetForecast).
func (m *BudgetForecastMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *BudgetForecastMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.year != nil {
		fields = append(fields, budgetforecast.FieldYear)
	}
	if m.month != nil {
		fields = append(fields, budgetforecast.FieldMonth)
	}
	if m.projected_amount != nil {
		fields = append(fields, budgetforecast.FieldProjectedAmount)
	}
	if m.actual_spent != nil {
		fields = append(fields, budgetforecast.FieldActualSpent)
	}
	if m.forecast_data != nil {
		fields = append(fields, budgetforecast.FieldForecastData)
	}
	if m.created_at != nil {
		fields = append(fields, budgetforecast.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *BudgetForecastMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case budgetforecast.FieldYear:
		return m.Year()
	case budgetforecast.FieldMonth:
		return m.Month()
	case budgetforecast.FieldProjectedAmount:
		return m.ProjectedAmount()
	case budgetforecast.FieldActualSpent:
		return m.ActualSpent()
	case budgetforecast.FieldForecastData:
		return m.ForecastData()
	case budgetforecast.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *BudgetForecastMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case budgetforecast.FieldYear:
		return m.OldYear(ctx)
	case budgetforecast.FieldMonth:
		return m.OldMonth(ctx)
	case budgetforecast.FieldProjectedAmount:
		return m.OldProjectedAmount(ctx)
	case budgetforecast.FieldActualSpent:
		return m.OldActualSpent(ctx)
	case budgetforecast.FieldForecastData:
		return m.OldForecastData(ctx)
	case budgetforecast.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown BudgetForecast field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BudgetForecastMutation) SetField(name string, value ent.Value) error {
	switch name {
	case budgetforecast.FieldYear:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetYear(v)
		return nil
	case budgetforecast.FieldMonth:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMonth(v)
		return nil
	case budgetforecast.FieldProjectedAmount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProjectedAmount(v)
		return nil
	case budgetforecast.FieldActualSpent:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetActualSpent(v)
		return nil
	case budgetforecast.FieldForecastData:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetForecastData(v)
		return nil
	case budgetforecast.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown BudgetForecast field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *BudgetForecastMutation) AddedFields() []string {
	var fields []string
	if m.addyear != nil {
		fields = append(fields, budgetforecast.FieldYear)
	}
	if m.addmonth != nil {
		fields = append(fields, budgetforecast.FieldMonth)
	}
	if m.addprojected_amount != nil {
		fields = append(fields, budgetforecast.FieldProjectedAmount)
	}
	if m.addactual_spent != nil {
		fields = append(fields, budgetforecast.FieldActualSpent)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *BudgetForecastMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case budgetforecast.FieldYear:
		return m.AddedYear()
	case budgetforecast.FieldMonth:
		return m.AddedMonth()
	case budgetforecast.FieldProjectedAmount:
		return m.AddedProjectedAmount()
	case budgetforecast.FieldActualSpent:
		return m.AddedActualSpent()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BudgetForecastMutation) AddField(name string, value ent.Value) error {
	switch name {
	case budgetforecast.FieldYear:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddYear(v)
		return nil
	case budgetforecast.FieldMonth:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMonth(v)
		return nil
	case budgetforecast.FieldProjectedAmount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddProjectedAmount(v)
		return nil
	case budgetforecast.FieldActualSpent:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddActualSpent(v)
		return nil
	}
	return fmt.Errorf("unknown BudgetForecast numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *BudgetForecastMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(budgetforecast.FieldForecastData) {
		fields = append(fields, budgetforecast.FieldForecastData)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *BudgetForecastMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *BudgetForecastMutation) ClearField(name string) error {
	switch name {
	case budgetforecast.FieldForecastData:
		m.ClearForecastData()
		return nil
	}
	return fmt.Errorf("unknown BudgetForecast nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *BudgetForecastMutation) ResetField(name string) error {
	switch name {
	case budgetforecast.FieldYear:
		m.ResetYear()
		return nil
	case budgetforecast.FieldMonth:
		m.ResetMonth()
		return nil
	case budgetforecast.FieldProjectedAmount:
		m.ResetProjectedAmount()
		return nil
	case budgetforecast.FieldActualSpent:
		m.ResetActualSpent()
		return nil
	case budgetforecast.FieldForecastData:
		m.ResetForecastData()
		return nil
	case budgetforecast.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown BudgetForecast field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *BudgetForecastMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.tenant != nil {
		edges = append(edges, budgetforecast.EdgeTenant)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *BudgetForecastMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case budgetforecast.EdgeTenant:
		if id := m.tenant; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *BudgetForecastMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *BudgetForecastMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *BudgetForecastMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedtenant {
		edges = append(edges, budgetforecast.EdgeTenant)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *BudgetForecastMutation) EdgeCleared(name string) bool {
	switch name {
	case budgetforecast.EdgeTenant:
		return m.clearedtenant
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *BudgetForecastMutation) ClearEdge(name string) error {
	switch name {
	case budgetforecast.EdgeTenant:
		m.ClearTenant()
		return nil
	}
	return fmt.Errorf("unknown BudgetForecast unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *BudgetForecastMutation) ResetEdge(name string) error {
	switch name {
	case budgetforecast.EdgeTenant:
		m.ResetTenant()
		return nil
	}
	return fmt.Errorf("unknown BudgetForecast edge %s", name)
}

// CallLogMutation represents an operation that mutates the CallLog nodes in the graph.
type CallLogMutation struct {
	config
	op             Op
	typ            string
	id             *int
	caller         *string
	callee         *string
	direction      *calllog.Direction
	start_time     *time.Time
	end_time       *time.Time
	duration       *int
	addduration    *int
	status         *string
	recording_path *string
	transcript     *string
	clearedFields  map[string]struct{}
	tenant         *int
	clearedtenant  bool
	user           *int
	cleareduser    bool
	done           bool
	oldValue       func(context.Context) (*CallLog, error)
	predicates     []predicate.CallLog
}

var _ ent.Mutation = (*CallLogMutation)(nil)

// calllogOption allows management of the mutation configuration using functional options.
type calllogOption func(*CallLogMutation)

// newCallLogMutation creates new mutation for the CallLog entity.
func newCallLogMutation(c config, op Op, opts ...calllogOption) *CallLogMutation {
	m := &CallLogMutation{
		config:        c,
		op:            op,
		typ:           TypeCallLog,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCallLogID sets the ID field of the mutation.
func withCallLogID(id int) calllogOption {
	return func(m *CallLogMutation) {
		var (
			err   error
			once  sync.Once
			value *CallLog
		)
		m.oldValue = func(ctx context.Context) (*CallLog, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CallLog.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCallLog sets the old CallLog of the mutation.
func withCallLog(node *CallLog) calllogOption {
	return func(m *CallLogMutation) {
		m.oldValue = func(context.Context) (*CallLog, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CallLogMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CallLogMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CallLogMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CallLogMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().CallLog.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCaller sets the "caller" field.
func (m *CallLogMutation) SetCaller(s string) {
	m.caller = &s
}

// Caller returns the value of the "caller" field in the mutation.
func (m *CallLogMutation) Caller() (r string, exists bool) {
	v := m.caller
	if v == nil {
		return
	}
	return *v, true
}

// OldCaller returns the old "caller" field's value of the CallLog entity.
// If the CallLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CallLogMutation) OldCaller(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCaller is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCaller requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCaller: %w", err)
	}
	return oldValue.Caller, nil
}

// ResetCaller resets all changes to the "caller" field.
func (m *CallLogMutation) ResetCaller() {
	m.caller = nil
}

// SetCallee sets the "callee" field.
func (m *CallLogMutation) SetCallee(s string) {
	m.callee = &s
}

// Callee returns the value of the "callee" field in the mutation.
func (m *CallLogMutation) Callee() (r string, exists bool) {
	v := m.callee
	if v == nil {
		return
	}
	return *v, true
}

// OldCallee returns the old "callee" field's value of the CallLog entity.
// If the CallLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CallLogMutation) OldCallee(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCallee is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCallee requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCallee: %w", err)
	}
	return oldValue.Callee, nil
}

// ResetCallee resets all changes to the "callee" field.
func (m *CallLogMutation) ResetCallee() {
	m.callee = nil
}

// SetDirection sets the "direction" field.
func (m *CallLogMutation) SetDirection(c calllog.Direction) {
	m.direction = &c
}

// Direction returns the value of the "direction" field in the mutation.
func (m *CallLogMutation) Direction() (r calllog.Direction, exists bool) {
	v := m.direction
	if v == nil {
		return
	}
	return *v, true
}

// OldDirection returns the old "direction" field's value of the CallLog entity.
// If the CallLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CallLogMutation) OldDirection(ctx context.Context) (v calllog.Direction, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDirection is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDirection requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDirection: %w", err)
	}
	return oldValue.Direction, nil
}

// ResetDirection resets all changes to the "direction" field.
func (m *CallLogMutation) ResetDirection() {
	m.direction = nil
}

// SetStartTime sets the "start_time" field.
func (m *CallLogMutation) SetStartTime(t time.Time) {
	m.start_time = &t
}

// StartTime returns the value of the "start_time" field in the mutation.
func (m *CallLogMutation) StartTime() (r time.Time, exists bool) {
	v := m.start_time
	if v == nil {
		return
	}
	return *v, true
}

// OldStartTime returns the old "start_time" field's value of the CallLog entity.
// If the CallLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CallLogMutation) OldStartTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartTime: %w", err)
	}
	return oldValue.StartTime, nil
}

// ResetStartTime resets all changes to the "start_time" field.
func (m *CallLogMutation) ResetStartTime() {
	m.start_time = nil
}

// SetEndTime sets the "end_time" field.
func (m *CallLogMutation) SetEndTime(t time.Time) {
	m.end_time = &t
}

// EndTime returns the value of the "end_time" field in the mutation.
func (m *CallLogMutation) EndTime() (r time.Time, exists bool) {
	v := m.end_time
	if v == nil {
		return
	}
	return *v, true
}

// OldEndTime returns the old "end_time" field's value of the CallLog entity.
// If the CallLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CallLogMutation) OldEndTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEndTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEndTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndTime: %w", err)
	}
	return oldValue.EndTime, nil
}

// ClearEndTime clears the value of the "end_time" field.
func (m *CallLogMutation) ClearEndTime() {
	m.end_time = nil
	m.clearedFields[calllog.FieldEndTime] = struct{}{}
}

// EndTimeCleared returns if the "end_time" field was cleared in this mutation.
func (m *CallLogMutation) EndTimeCleared() bool {
	_, ok := m.clearedFields[calllog.FieldEndTime]
	return ok
}

// ResetEndTime resets all changes to the "end_time" field.
func (m *CallLogMutation) ResetEndTime() {
	m.end_time = nil
	delete(m.clearedFields, calllog.FieldEndTime)
}

// SetDuration sets the "duration" field.
func (m *CallLogMutation) SetDuration(i int) {
	m.duration = &i
	m.addduration = nil
}

// Duration returns the value of the "duration" field in the mutation.
func (m *CallLogMutation) Duration() (r int, exists bool) {
	v := m.duration
	if v == nil {
		return
	}
	return *v, true
}

// OldDuration returns the old "duration" field's value of the CallLog entity.
// If the CallLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CallLogMutation) OldDuration(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDuration is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDuration requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDuration: %w", err)
	}
	return oldValue.Duration, nil
}

// AddDuration adds i to the "duration" field.
func (m *CallLogMutation) AddDuration(i int) {
	if m.addduration != nil {
		*m.addduration += i
	} else {
		m.addduration = &i
	}
}

// AddedDuration returns the value that was added to the "duration" field in this mutation.
func (m *CallLogMutation) AddedDuration() (r int, exists bool) {
	v := m.addduration
	if v == nil {
		return
	}
	return *v, true
}

// ResetDuration resets all changes to the "duration" field.
func (m *CallLogMutation) ResetDuration() {
	m.duration = nil
	m.addduration = nil
}

// SetStatus sets the "status" field.
func (m *CallLogMutation) SetStatus(s string) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *CallLogMutation) Status() (r string, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the CallLog entity.
// If the CallLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CallLogMutation) OldStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *CallLogMutation) ResetStatus() {
	m.status = nil
}

// SetRecordingPath sets the "recording_path" field.
func (m *CallLogMutation) SetRecordingPath(s string) {
	m.recording_path = &s
}

// RecordingPath returns the value of the "recording_path" field in the mutation.
func (m *CallLogMutation) RecordingPath() (r string, exists bool) {
	v := m.recording_path
	if v == nil {
		return
	}
	return *v, true
}

// OldRecordingPath returns the old "recording_path" field's value of the CallLog entity.
// If the CallLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CallLogMutation) OldRecordingPath(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRecordingPath is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRecordingPath requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRecordingPath: %w", err)
	}
	return oldValue.RecordingPath, nil
}

// ClearRecordingPath clears the value of the "recording_path" field.
func (m *CallLogMutation) ClearRecordingPath() {
	m.recording_path = nil
	m.clearedFields[calllog.FieldRecordingPath] = struct{}{}
}

// RecordingPathCleared returns if the "recording_path" field was cleared in this mutation.
func (m *CallLogMutation) RecordingPathCleared() bool {
	_, ok := m.clearedFields[calllog.FieldRecordingPath]
	return ok
}

// ResetRecordingPath resets all changes to the "recording_path" field.
func (m *CallLogMutation) ResetRecordingPath() {
	m.recording_path = nil
	delete(m.clearedFields, calllog.FieldRecordingPath)
}

// SetTranscript sets the "transcript" field.
func (m *CallLogMutation) SetTranscript(s string) {
	m.transcript = &s
}

// Transcript returns the value of the "transcript" field in the mutation.
func (m *CallLogMutation) Transcript() (r string, exists bool) {
	v := m.transcript
	if v == nil {
		return
	}
	return *v, true
}

// OldTranscript returns the old "transcript" field's value of the CallLog entity.
// If the CallLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CallLogMutation) OldTranscript(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTranscript is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTranscript requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTranscript: %w", err)
	}
	return oldValue.Transcript, nil
}

// ClearTranscript clears the value of the "transcript" field.
func (m *CallLogMutation) ClearTranscript() {
	m.transcript = nil
	m.clearedFields[calllog.FieldTranscript] = struct{}{}
}

// TranscriptCleared returns if the "transcript" field was cleared in this mutation.
func (m *CallLogMutation) TranscriptCleared() bool {
	_, ok := m.clearedFields[calllog.FieldTranscript]
	return ok
}

// ResetTranscript resets all changes to the "transcript" field.
func (m *CallLogMutation) ResetTranscript() {
	m.transcript = nil
	delete(m.clearedFields, calllog.FieldTranscript)
}

// SetTenantID sets the "tenant" edge to the Tenant entity by id.
func (m *CallLogMutation) SetTenantID(id int) {
	m.tenant = &id
}

// ClearTenant clears the "tenant" edge to the Tenant entity.
func (m *CallLogMutation) ClearTenant() {
	m.clearedtenant = true
}

// TenantCleared reports if the "tenant" edge to the Tenant entity was cleared.
func (m *CallLogMutation) TenantCleared() bool {
	return m.clearedtenant
}

// TenantID returns the "tenant" edge ID in the mutation.
func (m *CallLogMutation) TenantID() (id int, exists bool) {
	if m.tenant != nil {
		return *m.tenant, true
	}
	return
}

// TenantIDs returns the "tenant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TenantID instead. It exists only for internal usage by the builders.
func (m *CallLogMutation) TenantIDs() (ids []int) {
	if id := m.tenant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTenant resets all changes to the "tenant" edge.
func (m *CallLogMutation) ResetTenant() {
	m.tenant = nil
	m.clearedtenant = false
}

// SetUserID sets the "user" edge to the User entity by id.
func (m *CallLogMutation) SetUserID(id int) {
	m.user = &id
}

// ClearUser clears the "user" edge to the User entity.
func (m *CallLogMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *CallLogMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *CallLogMutation) UserID() (id int, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *CallLogMutation) UserIDs() (ids []int) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *CallLogMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the CallLogMutation builder.
func (m *CallLogMutation) Where(ps ...predicate.CallLog) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CallLogMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CallLogMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.CallLog, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CallLogMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CallLogMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (CallLog).
func (m *CallLogMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CallLogMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.caller != nil {
		fields = append(fields, calllog.FieldCaller)
	}
	if m.callee != nil {
		fields = append(fields, calllog.FieldCallee)
	}
	if m.direction != nil {
		fields = append(fields, calllog.FieldDirection)
	}
	if m.start_time != nil {
		fields = append(fields, calllog.FieldStartTime)
	}
	if m.end_time != nil {
		fields = append(fields, calllog.FieldEndTime)
	}
	if m.duration != nil {
		fields = append(fields, calllog.FieldDuration)
	}
	if m.status != nil {
		fields = append(fields, calllog.FieldStatus)
	}
	if m.recording_path != nil {
		fields = append(fields, calllog.FieldRecordingPath)
	}
	if m.transcript != nil {
		fields = append(fields, calllog.FieldTranscript)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CallLogMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case calllog.FieldCaller:
		return m.Caller()
	case calllog.FieldCallee:
		return m.Callee()
	case calllog.FieldDirection:
		return m.Direction()
	case calllog.FieldStartTime:
		return m.StartTime()
	case calllog.FieldEndTime:
		return m.EndTime()
	case calllog.FieldDuration:
		return m.Duration()
	case calllog.FieldStatus:
		return m.Status()
	case calllog.FieldRecordingPath:
		return m.RecordingPath()
	case calllog.FieldTranscript:
		return m.Transcript()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CallLogMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case calllog.FieldCaller:
		return m.OldCaller(ctx)
	case calllog.FieldCallee:
		return m.OldCallee(ctx)
	case calllog.FieldDirection:
		return m.OldDirection(ctx)
	case calllog.FieldStartTime:
		return m.OldStartTime(ctx)
	case calllog.FieldEndTime:
		return m.OldEndTime(ctx)
	case calllog.FieldDuration:
		return m.OldDuration(ctx)
	case calllog.FieldStatus:
		return m.OldStatus(ctx)
	case calllog.FieldRecordingPath:
		return m.OldRecordingPath(ctx)
	case calllog.FieldTranscript:
		return m.OldTranscript(ctx)
	}
	return nil, fmt.Errorf("unknown CallLog field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CallLogMutation) SetField(name string, value ent.Value) error {
	switch name {
	case calllog.FieldCaller:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCaller(v)
		return nil
	case calllog.FieldCallee:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCallee(v)
		return nil
	case calllog.FieldDirection:
		v, ok := value.(calllog.Direction)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDirection(v)
		return nil
	case calllog.FieldStartTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartTime(v)
		return nil
	case calllog.FieldEndTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndTime(v)
		return nil
	case calllog.FieldDuration:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDuration(v)
		return nil
	case calllog.FieldStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case calllog.FieldRecordingPath:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRecordingPath(v)
		return nil
	case calllog.FieldTranscript:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTranscript(v)
		return nil
	}
	return fmt.Errorf("unknown CallLog field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CallLogMutation) AddedFields() []string {
	var fields []string
	if m.addduration != nil {
		fields = append(fields, calllog.FieldDuration)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CallLogMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case calllog.FieldDuration:
		return m.AddedDuration()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CallLogMutation) AddField(name string, value ent.Value) error {
	switch name {
	case calllog.FieldDuration:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDuration(v)
		return nil
	}
	return fmt.Errorf("unknown CallLog numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CallLogMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(calllog.FieldEndTime) {
		fields = append(fields, calllog.FieldEndTime)
	}
	if m.FieldCleared(calllog.FieldRecordingPath) {
		fields = append(fields, calllog.FieldRecordingPath)
	}
	if m.FieldCleared(calllog.FieldTranscript) {
		fields = append(fields, calllog.FieldTranscript)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CallLogMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CallLogMutation) ClearField(name string) error {
	switch name {
	case calllog.FieldEndTime:
		m.ClearEndTime()
		return nil
	case calllog.FieldRecordingPath:
		m.ClearRecordingPath()
		return nil
	case calllog.FieldTranscript:
		m.ClearTranscript()
		return nil
	}
	return fmt.Errorf("unknown CallLog nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CallLogMutation) ResetField(name string) error {
	switch name {
	case calllog.FieldCaller:
		m.ResetCaller()
		return nil
	case calllog.FieldCallee:
		m.ResetCallee()
		return nil
	case calllog.FieldDirection:
		m.ResetDirection()
		return nil
	case calllog.FieldStartTime:
		m.ResetStartTime()
		return nil
	case calllog.FieldEndTime:
		m.ResetEndTime()
		return nil
	case calllog.FieldDuration:
		m.ResetDuration()
		return nil
	case calllog.FieldStatus:
		m.ResetStatus()
		return nil
	case calllog.FieldRecordingPath:
		m.ResetRecordingPath()
		return nil
	case calllog.FieldTranscript:
		m.ResetTranscript()
		return nil
	}
	return fmt.Errorf("unknown CallLog field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CallLogMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.tenant != nil {
		edges = append(edges, calllog.EdgeTenant)
	}
	if m.user != nil {
		edges = append(edges, calllog.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CallLogMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case calllog.EdgeTenant:
		if id := m.tenant; id != nil {
			return []ent.Value{*id}
		}
	case calllog.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CallLogMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CallLogMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CallLogMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedtenant {
		edges = append(edges, calllog.EdgeTenant)
	}
	if m.cleareduser {
		edges = append(edges, calllog.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CallLogMutation) EdgeCleared(name string) bool {
	switch name {
	case calllog.EdgeTenant:
		return m.clearedtenant
	case calllog.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CallLogMutation) ClearEdge(name string) error {
	switch name {
	case calllog.EdgeTenant:
		m.ClearTenant()
		return nil
	case calllog.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown CallLog unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CallLogMutation) ResetEdge(name string) error {
	switch name {
	case calllog.EdgeTenant:
		m.ResetTenant()
		return nil
	case calllog.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown CallLog edge %s", name)
}

// CameraMutation represents an operation that mutates the Camera nodes in the graph.
type CameraMutation struct {
	config
	op                Op
	typ               string
	id                *int
	name              *string
	rtsp_url          *string
	ip_address        *string
	onvif_port        *int
	addonvif_port     *int
	username          *string
	password          *string
	created_at        *time.Time
	updated_at        *time.Time
	clearedFields     map[string]struct{}
	tenant            *int
	clearedtenant     bool
	recordings        map[int]struct{}
	removedrecordings map[int]struct{}
	clearedrecordings bool
	detections        map[int]struct{}
	removeddetections map[int]struct{}
	cleareddetections bool
	done              bool
	oldValue          func(context.Context) (*Camera, error)
	predicates        []predicate.Camera
}

var _ ent.Mutation = (*CameraMutation)(nil)

// cameraOption allows management of the mutation configuration using functional options.
type cameraOption func(*CameraMutation)

// newCameraMutation creates new mutation for the Camera entity.
func newCameraMutation(c config, op Op, opts ...cameraOption) *CameraMutation {
	m := &CameraMutation{
		config:        c,
		op:            op,
		typ:           TypeCamera,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCameraID sets the ID field of the mutation.
func withCameraID(id int) cameraOption {
	return func(m *CameraMutation) {
		var (
			err   error
			once  sync.Once
			value *Camera
		)
		m.oldValue = func(ctx context.Context) (*Camera, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Camera.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCamera sets the old Camera of the mutation.
func withCamera(node *Camera) cameraOption {
	return func(m *CameraMutation) {
		m.oldValue = func(context.Context) (*Camera, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CameraMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CameraMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CameraMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CameraMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Camera.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *CameraMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *CameraMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Camera entity.
// If the Camera object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CameraMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *CameraMutation) ResetName() {
	m.name = nil
}

// SetRtspURL sets the "rtsp_url" field.
func (m *CameraMutation) SetRtspURL(s string) {
	m.rtsp_url = &s
}

// RtspURL returns the value of the "rtsp_url" field in the mutation.
func (m *CameraMutation) RtspURL() (r string, exists bool) {
	v := m.rtsp_url
	if v == nil {
		return
	}
	return *v, true
}

// OldRtspURL returns the old "rtsp_url" field's value of the Camera entity.
// If the Camera object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CameraMutation) OldRtspURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRtspURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRtspURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRtspURL: %w", err)
	}
	return oldValue.RtspURL, nil
}

// ResetRtspURL resets all changes to the "rtsp_url" field.
func (m *CameraMutation) ResetRtspURL() {
	m.rtsp_url = nil
}

// SetIPAddress sets the "ip_address" field.
func (m *CameraMutation) SetIPAddress(s string) {
	m.ip_address = &s
}

// IPAddress returns the value of the "ip_address" field in the mutation.
func (m *CameraMutation) IPAddress() (r string, exists bool) {
	v := m.ip_address
	if v == nil {
		return
	}
	return *v, true
}

// OldIPAddress returns the old "ip_address" field's value of the Camera entity.
// If the Camera object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CameraMutation) OldIPAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIPAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIPAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIPAddress: %w", err)
	}
	return oldValue.IPAddress, nil
}

// ClearIPAddress clears the value of the "ip_address" field.
func (m *CameraMutation) ClearIPAddress() {
	m.ip_address = nil
	m.clearedFields[camera.FieldIPAddress] = struct{}{}
}

// IPAddressCleared returns if the "ip_address" field was cleared in this mutation.
func (m *CameraMutation) IPAddressCleared() bool {
	_, ok := m.clearedFields[camera.FieldIPAddress]
	return ok
}

// ResetIPAddress resets all changes to the "ip_address" field.
func (m *CameraMutation) ResetIPAddress() {
	m.ip_address = nil
	delete(m.clearedFields, camera.FieldIPAddress)
}

// SetOnvifPort sets the "onvif_port" field.
func (m *CameraMutation) SetOnvifPort(i int) {
	m.onvif_port = &i
	m.addonvif_port = nil
}

// OnvifPort returns the value of the "onvif_port" field in the mutation.
func (m *CameraMutation) OnvifPort() (r int, exists bool) {
	v := m.onvif_port
	if v == nil {
		return
	}
	return *v, true
}

// OldOnvifPort returns the old "onvif_port" field's value of the Camera entity.
// If the Camera object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CameraMutation) OldOnvifPort(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOnvifPort is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOnvifPort requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOnvifPort: %w", err)
	}
	return oldValue.OnvifPort, nil
}

// AddOnvifPort adds i to the "onvif_port" field.
func (m *CameraMutation) AddOnvifPort(i int) {
	if m.addonvif_port != nil {
		*m.addonvif_port += i
	} else {
		m.addonvif_port = &i
	}
}

// AddedOnvifPort returns the value that was added to the "onvif_port" field in this mutation.
func (m *CameraMutation) AddedOnvifPort() (r int, exists bool) {
	v := m.addonvif_port
	if v == nil {
		return
	}
	return *v, true
}

// ResetOnvifPort resets all changes to the "onvif_port" field.
func (m *CameraMutation) ResetOnvifPort() {
	m.onvif_port = nil
	m.addonvif_port = nil
}

// SetUsername sets the "username" field.
func (m *CameraMutation) SetUsername(s string) {
	m.username = &s
}

// Username returns the value of the "username" field in the mutation.
func (m *CameraMutation) Username() (r string, exists bool) {
	v := m.username
	if v == nil {
		return
	}
	return *v, true
}

// OldUsername returns the old "username" field's value of the Camera entity.
// If the Camera object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CameraMutation) OldUsername(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsername is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsername requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsername: %w", err)
	}
	return oldValue.Username, nil
}

// ClearUsername clears the value of the "username" field.
func (m *CameraMutation) ClearUsername() {
	m.username = nil
	m.clearedFields[camera.FieldUsername] = struct{}{}
}

// UsernameCleared returns if the "username" field was cleared in this mutation.
func (m *CameraMutation) UsernameCleared() bool {
	_, ok := m.clearedFields[camera.FieldUsername]
	return ok
}

// ResetUsername resets all changes to the "username" field.
func (m *CameraMutation) ResetUsername() {
	m.username = nil
	delete(m.clearedFields, camera.FieldUsername)
}

// SetPassword sets the "password" field.
func (m *CameraMutation) SetPassword(s string) {
	m.password = &s
}

// Password returns the value of the "password" field in the mutation.
func (m *CameraMutation) Password() (r string, exists bool) {
	v := m.password
	if v == nil {
		return
	}
	return *v, true
}

// OldPassword returns the old "password" field's value of the Camera entity.
// If the Camera object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CameraMutation) OldPassword(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPassword is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPassword: %w", err)
	}
	return oldValue.Password, nil
}

// ClearPassword clears the value of the "password" field.
func (m *CameraMutation) ClearPassword() {
	m.password = nil
	m.clearedFields[camera.FieldPassword] = struct{}{}
}

// PasswordCleared returns if the "password" field was cleared in this mutation.
func (m *CameraMutation) PasswordCleared() bool {
	_, ok := m.clearedFields[camera.FieldPassword]
	return ok
}

// ResetPassword resets all changes to the "password" field.
func (m *CameraMutation) ResetPassword() {
	m.password = nil
	delete(m.clearedFields, camera.FieldPassword)
}

// SetCreatedAt sets the "created_at" field.
func (m *CameraMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *CameraMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Camera entity.
// If the Camera object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CameraMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *CameraMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *CameraMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *CameraMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Camera entity.
// If the Camera object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CameraMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *CameraMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetTenantID sets the "tenant" edge to the Tenant entity by id.
func (m *CameraMutation) SetTenantID(id int) {
	m.tenant = &id
}

// ClearTenant clears the "tenant" edge to the Tenant entity.
func (m *CameraMutation) ClearTenant() {
	m.clearedtenant = true
}

// TenantCleared reports if the "tenant" edge to the Tenant entity was cleared.
func (m *CameraMutation) TenantCleared() bool {
	return m.clearedtenant
}

// TenantID returns the "tenant" edge ID in the mutation.
func (m *CameraMutation) TenantID() (id int, exists bool) {
	if m.tenant != nil {
		return *m.tenant, true
	}
	return
}

// TenantIDs returns the "tenant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TenantID instead. It exists only for internal usage by the builders.
func (m *CameraMutation) TenantIDs() (ids []int) {
	if id := m.tenant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTenant resets all changes to the "tenant" edge.
func (m *CameraMutation) ResetTenant() {
	m.tenant = nil
	m.clearedtenant = false
}

// AddRecordingIDs adds the "recordings" edge to the Recording entity by ids.
func (m *CameraMutation) AddRecordingIDs(ids ...int) {
	if m.recordings == nil {
		m.recordings = make(map[int]struct{})
	}
	for i := range ids {
		m.recordings[ids[i]] = struct{}{}
	}
}

// ClearRecordings clears the "recordings" edge to the Recording entity.
func (m *CameraMutation) ClearRecordings() {
	m.clearedrecordings = true
}

// RecordingsCleared reports if the "recordings" edge to the Recording entity was cleared.
func (m *CameraMutation) RecordingsCleared() bool {
	return m.clearedrecordings
}

// RemoveRecordingIDs removes the "recordings" edge to the Recording entity by IDs.
func (m *CameraMutation) RemoveRecordingIDs(ids ...int) {
	if m.removedrecordings == nil {
		m.removedrecordings = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.recordings, ids[i])
		m.removedrecordings[ids[i]] = struct{}{}
	}
}

// RemovedRecordings returns the removed IDs of the "recordings" edge to the Recording entity.
func (m *CameraMutation) RemovedRecordingsIDs() (ids []int) {
	for id := range m.removedrecordings {
		ids = append(ids, id)
	}
	return
}

// RecordingsIDs returns the "recordings" edge IDs in the mutation.
func (m *CameraMutation) RecordingsIDs() (ids []int) {
	for id := range m.recordings {
		ids = append(ids, id)
	}
	return
}

// ResetRecordings resets all changes to the "recordings" edge.
func (m *CameraMutation) ResetRecordings() {
	m.recordings = nil
	m.clearedrecordings = false
	m.removedrecordings = nil
}

// AddDetectionIDs adds the "detections" edge to the DetectionEvent entity by ids.
func (m *CameraMutation) AddDetectionIDs(ids ...int) {
	if m.detections == nil {
		m.detections = make(map[int]struct{})
	}
	for i := range ids {
		m.detections[ids[i]] = struct{}{}
	}
}

// ClearDetections clears the "detections" edge to the DetectionEvent entity.
func (m *CameraMutation) ClearDetections() {
	m.cleareddetections = true
}

// DetectionsCleared reports if the "detections" edge to the DetectionEvent entity was cleared.
func (m *CameraMutation) DetectionsCleared() bool {
	return m.cleareddetections
}

// RemoveDetectionIDs removes the "detections" edge to the DetectionEvent entity by IDs.
func (m *CameraMutation) RemoveDetectionIDs(ids ...int) {
	if m.removeddetections == nil {
		m.removeddetections = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.detections, ids[i])
		m.removeddetections[ids[i]] = struct{}{}
	}
}

// RemovedDetections returns the removed IDs of the "detections" edge to the DetectionEvent entity.
func (m *CameraMutation) RemovedDetectionsIDs() (ids []int) {
	for id := range m.removeddetections {
		ids = append(ids, id)
	}
	return
}

// DetectionsIDs returns the "detections" edge IDs in the mutation.
func (m *CameraMutation) DetectionsIDs() (ids []int) {
	for id := range m.detections {
		ids = append(ids, id)
	}
	return
}

// ResetDetections resets all changes to the "detections" edge.
func (m *CameraMutation) ResetDetections() {
	m.detections = nil
	m.cleareddetections = false
	m.removeddetections = nil
}

// Where appends a list predicates to the CameraMutation builder.
func (m *CameraMutation) Where(ps ...predicate.Camera) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CameraMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CameraMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Camera, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CameraMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CameraMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Camera).
func (m *CameraMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CameraMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.name != nil {
		fields = append(fields, camera.FieldName)
	}
	if m.rtsp_url != nil {
		fields = append(fields, camera.FieldRtspURL)
	}
	if m.ip_address != nil {
		fields = append(fields, camera.FieldIPAddress)
	}
	if m.onvif_port != nil {
		fields = append(fields, camera.FieldOnvifPort)
	}
	if m.username != nil {
		fields = append(fields, camera.FieldUsername)
	}
	if m.password != nil {
		fields = append(fields, camera.FieldPassword)
	}
	if m.created_at != nil {
		fields = append(fields, camera.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, camera.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CameraMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case camera.FieldName:
		return m.Name()
	case camera.FieldRtspURL:
		return m.RtspURL()
	case camera.FieldIPAddress:
		return m.IPAddress()
	case camera.FieldOnvifPort:
		return m.OnvifPort()
	case camera.FieldUsername:
		return m.Username()
	case camera.FieldPassword:
		return m.Password()
	case camera.FieldCreatedAt:
		return m.CreatedAt()
	case camera.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CameraMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case camera.FieldName:
		return m.OldName(ctx)
	case camera.FieldRtspURL:
		return m.OldRtspURL(ctx)
	case camera.FieldIPAddress:
		return m.OldIPAddress(ctx)
	case camera.FieldOnvifPort:
		return m.OldOnvifPort(ctx)
	case camera.FieldUsername:
		return m.OldUsername(ctx)
	case camera.FieldPassword:
		return m.OldPassword(ctx)
	case camera.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case camera.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Camera field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CameraMutation) SetField(name string, value ent.Value) error {
	switch name {
	case camera.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case camera.FieldRtspURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRtspURL(v)
		return nil
	case camera.FieldIPAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIPAddress(v)
		return nil
	case camera.FieldOnvifPort:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOnvifPort(v)
		return nil
	case camera.FieldUsername:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsername(v)
		return nil
	case camera.FieldPassword:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPassword(v)
		return nil
	case camera.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case camera.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Camera field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CameraMutation) AddedFields() []string {
	var fields []string
	if m.addonvif_port != nil {
		fields = append(fields, camera.FieldOnvifPort)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CameraMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case camera.FieldOnvifPort:
		return m.AddedOnvifPort()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CameraMutation) AddField(name string, value ent.Value) error {
	switch name {
	case camera.FieldOnvifPort:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOnvifPort(v)
		return nil
	}
	return fmt.Errorf("unknown Camera numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CameraMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(camera.FieldIPAddress) {
		fields = append(fields, camera.FieldIPAddress)
	}
	if m.FieldCleared(camera.FieldUsername) {
		fields = append(fields, camera.FieldUsername)
	}
	if m.FieldCleared(camera.FieldPassword) {
		fields = append(fields, camera.FieldPassword)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CameraMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CameraMutation) ClearField(name string) error {
	switch name {
	case camera.FieldIPAddress:
		m.ClearIPAddress()
		return nil
	case camera.FieldUsername:
		m.ClearUsername()
		return nil
	case camera.FieldPassword:
		m.ClearPassword()
		return nil
	}
	return fmt.Errorf("unknown Camera nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CameraMutation) ResetField(name string) error {
	switch name {
	case camera.FieldName:
		m.ResetName()
		return nil
	case camera.FieldRtspURL:
		m.ResetRtspURL()
		return nil
	case camera.FieldIPAddress:
		m.ResetIPAddress()
		return nil
	case camera.FieldOnvifPort:
		m.ResetOnvifPort()
		return nil
	case camera.FieldUsername:
		m.ResetUsername()
		return nil
	case camera.FieldPassword:
		m.ResetPassword()
		return nil
	case camera.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case camera.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Camera field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CameraMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.tenant != nil {
		edges = append(edges, camera.EdgeTenant)
	}
	if m.recordings != nil {
		edges = append(edges, camera.EdgeRecordings)
	}
	if m.detections != nil {
		edges = append(edges, camera.EdgeDetections)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CameraMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case camera.EdgeTenant:
		if id := m.tenant; id != nil {
			return []ent.Value{*id}
		}
	case camera.EdgeRecordings:
		ids := make([]ent.Value, 0, len(m.recordings))
		for id := range m.recordings {
			ids = append(ids, id)
		}
		return ids
	case camera.EdgeDetections:
		ids := make([]ent.Value, 0, len(m.detections))
		for id := range m.detections {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CameraMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedrecordings != nil {
		edges = append(edges, camera.EdgeRecordings)
	}
	if m.removeddetections != nil {
		edges = append(edges, camera.EdgeDetections)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CameraMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case camera.EdgeRecordings:
		ids := make([]ent.Value, 0, len(m.removedrecordings))
		for id := range m.removedrecordings {
			ids = append(ids, id)
		}
		return ids
	case camera.EdgeDetections:
		ids := make([]ent.Value, 0, len(m.removeddetections))
		for id := range m.removeddetections {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CameraMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedtenant {
		edges = append(edges, camera.EdgeTenant)
	}
	if m.clearedrecordings {
		edges = append(edges, camera.EdgeRecordings)
	}
	if m.cleareddetections {
		edges = append(edges, camera.EdgeDetections)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CameraMutation) EdgeCleared(name string) bool {
	switch name {
	case camera.EdgeTenant:
		return m.clearedtenant
	case camera.EdgeRecordings:
		return m.clearedrecordings
	case camera.EdgeDetections:
		return m.cleareddetections
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CameraMutation) ClearEdge(name string) error {
	switch name {
	case camera.EdgeTenant:
		m.ClearTenant()
		return nil
	}
	return fmt.Errorf("unknown Camera unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CameraMutation) ResetEdge(name string) error {
	switch name {
	case camera.EdgeTenant:
		m.ResetTenant()
		return nil
	case camera.EdgeRecordings:
		m.ResetRecordings()
		return nil
	case camera.EdgeDetections:
		m.ResetDetections()
		return nil
	}
	return fmt.Errorf("unknown Camera edge %s", name)
}

// CompensationAgreementMutation represents an operation that mutates the CompensationAgreement nodes in the graph.
type CompensationAgreementMutation struct {
	config
	op              Op
	typ             string
	id              *int
	base_salary     *float64
	addbase_salary  *float64
	currency        *string
	effective_date  *time.Time
	status          *compensationagreement.Status
	created_at      *time.Time
	clearedFields   map[string]struct{}
	tenant          *int
	clearedtenant   bool
	employee        *int
	clearedemployee bool
	done            bool
	oldValue        func(context.Context) (*CompensationAgreement, error)
	predicates      []predicate.CompensationAgreement
}

var _ ent.Mutation = (*CompensationAgreementMutation)(nil)

// compensationagreementOption allows management of the mutation configuration using functional options.
type compensationagreementOption func(*CompensationAgreementMutation)

// newCompensationAgreementMutation creates new mutation for the CompensationAgreement entity.
func newCompensationAgreementMutation(c config, op Op, opts ...compensationagreementOption) *CompensationAgreementMutation {
	m := &CompensationAgreementMutation{
		config:        c,
		op:            op,
		typ:           TypeCompensationAgreement,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCompensationAgreementID sets the ID field of the mutation.
func withCompensationAgreementID(id int) compensationagreementOption {
	return func(m *CompensationAgreementMutation) {
		var (
			err   error
			once  sync.Once
			value *CompensationAgreement
		)
		m.oldValue = func(ctx context.Context) (*CompensationAgreement, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CompensationAgreement.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCompensationAgreement sets the old CompensationAgreement of the mutation.
func withCompensationAgreement(node *CompensationAgreement) compensationagreementOption {
	return func(m *CompensationAgreementMutation) {
		m.oldValue = func(context.Context) (*CompensationAgreement, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CompensationAgreementMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CompensationAgreementMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CompensationAgreementMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CompensationAgreementMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().CompensationAgreement.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetBaseSalary sets the "base_salary" field.
func (m *CompensationAgreementMutation) SetBaseSalary(f float64) {
	m.base_salary = &f
	m.addbase_salary = nil
}

// BaseSalary returns the value of the "base_salary" field in the mutation.
func (m *CompensationAgreementMutation) BaseSalary() (r float64, exists bool) {
	v := m.base_salary
	if v == nil {
		return
	}
	return *v, true
}

// OldBaseSalary returns the old "base_salary" field's value of the CompensationAgreement entity.
// If the CompensationAgreement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CompensationAgreementMutation) OldBaseSalary(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBaseSalary is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBaseSalary requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBaseSalary: %w", err)
	}
	return oldValue.BaseSalary, nil
}

// AddBaseSalary adds f to the "base_salary" field.
func (m *CompensationAgreementMutation) AddBaseSalary(f float64) {
	if m.addbase_salary != nil {
		*m.addbase_salary += f
	} else {
		m.addbase_salary = &f
	}
}

// AddedBaseSalary returns the value that was added to the "base_salary" field in this mutation.
func (m *CompensationAgreementMutation) AddedBaseSalary() (r float64, exists bool) {
	v := m.addbase_salary
	if v == nil {
		return
	}
	return *v, true
}

// ResetBaseSalary resets all changes to the "base_salary" field.
func (m *CompensationAgreementMutation) ResetBaseSalary() {
	m.base_salary = nil
	m.addbase_salary = nil
}

// SetCurrency sets the "currency" field.
func (m *CompensationAgreementMutation) SetCurrency(s string) {
	m.currency = &s
}

// Currency returns the value of the "currency" field in the mutation.
func (m *CompensationAgreementMutation) Currency() (r string, exists bool) {
	v := m.currency
	if v == nil {
		return
	}
	return *v, true
}

// OldCurrency returns the old "currency" field's value of the CompensationAgreement entity.
// If the CompensationAgreement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CompensationAgreementMutation) OldCurrency(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCurrency is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCurrency requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCurrency: %w", err)
	}
	return oldValue.Currency, nil
}

// ResetCurrency resets all changes to the "currency" field.
func (m *CompensationAgreementMutation) ResetCurrency() {
	m.currency = nil
}

// SetEffectiveDate sets the "effective_date" field.
func (m *CompensationAgreementMutation) SetEffectiveDate(t time.Time) {
	m.effective_date = &t
}

// EffectiveDate returns the value of the "effective_date" field in the mutation.
func (m *CompensationAgreementMutation) EffectiveDate() (r time.Time, exists bool) {
	v := m.effective_date
	if v == nil {
		return
	}
	return *v, true
}

// OldEffectiveDate returns the old "effective_date" field's value of the CompensationAgreement entity.
// If the CompensationAgreement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CompensationAgreementMutation) OldEffectiveDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEffectiveDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEffectiveDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEffectiveDate: %w", err)
	}
	return oldValue.EffectiveDate, nil
}

// ResetEffectiveDate resets all changes to the "effective_date" field.
func (m *CompensationAgreementMutation) ResetEffectiveDate() {
	m.effective_date = nil
}

// SetStatus sets the "status" field.
func (m *CompensationAgreementMutation) SetStatus(c compensationagreement.Status) {
	m.status = &c
}

// Status returns the value of the "status" field in the mutation.
func (m *CompensationAgreementMutation) Status() (r compensationagreement.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the CompensationAgreement entity.
// If the CompensationAgreement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CompensationAgreementMutation) OldStatus(ctx context.Context) (v compensationagreement.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *CompensationAgreementMutation) ResetStatus() {
	m.status = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *CompensationAgreementMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *CompensationAgreementMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the CompensationAgreement entity.
// If the CompensationAgreement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CompensationAgreementMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *CompensationAgreementMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetTenantID sets the "tenant" edge to the Tenant entity by id.
func (m *CompensationAgreementMutation) SetTenantID(id int) {
	m.tenant = &id
}

// ClearTenant clears the "tenant" edge to the Tenant entity.
func (m *CompensationAgreementMutation) ClearTenant() {
	m.clearedtenant = true
}

// TenantCleared reports if the "tenant" edge to the Tenant entity was cleared.
func (m *CompensationAgreementMutation) TenantCleared() bool {
	return m.clearedtenant
}

// TenantID returns the "tenant" edge ID in the mutation.
func (m *CompensationAgreementMutation) TenantID() (id int, exists bool) {
	if m.tenant != nil {
		return *m.tenant, true
	}
	return
}

// TenantIDs returns the "tenant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TenantID instead. It exists only for internal usage by the builders.
func (m *CompensationAgreementMutation) TenantIDs() (ids []int) {
	if id := m.tenant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTenant resets all changes to the "tenant" edge.
func (m *CompensationAgreementMutation) ResetTenant() {
	m.tenant = nil
	m.clearedtenant = false
}

// SetEmployeeID sets the "employee" edge to the Employee entity by id.
func (m *CompensationAgreementMutation) SetEmployeeID(id int) {
	m.employee = &id
}

// ClearEmployee clears the "employee" edge to the Employee entity.
func (m *CompensationAgreementMutation) ClearEmployee() {
	m.clearedemployee = true
}

// EmployeeCleared reports if the "employee" edge to the Employee entity was cleared.
func (m *CompensationAgreementMutation) EmployeeCleared() bool {
	return m.clearedemployee
}

// EmployeeID returns the "employee" edge ID in the mutation.
func (m *CompensationAgreementMutation) EmployeeID() (id int, exists bool) {
	if m.employee != nil {
		return *m.employee, true
	}
	return
}

// EmployeeIDs returns the "employee" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// EmployeeID instead. It exists only for internal usage by the builders.
func (m *CompensationAgreementMutation) EmployeeIDs() (ids []int) {
	if id := m.employee; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEmployee resets all changes to the "employee" edge.
func (m *CompensationAgreementMutation) ResetEmployee() {
	m.employee = nil
	m.clearedemployee = false
}

// Where appends a list predicates to the CompensationAgreementMutation builder.
func (m *CompensationAgreementMutation) Where(ps ...predicate.CompensationAgreement) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CompensationAgreementMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CompensationAgreementMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.CompensationAgreement, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CompensationAgreementMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CompensationAgreementMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (CompensationAgreement).
func (m *CompensationAgreementMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CompensationAgreementMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.base_salary != nil {
		fields = append(fields, compensationagreement.FieldBaseSalary)
	}
	if m.currency != nil {
		fields = append(fields, compensationagreement.FieldCurrency)
	}
	if m.effective_date != nil {
		fields = append(fields, compensationagreement.FieldEffectiveDate)
	}
	if m.status != nil {
		fields = append(fields, compensationagreement.FieldStatus)
	}
	if m.created_at != nil {
		fields = append(fields, compensationagreement.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CompensationAgreementMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case compensationagreement.FieldBaseSalary:
		return m.BaseSalary()
	case compensationagreement.FieldCurrency:
		return m.Currency()
	case compensationagreement.FieldEffectiveDate:
		return m.EffectiveDate()
	case compensationagreement.FieldStatus:
		return m.Status()
	case compensationagreement.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CompensationAgreementMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case compensationagreement.FieldBaseSalary:
		return m.OldBaseSalary(ctx)
	case compensationagreement.FieldCurrency:
		return m.OldCurrency(ctx)
	case compensationagreement.FieldEffectiveDate:
		return m.OldEffectiveDate(ctx)
	case compensationagreement.FieldStatus:
		return m.OldStatus(ctx)
	case compensationagreement.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown CompensationAgreement field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CompensationAgreementMutation) SetField(name string, value ent.Value) error {
	switch name {
	case compensationagreement.FieldBaseSalary:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBaseSalary(v)
		return nil
	case compensationagreement.FieldCurrency:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCurrency(v)
		return nil
	case compensationagreement.FieldEffectiveDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEffectiveDate(v)
		return nil
	case compensationagreement.FieldStatus:
		v, ok := value.(compensationagreement.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case compensationagreement.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown CompensationAgreement field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CompensationAgreementMutation) AddedFields() []string {
	var fields []string
	if m.addbase_salary != nil {
		fields = append(fields, compensationagreement.FieldBaseSalary)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CompensationAgreementMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case compensationagreement.FieldBaseSalary:
		return m.AddedBaseSalary()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CompensationAgreementMutation) AddField(name string, value ent.Value) error {
	switch name {
	case compensationagreement.FieldBaseSalary:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddBaseSalary(v)
		return nil
	}
	return fmt.Errorf("unknown CompensationAgreement numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CompensationAgreementMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CompensationAgreementMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CompensationAgreementMutation) ClearField(name string) error {
	return fmt.Errorf("unknown CompensationAgreement nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CompensationAgreementMutation) ResetField(name string) error {
	switch name {
	case compensationagreement.FieldBaseSalary:
		m.ResetBaseSalary()
		return nil
	case compensationagreement.FieldCurrency:
		m.ResetCurrency()
		return nil
	case compensationagreement.FieldEffectiveDate:
		m.ResetEffectiveDate()
		return nil
	case compensationagreement.FieldStatus:
		m.ResetStatus()
		return nil
	case compensationagreement.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown CompensationAgreement field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CompensationAgreementMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.tenant != nil {
		edges = append(edges, compensationagreement.EdgeTenant)
	}
	if m.employee != nil {
		edges = append(edges, compensationagreement.EdgeEmployee)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CompensationAgreementMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case compensationagreement.EdgeTenant:
		if id := m.tenant; id != nil {
			return []ent.Value{*id}
		}
	case compensationagreement.EdgeEmployee:
		if id := m.employee; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CompensationAgreementMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CompensationAgreementMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CompensationAgreementMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedtenant {
		edges = append(edges, compensationagreement.EdgeTenant)
	}
	if m.clearedemployee {
		edges = append(edges, compensationagreement.EdgeEmployee)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CompensationAgreementMutation) EdgeCleared(name string) bool {
	switch name {
	case compensationagreement.EdgeTenant:
		return m.clearedtenant
	case compensationagreement.EdgeEmployee:
		return m.clearedemployee
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CompensationAgreementMutation) ClearEdge(name string) error {
	switch name {
	case compensationagreement.EdgeTenant:
		m.ClearTenant()
		return nil
	case compensationagreement.EdgeEmployee:
		m.ClearEmployee()
		return nil
	}
	return fmt.Errorf("unknown CompensationAgreement unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CompensationAgreementMutation) ResetEdge(name string) error {
	switch name {
	case compensationagreement.EdgeTenant:
		m.ResetTenant()
		return nil
	case compensationagreement.EdgeEmployee:
		m.ResetEmployee()
		return nil
	}
	return fmt.Errorf("unknown CompensationAgreement edge %s", name)
}

// ContractMutation represents an operation that mutates the Contract nodes in the graph.
type ContractMutation struct {
	config
	op                         Op
	typ                        string
	id                         *int
	name                       *string
	_type                      *contract.Type
	total_hours                *float64
	addtotal_hours             *float64
	remaining_hours            *float64
	addremaining_hours         *float64
	grace_threshold_percent    *float64
	addgrace_threshold_percent *float64
	start_date                 *time.Time
	end_date                   *time.Time
	is_active                  *bool
	clearedFields              map[string]struct{}
	tenant                     *int
	clearedtenant              bool
	done                       bool
	oldValue                   func(context.Context) (*Contract, error)
	predicates                 []predicate.Contract
}

var _ ent.Mutation = (*ContractMutation)(nil)

// contractOption allows management of the mutation configuration using functional options.
type contractOption func(*ContractMutation)

// newContractMutation creates new mutation for the Contract entity.
func newContractMutation(c config, op Op, opts ...contractOption) *ContractMutation {
	m := &ContractMutation{
		config:        c,
		op:            op,
		typ:           TypeContract,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withContractID sets the ID field of the mutation.
func withContractID(id int) contractOption {
	return func(m *ContractMutation) {
		var (
			err   error
			once  sync.Once
			value *Contract
		)
		m.oldValue = func(ctx context.Context) (*Contract, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Contract.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withContract sets the old Contract of the mutation.
func withContract(node *Contract) contractOption {
	return func(m *ContractMutation) {
		m.oldValue = func(context.Context) (*Contract, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ContractMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ContractMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ContractMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ContractMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Contract.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *ContractMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ContractMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Contract entity.
// If the Contract object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContractMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ContractMutation) ResetName() {
	m.name = nil
}

// SetType sets the "type" field.
func (m *ContractMutation) SetType(c contract.Type) {
	m._type = &c
}

// GetType returns the value of the "type" field in the mutation.
func (m *ContractMutation) GetType() (r contract.Type, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Contract entity.
// If the Contract object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContractMutation) OldType(ctx context.Context) (v contract.Type, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *ContractMutation) ResetType() {
	m._type = nil
}

// SetTotalHours sets the "total_hours" field.
func (m *ContractMutation) SetTotalHours(f float64) {
	m.total_hours = &f
	m.addtotal_hours = nil
}

// TotalHours returns the value of the "total_hours" field in the mutation.
func (m *ContractMutation) TotalHours() (r float64, exists bool) {
	v := m.total_hours
	if v == nil {
		return
	}
	return *v, true
}

// OldTotalHours returns the old "total_hours" field's value of the Contract entity.
// If the Contract object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContractMutation) OldTotalHours(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTotalHours is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTotalHours requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTotalHours: %w", err)
	}
	return oldValue.TotalHours, nil
}

// AddTotalHours adds f to the "total_hours" field.
func (m *ContractMutation) AddTotalHours(f float64) {
	if m.addtotal_hours != nil {
		*m.addtotal_hours += f
	} else {
		m.addtotal_hours = &f
	}
}

// AddedTotalHours returns the value that was added to the "total_hours" field in this mutation.
func (m *ContractMutation) AddedTotalHours() (r float64, exists bool) {
	v := m.addtotal_hours
	if v == nil {
		return
	}
	return *v, true
}

// ResetTotalHours resets all changes to the "total_hours" field.
func (m *ContractMutation) ResetTotalHours() {
	m.total_hours = nil
	m.addtotal_hours = nil
}

// SetRemainingHours sets the "remaining_hours" field.
func (m *ContractMutation) SetRemainingHours(f float64) {
	m.remaining_hours = &f
	m.addremaining_hours = nil
}

// RemainingHours returns the value of the "remaining_hours" field in the mutation.
func (m *ContractMutation) RemainingHours() (r float64, exists bool) {
	v := m.remaining_hours
	if v == nil {
		return
	}
	return *v, true
}

// OldRemainingHours returns the old "remaining_hours" field's value of the Contract entity.
// If the Contract object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContractMutation) OldRemainingHours(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRemainingHours is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRemainingHours requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemainingHours: %w", err)
	}
	return oldValue.RemainingHours, nil
}

// AddRemainingHours adds f to the "remaining_hours" field.
func (m *ContractMutation) AddRemainingHours(f float64) {
	if m.addremaining_hours != nil {
		*m.addremaining_hours += f
	} else {
		m.addremaining_hours = &f
	}
}

// AddedRemainingHours returns the value that was added to the "remaining_hours" field in this mutation.
func (m *ContractMutation) AddedRemainingHours() (r float64, exists bool) {
	v := m.addremaining_hours
	if v == nil {
		return
	}
	return *v, true
}

// ResetRemainingHours resets all changes to the "remaining_hours" field.
func (m *ContractMutation) ResetRemainingHours() {
	m.remaining_hours = nil
	m.addremaining_hours = nil
}

// SetGraceThresholdPercent sets the "grace_threshold_percent" field.
func (m *ContractMutation) SetGraceThresholdPercent(f float64) {
	m.grace_threshold_percent = &f
	m.addgrace_threshold_percent = nil
}

// GraceThresholdPercent returns the value of the "grace_threshold_percent" field in the mutation.
func (m *ContractMutation) GraceThresholdPercent() (r float64, exists bool) {
	v := m.grace_threshold_percent
	if v == nil {
		return
	}
	return *v, true
}

// OldGraceThresholdPercent returns the old "grace_threshold_percent" field's value of the Contract entity.
// If the Contract object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContractMutation) OldGraceThresholdPercent(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGraceThresholdPercent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGraceThresholdPercent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGraceThresholdPercent: %w", err)
	}
	return oldValue.GraceThresholdPercent, nil
}

// AddGraceThresholdPercent adds f to the "grace_threshold_percent" field.
func (m *ContractMutation) AddGraceThresholdPercent(f float64) {
	if m.addgrace_threshold_percent != nil {
		*m.addgrace_threshold_percent += f
	} else {
		m.addgrace_threshold_percent = &f
	}
}

// AddedGraceThresholdPercent returns the value that was added to the "grace_threshold_percent" field in this mutation.
func (m *ContractMutation) AddedGraceThresholdPercent() (r float64, exists bool) {
	v := m.addgrace_threshold_percent
	if v == nil {
		return
	}
	return *v, true
}

// ResetGraceThresholdPercent resets all changes to the "grace_threshold_percent" field.
func (m *ContractMutation) ResetGraceThresholdPercent() {
	m.grace_threshold_percent = nil
	m.addgrace_threshold_percent = nil
}

// SetStartDate sets the "start_date" field.
func (m *ContractMutation) SetStartDate(t time.Time) {
	m.start_date = &t
}

// StartDate returns the value of the "start_date" field in the mutation.
func (m *ContractMutation) StartDate() (r time.Time, exists bool) {
	v := m.start_date
	if v == nil {
		return
	}
	return *v, true
}

// OldStartDate returns the old "start_date" field's value of the Contract entity.
// If the Contract object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContractMutation) OldStartDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartDate: %w", err)
	}
	return oldValue.StartDate, nil
}

// ResetStartDate resets all changes to the "start_date" field.
func (m *ContractMutation) ResetStartDate() {
	m.start_date = nil
}

// SetEndDate sets the "end_date" field.
func (m *ContractMutation) SetEndDate(t time.Time) {
	m.end_date = &t
}

// EndDate returns the value of the "end_date" field in the mutation.
func (m *ContractMutation) EndDate() (r time.Time, exists bool) {
	v := m.end_date
	if v == nil {
		return
	}
	return *v, true
}

// OldEndDate returns the old "end_date" field's value of the Contract entity.
// If the Contract object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContractMutation) OldEndDate(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEndDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEndDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndDate: %w", err)
	}
	return oldValue.EndDate, nil
}

// ClearEndDate clears the value of the "end_date" field.
func (m *ContractMutation) ClearEndDate() {
	m.end_date = nil
	m.clearedFields[contract.FieldEndDate] = struct{}{}
}

// EndDateCleared returns if the "end_date" field was cleared in this mutation.
func (m *ContractMutation) EndDateCleared() bool {
	_, ok := m.clearedFields[contract.FieldEndDate]
	return ok
}

// ResetEndDate resets all changes to the "end_date" field.
func (m *ContractMutation) ResetEndDate() {
	m.end_date = nil
	delete(m.clearedFields, contract.FieldEndDate)
}

// SetIsActive sets the "is_active" field.
func (m *ContractMutation) SetIsActive(b bool) {
	m.is_active = &b
}

// IsActive returns the value of the "is_active" field in the mutation.
func (m *ContractMutation) IsActive() (r bool, exists bool) {
	v := m.is_active
	if v == nil {
		return
	}
	return *v, true
}

// OldIsActive returns the old "is_active" field's value of the Contract entity.
// If the Contract object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContractMutation) OldIsActive(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsActive is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsActive requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsActive: %w", err)
	}
	return oldValue.IsActive, nil
}

// ResetIsActive resets all changes to the "is_active" field.
func (m *ContractMutation) ResetIsActive() {
	m.is_active = nil
}

// SetTenantID sets the "tenant" edge to the Tenant entity by id.
func (m *ContractMutation) SetTenantID(id int) {
	m.tenant = &id
}

// ClearTenant clears the "tenant" edge to the Tenant entity.
func (m *ContractMutation) ClearTenant() {
	m.clearedtenant = true
}

// TenantCleared reports if the "tenant" edge to the Tenant entity was cleared.
func (m *ContractMutation) TenantCleared() bool {
	return m.clearedtenant
}

// TenantID returns the "tenant" edge ID in the mutation.
func (m *ContractMutation) TenantID() (id int, exists bool) {
	if m.tenant != nil {
		return *m.tenant, true
	}
	return
}

// TenantIDs returns the "tenant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TenantID instead. It exists only for internal usage by the builders.
func (m *ContractMutation) TenantIDs() (ids []int) {
	if id := m.tenant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTenant resets all changes to the "tenant" edge.
func (m *ContractMutation) ResetTenant() {
	m.tenant = nil
	m.clearedtenant = false
}

// Where appends a list predicates to the ContractMutation builder.
func (m *ContractMutation) Where(ps ...predicate.Contract) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ContractMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ContractMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Contract, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ContractMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ContractMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Contract).
func (m *ContractMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ContractMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.name != nil {
		fields = append(fields, contract.FieldName)
	}
	if m._type != nil {
		fields = append(fields, contract.FieldType)
	}
	if m.total_hours != nil {
		fields = append(fields, contract.FieldTotalHours)
	}
	if m.remaining_hours != nil {
		fields = append(fields, contract.FieldRemainingHours)
	}
	if m.grace_threshold_percent != nil {
		fields = append(fields, contract.FieldGraceThresholdPercent)
	}
	if m.start_date != nil {
		fields = append(fields, contract.FieldStartDate)
	}
	if m.end_date != nil {
		fields = append(fields, contract.FieldEndDate)
	}
	if m.is_active != nil {
		fields = append(fields, contract.FieldIsActive)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ContractMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case contract.FieldName:
		return m.Name()
	case contract.FieldType:
		return m.GetType()
	case contract.FieldTotalHours:
		return m.TotalHours()
	case contract.FieldRemainingHours:
		return m.RemainingHours()
	case contract.FieldGraceThresholdPercent:
		return m.GraceThresholdPercent()
	case contract.FieldStartDate:
		return m.StartDate()
	case contract.FieldEndDate:
		return m.EndDate()
	case contract.FieldIsActive:
		return m.IsActive()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ContractMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case contract.FieldName:
		return m.OldName(ctx)
	case contract.FieldType:
		return m.OldType(ctx)
	case contract.FieldTotalHours:
		return m.OldTotalHours(ctx)
	case contract.FieldRemainingHours:
		return m.OldRemainingHours(ctx)
	case contract.FieldGraceThresholdPercent:
		return m.OldGraceThresholdPercent(ctx)
	case contract.FieldStartDate:
		return m.OldStartDate(ctx)
	case contract.FieldEndDate:
		return m.OldEndDate(ctx)
	case contract.FieldIsActive:
		return m.OldIsActive(ctx)
	}
	return nil, fmt.Errorf("unknown Contract field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ContractMutation) SetField(name string, value ent.Value) error {
	switch name {
	case contract.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case contract.FieldType:
		v, ok := value.(contract.Type)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case contract.FieldTotalHours:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTotalHours(v)
		return nil
	case contract.FieldRemainingHours:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemainingHours(v)
		return nil
	case contract.FieldGraceThresholdPercent:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGraceThresholdPercent(v)
		return nil
	case contract.FieldStartDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartDate(v)
		return nil
	case contract.FieldEndDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndDate(v)
		return nil
	case contract.FieldIsActive:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsActive(v)
		return nil
	}
	return fmt.Errorf("unknown Contract field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ContractMutation) AddedFields() []string {
	var fields []string
	if m.addtotal_hours != nil {
		fields = append(fields, contract.FieldTotalHours)
	}
	if m.addremaining_hours != nil {
		fields = append(fields, contract.FieldRemainingHours)
	}
	if m.addgrace_threshold_percent != nil {
		fields = append(fields, contract.FieldGraceThresholdPercent)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ContractMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case contract.FieldTotalHours:
		return m.AddedTotalHours()
	case contract.FieldRemainingHours:
		return m.AddedRemainingHours()
	case contract.FieldGraceThresholdPercent:
		return m.AddedGraceThresholdPercent()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ContractMutation) AddField(name string, value ent.Value) error {
	switch name {
	case contract.FieldTotalHours:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTotalHours(v)
		return nil
	case contract.FieldRemainingHours:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRemainingHours(v)
		return nil
	case contract.FieldGraceThresholdPercent:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddGraceThresholdPercent(v)
		return nil
	}
	return fmt.Errorf("unknown Contract numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ContractMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(contract.FieldEndDate) {
		fields = append(fields, contract.FieldEndDate)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ContractMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ContractMutation) ClearField(name string) error {
	switch name {
	case contract.FieldEndDate:
		m.ClearEndDate()
		return nil
	}
	return fmt.Errorf("unknown Contract nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ContractMutation) ResetField(name string) error {
	switch name {
	case contract.FieldName:
		m.ResetName()
		return nil
	case contract.FieldType:
		m.ResetType()
		return nil
	case contract.FieldTotalHours:
		m.ResetTotalHours()
		return nil
	case contract.FieldRemainingHours:
		m.ResetRemainingHours()
		return nil
	case contract.FieldGraceThresholdPercent:
		m.ResetGraceThresholdPercent()
		return nil
	case contract.FieldStartDate:
		m.ResetStartDate()
		return nil
	case contract.FieldEndDate:
		m.ResetEndDate()
		return nil
	case contract.FieldIsActive:
		m.ResetIsActive()
		return nil
	}
	return fmt.Errorf("unknown Contract field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ContractMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.tenant != nil {
		edges = append(edges, contract.EdgeTenant)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ContractMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case contract.EdgeTenant:
		if id := m.tenant; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ContractMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ContractMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ContractMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedtenant {
		edges = append(edges, contract.EdgeTenant)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ContractMutation) EdgeCleared(name string) bool {
	switch name {
	case contract.EdgeTenant:
		return m.clearedtenant
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ContractMutation) ClearEdge(name string) error {
	switch name {
	case contract.EdgeTenant:
		m.ClearTenant()
		return nil
	}
	return fmt.Errorf("unknown Contract unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ContractMutation) ResetEdge(name string) error {
	switch name {
	case contract.EdgeTenant:
		m.ResetTenant()
		return nil
	}
	return fmt.Errorf("unknown Contract edge %s", name)
}

// CredentialMutation represents an operation that mutates the Credential nodes in the graph.
type CredentialMutation struct {
	config
	op                    Op
	typ                   string
	id                    *int
	name                  *string
	username              *string
	password_encrypted    *[]byte
	last_revealed_at      *time.Time
	created_at            *time.Time
	clearedFields         map[string]struct{}
	tenant                *int
	clearedtenant         bool
	asset                 *int
	clearedasset          bool
	one_time_links        map[int]struct{}
	removedone_time_links map[int]struct{}
	clearedone_time_links bool
	done                  bool
	oldValue              func(context.Context) (*Credential, error)
	predicates            []predicate.Credential
}

var _ ent.Mutation = (*CredentialMutation)(nil)

// credentialOption allows management of the mutation configuration using functional options.
type credentialOption func(*CredentialMutation)

// newCredentialMutation creates new mutation for the Credential entity.
func newCredentialMutation(c config, op Op, opts ...credentialOption) *CredentialMutation {
	m := &CredentialMutation{
		config:        c,
		op:            op,
		typ:           TypeCredential,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCredentialID sets the ID field of the mutation.
func withCredentialID(id int) credentialOption {
	return func(m *CredentialMutation) {
		var (
			err   error
			once  sync.Once
			value *Credential
		)
		m.oldValue = func(ctx context.Context) (*Credential, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Credential.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCredential sets the old Credential of the mutation.
func withCredential(node *Credential) credentialOption {
	return func(m *CredentialMutation) {
		m.oldValue = func(context.Context) (*Credential, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CredentialMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CredentialMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CredentialMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CredentialMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Credential.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *CredentialMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *CredentialMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Credential entity.
// If the Credential object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CredentialMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *CredentialMutation) ResetName() {
	m.name = nil
}

// SetUsername sets the "username" field.
func (m *CredentialMutation) SetUsername(s string) {
	m.username = &s
}

// Username returns the value of the "username" field in the mutation.
func (m *CredentialMutation) Username() (r string, exists bool) {
	v := m.username
	if v == nil {
		return
	}
	return *v, true
}

// OldUsername returns the old "username" field's value of the Credential entity.
// If the Credential object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CredentialMutation) OldUsername(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsername is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsername requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsername: %w", err)
	}
	return oldValue.Username, nil
}

// ClearUsername clears the value of the "username" field.
func (m *CredentialMutation) ClearUsername() {
	m.username = nil
	m.clearedFields[credential.FieldUsername] = struct{}{}
}

// UsernameCleared returns if the "username" field was cleared in this mutation.
func (m *CredentialMutation) UsernameCleared() bool {
	_, ok := m.clearedFields[credential.FieldUsername]
	return ok
}

// ResetUsername resets all changes to the "username" field.
func (m *CredentialMutation) ResetUsername() {
	m.username = nil
	delete(m.clearedFields, credential.FieldUsername)
}

// SetPasswordEncrypted sets the "password_encrypted" field.
func (m *CredentialMutation) SetPasswordEncrypted(b []byte) {
	m.password_encrypted = &b
}

// PasswordEncrypted returns the value of the "password_encrypted" field in the mutation.
func (m *CredentialMutation) PasswordEncrypted() (r []byte, exists bool) {
	v := m.password_encrypted
	if v == nil {
		return
	}
	return *v, true
}

// OldPasswordEncrypted returns the old "password_encrypted" field's value of the Credential entity.
// If the Credential object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CredentialMutation) OldPasswordEncrypted(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPasswordEncrypted is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPasswordEncrypted requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPasswordEncrypted: %w", err)
	}
	return oldValue.PasswordEncrypted, nil
}

// ResetPasswordEncrypted resets all changes to the "password_encrypted" field.
func (m *CredentialMutation) ResetPasswordEncrypted() {
	m.password_encrypted = nil
}

// SetLastRevealedAt sets the "last_revealed_at" field.
func (m *CredentialMutation) SetLastRevealedAt(t time.Time) {
	m.last_revealed_at = &t
}

// LastRevealedAt returns the value of the "last_revealed_at" field in the mutation.
func (m *CredentialMutation) LastRevealedAt() (r time.Time, exists bool) {
	v := m.last_revealed_at
	if v == nil {
		return
	}
	return *v, true
}

// OldLastRevealedAt returns the old "last_revealed_at" field's value of the Credential entity.
// If the Credential object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CredentialMutation) OldLastRevealedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastRevealedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastRevealedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastRevealedAt: %w", err)
	}
	return oldValue.LastRevealedAt, nil
}

// ClearLastRevealedAt clears the value of the "last_revealed_at" field.
func (m *CredentialMutation) ClearLastRevealedAt() {
	m.last_revealed_at = nil
	m.clearedFields[credential.FieldLastRevealedAt] = struct{}{}
}

// LastRevealedAtCleared returns if the "last_revealed_at" field was cleared in this mutation.
func (m *CredentialMutation) LastRevealedAtCleared() bool {
	_, ok := m.clearedFields[credential.FieldLastRevealedAt]
	return ok
}

// ResetLastRevealedAt resets all changes to the "last_revealed_at" field.
func (m *CredentialMutation) ResetLastRevealedAt() {
	m.last_revealed_at = nil
	delete(m.clearedFields, credential.FieldLastRevealedAt)
}

// SetCreatedAt sets the "created_at" field.
func (m *CredentialMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *CredentialMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Credential entity.
// If the Credential object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CredentialMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *CredentialMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetTenantID sets the "tenant" edge to the Tenant entity by id.
func (m *CredentialMutation) SetTenantID(id int) {
	m.tenant = &id
}

// ClearTenant clears the "tenant" edge to the Tenant entity.
func (m *CredentialMutation) ClearTenant() {
	m.clearedtenant = true
}

// TenantCleared reports if the "tenant" edge to the Tenant entity was cleared.
func (m *CredentialMutation) TenantCleared() bool {
	return m.clearedtenant
}

// TenantID returns the "tenant" edge ID in the mutation.
func (m *CredentialMutation) TenantID() (id int, exists bool) {
	if m.tenant != nil {
		return *m.tenant, true
	}
	return
}

// TenantIDs returns the "tenant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TenantID instead. It exists only for internal usage by the builders.
func (m *CredentialMutation) TenantIDs() (ids []int) {
	if id := m.tenant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTenant resets all changes to the "tenant" edge.
func (m *CredentialMutation) ResetTenant() {
	m.tenant = nil
	m.clearedtenant = false
}

// SetAssetID sets the "asset" edge to the Asset entity by id.
func (m *CredentialMutation) SetAssetID(id int) {
	m.asset = &id
}

// ClearAsset clears the "asset" edge to the Asset entity.
func (m *CredentialMutation) ClearAsset() {
	m.clearedasset = true
}

// AssetCleared reports if the "asset" edge to the Asset entity was cleared.
func (m *CredentialMutation) AssetCleared() bool {
	return m.clearedasset
}

// AssetID returns the "asset" edge ID in the mutation.
func (m *CredentialMutation) AssetID() (id int, exists bool) {
	if m.asset != nil {
		return *m.asset, true
	}
	return
}

// AssetIDs returns the "asset" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AssetID instead. It exists only for internal usage by the builders.
func (m *CredentialMutation) AssetIDs() (ids []int) {
	if id := m.asset; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAsset resets all changes to the "asset" edge.
func (m *CredentialMutation) ResetAsset() {
	m.asset = nil
	m.clearedasset = false
}

// AddOneTimeLinkIDs adds the "one_time_links" edge to the OneTimeLink entity by ids.
func (m *CredentialMutation) AddOneTimeLinkIDs(ids ...int) {
	if m.one_time_links == nil {
		m.one_time_links = make(map[int]struct{})
	}
	for i := range ids {
		m.one_time_links[ids[i]] = struct{}{}
	}
}

// ClearOneTimeLinks clears the "one_time_links" edge to the OneTimeLink entity.
func (m *CredentialMutation) ClearOneTimeLinks() {
	m.clearedone_time_links = true
}

// OneTimeLinksCleared reports if the "one_time_links" edge to the OneTimeLink entity was cleared.
func (m *CredentialMutation) OneTimeLinksCleared() bool {
	return m.clearedone_time_links
}

// RemoveOneTimeLinkIDs removes the "one_time_links" edge to the OneTimeLink entity by IDs.
func (m *CredentialMutation) RemoveOneTimeLinkIDs(ids ...int) {
	if m.removedone_time_links == nil {
		m.removedone_time_links = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.one_time_links, ids[i])
		m.removedone_time_links[ids[i]] = struct{}{}
	}
}

// RemovedOneTimeLinks returns the removed IDs of the "one_time_links" edge to the OneTimeLink entity.
func (m *CredentialMutation) RemovedOneTimeLinksIDs() (ids []int) {
	for id := range m.removedone_time_links {
		ids = append(ids, id)
	}
	return
}

// OneTimeLinksIDs returns the "one_time_links" edge IDs in the mutation.
func (m *CredentialMutation) OneTimeLinksIDs() (ids []int) {
	for id := range m.one_time_links {
		ids = append(ids, id)
	}
	return
}

// ResetOneTimeLinks resets all changes to the "one_time_links" edge.
func (m *CredentialMutation) ResetOneTimeLinks() {
	m.one_time_links = nil
	m.clearedone_time_links = false
	m.removedone_time_links = nil
}

// Where appends a list predicates to the CredentialMutation builder.
func (m *CredentialMutation) Where(ps ...predicate.Credential) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CredentialMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CredentialMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Credential, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CredentialMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CredentialMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Credential).
func (m *CredentialMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CredentialMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.name != nil {
		fields = append(fields, credential.FieldName)
	}
	if m.username != nil {
		fields = append(fields, credential.FieldUsername)
	}
	if m.password_encrypted != nil {
		fields = append(fields, credential.FieldPasswordEncrypted)
	}
	if m.last_revealed_at != nil {
		fields = append(fields, credential.FieldLastRevealedAt)
	}
	if m.created_at != nil {
		fields = append(fields, credential.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CredentialMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case credential.FieldName:
		return m.Name()
	case credential.FieldUsername:
		return m.Username()
	case credential.FieldPasswordEncrypted:
		return m.PasswordEncrypted()
	case credential.FieldLastRevealedAt:
		return m.LastRevealedAt()
	case credential.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CredentialMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case credential.FieldName:
		return m.OldName(ctx)
	case credential.FieldUsername:
		return m.OldUsername(ctx)
	case credential.FieldPasswordEncrypted:
		return m.OldPasswordEncrypted(ctx)
	case credential.FieldLastRevealedAt:
		return m.OldLastRevealedAt(ctx)
	case credential.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Credential field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CredentialMutation) SetField(name string, value ent.Value) error {
	switch name {
	case credential.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case credential.FieldUsername:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsername(v)
		return nil
	case credential.FieldPasswordEncrypted:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPasswordEncrypted(v)
		return nil
	case credential.FieldLastRevealedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastRevealedAt(v)
		return nil
	case credential.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Credential field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CredentialMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CredentialMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CredentialMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Credential numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CredentialMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(credential.FieldUsername) {
		fields = append(fields, credential.FieldUsername)
	}
	if m.FieldCleared(credential.FieldLastRevealedAt) {
		fields = append(fields, credential.FieldLastRevealedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CredentialMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CredentialMutation) ClearField(name string) error {
	switch name {
	case credential.FieldUsername:
		m.ClearUsername()
		return nil
	case credential.FieldLastRevealedAt:
		m.ClearLastRevealedAt()
		return nil
	}
	return fmt.Errorf("unknown Credential nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CredentialMutation) ResetField(name string) error {
	switch name {
	case credential.FieldName:
		m.ResetName()
		return nil
	case credential.FieldUsername:
		m.ResetUsername()
		return nil
	case credential.FieldPasswordEncrypted:
		m.ResetPasswordEncrypted()
		return nil
	case credential.FieldLastRevealedAt:
		m.ResetLastRevealedAt()
		return nil
	case credential.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown Credential field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CredentialMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.tenant != nil {
		edges = append(edges, credential.EdgeTenant)
	}
	if m.asset != nil {
		edges = append(edges, credential.EdgeAsset)
	}
	if m.one_time_links != nil {
		edges = append(edges, credential.EdgeOneTimeLinks)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CredentialMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case credential.EdgeTenant:
		if id := m.tenant; id != nil {
			return []ent.Value{*id}
		}
	case credential.EdgeAsset:
		if id := m.asset; id != nil {
			return []ent.Value{*id}
		}
	case credential.EdgeOneTimeLinks:
		ids := make([]ent.Value, 0, len(m.one_time_links))
		for id := range m.one_time_links {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CredentialMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedone_time_links != nil {
		edges = append(edges, credential.EdgeOneTimeLinks)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CredentialMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case credential.EdgeOneTimeLinks:
		ids := make([]ent.Value, 0, len(m.removedone_time_links))
		for id := range m.removedone_time_links {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CredentialMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedtenant {
		edges = append(edges, credential.EdgeTenant)
	}
	if m.clearedasset {
		edges = append(edges, credential.EdgeAsset)
	}
	if m.clearedone_time_links {
		edges = append(edges, credential.EdgeOneTimeLinks)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CredentialMutation) EdgeCleared(name string) bool {
	switch name {
	case credential.EdgeTenant:
		return m.clearedtenant
	case credential.EdgeAsset:
		return m.clearedasset
	case credential.EdgeOneTimeLinks:
		return m.clearedone_time_links
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CredentialMutation) ClearEdge(name string) error {
	switch name {
	case credential.EdgeTenant:
		m.ClearTenant()
		return nil
	case credential.EdgeAsset:
		m.ClearAsset()
		return nil
	}
	return fmt.Errorf("unknown Credential unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CredentialMutation) ResetEdge(name string) error {
	switch name {
	case credential.EdgeTenant:
		m.ResetTenant()
		return nil
	case credential.EdgeAsset:
		m.ResetAsset()
		return nil
	case credential.EdgeOneTimeLinks:
		m.ResetOneTimeLinks()
		return nil
	}
	return fmt.Errorf("unknown Credential edge %s", name)
}

// DepartmentMutation represents an operation that mutates the Department nodes in the graph.
type DepartmentMutation struct {
	config
	op              Op
	typ             string
	id              *int
	name            *string
	code            *string
	description     *string
	clearedFields   map[string]struct{}
	parent          *int
	clearedparent   bool
	children        map[int]struct{}
	removedchildren map[int]struct{}
	clearedchildren bool
	members         map[int]struct{}
	removedmembers  map[int]struct{}
	clearedmembers  bool
	head            *int
	clearedhead     bool
	done            bool
	oldValue        func(context.Context) (*Department, error)
	predicates      []predicate.Department
}

var _ ent.Mutation = (*DepartmentMutation)(nil)

// departmentOption allows management of the mutation configuration using functional options.
type departmentOption func(*DepartmentMutation)

// newDepartmentMutation creates new mutation for the Department entity.
func newDepartmentMutation(c config, op Op, opts ...departmentOption) *DepartmentMutation {
	m := &DepartmentMutation{
		config:        c,
		op:            op,
		typ:           TypeDepartment,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDepartmentID sets the ID field of the mutation.
func withDepartmentID(id int) departmentOption {
	return func(m *DepartmentMutation) {
		var (
			err   error
			once  sync.Once
			value *Department
		)
		m.oldValue = func(ctx context.Context) (*Department, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Department.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDepartment sets the old Department of the mutation.
func withDepartment(node *Department) departmentOption {
	return func(m *DepartmentMutation) {
		m.oldValue = func(context.Context) (*Department, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DepartmentMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DepartmentMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *DepartmentMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *DepartmentMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Department.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *DepartmentMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *DepartmentMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Department entity.
// If the Department object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DepartmentMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *DepartmentMutation) ResetName() {
	m.name = nil
}

// SetCode sets the "code" field.
func (m *DepartmentMutation) SetCode(s string) {
	m.code = &s
}

// Code returns the value of the "code" field in the mutation.
func (m *DepartmentMutation) Code() (r string, exists bool) {
	v := m.code
	if v == nil {
		return
	}
	return *v, true
}

// OldCode returns the old "code" field's value of the Department entity.
// If the Department object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DepartmentMutation) OldCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCode: %w", err)
	}
	return oldValue.Code, nil
}

// ResetCode resets all changes to the "code" field.
func (m *DepartmentMutation) ResetCode() {
	m.code = nil
}

// SetDescription sets the "description" field.
func (m *DepartmentMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *DepartmentMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Department entity.
// If the Department object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DepartmentMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *DepartmentMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[department.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *DepartmentMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[department.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *DepartmentMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, department.FieldDescription)
}

// SetParentID sets the "parent" edge to the Department entity by id.
func (m *DepartmentMutation) SetParentID(id int) {
	m.parent = &id
}

// ClearParent clears the "parent" edge to the Department entity.
func (m *DepartmentMutation) ClearParent() {
	m.clearedparent = true
}

// ParentCleared reports if the "parent" edge to the Department entity was cleared.
func (m *DepartmentMutation) ParentCleared() bool {
	return m.clearedparent
}

// ParentID returns the "parent" edge ID in the mutation.
func (m *DepartmentMutation) ParentID() (id int, exists bool) {
	if m.parent != nil {
		return *m.parent, true
	}
	return
}

// ParentIDs returns the "parent" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ParentID instead. It exists only for internal usage by the builders.
func (m *DepartmentMutation) ParentIDs() (ids []int) {
	if id := m.parent; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetParent resets all changes to the "parent" edge.
func (m *DepartmentMutation) ResetParent() {
	m.parent = nil
	m.clearedparent = false
}

// AddChildIDs adds the "children" edge to the Department entity by ids.
func (m *DepartmentMutation) AddChildIDs(ids ...int) {
	if m.children == nil {
		m.children = make(map[int]struct{})
	}
	for i := range ids {
		m.children[ids[i]] = struct{}{}
	}
}

// ClearChildren clears the "children" edge to the Department entity.
func (m *DepartmentMutation) ClearChildren() {
	m.clearedchildren = true
}

// ChildrenCleared reports if the "children" edge to the Department entity was cleared.
func (m *DepartmentMutation) ChildrenCleared() bool {
	return m.clearedchildren
}

// RemoveChildIDs removes the "children" edge to the Department entity by IDs.
func (m *DepartmentMutation) RemoveChildIDs(ids ...int) {
	if m.removedchildren == nil {
		m.removedchildren = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.children, ids[i])
		m.removedchildren[ids[i]] = struct{}{}
	}
}

// RemovedChildren returns the removed IDs of the "children" edge to the Department entity.
func (m *DepartmentMutation) RemovedChildrenIDs() (ids []int) {
	for id := range m.removedchildren {
		ids = append(ids, id)
	}
	return
}

// ChildrenIDs returns the "children" edge IDs in the mutation.
func (m *DepartmentMutation) ChildrenIDs() (ids []int) {
	for id := range m.children {
		ids = append(ids, id)
	}
	return
}

// ResetChildren resets all changes to the "children" edge.
func (m *DepartmentMutation) ResetChildren() {
	m.children = nil
	m.clearedchildren = false
	m.removedchildren = nil
}

// AddMemberIDs adds the "members" edge to the Employee entity by ids.
func (m *DepartmentMutation) AddMemberIDs(ids ...int) {
	if m.members == nil {
		m.members = make(map[int]struct{})
	}
	for i := range ids {
		m.members[ids[i]] = struct{}{}
	}
}

// ClearMembers clears the "members" edge to the Employee entity.
func (m *DepartmentMutation) ClearMembers() {
	m.clearedmembers = true
}

// MembersCleared reports if the "members" edge to the Employee entity was cleared.
func (m *DepartmentMutation) MembersCleared() bool {
	return m.clearedmembers
}

// RemoveMemberIDs removes the "members" edge to the Employee entity by IDs.
func (m *DepartmentMutation) RemoveMemberIDs(ids ...int) {
	if m.removedmembers == nil {
		m.removedmembers = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.members, ids[i])
		m.removedmembers[ids[i]] = struct{}{}
	}
}

// RemovedMembers returns the removed IDs of the "members" edge to the Employee entity.
func (m *DepartmentMutation) RemovedMembersIDs() (ids []int) {
	for id := range m.removedmembers {
		ids = append(ids, id)
	}
	return
}

// MembersIDs returns the "members" edge IDs in the mutation.
func (m *DepartmentMutation) MembersIDs() (ids []int) {
	for id := range m.members {
		ids = append(ids, id)
	}
	return
}

// ResetMembers resets all changes to the "members" edge.
func (m *DepartmentMutation) ResetMembers() {
	m.members = nil
	m.clearedmembers = false
	m.removedmembers = nil
}

// SetHeadID sets the "head" edge to the Employee entity by id.
func (m *DepartmentMutation) SetHeadID(id int) {
	m.head = &id
}

// ClearHead clears the "head" edge to the Employee entity.
func (m *DepartmentMutation) ClearHead() {
	m.clearedhead = true
}

// HeadCleared reports if the "head" edge to the Employee entity was cleared.
func (m *DepartmentMutation) HeadCleared() bool {
	return m.clearedhead
}

// HeadID returns the "head" edge ID in the mutation.
func (m *DepartmentMutation) HeadID() (id int, exists bool) {
	if m.head != nil {
		return *m.head, true
	}
	return
}

// HeadIDs returns the "head" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// HeadID instead. It exists only for internal usage by the builders.
func (m *DepartmentMutation) HeadIDs() (ids []int) {
	if id := m.head; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetHead resets all changes to the "head" edge.
func (m *DepartmentMutation) ResetHead() {
	m.head = nil
	m.clearedhead = false
}

// Where appends a list predicates to the DepartmentMutation builder.
func (m *DepartmentMutation) Where(ps ...predicate.Department) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the DepartmentMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *DepartmentMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Department, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *DepartmentMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *DepartmentMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Department).
func (m *DepartmentMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DepartmentMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.name != nil {
		fields = append(fields, department.FieldName)
	}
	if m.code != nil {
		fields = append(fields, department.FieldCode)
	}
	if m.description != nil {
		fields = append(fields, department.FieldDescription)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DepartmentMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case department.FieldName:
		return m.Name()
	case department.FieldCode:
		return m.Code()
	case department.FieldDescription:
		return m.Description()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DepartmentMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case department.FieldName:
		return m.OldName(ctx)
	case department.FieldCode:
		return m.OldCode(ctx)
	case department.FieldDescription:
		return m.OldDescription(ctx)
	}
	return nil, fmt.Errorf("unknown Department field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DepartmentMutation) SetField(name string, value ent.Value) error {
	switch name {
	case department.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case department.FieldCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCode(v)
		return nil
	case department.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	}
	return fmt.Errorf("unknown Department field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DepartmentMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DepartmentMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DepartmentMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Department numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DepartmentMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(department.FieldDescription) {
		fields = append(fields, department.FieldDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DepartmentMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DepartmentMutation) ClearField(name string) error {
	switch name {
	case department.FieldDescription:
		m.ClearDescription()
		return nil
	}
	return fmt.Errorf("unknown Department nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DepartmentMutation) ResetField(name string) error {
	switch name {
	case department.FieldName:
		m.ResetName()
		return nil
	case department.FieldCode:
		m.ResetCode()
		return nil
	case department.FieldDescription:
		m.ResetDescription()
		return nil
	}
	return fmt.Errorf("unknown Department field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DepartmentMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.parent != nil {
		edges = append(edges, department.EdgeParent)
	}
	if m.children != nil {
		edges = append(edges, department.EdgeChildren)
	}
	if m.members != nil {
		edges = append(edges, department.EdgeMembers)
	}
	if m.head != nil {
		edges = append(edges, department.EdgeHead)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DepartmentMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case department.EdgeParent:
		if id := m.parent; id != nil {
			return []ent.Value{*id}
		}
	case department.EdgeChildren:
		ids := make([]ent.Value, 0, len(m.children))
		for id := range m.children {
			ids = append(ids, id)
		}
		return ids
	case department.EdgeMembers:
		ids := make([]ent.Value, 0, len(m.members))
		for id := range m.members {
			ids = append(ids, id)
		}
		return ids
	case department.EdgeHead:
		if id := m.head; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DepartmentMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedchildren != nil {
		edges = append(edges, department.EdgeChildren)
	}
	if m.removedmembers != nil {
		edges = append(edges, department.EdgeMembers)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DepartmentMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case department.EdgeChildren:
		ids := make([]ent.Value, 0, len(m.removedchildren))
		for id := range m.removedchildren {
			ids = append(ids, id)
		}
		return ids
	case department.EdgeMembers:
		ids := make([]ent.Value, 0, len(m.removedmembers))
		for id := range m.removedmembers {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DepartmentMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedparent {
		edges = append(edges, department.EdgeParent)
	}
	if m.clearedchildren {
		edges = append(edges, department.EdgeChildren)
	}
	if m.clearedmembers {
		edges = append(edges, department.EdgeMembers)
	}
	if m.clearedhead {
		edges = append(edges, department.EdgeHead)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DepartmentMutation) EdgeCleared(name string) bool {
	switch name {
	case department.EdgeParent:
		return m.clearedparent
	case department.EdgeChildren:
		return m.clearedchildren
	case department.EdgeMembers:
		return m.clearedmembers
	case department.EdgeHead:
		return m.clearedhead
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DepartmentMutation) ClearEdge(name string) error {
	switch name {
	case department.EdgeParent:
		m.ClearParent()
		return nil
	case department.EdgeHead:
		m.ClearHead()
		return nil
	}
	return fmt.Errorf("unknown Department unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DepartmentMutation) ResetEdge(name string) error {
	switch name {
	case department.EdgeParent:
		m.ResetParent()
		return nil
	case department.EdgeChildren:
		m.ResetChildren()
		return nil
	case department.EdgeMembers:
		m.ResetMembers()
		return nil
	case department.EdgeHead:
		m.ResetHead()
		return nil
	}
	return fmt.Errorf("unknown Department edge %s", name)
}

// DetectionEventMutation represents an operation that mutates the DetectionEvent nodes in the graph.
type DetectionEventMutation struct {
	config
	op             Op
	typ            string
	id             *int
	label          *string
	confidence     *float64
	addconfidence  *float64
	box            *map[string]float64
	timestamp      *time.Time
	thumbnail_path *string
	metadata       *map[string]interface{}
	clearedFields  map[string]struct{}
	camera         *int
	clearedcamera  bool
	done           bool
	oldValue       func(context.Context) (*DetectionEvent, error)
	predicates     []predicate.DetectionEvent
}

var _ ent.Mutation = (*DetectionEventMutation)(nil)

// detectioneventOption allows management of the mutation configuration using functional options.
type detectioneventOption func(*DetectionEventMutation)

// newDetectionEventMutation creates new mutation for the DetectionEvent entity.
func newDetectionEventMutation(c config, op Op, opts ...detectioneventOption) *DetectionEventMutation {
	m := &DetectionEventMutation{
		config:        c,
		op:            op,
		typ:           TypeDetectionEvent,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDetectionEventID sets the ID field of the mutation.
func withDetectionEventID(id int) detectioneventOption {
	return func(m *DetectionEventMutation) {
		var (
			err   error
			once  sync.Once
			value *DetectionEvent
		)
		m.oldValue = func(ctx context.Context) (*DetectionEvent, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().DetectionEvent.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDetectionEvent sets the old DetectionEvent of the mutation.
func withDetectionEvent(node *DetectionEvent) detectioneventOption {
	return func(m *DetectionEventMutation) {
		m.oldValue = func(context.Context) (*DetectionEvent, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DetectionEventMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DetectionEventMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *DetectionEventMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *DetectionEventMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().DetectionEvent.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetLabel sets the "label" field.
func (m *DetectionEventMutation) SetLabel(s string) {
	m.label = &s
}

// Label returns the value of the "label" field in the mutation.
func (m *DetectionEventMutation) Label() (r string, exists bool) {
	v := m.label
	if v == nil {
		return
	}
	return *v, true
}

// OldLabel returns the old "label" field's value of the DetectionEvent entity.
// If the DetectionEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DetectionEventMutation) OldLabel(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLabel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLabel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLabel: %w", err)
	}
	return oldValue.Label, nil
}

// ResetLabel resets all changes to the "label" field.
func (m *DetectionEventMutation) ResetLabel() {
	m.label = nil
}

// SetConfidence sets the "confidence" field.
func (m *DetectionEventMutation) SetConfidence(f float64) {
	m.confidence = &f
	m.addconfidence = nil
}

// Confidence returns the value of the "confidence" field in the mutation.
func (m *DetectionEventMutation) Confidence() (r float64, exists bool) {
	v := m.confidence
	if v == nil {
		return
	}
	return *v, true
}

// OldConfidence returns the old "confidence" field's value of the DetectionEvent entity.
// If the DetectionEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DetectionEventMutation) OldConfidence(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldConfidence is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldConfidence requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldConfidence: %w", err)
	}
	return oldValue.Confidence, nil
}

// AddConfidence adds f to the "confidence" field.
func (m *DetectionEventMutation) AddConfidence(f float64) {
	if m.addconfidence != nil {
		*m.addconfidence += f
	} else {
		m.addconfidence = &f
	}
}

// AddedConfidence returns the value that was added to the "confidence" field in this mutation.
func (m *DetectionEventMutation) AddedConfidence() (r float64, exists bool) {
	v := m.addconfidence
	if v == nil {
		return
	}
	return *v, true
}

// ResetConfidence resets all changes to the "confidence" field.
func (m *DetectionEventMutation) ResetConfidence() {
	m.confidence = nil
	m.addconfidence = nil
}

// SetBox sets the "box" field.
func (m *DetectionEventMutation) SetBox(value map[string]float64) {
	m.box = &value
}

// Box returns the value of the "box" field in the mutation.
func (m *DetectionEventMutation) Box() (r map[string]float64, exists bool) {
	v := m.box
	if v == nil {
		return
	}
	return *v, true
}

// OldBox returns the old "box" field's value of the DetectionEvent entity.
// If the DetectionEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DetectionEventMutation) OldBox(ctx context.Context) (v map[string]float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBox is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBox requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBox: %w", err)
	}
	return oldValue.Box, nil
}

// ResetBox resets all changes to the "box" field.
func (m *DetectionEventMutation) ResetBox() {
	m.box = nil
}

// SetTimestamp sets the "timestamp" field.
func (m *DetectionEventMutation) SetTimestamp(t time.Time) {
	m.timestamp = &t
}

// Timestamp returns the value of the "timestamp" field in the mutation.
func (m *DetectionEventMutation) Timestamp() (r time.Time, exists bool) {
	v := m.timestamp
	if v == nil {
		return
	}
	return *v, true
}

// OldTimestamp returns the old "timestamp" field's value of the DetectionEvent entity.
// If the DetectionEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DetectionEventMutation) OldTimestamp(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTimestamp is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTimestamp requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTimestamp: %w", err)
	}
	return oldValue.Timestamp, nil
}

// ResetTimestamp resets all changes to the "timestamp" field.
func (m *DetectionEventMutation) ResetTimestamp() {
	m.timestamp = nil
}

// SetThumbnailPath sets the "thumbnail_path" field.
func (m *DetectionEventMutation) SetThumbnailPath(s string) {
	m.thumbnail_path = &s
}

// ThumbnailPath returns the value of the "thumbnail_path" field in the mutation.
func (m *DetectionEventMutation) ThumbnailPath() (r string, exists bool) {
	v := m.thumbnail_path
	if v == nil {
		return
	}
	return *v, true
}

// OldThumbnailPath returns the old "thumbnail_path" field's value of the DetectionEvent entity.
// If the DetectionEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DetectionEventMutation) OldThumbnailPath(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldThumbnailPath is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldThumbnailPath requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldThumbnailPath: %w", err)
	}
	return oldValue.ThumbnailPath, nil
}

// ClearThumbnailPath clears the value of the "thumbnail_path" field.
func (m *DetectionEventMutation) ClearThumbnailPath() {
	m.thumbnail_path = nil
	m.clearedFields[detectionevent.FieldThumbnailPath] = struct{}{}
}

// ThumbnailPathCleared returns if the "thumbnail_path" field was cleared in this mutation.
func (m *DetectionEventMutation) ThumbnailPathCleared() bool {
	_, ok := m.clearedFields[detectionevent.FieldThumbnailPath]
	return ok
}

// ResetThumbnailPath resets all changes to the "thumbnail_path" field.
func (m *DetectionEventMutation) ResetThumbnailPath() {
	m.thumbnail_path = nil
	delete(m.clearedFields, detectionevent.FieldThumbnailPath)
}

// SetMetadata sets the "metadata" field.
func (m *DetectionEventMutation) SetMetadata(value map[string]interface{}) {
	m.metadata = &value
}

// Metadata returns the value of the "metadata" field in the mutation.
func (m *DetectionEventMutation) Metadata() (r map[string]interface{}, exists bool) {
	v := m.metadata
	if v == nil {
		return
	}
	return *v, true
}

// OldMetadata returns the old "metadata" field's value of the DetectionEvent entity.
// If the DetectionEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DetectionEventMutation) OldMetadata(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMetadata is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMetadata requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetadata: %w", err)
	}
	return oldValue.Metadata, nil
}

// ClearMetadata clears the value of the "metadata" field.
func (m *DetectionEventMutation) ClearMetadata() {
	m.metadata = nil
	m.clearedFields[detectionevent.FieldMetadata] = struct{}{}
}

// MetadataCleared returns if the "metadata" field was cleared in this mutation.
func (m *DetectionEventMutation) MetadataCleared() bool {
	_, ok := m.clearedFields[detectionevent.FieldMetadata]
	return ok
}

// ResetMetadata resets all changes to the "metadata" field.
func (m *DetectionEventMutation) ResetMetadata() {
	m.metadata = nil
	delete(m.clearedFields, detectionevent.FieldMetadata)
}

// SetCameraID sets the "camera" edge to the Camera entity by id.
func (m *DetectionEventMutation) SetCameraID(id int) {
	m.camera = &id
}

// ClearCamera clears the "camera" edge to the Camera entity.
func (m *DetectionEventMutation) ClearCamera() {
	m.clearedcamera = true
}

// CameraCleared reports if the "camera" edge to the Camera entity was cleared.
func (m *DetectionEventMutation) CameraCleared() bool {
	return m.clearedcamera
}

// CameraID returns the "camera" edge ID in the mutation.
func (m *DetectionEventMutation) CameraID() (id int, exists bool) {
	if m.camera != nil {
		return *m.camera, true
	}
	return
}

// CameraIDs returns the "camera" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CameraID instead. It exists only for internal usage by the builders.
func (m *DetectionEventMutation) CameraIDs() (ids []int) {
	if id := m.camera; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCamera resets all changes to the "camera" edge.
func (m *DetectionEventMutation) ResetCamera() {
	m.camera = nil
	m.clearedcamera = false
}

// Where appends a list predicates to the DetectionEventMutation builder.
func (m *DetectionEventMutation) Where(ps ...predicate.DetectionEvent) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the DetectionEventMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *DetectionEventMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.DetectionEvent, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *DetectionEventMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *DetectionEventMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (DetectionEvent).
func (m *DetectionEventMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DetectionEventMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.label != nil {
		fields = append(fields, detectionevent.FieldLabel)
	}
	if m.confidence != nil {
		fields = append(fields, detectionevent.FieldConfidence)
	}
	if m.box != nil {
		fields = append(fields, detectionevent.FieldBox)
	}
	if m.timestamp != nil {
		fields = append(fields, detectionevent.FieldTimestamp)
	}
	if m.thumbnail_path != nil {
		fields = append(fields, detectionevent.FieldThumbnailPath)
	}
	if m.metadata != nil {
		fields = append(fields, detectionevent.FieldMetadata)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DetectionEventMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case detectionevent.FieldLabel:
		return m.Label()
	case detectionevent.FieldConfidence:
		return m.Confidence()
	case detectionevent.FieldBox:
		return m.Box()
	case detectionevent.FieldTimestamp:
		return m.Timestamp()
	case detectionevent.FieldThumbnailPath:
		return m.ThumbnailPath()
	case detectionevent.FieldMetadata:
		return m.Metadata()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DetectionEventMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case detectionevent.FieldLabel:
		return m.OldLabel(ctx)
	case detectionevent.FieldConfidence:
		return m.OldConfidence(ctx)
	case detectionevent.FieldBox:
		return m.OldBox(ctx)
	case detectionevent.FieldTimestamp:
		return m.OldTimestamp(ctx)
	case detectionevent.FieldThumbnailPath:
		return m.OldThumbnailPath(ctx)
	case detectionevent.FieldMetadata:
		return m.OldMetadata(ctx)
	}
	return nil, fmt.Errorf("unknown DetectionEvent field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DetectionEventMutation) SetField(name string, value ent.Value) error {
	switch name {
	case detectionevent.FieldLabel:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLabel(v)
		return nil
	case detectionevent.FieldConfidence:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetConfidence(v)
		return nil
	case detectionevent.FieldBox:
		v, ok := value.(map[string]float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBox(v)
		return nil
	case detectionevent.FieldTimestamp:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTimestamp(v)
		return nil
	case detectionevent.FieldThumbnailPath:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetThumbnailPath(v)
		return nil
	case detectionevent.FieldMetadata:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetadata(v)
		return nil
	}
	return fmt.Errorf("unknown DetectionEvent field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DetectionEventMutation) AddedFields() []string {
	var fields []string
	if m.addconfidence != nil {
		fields = append(fields, detectionevent.FieldConfidence)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DetectionEventMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case detectionevent.FieldConfidence:
		return m.AddedConfidence()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DetectionEventMutation) AddField(name string, value ent.Value) error {
	switch name {
	case detectionevent.FieldConfidence:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddConfidence(v)
		return nil
	}
	return fmt.Errorf("unknown DetectionEvent numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DetectionEventMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(detectionevent.FieldThumbnailPath) {
		fields = append(fields, detectionevent.FieldThumbnailPath)
	}
	if m.FieldCleared(detectionevent.FieldMetadata) {
		fields = append(fields, detectionevent.FieldMetadata)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DetectionEventMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DetectionEventMutation) ClearField(name string) error {
	switch name {
	case detectionevent.FieldThumbnailPath:
		m.ClearThumbnailPath()
		return nil
	case detectionevent.FieldMetadata:
		m.ClearMetadata()
		return nil
	}
	return fmt.Errorf("unknown DetectionEvent nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DetectionEventMutation) ResetField(name string) error {
	switch name {
	case detectionevent.FieldLabel:
		m.ResetLabel()
		return nil
	case detectionevent.FieldConfidence:
		m.ResetConfidence()
		return nil
	case detectionevent.FieldBox:
		m.ResetBox()
		return nil
	case detectionevent.FieldTimestamp:
		m.ResetTimestamp()
		return nil
	case detectionevent.FieldThumbnailPath:
		m.ResetThumbnailPath()
		return nil
	case detectionevent.FieldMetadata:
		m.ResetMetadata()
		return nil
	}
	return fmt.Errorf("unknown DetectionEvent field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DetectionEventMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.camera != nil {
		edges = append(edges, detectionevent.EdgeCamera)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DetectionEventMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case detectionevent.EdgeCamera:
		if id := m.camera; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DetectionEventMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DetectionEventMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DetectionEventMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedcamera {
		edges = append(edges, detectionevent.EdgeCamera)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DetectionEventMutation) EdgeCleared(name string) bool {
	switch name {
	case detectionevent.EdgeCamera:
		return m.clearedcamera
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DetectionEventMutation) ClearEdge(name string) error {
	switch name {
	case detectionevent.EdgeCamera:
		m.ClearCamera()
		return nil
	}
	return fmt.Errorf("unknown DetectionEvent unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DetectionEventMutation) ResetEdge(name string) error {
	switch name {
	case detectionevent.EdgeCamera:
		m.ResetCamera()
		return nil
	}
	return fmt.Errorf("unknown DetectionEvent edge %s", name)
}

// DiscoveryEntryMutation represents an operation that mutates the DiscoveryEntry nodes in the graph.
type DiscoveryEntryMutation struct {
	config
	op            Op
	typ           string
	id            *int
	hardware_id   *string
	name          *string
	_type         *string
	metadata      *map[string]interface{}
	status        *discoveryentry.Status
	discovered_at *time.Time
	clearedFields map[string]struct{}
	tenant        *int
	clearedtenant bool
	done          bool
	oldValue      func(context.Context) (*DiscoveryEntry, error)
	predicates    []predicate.DiscoveryEntry
}

var _ ent.Mutation = (*DiscoveryEntryMutation)(nil)

// discoveryentryOption allows management of the mutation configuration using functional options.
type discoveryentryOption func(*DiscoveryEntryMutation)

// newDiscoveryEntryMutation creates new mutation for the DiscoveryEntry entity.
func newDiscoveryEntryMutation(c config, op Op, opts ...discoveryentryOption) *DiscoveryEntryMutation {
	m := &DiscoveryEntryMutation{
		config:        c,
		op:            op,
		typ:           TypeDiscoveryEntry,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDiscoveryEntryID sets the ID field of the mutation.
func withDiscoveryEntryID(id int) discoveryentryOption {
	return func(m *DiscoveryEntryMutation) {
		var (
			err   error
			once  sync.Once
			value *DiscoveryEntry
		)
		m.oldValue = func(ctx context.Context) (*DiscoveryEntry, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().DiscoveryEntry.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDiscoveryEntry sets the old DiscoveryEntry of the mutation.
func withDiscoveryEntry(node *DiscoveryEntry) discoveryentryOption {
	return func(m *DiscoveryEntryMutation) {
		m.oldValue = func(context.Context) (*DiscoveryEntry, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DiscoveryEntryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DiscoveryEntryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *DiscoveryEntryMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *DiscoveryEntryMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().DiscoveryEntry.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetHardwareID sets the "hardware_id" field.
func (m *DiscoveryEntryMutation) SetHardwareID(s string) {
	m.hardware_id = &s
}

// HardwareID returns the value of the "hardware_id" field in the mutation.
func (m *DiscoveryEntryMutation) HardwareID() (r string, exists bool) {
	v := m.hardware_id
	if v == nil {
		return
	}
	return *v, true
}

// OldHardwareID returns the old "hardware_id" field's value of the DiscoveryEntry entity.
// If the DiscoveryEntry object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DiscoveryEntryMutation) OldHardwareID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHardwareID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHardwareID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHardwareID: %w", err)
	}
	return oldValue.HardwareID, nil
}

// ResetHardwareID resets all changes to the "hardware_id" field.
func (m *DiscoveryEntryMutation) ResetHardwareID() {
	m.hardware_id = nil
}

// SetName sets the "name" field.
func (m *DiscoveryEntryMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *DiscoveryEntryMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the DiscoveryEntry entity.
// If the DiscoveryEntry object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DiscoveryEntryMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *DiscoveryEntryMutation) ResetName() {
	m.name = nil
}

// SetType sets the "type" field.
func (m *DiscoveryEntryMutation) SetType(s string) {
	m._type = &s
}

// GetType returns the value of the "type" field in the mutation.
func (m *DiscoveryEntryMutation) GetType() (r string, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the DiscoveryEntry entity.
// If the DiscoveryEntry object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DiscoveryEntryMutation) OldType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *DiscoveryEntryMutation) ResetType() {
	m._type = nil
}

// SetMetadata sets the "metadata" field.
func (m *DiscoveryEntryMutation) SetMetadata(value map[string]interface{}) {
	m.metadata = &value
}

// Metadata returns the value of the "metadata" field in the mutation.
func (m *DiscoveryEntryMutation) Metadata() (r map[string]interface{}, exists bool) {
	v := m.metadata
	if v == nil {
		return
	}
	return *v, true
}

// OldMetadata returns the old "metadata" field's value of the DiscoveryEntry entity.
// If the DiscoveryEntry object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DiscoveryEntryMutation) OldMetadata(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMetadata is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMetadata requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetadata: %w", err)
	}
	return oldValue.Metadata, nil
}

// ResetMetadata resets all changes to the "metadata" field.
func (m *DiscoveryEntryMutation) ResetMetadata() {
	m.metadata = nil
}

// SetStatus sets the "status" field.
func (m *DiscoveryEntryMutation) SetStatus(d discoveryentry.Status) {
	m.status = &d
}

// Status returns the value of the "status" field in the mutation.
func (m *DiscoveryEntryMutation) Status() (r discoveryentry.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the DiscoveryEntry entity.
// If the DiscoveryEntry object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DiscoveryEntryMutation) OldStatus(ctx context.Context) (v discoveryentry.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *DiscoveryEntryMutation) ResetStatus() {
	m.status = nil
}

// SetDiscoveredAt sets the "discovered_at" field.
func (m *DiscoveryEntryMutation) SetDiscoveredAt(t time.Time) {
	m.discovered_at = &t
}

// DiscoveredAt returns the value of the "discovered_at" field in the mutation.
func (m *DiscoveryEntryMutation) DiscoveredAt() (r time.Time, exists bool) {
	v := m.discovered_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDiscoveredAt returns the old "discovered_at" field's value of the DiscoveryEntry entity.
// If the DiscoveryEntry object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DiscoveryEntryMutation) OldDiscoveredAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDiscoveredAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDiscoveredAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDiscoveredAt: %w", err)
	}
	return oldValue.DiscoveredAt, nil
}

// ResetDiscoveredAt resets all changes to the "discovered_at" field.
func (m *DiscoveryEntryMutation) ResetDiscoveredAt() {
	m.discovered_at = nil
}

// SetTenantID sets the "tenant" edge to the Tenant entity by id.
func (m *DiscoveryEntryMutation) SetTenantID(id int) {
	m.tenant = &id
}

// ClearTenant clears the "tenant" edge to the Tenant entity.
func (m *DiscoveryEntryMutation) ClearTenant() {
	m.clearedtenant = true
}

// TenantCleared reports if the "tenant" edge to the Tenant entity was cleared.
func (m *DiscoveryEntryMutation) TenantCleared() bool {
	return m.clearedtenant
}

// TenantID returns the "tenant" edge ID in the mutation.
func (m *DiscoveryEntryMutation) TenantID() (id int, exists bool) {
	if m.tenant != nil {
		return *m.tenant, true
	}
	return
}

// TenantIDs returns the "tenant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TenantID instead. It exists only for internal usage by the builders.
func (m *DiscoveryEntryMutation) TenantIDs() (ids []int) {
	if id := m.tenant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTenant resets all changes to the "tenant" edge.
func (m *DiscoveryEntryMutation) ResetTenant() {
	m.tenant = nil
	m.clearedtenant = false
}

// Where appends a list predicates to the DiscoveryEntryMutation builder.
func (m *DiscoveryEntryMutation) Where(ps ...predicate.DiscoveryEntry) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the DiscoveryEntryMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *DiscoveryEntryMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.DiscoveryEntry, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *DiscoveryEntryMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *DiscoveryEntryMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (DiscoveryEntry).
func (m *DiscoveryEntryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DiscoveryEntryMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.hardware_id != nil {
		fields = append(fields, discoveryentry.FieldHardwareID)
	}
	if m.name != nil {
		fields = append(fields, discoveryentry.FieldName)
	}
	if m._type != nil {
		fields = append(fields, discoveryentry.FieldType)
	}
	if m.metadata != nil {
		fields = append(fields, discoveryentry.FieldMetadata)
	}
	if m.status != nil {
		fields = append(fields, discoveryentry.FieldStatus)
	}
	if m.discovered_at != nil {
		fields = append(fields, discoveryentry.FieldDiscoveredAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DiscoveryEntryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case discoveryentry.FieldHardwareID:
		return m.HardwareID()
	case discoveryentry.FieldName:
		return m.Name()
	case discoveryentry.FieldType:
		return m.GetType()
	case discoveryentry.FieldMetadata:
		return m.Metadata()
	case discoveryentry.FieldStatus:
		return m.Status()
	case discoveryentry.FieldDiscoveredAt:
		return m.DiscoveredAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DiscoveryEntryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case discoveryentry.FieldHardwareID:
		return m.OldHardwareID(ctx)
	case discoveryentry.FieldName:
		return m.OldName(ctx)
	case discoveryentry.FieldType:
		return m.OldType(ctx)
	case discoveryentry.FieldMetadata:
		return m.OldMetadata(ctx)
	case discoveryentry.FieldStatus:
		return m.OldStatus(ctx)
	case discoveryentry.FieldDiscoveredAt:
		return m.OldDiscoveredAt(ctx)
	}
	return nil, fmt.Errorf("unknown DiscoveryEntry field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DiscoveryEntryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case discoveryentry.FieldHardwareID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHardwareID(v)
		return nil
	case discoveryentry.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case discoveryentry.FieldType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case discoveryentry.FieldMetadata:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetadata(v)
		return nil
	case discoveryentry.FieldStatus:
		v, ok := value.(discoveryentry.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case discoveryentry.FieldDiscoveredAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDiscoveredAt(v)
		return nil
	}
	return fmt.Errorf("unknown DiscoveryEntry field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DiscoveryEntryMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DiscoveryEntryMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DiscoveryEntryMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown DiscoveryEntry numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DiscoveryEntryMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DiscoveryEntryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DiscoveryEntryMutation) ClearField(name string) error {
	return fmt.Errorf("unknown DiscoveryEntry nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DiscoveryEntryMutation) ResetField(name string) error {
	switch name {
	case discoveryentry.FieldHardwareID:
		m.ResetHardwareID()
		return nil
	case discoveryentry.FieldName:
		m.ResetName()
		return nil
	case discoveryentry.FieldType:
		m.ResetType()
		return nil
	case discoveryentry.FieldMetadata:
		m.ResetMetadata()
		return nil
	case discoveryentry.FieldStatus:
		m.ResetStatus()
		return nil
	case discoveryentry.FieldDiscoveredAt:
		m.ResetDiscoveredAt()
		return nil
	}
	return fmt.Errorf("unknown DiscoveryEntry field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DiscoveryEntryMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.tenant != nil {
		edges = append(edges, discoveryentry.EdgeTenant)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DiscoveryEntryMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case discoveryentry.EdgeTenant:
		if id := m.tenant; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DiscoveryEntryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DiscoveryEntryMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DiscoveryEntryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedtenant {
		edges = append(edges, discoveryentry.EdgeTenant)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DiscoveryEntryMutation) EdgeCleared(name string) bool {
	switch name {
	case discoveryentry.EdgeTenant:
		return m.clearedtenant
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DiscoveryEntryMutation) ClearEdge(name string) error {
	switch name {
	case discoveryentry.EdgeTenant:
		m.ClearTenant()
		return nil
	}
	return fmt.Errorf("unknown DiscoveryEntry unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DiscoveryEntryMutation) ResetEdge(name string) error {
	switch name {
	case discoveryentry.EdgeTenant:
		m.ResetTenant()
		return nil
	}
	return fmt.Errorf("unknown DiscoveryEntry edge %s", name)
}

// EmployeeMutation represents an operation that mutates the Employee nodes in the graph.
type EmployeeMutation struct {
	config
	op                             Op
	typ                            string
	id                             *int
	zitadel_id                     *string
	employee_id                    *string
	first_name                     *string
	last_name                      *string
	email                          *string
	phone                          *string
	status                         *employee.Status
	salary_encrypted               *string
	bank_details_encrypted         *string
	signature_hash                 *string
	signed_at                      *time.Time
	hipo_status                    *bool
	created_at                     *time.Time
	updated_at                     *time.Time
	clearedFields                  map[string]struct{}
	tenant                         *int
	clearedtenant                  bool
	department                     *int
	cleareddepartment              bool
	manager                        *int
	clearedmanager                 bool
	subordinates                   map[int]struct{}
	removedsubordinates            map[int]struct{}
	clearedsubordinates            bool
	compensation_agreements        map[int]struct{}
	removedcompensation_agreements map[int]struct{}
	clearedcompensation_agreements bool
	succession_plans               map[int]struct{}
	removedsuccession_plans        map[int]struct{}
	clearedsuccession_plans        bool
	backup_for                     map[int]struct{}
	removedbackup_for              map[int]struct{}
	clearedbackup_for              bool
	expense_account                *int
	clearedexpense_account         bool
	done                           bool
	oldValue                       func(context.Context) (*Employee, error)
	predicates                     []predicate.Employee
}

var _ ent.Mutation = (*EmployeeMutation)(nil)

// employeeOption allows management of the mutation configuration using functional options.
type employeeOption func(*EmployeeMutation)

// newEmployeeMutation creates new mutation for the Employee entity.
func newEmployeeMutation(c config, op Op, opts ...employeeOption) *EmployeeMutation {
	m := &EmployeeMutation{
		config:        c,
		op:            op,
		typ:           TypeEmployee,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withEmployeeID sets the ID field of the mutation.
func withEmployeeID(id int) employeeOption {
	return func(m *EmployeeMutation) {
		var (
			err   error
			once  sync.Once
			value *Employee
		)
		m.oldValue = func(ctx context.Context) (*Employee, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Employee.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withEmployee sets the old Employee of the mutation.
func withEmployee(node *Employee) employeeOption {
	return func(m *EmployeeMutation) {
		m.oldValue = func(context.Context) (*Employee, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m EmployeeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m EmployeeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *EmployeeMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *EmployeeMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Employee.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetZitadelID sets the "zitadel_id" field.
func (m *EmployeeMutation) SetZitadelID(s string) {
	m.zitadel_id = &s
}

// ZitadelID returns the value of the "zitadel_id" field in the mutation.
func (m *EmployeeMutation) ZitadelID() (r string, exists bool) {
	v := m.zitadel_id
	if v == nil {
		return
	}
	return *v, true
}

// OldZitadelID returns the old "zitadel_id" field's value of the Employee entity.
// If the Employee object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeeMutation) OldZitadelID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldZitadelID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldZitadelID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldZitadelID: %w", err)
	}
	return oldValue.ZitadelID, nil
}

// ResetZitadelID resets all changes to the "zitadel_id" field.
func (m *EmployeeMutation) ResetZitadelID() {
	m.zitadel_id = nil
}

// SetEmployeeID sets the "employee_id" field.
func (m *EmployeeMutation) SetEmployeeID(s string) {
	m.employee_id = &s
}

// EmployeeID returns the value of the "employee_id" field in the mutation.
func (m *EmployeeMutation) EmployeeID() (r string, exists bool) {
	v := m.employee_id
	if v == nil {
		return
	}
	return *v, true
}

// OldEmployeeID returns the old "employee_id" field's value of the Employee entity.
// If the Employee object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeeMutation) OldEmployeeID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmployeeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmployeeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmployeeID: %w", err)
	}
	return oldValue.EmployeeID, nil
}

// ResetEmployeeID resets all changes to the "employee_id" field.
func (m *EmployeeMutation) ResetEmployeeID() {
	m.employee_id = nil
}

// SetFirstName sets the "first_name" field.
func (m *EmployeeMutation) SetFirstName(s string) {
	m.first_name = &s
}

// FirstName returns the value of the "first_name" field in the mutation.
func (m *EmployeeMutation) FirstName() (r string, exists bool) {
	v := m.first_name
	if v == nil {
		return
	}
	return *v, true
}

// OldFirstName returns the old "first_name" field's value of the Employee entity.
// If the Employee object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeeMutation) OldFirstName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFirstName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFirstName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFirstName: %w", err)
	}
	return oldValue.FirstName, nil
}

// ResetFirstName resets all changes to the "first_name" field.
func (m *EmployeeMutation) ResetFirstName() {
	m.first_name = nil
}

// SetLastName sets the "last_name" field.
func (m *EmployeeMutation) SetLastName(s string) {
	m.last_name = &s
}

// LastName returns the value of the "last_name" field in the mutation.
func (m *EmployeeMutation) LastName() (r string, exists bool) {
	v := m.last_name
	if v == nil {
		return
	}
	return *v, true
}

// OldLastName returns the old "last_name" field's value of the Employee entity.
// If the Employee object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeeMutation) OldLastName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastName: %w", err)
	}
	return oldValue.LastName, nil
}

// ResetLastName resets all changes to the "last_name" field.
func (m *EmployeeMutation) ResetLastName() {
	m.last_name = nil
}

// SetEmail sets the "email" field.
func (m *EmployeeMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *EmployeeMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the Employee entity.
// If the Employee object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeeMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail resets all changes to the "email" field.
func (m *EmployeeMutation) ResetEmail() {
	m.email = nil
}

// SetPhone sets the "phone" field.
func (m *EmployeeMutation) SetPhone(s string) {
	m.phone = &s
}

// Phone returns the value of the "phone" field in the mutation.
func (m *EmployeeMutation) Phone() (r string, exists bool) {
	v := m.phone
	if v == nil {
		return
	}
	return *v, true
}

// OldPhone returns the old "phone" field's value of the Employee entity.
// If the Employee object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeeMutation) OldPhone(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPhone is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPhone requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhone: %w", err)
	}
	return oldValue.Phone, nil
}

// ClearPhone clears the value of the "phone" field.
func (m *EmployeeMutation) ClearPhone() {
	m.phone = nil
	m.clearedFields[employee.FieldPhone] = struct{}{}
}

// PhoneCleared returns if the "phone" field was cleared in this mutation.
func (m *EmployeeMutation) PhoneCleared() bool {
	_, ok := m.clearedFields[employee.FieldPhone]
	return ok
}

// ResetPhone resets all changes to the "phone" field.
func (m *EmployeeMutation) ResetPhone() {
	m.phone = nil
	delete(m.clearedFields, employee.FieldPhone)
}

// SetStatus sets the "status" field.
func (m *EmployeeMutation) SetStatus(e employee.Status) {
	m.status = &e
}

// Status returns the value of the "status" field in the mutation.
func (m *EmployeeMutation) Status() (r employee.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Employee entity.
// If the Employee object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeeMutation) OldStatus(ctx context.Context) (v employee.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *EmployeeMutation) ResetStatus() {
	m.status = nil
}

// SetSalaryEncrypted sets the "salary_encrypted" field.
func (m *EmployeeMutation) SetSalaryEncrypted(s string) {
	m.salary_encrypted = &s
}

// SalaryEncrypted returns the value of the "salary_encrypted" field in the mutation.
func (m *EmployeeMutation) SalaryEncrypted() (r string, exists bool) {
	v := m.salary_encrypted
	if v == nil {
		return
	}
	return *v, true
}

// OldSalaryEncrypted returns the old "salary_encrypted" field's value of the Employee entity.
// If the Employee object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeeMutation) OldSalaryEncrypted(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSalaryEncrypted is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSalaryEncrypted requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSalaryEncrypted: %w", err)
	}
	return oldValue.SalaryEncrypted, nil
}

// ResetSalaryEncrypted resets all changes to the "salary_encrypted" field.
func (m *EmployeeMutation) ResetSalaryEncrypted() {
	m.salary_encrypted = nil
}

// SetBankDetailsEncrypted sets the "bank_details_encrypted" field.
func (m *EmployeeMutation) SetBankDetailsEncrypted(s string) {
	m.bank_details_encrypted = &s
}

// BankDetailsEncrypted returns the value of the "bank_details_encrypted" field in the mutation.
func (m *EmployeeMutation) BankDetailsEncrypted() (r string, exists bool) {
	v := m.bank_details_encrypted
	if v == nil {
		return
	}
	return *v, true
}

// OldBankDetailsEncrypted returns the old "bank_details_encrypted" field's value of the Employee entity.
// If the Employee object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeeMutation) OldBankDetailsEncrypted(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBankDetailsEncrypted is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBankDetailsEncrypted requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBankDetailsEncrypted: %w", err)
	}
	return oldValue.BankDetailsEncrypted, nil
}

// ClearBankDetailsEncrypted clears the value of the "bank_details_encrypted" field.
func (m *EmployeeMutation) ClearBankDetailsEncrypted() {
	m.bank_details_encrypted = nil
	m.clearedFields[employee.FieldBankDetailsEncrypted] = struct{}{}
}

// BankDetailsEncryptedCleared returns if the "bank_details_encrypted" field was cleared in this mutation.
func (m *EmployeeMutation) BankDetailsEncryptedCleared() bool {
	_, ok := m.clearedFields[employee.FieldBankDetailsEncrypted]
	return ok
}

// ResetBankDetailsEncrypted resets all changes to the "bank_details_encrypted" field.
func (m *EmployeeMutation) ResetBankDetailsEncrypted() {
	m.bank_details_encrypted = nil
	delete(m.clearedFields, employee.FieldBankDetailsEncrypted)
}

// SetSignatureHash sets the "signature_hash" field.
func (m *EmployeeMutation) SetSignatureHash(s string) {
	m.signature_hash = &s
}

// SignatureHash returns the value of the "signature_hash" field in the mutation.
func (m *EmployeeMutation) SignatureHash() (r string, exists bool) {
	v := m.signature_hash
	if v == nil {
		return
	}
	return *v, true
}

// OldSignatureHash returns the old "signature_hash" field's value of the Employee entity.
// If the Employee object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeeMutation) OldSignatureHash(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSignatureHash is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSignatureHash requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSignatureHash: %w", err)
	}
	return oldValue.SignatureHash, nil
}

// ClearSignatureHash clears the value of the "signature_hash" field.
func (m *EmployeeMutation) ClearSignatureHash() {
	m.signature_hash = nil
	m.clearedFields[employee.FieldSignatureHash] = struct{}{}
}

// SignatureHashCleared returns if the "signature_hash" field was cleared in this mutation.
func (m *EmployeeMutation) SignatureHashCleared() bool {
	_, ok := m.clearedFields[employee.FieldSignatureHash]
	return ok
}

// ResetSignatureHash resets all changes to the "signature_hash" field.
func (m *EmployeeMutation) ResetSignatureHash() {
	m.signature_hash = nil
	delete(m.clearedFields, employee.FieldSignatureHash)
}

// SetSignedAt sets the "signed_at" field.
func (m *EmployeeMutation) SetSignedAt(t time.Time) {
	m.signed_at = &t
}

// SignedAt returns the value of the "signed_at" field in the mutation.
func (m *EmployeeMutation) SignedAt() (r time.Time, exists bool) {
	v := m.signed_at
	if v == nil {
		return
	}
	return *v, true
}

// OldSignedAt returns the old "signed_at" field's value of the Employee entity.
// If the Employee object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeeMutation) OldSignedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSignedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSignedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSignedAt: %w", err)
	}
	return oldValue.SignedAt, nil
}

// ClearSignedAt clears the value of the "signed_at" field.
func (m *EmployeeMutation) ClearSignedAt() {
	m.signed_at = nil
	m.clearedFields[employee.FieldSignedAt] = struct{}{}
}

// SignedAtCleared returns if the "signed_at" field was cleared in this mutation.
func (m *EmployeeMutation) SignedAtCleared() bool {
	_, ok := m.clearedFields[employee.FieldSignedAt]
	return ok
}

// ResetSignedAt resets all changes to the "signed_at" field.
func (m *EmployeeMutation) ResetSignedAt() {
	m.signed_at = nil
	delete(m.clearedFields, employee.FieldSignedAt)
}

// SetHipoStatus sets the "hipo_status" field.
func (m *EmployeeMutation) SetHipoStatus(b bool) {
	m.hipo_status = &b
}

// HipoStatus returns the value of the "hipo_status" field in the mutation.
func (m *EmployeeMutation) HipoStatus() (r bool, exists bool) {
	v := m.hipo_status
	if v == nil {
		return
	}
	return *v, true
}

// OldHipoStatus returns the old "hipo_status" field's value of the Employee entity.
// If the Employee object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeeMutation) OldHipoStatus(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHipoStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHipoStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHipoStatus: %w", err)
	}
	return oldValue.HipoStatus, nil
}

// ResetHipoStatus resets all changes to the "hipo_status" field.
func (m *EmployeeMutation) ResetHipoStatus() {
	m.hipo_status = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *EmployeeMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *EmployeeMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Employee entity.
// If the Employee object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeeMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *EmployeeMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *EmployeeMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *EmployeeMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Employee entity.
// If the Employee object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeeMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *EmployeeMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetTenantID sets the "tenant" edge to the Tenant entity by id.
func (m *EmployeeMutation) SetTenantID(id int) {
	m.tenant = &id
}

// ClearTenant clears the "tenant" edge to the Tenant entity.
func (m *EmployeeMutation) ClearTenant() {
	m.clearedtenant = true
}

// TenantCleared reports if the "tenant" edge to the Tenant entity was cleared.
func (m *EmployeeMutation) TenantCleared() bool {
	return m.clearedtenant
}

// TenantID returns the "tenant" edge ID in the mutation.
func (m *EmployeeMutation) TenantID() (id int, exists bool) {
	if m.tenant != nil {
		return *m.tenant, true
	}
	return
}

// TenantIDs returns the "tenant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TenantID instead. It exists only for internal usage by the builders.
func (m *EmployeeMutation) TenantIDs() (ids []int) {
	if id := m.tenant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTenant resets all changes to the "tenant" edge.
func (m *EmployeeMutation) ResetTenant() {
	m.tenant = nil
	m.clearedtenant = false
}

// SetDepartmentID sets the "department" edge to the Department entity by id.
func (m *EmployeeMutation) SetDepartmentID(id int) {
	m.department = &id
}

// ClearDepartment clears the "department" edge to the Department entity.
func (m *EmployeeMutation) ClearDepartment() {
	m.cleareddepartment = true
}

// DepartmentCleared reports if the "department" edge to the Department entity was cleared.
func (m *EmployeeMutation) DepartmentCleared() bool {
	return m.cleareddepartment
}

// DepartmentID returns the "department" edge ID in the mutation.
func (m *EmployeeMutation) DepartmentID() (id int, exists bool) {
	if m.department != nil {
		return *m.department, true
	}
	return
}

// DepartmentIDs returns the "department" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// DepartmentID instead. It exists only for internal usage by the builders.
func (m *EmployeeMutation) DepartmentIDs() (ids []int) {
	if id := m.department; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDepartment resets all changes to the "department" edge.
func (m *EmployeeMutation) ResetDepartment() {
	m.department = nil
	m.cleareddepartment = false
}

// SetManagerID sets the "manager" edge to the Employee entity by id.
func (m *EmployeeMutation) SetManagerID(id int) {
	m.manager = &id
}

// ClearManager clears the "manager" edge to the Employee entity.
func (m *EmployeeMutation) ClearManager() {
	m.clearedmanager = true
}

// ManagerCleared reports if the "manager" edge to the Employee entity was cleared.
func (m *EmployeeMutation) ManagerCleared() bool {
	return m.clearedmanager
}

// ManagerID returns the "manager" edge ID in the mutation.
func (m *EmployeeMutation) ManagerID() (id int, exists bool) {
	if m.manager != nil {
		return *m.manager, true
	}
	return
}

// ManagerIDs returns the "manager" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ManagerID instead. It exists only for internal usage by the builders.
func (m *EmployeeMutation) ManagerIDs() (ids []int) {
	if id := m.manager; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetManager resets all changes to the "manager" edge.
func (m *EmployeeMutation) ResetManager() {
	m.manager = nil
	m.clearedmanager = false
}

// AddSubordinateIDs adds the "subordinates" edge to the Employee entity by ids.
func (m *EmployeeMutation) AddSubordinateIDs(ids ...int) {
	if m.subordinates == nil {
		m.subordinates = make(map[int]struct{})
	}
	for i := range ids {
		m.subordinates[ids[i]] = struct{}{}
	}
}

// ClearSubordinates clears the "subordinates" edge to the Employee entity.
func (m *EmployeeMutation) ClearSubordinates() {
	m.clearedsubordinates = true
}

// SubordinatesCleared reports if the "subordinates" edge to the Employee entity was cleared.
func (m *EmployeeMutation) SubordinatesCleared() bool {
	return m.clearedsubordinates
}

// RemoveSubordinateIDs removes the "subordinates" edge to the Employee entity by IDs.
func (m *EmployeeMutation) RemoveSubordinateIDs(ids ...int) {
	if m.removedsubordinates == nil {
		m.removedsubordinates = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.subordinates, ids[i])
		m.removedsubordinates[ids[i]] = struct{}{}
	}
}

// RemovedSubordinates returns the removed IDs of the "subordinates" edge to the Employee entity.
func (m *EmployeeMutation) RemovedSubordinatesIDs() (ids []int) {
	for id := range m.removedsubordinates {
		ids = append(ids, id)
	}
	return
}

// SubordinatesIDs returns the "subordinates" edge IDs in the mutation.
func (m *EmployeeMutation) SubordinatesIDs() (ids []int) {
	for id := range m.subordinates {
		ids = append(ids, id)
	}
	return
}

// ResetSubordinates resets all changes to the "subordinates" edge.
func (m *EmployeeMutation) ResetSubordinates() {
	m.subordinates = nil
	m.clearedsubordinates = false
	m.removedsubordinates = nil
}

// AddCompensationAgreementIDs adds the "compensation_agreements" edge to the CompensationAgreement entity by ids.
func (m *EmployeeMutation) AddCompensationAgreementIDs(ids ...int) {
	if m.compensation_agreements == nil {
		m.compensation_agreements = make(map[int]struct{})
	}
	for i := range ids {
		m.compensation_agreements[ids[i]] = struct{}{}
	}
}

// ClearCompensationAgreements clears the "compensation_agreements" edge to the CompensationAgreement entity.
func (m *EmployeeMutation) ClearCompensationAgreements() {
	m.clearedcompensation_agreements = true
}

// CompensationAgreementsCleared reports if the "compensation_agreements" edge to the CompensationAgreement entity was cleared.
func (m *EmployeeMutation) CompensationAgreementsCleared() bool {
	return m.clearedcompensation_agreements
}

// RemoveCompensationAgreementIDs removes the "compensation_agreements" edge to the CompensationAgreement entity by IDs.
func (m *EmployeeMutation) RemoveCompensationAgreementIDs(ids ...int) {
	if m.removedcompensation_agreements == nil {
		m.removedcompensation_agreements = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.compensation_agreements, ids[i])
		m.removedcompensation_agreements[ids[i]] = struct{}{}
	}
}

// RemovedCompensationAgreements returns the removed IDs of the "compensation_agreements" edge to the CompensationAgreement entity.
func (m *EmployeeMutation) RemovedCompensationAgreementsIDs() (ids []int) {
	for id := range m.removedcompensation_agreements {
		ids = append(ids, id)
	}
	return
}

// CompensationAgreementsIDs returns the "compensation_agreements" edge IDs in the mutation.
func (m *EmployeeMutation) CompensationAgreementsIDs() (ids []int) {
	for id := range m.compensation_agreements {
		ids = append(ids, id)
	}
	return
}

// ResetCompensationAgreements resets all changes to the "compensation_agreements" edge.
func (m *EmployeeMutation) ResetCompensationAgreements() {
	m.compensation_agreements = nil
	m.clearedcompensation_agreements = false
	m.removedcompensation_agreements = nil
}

// AddSuccessionPlanIDs adds the "succession_plans" edge to the SuccessionMap entity by ids.
func (m *EmployeeMutation) AddSuccessionPlanIDs(ids ...int) {
	if m.succession_plans == nil {
		m.succession_plans = make(map[int]struct{})
	}
	for i := range ids {
		m.succession_plans[ids[i]] = struct{}{}
	}
}

// ClearSuccessionPlans clears the "succession_plans" edge to the SuccessionMap entity.
func (m *EmployeeMutation) ClearSuccessionPlans() {
	m.clearedsuccession_plans = true
}

// SuccessionPlansCleared reports if the "succession_plans" edge to the SuccessionMap entity was cleared.
func (m *EmployeeMutation) SuccessionPlansCleared() bool {
	return m.clearedsuccession_plans
}

// RemoveSuccessionPlanIDs removes the "succession_plans" edge to the SuccessionMap entity by IDs.
func (m *EmployeeMutation) RemoveSuccessionPlanIDs(ids ...int) {
	if m.removedsuccession_plans == nil {
		m.removedsuccession_plans = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.succession_plans, ids[i])
		m.removedsuccession_plans[ids[i]] = struct{}{}
	}
}

// RemovedSuccessionPlans returns the removed IDs of the "succession_plans" edge to the SuccessionMap entity.
func (m *EmployeeMutation) RemovedSuccessionPlansIDs() (ids []int) {
	for id := range m.removedsuccession_plans {
		ids = append(ids, id)
	}
	return
}

// SuccessionPlansIDs returns the "succession_plans" edge IDs in the mutation.
func (m *EmployeeMutation) SuccessionPlansIDs() (ids []int) {
	for id := range m.succession_plans {
		ids = append(ids, id)
	}
	return
}

// ResetSuccessionPlans resets all changes to the "succession_plans" edge.
func (m *EmployeeMutation) ResetSuccessionPlans() {
	m.succession_plans = nil
	m.clearedsuccession_plans = false
	m.removedsuccession_plans = nil
}

// AddBackupForIDs adds the "backup_for" edge to the SuccessionMap entity by ids.
func (m *EmployeeMutation) AddBackupForIDs(ids ...int) {
	if m.backup_for == nil {
		m.backup_for = make(map[int]struct{})
	}
	for i := range ids {
		m.backup_for[ids[i]] = struct{}{}
	}
}

// ClearBackupFor clears the "backup_for" edge to the SuccessionMap entity.
func (m *EmployeeMutation) ClearBackupFor() {
	m.clearedbackup_for = true
}

// BackupForCleared reports if the "backup_for" edge to the SuccessionMap entity was cleared.
func (m *EmployeeMutation) BackupForCleared() bool {
	return m.clearedbackup_for
}

// RemoveBackupForIDs removes the "backup_for" edge to the SuccessionMap entity by IDs.
func (m *EmployeeMutation) RemoveBackupForIDs(ids ...int) {
	if m.removedbackup_for == nil {
		m.removedbackup_for = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.backup_for, ids[i])
		m.removedbackup_for[ids[i]] = struct{}{}
	}
}

// RemovedBackupFor returns the removed IDs of the "backup_for" edge to the SuccessionMap entity.
func (m *EmployeeMutation) RemovedBackupForIDs() (ids []int) {
	for id := range m.removedbackup_for {
		ids = append(ids, id)
	}
	return
}

// BackupForIDs returns the "backup_for" edge IDs in the mutation.
func (m *EmployeeMutation) BackupForIDs() (ids []int) {
	for id := range m.backup_for {
		ids = append(ids, id)
	}
	return
}

// ResetBackupFor resets all changes to the "backup_for" edge.
func (m *EmployeeMutation) ResetBackupFor() {
	m.backup_for = nil
	m.clearedbackup_for = false
	m.removedbackup_for = nil
}

// SetExpenseAccountID sets the "expense_account" edge to the Account entity by id.
func (m *EmployeeMutation) SetExpenseAccountID(id int) {
	m.expense_account = &id
}

// ClearExpenseAccount clears the "expense_account" edge to the Account entity.
func (m *EmployeeMutation) ClearExpenseAccount() {
	m.clearedexpense_account = true
}

// ExpenseAccountCleared reports if the "expense_account" edge to the Account entity was cleared.
func (m *EmployeeMutation) ExpenseAccountCleared() bool {
	return m.clearedexpense_account
}

// ExpenseAccountID returns the "expense_account" edge ID in the mutation.
func (m *EmployeeMutation) ExpenseAccountID() (id int, exists bool) {
	if m.expense_account != nil {
		return *m.expense_account, true
	}
	return
}

// ExpenseAccountIDs returns the "expense_account" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ExpenseAccountID instead. It exists only for internal usage by the builders.
func (m *EmployeeMutation) ExpenseAccountIDs() (ids []int) {
	if id := m.expense_account; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetExpenseAccount resets all changes to the "expense_account" edge.
func (m *EmployeeMutation) ResetExpenseAccount() {
	m.expense_account = nil
	m.clearedexpense_account = false
}

// Where appends a list predicates to the EmployeeMutation builder.
func (m *EmployeeMutation) Where(ps ...predicate.Employee) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the EmployeeMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *EmployeeMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Employee, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *EmployeeMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *EmployeeMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Employee).
func (m *EmployeeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *EmployeeMutation) Fields() []string {
	fields := make([]string, 0, 14)
	if m.zitadel_id != nil {
		fields = append(fields, employee.FieldZitadelID)
	}
	if m.employee_id != nil {
		fields = append(fields, employee.FieldEmployeeID)
	}
	if m.first_name != nil {
		fields = append(fields, employee.FieldFirstName)
	}
	if m.last_name != nil {
		fields = append(fields, employee.FieldLastName)
	}
	if m.email != nil {
		fields = append(fields, employee.FieldEmail)
	}
	if m.phone != nil {
		fields = append(fields, employee.FieldPhone)
	}
	if m.status != nil {
		fields = append(fields, employee.FieldStatus)
	}
	if m.salary_encrypted != nil {
		fields = append(fields, employee.FieldSalaryEncrypted)
	}
	if m.bank_details_encrypted != nil {
		fields = append(fields, employee.FieldBankDetailsEncrypted)
	}
	if m.signature_hash != nil {
		fields = append(fields, employee.FieldSignatureHash)
	}
	if m.signed_at != nil {
		fields = append(fields, employee.FieldSignedAt)
	}
	if m.hipo_status != nil {
		fields = append(fields, employee.FieldHipoStatus)
	}
	if m.created_at != nil {
		fields = append(fields, employee.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, employee.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *EmployeeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case employee.FieldZitadelID:
		return m.ZitadelID()
	case employee.FieldEmployeeID:
		return m.EmployeeID()
	case employee.FieldFirstName:
		return m.FirstName()
	case employee.FieldLastName:
		return m.LastName()
	case employee.FieldEmail:
		return m.Email()
	case employee.FieldPhone:
		return m.Phone()
	case employee.FieldStatus:
		return m.Status()
	case employee.FieldSalaryEncrypted:
		return m.SalaryEncrypted()
	case employee.FieldBankDetailsEncrypted:
		return m.BankDetailsEncrypted()
	case employee.FieldSignatureHash:
		return m.SignatureHash()
	case employee.FieldSignedAt:
		return m.SignedAt()
	case employee.FieldHipoStatus:
		return m.HipoStatus()
	case employee.FieldCreatedAt:
		return m.CreatedAt()
	case employee.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *EmployeeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case employee.FieldZitadelID:
		return m.OldZitadelID(ctx)
	case employee.FieldEmployeeID:
		return m.OldEmployeeID(ctx)
	case employee.FieldFirstName:
		return m.OldFirstName(ctx)
	case employee.FieldLastName:
		return m.OldLastName(ctx)
	case employee.FieldEmail:
		return m.OldEmail(ctx)
	case employee.FieldPhone:
		return m.OldPhone(ctx)
	case employee.FieldStatus:
		return m.OldStatus(ctx)
	case employee.FieldSalaryEncrypted:
		return m.OldSalaryEncrypted(ctx)
	case employee.FieldBankDetailsEncrypted:
		return m.OldBankDetailsEncrypted(ctx)
	case employee.FieldSignatureHash:
		return m.OldSignatureHash(ctx)
	case employee.FieldSignedAt:
		return m.OldSignedAt(ctx)
	case employee.FieldHipoStatus:
		return m.OldHipoStatus(ctx)
	case employee.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case employee.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Employee field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EmployeeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case employee.FieldZitadelID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetZitadelID(v)
		return nil
	case employee.FieldEmployeeID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmployeeID(v)
		return nil
	case employee.FieldFirstName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFirstName(v)
		return nil
	case employee.FieldLastName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastName(v)
		return nil
	case employee.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case employee.FieldPhone:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhone(v)
		return nil
	case employee.FieldStatus:
		v, ok := value.(employee.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case employee.FieldSalaryEncrypted:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSalaryEncrypted(v)
		return nil
	case employee.FieldBankDetailsEncrypted:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBankDetailsEncrypted(v)
		return nil
	case employee.FieldSignatureHash:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSignatureHash(v)
		return nil
	case employee.FieldSignedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSignedAt(v)
		return nil
	case employee.FieldHipoStatus:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHipoStatus(v)
		return nil
	case employee.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case employee.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Employee field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *EmployeeMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *EmployeeMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EmployeeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Employee numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *EmployeeMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(employee.FieldPhone) {
		fields = append(fields, employee.FieldPhone)
	}
	if m.FieldCleared(employee.FieldBankDetailsEncrypted) {
		fields = append(fields, employee.FieldBankDetailsEncrypted)
	}
	if m.FieldCleared(employee.FieldSignatureHash) {
		fields = append(fields, employee.FieldSignatureHash)
	}
	if m.FieldCleared(employee.FieldSignedAt) {
		fields = append(fields, employee.FieldSignedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *EmployeeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *EmployeeMutation) ClearField(name string) error {
	switch name {
	case employee.FieldPhone:
		m.ClearPhone()
		return nil
	case employee.FieldBankDetailsEncrypted:
		m.ClearBankDetailsEncrypted()
		return nil
	case employee.FieldSignatureHash:
		m.ClearSignatureHash()
		return nil
	case employee.FieldSignedAt:
		m.ClearSignedAt()
		return nil
	}
	return fmt.Errorf("unknown Employee nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *EmployeeMutation) ResetField(name string) error {
	switch name {
	case employee.FieldZitadelID:
		m.ResetZitadelID()
		return nil
	case employee.FieldEmployeeID:
		m.ResetEmployeeID()
		return nil
	case employee.FieldFirstName:
		m.ResetFirstName()
		return nil
	case employee.FieldLastName:
		m.ResetLastName()
		return nil
	case employee.FieldEmail:
		m.ResetEmail()
		return nil
	case employee.FieldPhone:
		m.ResetPhone()
		return nil
	case employee.FieldStatus:
		m.ResetStatus()
		return nil
	case employee.FieldSalaryEncrypted:
		m.ResetSalaryEncrypted()
		return nil
	case employee.FieldBankDetailsEncrypted:
		m.ResetBankDetailsEncrypted()
		return nil
	case employee.FieldSignatureHash:
		m.ResetSignatureHash()
		return nil
	case employee.FieldSignedAt:
		m.ResetSignedAt()
		return nil
	case employee.FieldHipoStatus:
		m.ResetHipoStatus()
		return nil
	case employee.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case employee.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Employee field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *EmployeeMutation) AddedEdges() []string {
	edges := make([]string, 0, 8)
	if m.tenant != nil {
		edges = append(edges, employee.EdgeTenant)
	}
	if m.department != nil {
		edges = append(edges, employee.EdgeDepartment)
	}
	if m.manager != nil {
		edges = append(edges, employee.EdgeManager)
	}
	if m.subordinates != nil {
		edges = append(edges, employee.EdgeSubordinates)
	}
	if m.compensation_agreements != nil {
		edges = append(edges, employee.EdgeCompensationAgreements)
	}
	if m.succession_plans != nil {
		edges = append(edges, employee.EdgeSuccessionPlans)
	}
	if m.backup_for != nil {
		edges = append(edges, employee.EdgeBackupFor)
	}
	if m.expense_account != nil {
		edges = append(edges, employee.EdgeExpenseAccount)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *EmployeeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case employee.EdgeTenant:
		if id := m.tenant; id != nil {
			return []ent.Value{*id}
		}
	case employee.EdgeDepartment:
		if id := m.department; id != nil {
			return []ent.Value{*id}
		}
	case employee.EdgeManager:
		if id := m.manager; id != nil {
			return []ent.Value{*id}
		}
	case employee.EdgeSubordinates:
		ids := make([]ent.Value, 0, len(m.subordinates))
		for id := range m.subordinates {
			ids = append(ids, id)
		}
		return ids
	case employee.EdgeCompensationAgreements:
		ids := make([]ent.Value, 0, len(m.compensation_agreements))
		for id := range m.compensation_agreements {
			ids = append(ids, id)
		}
		return ids
	case employee.EdgeSuccessionPlans:
		ids := make([]ent.Value, 0, len(m.succession_plans))
		for id := range m.succession_plans {
			ids = append(ids, id)
		}
		return ids
	case employee.EdgeBackupFor:
		ids := make([]ent.Value, 0, len(m.backup_for))
		for id := range m.backup_for {
			ids = append(ids, id)
		}
		return ids
	case employee.EdgeExpenseAccount:
		if id := m.expense_account; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *EmployeeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 8)
	if m.removedsubordinates != nil {
		edges = append(edges, employee.EdgeSubordinates)
	}
	if m.removedcompensation_agreements != nil {
		edges = append(edges, employee.EdgeCompensationAgreements)
	}
	if m.removedsuccession_plans != nil {
		edges = append(edges, employee.EdgeSuccessionPlans)
	}
	if m.removedbackup_for != nil {
		edges = append(edges, employee.EdgeBackupFor)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *EmployeeMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case employee.EdgeSubordinates:
		ids := make([]ent.Value, 0, len(m.removedsubordinates))
		for id := range m.removedsubordinates {
			ids = append(ids, id)
		}
		return ids
	case employee.EdgeCompensationAgreements:
		ids := make([]ent.Value, 0, len(m.removedcompensation_agreements))
		for id := range m.removedcompensation_agreements {
			ids = append(ids, id)
		}
		return ids
	case employee.EdgeSuccessionPlans:
		ids := make([]ent.Value, 0, len(m.removedsuccession_plans))
		for id := range m.removedsuccession_plans {
			ids = append(ids, id)
		}
		return ids
	case employee.EdgeBackupFor:
		ids := make([]ent.Value, 0, len(m.removedbackup_for))
		for id := range m.removedbackup_for {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *EmployeeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 8)
	if m.clearedtenant {
		edges = append(edges, employee.EdgeTenant)
	}
	if m.cleareddepartment {
		edges = append(edges, employee.EdgeDepartment)
	}
	if m.clearedmanager {
		edges = append(edges, employee.EdgeManager)
	}
	if m.clearedsubordinates {
		edges = append(edges, employee.EdgeSubordinates)
	}
	if m.clearedcompensation_agreements {
		edges = append(edges, employee.EdgeCompensationAgreements)
	}
	if m.clearedsuccession_plans {
		edges = append(edges, employee.EdgeSuccessionPlans)
	}
	if m.clearedbackup_for {
		edges = append(edges, employee.EdgeBackupFor)
	}
	if m.clearedexpense_account {
		edges = append(edges, employee.EdgeExpenseAccount)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *EmployeeMutation) EdgeCleared(name string) bool {
	switch name {
	case employee.EdgeTenant:
		return m.clearedtenant
	case employee.EdgeDepartment:
		return m.cleareddepartment
	case employee.EdgeManager:
		return m.clearedmanager
	case employee.EdgeSubordinates:
		return m.clearedsubordinates
	case employee.EdgeCompensationAgreements:
		return m.clearedcompensation_agreements
	case employee.EdgeSuccessionPlans:
		return m.clearedsuccession_plans
	case employee.EdgeBackupFor:
		return m.clearedbackup_for
	case employee.EdgeExpenseAccount:
		return m.clearedexpense_account
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *EmployeeMutation) ClearEdge(name string) error {
	switch name {
	case employee.EdgeTenant:
		m.ClearTenant()
		return nil
	case employee.EdgeDepartment:
		m.ClearDepartment()
		return nil
	case employee.EdgeManager:
		m.ClearManager()
		return nil
	case employee.EdgeExpenseAccount:
		m.ClearExpenseAccount()
		return nil
	}
	return fmt.Errorf("unknown Employee unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *EmployeeMutation) ResetEdge(name string) error {
	switch name {
	case employee.EdgeTenant:
		m.ResetTenant()
		return nil
	case employee.EdgeDepartment:
		m.ResetDepartment()
		return nil
	case employee.EdgeManager:
		m.ResetManager()
		return nil
	case employee.EdgeSubordinates:
		m.ResetSubordinates()
		return nil
	case employee.EdgeCompensationAgreements:
		m.ResetCompensationAgreements()
		return nil
	case employee.EdgeSuccessionPlans:
		m.ResetSuccessionPlans()
		return nil
	case employee.EdgeBackupFor:
		m.ResetBackupFor()
		return nil
	case employee.EdgeExpenseAccount:
		m.ResetExpenseAccount()
		return nil
	}
	return fmt.Errorf("unknown Employee edge %s", name)
}

// HealthScoreSnapshotMutation represents an operation that mutates the HealthScoreSnapshot nodes in the graph.
type HealthScoreSnapshotMutation struct {
	config
	op                   Op
	typ                  string
	id                   *int
	overall_score        *float64
	addoverall_score     *float64
	performance_score    *float64
	addperformance_score *float64
	security_score       *float64
	addsecurity_score    *float64
	lifecycle_score      *float64
	addlifecycle_score   *float64
	metadata             *map[string]interface{}
	timestamp            *time.Time
	clearedFields        map[string]struct{}
	tenant               *int
	clearedtenant        bool
	done                 bool
	oldValue             func(context.Context) (*HealthScoreSnapshot, error)
	predicates           []predicate.HealthScoreSnapshot
}

var _ ent.Mutation = (*HealthScoreSnapshotMutation)(nil)

// healthscoresnapshotOption allows management of the mutation configuration using functional options.
type healthscoresnapshotOption func(*HealthScoreSnapshotMutation)

// newHealthScoreSnapshotMutation creates new mutation for the HealthScoreSnapshot entity.
func newHealthScoreSnapshotMutation(c config, op Op, opts ...healthscoresnapshotOption) *HealthScoreSnapshotMutation {
	m := &HealthScoreSnapshotMutation{
		config:        c,
		op:            op,
		typ:           TypeHealthScoreSnapshot,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withHealthScoreSnapshotID sets the ID field of the mutation.
func withHealthScoreSnapshotID(id int) healthscoresnapshotOption {
	return func(m *HealthScoreSnapshotMutation) {
		var (
			err   error
			once  sync.Once
			value *HealthScoreSnapshot
		)
		m.oldValue = func(ctx context.Context) (*HealthScoreSnapshot, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().HealthScoreSnapshot.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withHealthScoreSnapshot sets the old HealthScoreSnapshot of the mutation.
func withHealthScoreSnapshot(node *HealthScoreSnapshot) healthscoresnapshotOption {
	return func(m *HealthScoreSnapshotMutation) {
		m.oldValue = func(context.Context) (*HealthScoreSnapshot, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m HealthScoreSnapshotMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m HealthScoreSnapshotMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *HealthScoreSnapshotMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *HealthScoreSnapshotMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().HealthScoreSnapshot.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetOverallScore sets the "overall_score" field.
func (m *HealthScoreSnapshotMutation) SetOverallScore(f float64) {
	m.overall_score = &f
	m.addoverall_score = nil
}

// OverallScore returns the value of the "overall_score" field in the mutation.
func (m *HealthScoreSnapshotMutation) OverallScore() (r float64, exists bool) {
	v := m.overall_score
	if v == nil {
		return
	}
	return *v, true
}

// OldOverallScore returns the old "overall_score" field's value of the HealthScoreSnapshot entity.
// If the HealthScoreSnapshot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HealthScoreSnapshotMutation) OldOverallScore(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOverallScore is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOverallScore requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOverallScore: %w", err)
	}
	return oldValue.OverallScore, nil
}

// AddOverallScore adds f to the "overall_score" field.
func (m *HealthScoreSnapshotMutation) AddOverallScore(f float64) {
	if m.addoverall_score != nil {
		*m.addoverall_score += f
	} else {
		m.addoverall_score = &f
	}
}

// AddedOverallScore returns the value that was added to the "overall_score" field in this mutation.
func (m *HealthScoreSnapshotMutation) AddedOverallScore() (r float64, exists bool) {
	v := m.addoverall_score
	if v == nil {
		return
	}
	return *v, true
}

// ResetOverallScore resets all changes to the "overall_score" field.
func (m *HealthScoreSnapshotMutation) ResetOverallScore() {
	m.overall_score = nil
	m.addoverall_score = nil
}

// SetPerformanceScore sets the "performance_score" field.
func (m *HealthScoreSnapshotMutation) SetPerformanceScore(f float64) {
	m.performance_score = &f
	m.addperformance_score = nil
}

// PerformanceScore returns the value of the "performance_score" field in the mutation.
func (m *HealthScoreSnapshotMutation) PerformanceScore() (r float64, exists bool) {
	v := m.performance_score
	if v == nil {
		return
	}
	return *v, true
}

// OldPerformanceScore returns the old "performance_score" field's value of the HealthScoreSnapshot entity.
// If the HealthScoreSnapshot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HealthScoreSnapshotMutation) OldPerformanceScore(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPerformanceScore is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPerformanceScore requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPerformanceScore: %w", err)
	}
	return oldValue.PerformanceScore, nil
}

// AddPerformanceScore adds f to the "performance_score" field.
func (m *HealthScoreSnapshotMutation) AddPerformanceScore(f float64) {
	if m.addperformance_score != nil {
		*m.addperformance_score += f
	} else {
		m.addperformance_score = &f
	}
}

// AddedPerformanceScore returns the value that was added to the "performance_score" field in this mutation.
func (m *HealthScoreSnapshotMutation) AddedPerformanceScore() (r float64, exists bool) {
	v := m.addperformance_score
	if v == nil {
		return
	}
	return *v, true
}

// ResetPerformanceScore resets all changes to the "performance_score" field.
func (m *HealthScoreSnapshotMutation) ResetPerformanceScore() {
	m.performance_score = nil
	m.addperformance_score = nil
}

// SetSecurityScore sets the "security_score" field.
func (m *HealthScoreSnapshotMutation) SetSecurityScore(f float64) {
	m.security_score = &f
	m.addsecurity_score = nil
}

// SecurityScore returns the value of the "security_score" field in the mutation.
func (m *HealthScoreSnapshotMutation) SecurityScore() (r float64, exists bool) {
	v := m.security_score
	if v == nil {
		return
	}
	return *v, true
}

// OldSecurityScore returns the old "security_score" field's value of the HealthScoreSnapshot entity.
// If the HealthScoreSnapshot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HealthScoreSnapshotMutation) OldSecurityScore(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSecurityScore is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSecurityScore requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSecurityScore: %w", err)
	}
	return oldValue.SecurityScore, nil
}

// AddSecurityScore adds f to the "security_score" field.
func (m *HealthScoreSnapshotMutation) AddSecurityScore(f float64) {
	if m.addsecurity_score != nil {
		*m.addsecurity_score += f
	} else {
		m.addsecurity_score = &f
	}
}

// AddedSecurityScore returns the value that was added to the "security_score" field in this mutation.
func (m *HealthScoreSnapshotMutation) AddedSecurityScore() (r float64, exists bool) {
	v := m.addsecurity_score
	if v == nil {
		return
	}
	return *v, true
}

// ResetSecurityScore resets all changes to the "security_score" field.
func (m *HealthScoreSnapshotMutation) ResetSecurityScore() {
	m.security_score = nil
	m.addsecurity_score = nil
}

// SetLifecycleScore sets the "lifecycle_score" field.
func (m *HealthScoreSnapshotMutation) SetLifecycleScore(f float64) {
	m.lifecycle_score = &f
	m.addlifecycle_score = nil
}

// LifecycleScore returns the value of the "lifecycle_score" field in the mutation.
func (m *HealthScoreSnapshotMutation) LifecycleScore() (r float64, exists bool) {
	v := m.lifecycle_score
	if v == nil {
		return
	}
	return *v, true
}

// OldLifecycleScore returns the old "lifecycle_score" field's value of the HealthScoreSnapshot entity.
// If the HealthScoreSnapshot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HealthScoreSnapshotMutation) OldLifecycleScore(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLifecycleScore is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLifecycleScore requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLifecycleScore: %w", err)
	}
	return oldValue.LifecycleScore, nil
}

// AddLifecycleScore adds f to the "lifecycle_score" field.
func (m *HealthScoreSnapshotMutation) AddLifecycleScore(f float64) {
	if m.addlifecycle_score != nil {
		*m.addlifecycle_score += f
	} else {
		m.addlifecycle_score = &f
	}
}

// AddedLifecycleScore returns the value that was added to the "lifecycle_score" field in this mutation.
func (m *HealthScoreSnapshotMutation) AddedLifecycleScore() (r float64, exists bool) {
	v := m.addlifecycle_score
	if v == nil {
		return
	}
	return *v, true
}

// ResetLifecycleScore resets all changes to the "lifecycle_score" field.
func (m *HealthScoreSnapshotMutation) ResetLifecycleScore() {
	m.lifecycle_score = nil
	m.addlifecycle_score = nil
}

// SetMetadata sets the "metadata" field.
func (m *HealthScoreSnapshotMutation) SetMetadata(value map[string]interface{}) {
	m.metadata = &value
}

// Metadata returns the value of the "metadata" field in the mutation.
func (m *HealthScoreSnapshotMutation) Metadata() (r map[string]interface{}, exists bool) {
	v := m.metadata
	if v == nil {
		return
	}
	return *v, true
}

// OldMetadata returns the old "metadata" field's value of the HealthScoreSnapshot entity.
// If the HealthScoreSnapshot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HealthScoreSnapshotMutation) OldMetadata(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMetadata is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMetadata requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetadata: %w", err)
	}
	return oldValue.Metadata, nil
}

// ClearMetadata clears the value of the "metadata" field.
func (m *HealthScoreSnapshotMutation) ClearMetadata() {
	m.metadata = nil
	m.clearedFields[healthscoresnapshot.FieldMetadata] = struct{}{}
}

// MetadataCleared returns if the "metadata" field was cleared in this mutation.
func (m *HealthScoreSnapshotMutation) MetadataCleared() bool {
	_, ok := m.clearedFields[healthscoresnapshot.FieldMetadata]
	return ok
}

// ResetMetadata resets all changes to the "metadata" field.
func (m *HealthScoreSnapshotMutation) ResetMetadata() {
	m.metadata = nil
	delete(m.clearedFields, healthscoresnapshot.FieldMetadata)
}

// SetTimestamp sets the "timestamp" field.
func (m *HealthScoreSnapshotMutation) SetTimestamp(t time.Time) {
	m.timestamp = &t
}

// Timestamp returns the value of the "timestamp" field in the mutation.
func (m *HealthScoreSnapshotMutation) Timestamp() (r time.Time, exists bool) {
	v := m.timestamp
	if v == nil {
		return
	}
	return *v, true
}

// OldTimestamp returns the old "timestamp" field's value of the HealthScoreSnapshot entity.
// If the HealthScoreSnapshot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HealthScoreSnapshotMutation) OldTimestamp(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTimestamp is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTimestamp requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTimestamp: %w", err)
	}
	return oldValue.Timestamp, nil
}

// ResetTimestamp resets all changes to the "timestamp" field.
func (m *HealthScoreSnapshotMutation) ResetTimestamp() {
	m.timestamp = nil
}

// SetTenantID sets the "tenant" edge to the Tenant entity by id.
func (m *HealthScoreSnapshotMutation) SetTenantID(id int) {
	m.tenant = &id
}

// ClearTenant clears the "tenant" edge to the Tenant entity.
func (m *HealthScoreSnapshotMutation) ClearTenant() {
	m.clearedtenant = true
}

// TenantCleared reports if the "tenant" edge to the Tenant entity was cleared.
func (m *HealthScoreSnapshotMutation) TenantCleared() bool {
	return m.clearedtenant
}

// TenantID returns the "tenant" edge ID in the mutation.
func (m *HealthScoreSnapshotMutation) TenantID() (id int, exists bool) {
	if m.tenant != nil {
		return *m.tenant, true
	}
	return
}

// TenantIDs returns the "tenant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TenantID instead. It exists only for internal usage by the builders.
func (m *HealthScoreSnapshotMutation) TenantIDs() (ids []int) {
	if id := m.tenant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTenant resets all changes to the "tenant" edge.
func (m *HealthScoreSnapshotMutation) ResetTenant() {
	m.tenant = nil
	m.clearedtenant = false
}

// Where appends a list predicates to the HealthScoreSnapshotMutation builder.
func (m *HealthScoreSnapshotMutation) Where(ps ...predicate.HealthScoreSnapshot) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the HealthScoreSnapshotMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *HealthScoreSnapshotMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.HealthScoreSnapshot, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *HealthScoreSnapshotMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *HealthScoreSnapshotMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (HealthScoreSnapshot).
func (m *HealthScoreSnapshotMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *HealthScoreSnapshotMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.overall_score != nil {
		fields = append(fields, healthscoresnapshot.FieldOverallScore)
	}
	if m.performance_score != nil {
		fields = append(fields, healthscoresnapshot.FieldPerformanceScore)
	}
	if m.security_score != nil {
		fields = append(fields, healthscoresnapshot.FieldSecurityScore)
	}
	if m.lifecycle_score != nil {
		fields = append(fields, healthscoresnapshot.FieldLifecycleScore)
	}
	if m.metadata != nil {
		fields = append(fields, healthscoresnapshot.FieldMetadata)
	}
	if m.timestamp != nil {
		fields = append(fields, healthscoresnapshot.FieldTimestamp)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *HealthScoreSnapshotMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case healthscoresnapshot.FieldOverallScore:
		return m.OverallScore()
	case healthscoresnapshot.FieldPerformanceScore:
		return m.PerformanceScore()
	case healthscoresnapshot.FieldSecurityScore:
		return m.SecurityScore()
	case healthscoresnapshot.FieldLifecycleScore:
		return m.LifecycleScore()
	case healthscoresnapshot.FieldMetadata:
		return m.Metadata()
	case healthscoresnapshot.FieldTimestamp:
		return m.Timestamp()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *HealthScoreSnapshotMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case healthscoresnapshot.FieldOverallScore:
		return m.OldOverallScore(ctx)
	case healthscoresnapshot.FieldPerformanceScore:
		return m.OldPerformanceScore(ctx)
	case healthscoresnapshot.FieldSecurityScore:
		return m.OldSecurityScore(ctx)
	case healthscoresnapshot.FieldLifecycleScore:
		return m.OldLifecycleScore(ctx)
	case healthscoresnapshot.FieldMetadata:
		return m.OldMetadata(ctx)
	case healthscoresnapshot.FieldTimestamp:
		return m.OldTimestamp(ctx)
	}
	return nil, fmt.Errorf("unknown HealthScoreSnapshot field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *HealthScoreSnapshotMutation) SetField(name string, value ent.Value) error {
	switch name {
	case healthscoresnapshot.FieldOverallScore:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOverallScore(v)
		return nil
	case healthscoresnapshot.FieldPerformanceScore:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPerformanceScore(v)
		return nil
	case healthscoresnapshot.FieldSecurityScore:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSecurityScore(v)
		return nil
	case healthscoresnapshot.FieldLifecycleScore:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLifecycleScore(v)
		return nil
	case healthscoresnapshot.FieldMetadata:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetadata(v)
		return nil
	case healthscoresnapshot.FieldTimestamp:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTimestamp(v)
		return nil
	}
	return fmt.Errorf("unknown HealthScoreSnapshot field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *HealthScoreSnapshotMutation) AddedFields() []string {
	var fields []string
	if m.addoverall_score != nil {
		fields = append(fields, healthscoresnapshot.FieldOverallScore)
	}
	if m.addperformance_score != nil {
		fields = append(fields, healthscoresnapshot.FieldPerformanceScore)
	}
	if m.addsecurity_score != nil {
		fields = append(fields, healthscoresnapshot.FieldSecurityScore)
	}
	if m.addlifecycle_score != nil {
		fields = append(fields, healthscoresnapshot.FieldLifecycleScore)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *HealthScoreSnapshotMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case healthscoresnapshot.FieldOverallScore:
		return m.AddedOverallScore()
	case healthscoresnapshot.FieldPerformanceScore:
		return m.AddedPerformanceScore()
	case healthscoresnapshot.FieldSecurityScore:
		return m.AddedSecurityScore()
	case healthscoresnapshot.FieldLifecycleScore:
		return m.AddedLifecycleScore()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *HealthScoreSnapshotMutation) AddField(name string, value ent.Value) error {
	switch name {
	case healthscoresnapshot.FieldOverallScore:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOverallScore(v)
		return nil
	case healthscoresnapshot.FieldPerformanceScore:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPerformanceScore(v)
		return nil
	case healthscoresnapshot.FieldSecurityScore:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSecurityScore(v)
		return nil
	case healthscoresnapshot.FieldLifecycleScore:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLifecycleScore(v)
		return nil
	}
	return fmt.Errorf("unknown HealthScoreSnapshot numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *HealthScoreSnapshotMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(healthscoresnapshot.FieldMetadata) {
		fields = append(fields, healthscoresnapshot.FieldMetadata)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *HealthScoreSnapshotMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *HealthScoreSnapshotMutation) ClearField(name string) error {
	switch name {
	case healthscoresnapshot.FieldMetadata:
		m.ClearMetadata()
		return nil
	}
	return fmt.Errorf("unknown HealthScoreSnapshot nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *HealthScoreSnapshotMutation) ResetField(name string) error {
	switch name {
	case healthscoresnapshot.FieldOverallScore:
		m.ResetOverallScore()
		return nil
	case healthscoresnapshot.FieldPerformanceScore:
		m.ResetPerformanceScore()
		return nil
	case healthscoresnapshot.FieldSecurityScore:
		m.ResetSecurityScore()
		return nil
	case healthscoresnapshot.FieldLifecycleScore:
		m.ResetLifecycleScore()
		return nil
	case healthscoresnapshot.FieldMetadata:
		m.ResetMetadata()
		return nil
	case healthscoresnapshot.FieldTimestamp:
		m.ResetTimestamp()
		return nil
	}
	return fmt.Errorf("unknown HealthScoreSnapshot field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *HealthScoreSnapshotMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.tenant != nil {
		edges = append(edges, healthscoresnapshot.EdgeTenant)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *HealthScoreSnapshotMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case healthscoresnapshot.EdgeTenant:
		if id := m.tenant; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *HealthScoreSnapshotMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *HealthScoreSnapshotMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *HealthScoreSnapshotMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedtenant {
		edges = append(edges, healthscoresnapshot.EdgeTenant)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *HealthScoreSnapshotMutation) EdgeCleared(name string) bool {
	switch name {
	case healthscoresnapshot.EdgeTenant:
		return m.clearedtenant
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *HealthScoreSnapshotMutation) ClearEdge(name string) error {
	switch name {
	case healthscoresnapshot.EdgeTenant:
		m.ClearTenant()
		return nil
	}
	return fmt.Errorf("unknown HealthScoreSnapshot unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *HealthScoreSnapshotMutation) ResetEdge(name string) error {
	switch name {
	case healthscoresnapshot.EdgeTenant:
		m.ResetTenant()
		return nil
	}
	return fmt.Errorf("unknown HealthScoreSnapshot edge %s", name)
}

// IVRFlowMutation represents an operation that mutates the IVRFlow nodes in the graph.
type IVRFlowMutation struct {
	config
	op            Op
	typ           string
	id            *int
	name          *string
	nodes         *map[string]interface{}
	flow_edges    *map[string]interface{}
	is_active     *bool
	version       *int
	addversion    *int
	created_at    *time.Time
	updated_at    *time.Time
	clearedFields map[string]struct{}
	tenant        *int
	clearedtenant bool
	done          bool
	oldValue      func(context.Context) (*IVRFlow, error)
	predicates    []predicate.IVRFlow
}

var _ ent.Mutation = (*IVRFlowMutation)(nil)

// ivrflowOption allows management of the mutation configuration using functional options.
type ivrflowOption func(*IVRFlowMutation)

// newIVRFlowMutation creates new mutation for the IVRFlow entity.
func newIVRFlowMutation(c config, op Op, opts ...ivrflowOption) *IVRFlowMutation {
	m := &IVRFlowMutation{
		config:        c,
		op:            op,
		typ:           TypeIVRFlow,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withIVRFlowID sets the ID field of the mutation.
func withIVRFlowID(id int) ivrflowOption {
	return func(m *IVRFlowMutation) {
		var (
			err   error
			once  sync.Once
			value *IVRFlow
		)
		m.oldValue = func(ctx context.Context) (*IVRFlow, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().IVRFlow.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withIVRFlow sets the old IVRFlow of the mutation.
func withIVRFlow(node *IVRFlow) ivrflowOption {
	return func(m *IVRFlowMutation) {
		m.oldValue = func(context.Context) (*IVRFlow, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m IVRFlowMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m IVRFlowMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *IVRFlowMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *IVRFlowMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().IVRFlow.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *IVRFlowMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *IVRFlowMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the IVRFlow entity.
// If the IVRFlow object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IVRFlowMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *IVRFlowMutation) ResetName() {
	m.name = nil
}

// SetNodes sets the "nodes" field.
func (m *IVRFlowMutation) SetNodes(value map[string]interface{}) {
	m.nodes = &value
}

// Nodes returns the value of the "nodes" field in the mutation.
func (m *IVRFlowMutation) Nodes() (r map[string]interface{}, exists bool) {
	v := m.nodes
	if v == nil {
		return
	}
	return *v, true
}

// OldNodes returns the old "nodes" field's value of the IVRFlow entity.
// If the IVRFlow object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IVRFlowMutation) OldNodes(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNodes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNodes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNodes: %w", err)
	}
	return oldValue.Nodes, nil
}

// ResetNodes resets all changes to the "nodes" field.
func (m *IVRFlowMutation) ResetNodes() {
	m.nodes = nil
}

// SetFlowEdges sets the "flow_edges" field.
func (m *IVRFlowMutation) SetFlowEdges(value map[string]interface{}) {
	m.flow_edges = &value
}

// FlowEdges returns the value of the "flow_edges" field in the mutation.
func (m *IVRFlowMutation) FlowEdges() (r map[string]interface{}, exists bool) {
	v := m.flow_edges
	if v == nil {
		return
	}
	return *v, true
}

// OldFlowEdges returns the old "flow_edges" field's value of the IVRFlow entity.
// If the IVRFlow object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IVRFlowMutation) OldFlowEdges(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFlowEdges is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFlowEdges requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFlowEdges: %w", err)
	}
	return oldValue.FlowEdges, nil
}

// ResetFlowEdges resets all changes to the "flow_edges" field.
func (m *IVRFlowMutation) ResetFlowEdges() {
	m.flow_edges = nil
}

// SetIsActive sets the "is_active" field.
func (m *IVRFlowMutation) SetIsActive(b bool) {
	m.is_active = &b
}

// IsActive returns the value of the "is_active" field in the mutation.
func (m *IVRFlowMutation) IsActive() (r bool, exists bool) {
	v := m.is_active
	if v == nil {
		return
	}
	return *v, true
}

// OldIsActive returns the old "is_active" field's value of the IVRFlow entity.
// If the IVRFlow object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IVRFlowMutation) OldIsActive(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsActive is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsActive requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsActive: %w", err)
	}
	return oldValue.IsActive, nil
}

// ResetIsActive resets all changes to the "is_active" field.
func (m *IVRFlowMutation) ResetIsActive() {
	m.is_active = nil
}

// SetVersion sets the "version" field.
func (m *IVRFlowMutation) SetVersion(i int) {
	m.version = &i
	m.addversion = nil
}

// Version returns the value of the "version" field in the mutation.
func (m *IVRFlowMutation) Version() (r int, exists bool) {
	v := m.version
	if v == nil {
		return
	}
	return *v, true
}

// OldVersion returns the old "version" field's value of the IVRFlow entity.
// If the IVRFlow object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IVRFlowMutation) OldVersion(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVersion: %w", err)
	}
	return oldValue.Version, nil
}

// AddVersion adds i to the "version" field.
func (m *IVRFlowMutation) AddVersion(i int) {
	if m.addversion != nil {
		*m.addversion += i
	} else {
		m.addversion = &i
	}
}

// AddedVersion returns the value that was added to the "version" field in this mutation.
func (m *IVRFlowMutation) AddedVersion() (r int, exists bool) {
	v := m.addversion
	if v == nil {
		return
	}
	return *v, true
}

// ResetVersion resets all changes to the "version" field.
func (m *IVRFlowMutation) ResetVersion() {
	m.version = nil
	m.addversion = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *IVRFlowMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *IVRFlowMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the IVRFlow entity.
// If the IVRFlow object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IVRFlowMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *IVRFlowMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *IVRFlowMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *IVRFlowMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the IVRFlow entity.
// If the IVRFlow object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IVRFlowMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *IVRFlowMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetTenantID sets the "tenant" edge to the Tenant entity by id.
func (m *IVRFlowMutation) SetTenantID(id int) {
	m.tenant = &id
}

// ClearTenant clears the "tenant" edge to the Tenant entity.
func (m *IVRFlowMutation) ClearTenant() {
	m.clearedtenant = true
}

// TenantCleared reports if the "tenant" edge to the Tenant entity was cleared.
func (m *IVRFlowMutation) TenantCleared() bool {
	return m.clearedtenant
}

// TenantID returns the "tenant" edge ID in the mutation.
func (m *IVRFlowMutation) TenantID() (id int, exists bool) {
	if m.tenant != nil {
		return *m.tenant, true
	}
	return
}

// TenantIDs returns the "tenant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TenantID instead. It exists only for internal usage by the builders.
func (m *IVRFlowMutation) TenantIDs() (ids []int) {
	if id := m.tenant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTenant resets all changes to the "tenant" edge.
func (m *IVRFlowMutation) ResetTenant() {
	m.tenant = nil
	m.clearedtenant = false
}

// Where appends a list predicates to the IVRFlowMutation builder.
func (m *IVRFlowMutation) Where(ps ...predicate.IVRFlow) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the IVRFlowMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *IVRFlowMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.IVRFlow, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *IVRFlowMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *IVRFlowMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (IVRFlow).
func (m *IVRFlowMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *IVRFlowMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.name != nil {
		fields = append(fields, ivrflow.FieldName)
	}
	if m.nodes != nil {
		fields = append(fields, ivrflow.FieldNodes)
	}
	if m.flow_edges != nil {
		fields = append(fields, ivrflow.FieldFlowEdges)
	}
	if m.is_active != nil {
		fields = append(fields, ivrflow.FieldIsActive)
	}
	if m.version != nil {
		fields = append(fields, ivrflow.FieldVersion)
	}
	if m.created_at != nil {
		fields = append(fields, ivrflow.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, ivrflow.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *IVRFlowMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case ivrflow.FieldName:
		return m.Name()
	case ivrflow.FieldNodes:
		return m.Nodes()
	case ivrflow.FieldFlowEdges:
		return m.FlowEdges()
	case ivrflow.FieldIsActive:
		return m.IsActive()
	case ivrflow.FieldVersion:
		return m.Version()
	case ivrflow.FieldCreatedAt:
		return m.CreatedAt()
	case ivrflow.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *IVRFlowMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case ivrflow.FieldName:
		return m.OldName(ctx)
	case ivrflow.FieldNodes:
		return m.OldNodes(ctx)
	case ivrflow.FieldFlowEdges:
		return m.OldFlowEdges(ctx)
	case ivrflow.FieldIsActive:
		return m.OldIsActive(ctx)
	case ivrflow.FieldVersion:
		return m.OldVersion(ctx)
	case ivrflow.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case ivrflow.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown IVRFlow field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *IVRFlowMutation) SetField(name string, value ent.Value) error {
	switch name {
	case ivrflow.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case ivrflow.FieldNodes:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNodes(v)
		return nil
	case ivrflow.FieldFlowEdges:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFlowEdges(v)
		return nil
	case ivrflow.FieldIsActive:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsActive(v)
		return nil
	case ivrflow.FieldVersion:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVersion(v)
		return nil
	case ivrflow.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case ivrflow.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown IVRFlow field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *IVRFlowMutation) AddedFields() []string {
	var fields []string
	if m.addversion != nil {
		fields = append(fields, ivrflow.FieldVersion)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *IVRFlowMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case ivrflow.FieldVersion:
		return m.AddedVersion()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *IVRFlowMutation) AddField(name string, value ent.Value) error {
	switch name {
	case ivrflow.FieldVersion:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddVersion(v)
		return nil
	}
	return fmt.Errorf("unknown IVRFlow numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *IVRFlowMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *IVRFlowMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *IVRFlowMutation) ClearField(name string) error {
	return fmt.Errorf("unknown IVRFlow nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *IVRFlowMutation) ResetField(name string) error {
	switch name {
	case ivrflow.FieldName:
		m.ResetName()
		return nil
	case ivrflow.FieldNodes:
		m.ResetNodes()
		return nil
	case ivrflow.FieldFlowEdges:
		m.ResetFlowEdges()
		return nil
	case ivrflow.FieldIsActive:
		m.ResetIsActive()
		return nil
	case ivrflow.FieldVersion:
		m.ResetVersion()
		return nil
	case ivrflow.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case ivrflow.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown IVRFlow field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *IVRFlowMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.tenant != nil {
		edges = append(edges, ivrflow.EdgeTenant)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *IVRFlowMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case ivrflow.EdgeTenant:
		if id := m.tenant; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *IVRFlowMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *IVRFlowMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *IVRFlowMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedtenant {
		edges = append(edges, ivrflow.EdgeTenant)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *IVRFlowMutation) EdgeCleared(name string) bool {
	switch name {
	case ivrflow.EdgeTenant:
		return m.clearedtenant
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *IVRFlowMutation) ClearEdge(name string) error {
	switch name {
	case ivrflow.EdgeTenant:
		m.ClearTenant()
		return nil
	}
	return fmt.Errorf("unknown IVRFlow unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *IVRFlowMutation) ResetEdge(name string) error {
	switch name {
	case ivrflow.EdgeTenant:
		m.ResetTenant()
		return nil
	}
	return fmt.Errorf("unknown IVRFlow edge %s", name)
}

// InventoryReservationMutation represents an operation that mutates the InventoryReservation nodes in the graph.
type InventoryReservationMutation struct {
	config
	op             Op
	typ            string
	id             *int
	quantity       *float64
	addquantity    *float64
	expires_at     *time.Time
	status         *inventoryreservation.Status
	created_at     *time.Time
	clearedFields  map[string]struct{}
	product        *int
	clearedproduct bool
	tenant         *int
	clearedtenant  bool
	done           bool
	oldValue       func(context.Context) (*InventoryReservation, error)
	predicates     []predicate.InventoryReservation
}

var _ ent.Mutation = (*InventoryReservationMutation)(nil)

// inventoryreservationOption allows management of the mutation configuration using functional options.
type inventoryreservationOption func(*InventoryReservationMutation)

// newInventoryReservationMutation creates new mutation for the InventoryReservation entity.
func newInventoryReservationMutation(c config, op Op, opts ...inventoryreservationOption) *InventoryReservationMutation {
	m := &InventoryReservationMutation{
		config:        c,
		op:            op,
		typ:           TypeInventoryReservation,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withInventoryReservationID sets the ID field of the mutation.
func withInventoryReservationID(id int) inventoryreservationOption {
	return func(m *InventoryReservationMutation) {
		var (
			err   error
			once  sync.Once
			value *InventoryReservation
		)
		m.oldValue = func(ctx context.Context) (*InventoryReservation, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().InventoryReservation.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withInventoryReservation sets the old InventoryReservation of the mutation.
func withInventoryReservation(node *InventoryReservation) inventoryreservationOption {
	return func(m *InventoryReservationMutation) {
		m.oldValue = func(context.Context) (*InventoryReservation, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m InventoryReservationMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m InventoryReservationMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *InventoryReservationMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *InventoryReservationMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().InventoryReservation.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetQuantity sets the "quantity" field.
func (m *InventoryReservationMutation) SetQuantity(f float64) {
	m.quantity = &f
	m.addquantity = nil
}

// Quantity returns the value of the "quantity" field in the mutation.
func (m *InventoryReservationMutation) Quantity() (r float64, exists bool) {
	v := m.quantity
	if v == nil {
		return
	}
	return *v, true
}

// OldQuantity returns the old "quantity" field's value of the InventoryReservation entity.
// If the InventoryReservation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InventoryReservationMutation) OldQuantity(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldQuantity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldQuantity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldQuantity: %w", err)
	}
	return oldValue.Quantity, nil
}

// AddQuantity adds f to the "quantity" field.
func (m *InventoryReservationMutation) AddQuantity(f float64) {
	if m.addquantity != nil {
		*m.addquantity += f
	} else {
		m.addquantity = &f
	}
}

// AddedQuantity returns the value that was added to the "quantity" field in this mutation.
func (m *InventoryReservationMutation) AddedQuantity() (r float64, exists bool) {
	v := m.addquantity
	if v == nil {
		return
	}
	return *v, true
}

// ResetQuantity resets all changes to the "quantity" field.
func (m *InventoryReservationMutation) ResetQuantity() {
	m.quantity = nil
	m.addquantity = nil
}

// SetExpiresAt sets the "expires_at" field.
func (m *InventoryReservationMutation) SetExpiresAt(t time.Time) {
	m.expires_at = &t
}

// ExpiresAt returns the value of the "expires_at" field in the mutation.
func (m *InventoryReservationMutation) ExpiresAt() (r time.Time, exists bool) {
	v := m.expires_at
	if v == nil {
		return
	}
	return *v, true
}

// OldExpiresAt returns the old "expires_at" field's value of the InventoryReservation entity.
// If the InventoryReservation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InventoryReservationMutation) OldExpiresAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpiresAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpiresAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpiresAt: %w", err)
	}
	return oldValue.ExpiresAt, nil
}

// ResetExpiresAt resets all changes to the "expires_at" field.
func (m *InventoryReservationMutation) ResetExpiresAt() {
	m.expires_at = nil
}

// SetStatus sets the "status" field.
func (m *InventoryReservationMutation) SetStatus(i inventoryreservation.Status) {
	m.status = &i
}

// Status returns the value of the "status" field in the mutation.
func (m *InventoryReservationMutation) Status() (r inventoryreservation.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the InventoryReservation entity.
// If the InventoryReservation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InventoryReservationMutation) OldStatus(ctx context.Context) (v inventoryreservation.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *InventoryReservationMutation) ResetStatus() {
	m.status = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *InventoryReservationMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *InventoryReservationMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the InventoryReservation entity.
// If the InventoryReservation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InventoryReservationMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *InventoryReservationMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetProductID sets the "product" edge to the Product entity by id.
func (m *InventoryReservationMutation) SetProductID(id int) {
	m.product = &id
}

// ClearProduct clears the "product" edge to the Product entity.
func (m *InventoryReservationMutation) ClearProduct() {
	m.clearedproduct = true
}

// ProductCleared reports if the "product" edge to the Product entity was cleared.
func (m *InventoryReservationMutation) ProductCleared() bool {
	return m.clearedproduct
}

// ProductID returns the "product" edge ID in the mutation.
func (m *InventoryReservationMutation) ProductID() (id int, exists bool) {
	if m.product != nil {
		return *m.product, true
	}
	return
}

// ProductIDs returns the "product" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProductID instead. It exists only for internal usage by the builders.
func (m *InventoryReservationMutation) ProductIDs() (ids []int) {
	if id := m.product; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProduct resets all changes to the "product" edge.
func (m *InventoryReservationMutation) ResetProduct() {
	m.product = nil
	m.clearedproduct = false
}

// SetTenantID sets the "tenant" edge to the Tenant entity by id.
func (m *InventoryReservationMutation) SetTenantID(id int) {
	m.tenant = &id
}

// ClearTenant clears the "tenant" edge to the Tenant entity.
func (m *InventoryReservationMutation) ClearTenant() {
	m.clearedtenant = true
}

// TenantCleared reports if the "tenant" edge to the Tenant entity was cleared.
func (m *InventoryReservationMutation) TenantCleared() bool {
	return m.clearedtenant
}

// TenantID returns the "tenant" edge ID in the mutation.
func (m *InventoryReservationMutation) TenantID() (id int, exists bool) {
	if m.tenant != nil {
		return *m.tenant, true
	}
	return
}

// TenantIDs returns the "tenant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TenantID instead. It exists only for internal usage by the builders.
func (m *InventoryReservationMutation) TenantIDs() (ids []int) {
	if id := m.tenant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTenant resets all changes to the "tenant" edge.
func (m *InventoryReservationMutation) ResetTenant() {
	m.tenant = nil
	m.clearedtenant = false
}

// Where appends a list predicates to the InventoryReservationMutation builder.
func (m *InventoryReservationMutation) Where(ps ...predicate.InventoryReservation) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the InventoryReservationMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *InventoryReservationMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.InventoryReservation, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *InventoryReservationMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *InventoryReservationMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (InventoryReservation).
func (m *InventoryReservationMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *InventoryReservationMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.quantity != nil {
		fields = append(fields, inventoryreservation.FieldQuantity)
	}
	if m.expires_at != nil {
		fields = append(fields, inventoryreservation.FieldExpiresAt)
	}
	if m.status != nil {
		fields = append(fields, inventoryreservation.FieldStatus)
	}
	if m.created_at != nil {
		fields = append(fields, inventoryreservation.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *InventoryReservationMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case inventoryreservation.FieldQuantity:
		return m.Quantity()
	case inventoryreservation.FieldExpiresAt:
		return m.ExpiresAt()
	case inventoryreservation.FieldStatus:
		return m.Status()
	case inventoryreservation.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *InventoryReservationMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case inventoryreservation.FieldQuantity:
		return m.OldQuantity(ctx)
	case inventoryreservation.FieldExpiresAt:
		return m.OldExpiresAt(ctx)
	case inventoryreservation.FieldStatus:
		return m.OldStatus(ctx)
	case inventoryreservation.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown InventoryReservation field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *InventoryReservationMutation) SetField(name string, value ent.Value) error {
	switch name {
	case inventoryreservation.FieldQuantity:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetQuantity(v)
		return nil
	case inventoryreservation.FieldExpiresAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpiresAt(v)
		return nil
	case inventoryreservation.FieldStatus:
		v, ok := value.(inventoryreservation.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case inventoryreservation.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown InventoryReservation field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *InventoryReservationMutation) AddedFields() []string {
	var fields []string
	if m.addquantity != nil {
		fields = append(fields, inventoryreservation.FieldQuantity)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *InventoryReservationMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case inventoryreservation.FieldQuantity:
		return m.AddedQuantity()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *InventoryReservationMutation) AddField(name string, value ent.Value) error {
	switch name {
	case inventoryreservation.FieldQuantity:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddQuantity(v)
		return nil
	}
	return fmt.Errorf("unknown InventoryReservation numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *InventoryReservationMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *InventoryReservationMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *InventoryReservationMutation) ClearField(name string) error {
	return fmt.Errorf("unknown InventoryReservation nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *InventoryReservationMutation) ResetField(name string) error {
	switch name {
	case inventoryreservation.FieldQuantity:
		m.ResetQuantity()
		return nil
	case inventoryreservation.FieldExpiresAt:
		m.ResetExpiresAt()
		return nil
	case inventoryreservation.FieldStatus:
		m.ResetStatus()
		return nil
	case inventoryreservation.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown InventoryReservation field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *InventoryReservationMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.product != nil {
		edges = append(edges, inventoryreservation.EdgeProduct)
	}
	if m.tenant != nil {
		edges = append(edges, inventoryreservation.EdgeTenant)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *InventoryReservationMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case inventoryreservation.EdgeProduct:
		if id := m.product; id != nil {
			return []ent.Value{*id}
		}
	case inventoryreservation.EdgeTenant:
		if id := m.tenant; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *InventoryReservationMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *InventoryReservationMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *InventoryReservationMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedproduct {
		edges = append(edges, inventoryreservation.EdgeProduct)
	}
	if m.clearedtenant {
		edges = append(edges, inventoryreservation.EdgeTenant)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *InventoryReservationMutation) EdgeCleared(name string) bool {
	switch name {
	case inventoryreservation.EdgeProduct:
		return m.clearedproduct
	case inventoryreservation.EdgeTenant:
		return m.clearedtenant
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *InventoryReservationMutation) ClearEdge(name string) error {
	switch name {
	case inventoryreservation.EdgeProduct:
		m.ClearProduct()
		return nil
	case inventoryreservation.EdgeTenant:
		m.ClearTenant()
		return nil
	}
	return fmt.Errorf("unknown InventoryReservation unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *InventoryReservationMutation) ResetEdge(name string) error {
	switch name {
	case inventoryreservation.EdgeProduct:
		m.ResetProduct()
		return nil
	case inventoryreservation.EdgeTenant:
		m.ResetTenant()
		return nil
	}
	return fmt.Errorf("unknown InventoryReservation edge %s", name)
}

// JournalEntryMutation represents an operation that mutates the JournalEntry nodes in the graph.
type JournalEntryMutation struct {
	config
	op                 Op
	typ                string
	id                 *int
	amount             *float64
	addamount          *float64
	direction          *journalentry.Direction
	created_at         *time.Time
	description        *string
	approval_status    *journalentry.ApprovalStatus
	clearedFields      map[string]struct{}
	account            *int
	clearedaccount     bool
	tenant             *int
	clearedtenant      bool
	transaction        *int
	clearedtransaction bool
	approved_by        *int
	clearedapproved_by bool
	done               bool
	oldValue           func(context.Context) (*JournalEntry, error)
	predicates         []predicate.JournalEntry
}

var _ ent.Mutation = (*JournalEntryMutation)(nil)

// journalentryOption allows management of the mutation configuration using functional options.
type journalentryOption func(*JournalEntryMutation)

// newJournalEntryMutation creates new mutation for the JournalEntry entity.
func newJournalEntryMutation(c config, op Op, opts ...journalentryOption) *JournalEntryMutation {
	m := &JournalEntryMutation{
		config:        c,
		op:            op,
		typ:           TypeJournalEntry,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withJournalEntryID sets the ID field of the mutation.
func withJournalEntryID(id int) journalentryOption {
	return func(m *JournalEntryMutation) {
		var (
			err   error
			once  sync.Once
			value *JournalEntry
		)
		m.oldValue = func(ctx context.Context) (*JournalEntry, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().JournalEntry.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withJournalEntry sets the old JournalEntry of the mutation.
func withJournalEntry(node *JournalEntry) journalentryOption {
	return func(m *JournalEntryMutation) {
		m.oldValue = func(context.Context) (*JournalEntry, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m JournalEntryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m JournalEntryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *JournalEntryMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *JournalEntryMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().JournalEntry.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetAmount sets the "amount" field.
func (m *JournalEntryMutation) SetAmount(f float64) {
	m.amount = &f
	m.addamount = nil
}

// Amount returns the value of the "amount" field in the mutation.
func (m *JournalEntryMutation) Amount() (r float64, exists bool) {
	v := m.amount
	if v == nil {
		return
	}
	return *v, true
}

// OldAmount returns the old "amount" field's value of the JournalEntry entity.
// If the JournalEntry object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JournalEntryMutation) OldAmount(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAmount: %w", err)
	}
	return oldValue.Amount, nil
}

// AddAmount adds f to the "amount" field.
func (m *JournalEntryMutation) AddAmount(f float64) {
	if m.addamount != nil {
		*m.addamount += f
	} else {
		m.addamount = &f
	}
}

// AddedAmount returns the value that was added to the "amount" field in this mutation.
func (m *JournalEntryMutation) AddedAmount() (r float64, exists bool) {
	v := m.addamount
	if v == nil {
		return
	}
	return *v, true
}

// ResetAmount resets all changes to the "amount" field.
func (m *JournalEntryMutation) ResetAmount() {
	m.amount = nil
	m.addamount = nil
}

// SetDirection sets the "direction" field.
func (m *JournalEntryMutation) SetDirection(j journalentry.Direction) {
	m.direction = &j
}

// Direction returns the value of the "direction" field in the mutation.
func (m *JournalEntryMutation) Direction() (r journalentry.Direction, exists bool) {
	v := m.direction
	if v == nil {
		return
	}
	return *v, true
}

// OldDirection returns the old "direction" field's value of the JournalEntry entity.
// If the JournalEntry object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JournalEntryMutation) OldDirection(ctx context.Context) (v journalentry.Direction, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDirection is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDirection requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDirection: %w", err)
	}
	return oldValue.Direction, nil
}

// ResetDirection resets all changes to the "direction" field.
func (m *JournalEntryMutation) ResetDirection() {
	m.direction = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *JournalEntryMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *JournalEntryMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the JournalEntry entity.
// If the JournalEntry object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JournalEntryMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *JournalEntryMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetDescription sets the "description" field.
func (m *JournalEntryMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *JournalEntryMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the JournalEntry entity.
// If the JournalEntry object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JournalEntryMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *JournalEntryMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[journalentry.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *JournalEntryMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[journalentry.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *JournalEntryMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, journalentry.FieldDescription)
}

// SetApprovalStatus sets the "approval_status" field.
func (m *JournalEntryMutation) SetApprovalStatus(js journalentry.ApprovalStatus) {
	m.approval_status = &js
}

// ApprovalStatus returns the value of the "approval_status" field in the mutation.
func (m *JournalEntryMutation) ApprovalStatus() (r journalentry.ApprovalStatus, exists bool) {
	v := m.approval_status
	if v == nil {
		return
	}
	return *v, true
}

// OldApprovalStatus returns the old "approval_status" field's value of the JournalEntry entity.
// If the JournalEntry object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JournalEntryMutation) OldApprovalStatus(ctx context.Context) (v journalentry.ApprovalStatus, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldApprovalStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldApprovalStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldApprovalStatus: %w", err)
	}
	return oldValue.ApprovalStatus, nil
}

// ResetApprovalStatus resets all changes to the "approval_status" field.
func (m *JournalEntryMutation) ResetApprovalStatus() {
	m.approval_status = nil
}

// SetApprovedByID sets the "approved_by_id" field.
func (m *JournalEntryMutation) SetApprovedByID(i int) {
	m.approved_by = &i
}

// ApprovedByID returns the value of the "approved_by_id" field in the mutation.
func (m *JournalEntryMutation) ApprovedByID() (r int, exists bool) {
	v := m.approved_by
	if v == nil {
		return
	}
	return *v, true
}

// OldApprovedByID returns the old "approved_by_id" field's value of the JournalEntry entity.
// If the JournalEntry object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JournalEntryMutation) OldApprovedByID(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldApprovedByID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldApprovedByID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldApprovedByID: %w", err)
	}
	return oldValue.ApprovedByID, nil
}

// ClearApprovedByID clears the value of the "approved_by_id" field.
func (m *JournalEntryMutation) ClearApprovedByID() {
	m.approved_by = nil
	m.clearedFields[journalentry.FieldApprovedByID] = struct{}{}
}

// ApprovedByIDCleared returns if the "approved_by_id" field was cleared in this mutation.
func (m *JournalEntryMutation) ApprovedByIDCleared() bool {
	_, ok := m.clearedFields[journalentry.FieldApprovedByID]
	return ok
}

// ResetApprovedByID resets all changes to the "approved_by_id" field.
func (m *JournalEntryMutation) ResetApprovedByID() {
	m.approved_by = nil
	delete(m.clearedFields, journalentry.FieldApprovedByID)
}

// SetAccountID sets the "account" edge to the Account entity by id.
func (m *JournalEntryMutation) SetAccountID(id int) {
	m.account = &id
}

// ClearAccount clears the "account" edge to the Account entity.
func (m *JournalEntryMutation) ClearAccount() {
	m.clearedaccount = true
}

// AccountCleared reports if the "account" edge to the Account entity was cleared.
func (m *JournalEntryMutation) AccountCleared() bool {
	return m.clearedaccount
}

// AccountID returns the "account" edge ID in the mutation.
func (m *JournalEntryMutation) AccountID() (id int, exists bool) {
	if m.account != nil {
		return *m.account, true
	}
	return
}

// AccountIDs returns the "account" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AccountID instead. It exists only for internal usage by the builders.
func (m *JournalEntryMutation) AccountIDs() (ids []int) {
	if id := m.account; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAccount resets all changes to the "account" edge.
func (m *JournalEntryMutation) ResetAccount() {
	m.account = nil
	m.clearedaccount = false
}

// SetTenantID sets the "tenant" edge to the Tenant entity by id.
func (m *JournalEntryMutation) SetTenantID(id int) {
	m.tenant = &id
}

// ClearTenant clears the "tenant" edge to the Tenant entity.
func (m *JournalEntryMutation) ClearTenant() {
	m.clearedtenant = true
}

// TenantCleared reports if the "tenant" edge to the Tenant entity was cleared.
func (m *JournalEntryMutation) TenantCleared() bool {
	return m.clearedtenant
}

// TenantID returns the "tenant" edge ID in the mutation.
func (m *JournalEntryMutation) TenantID() (id int, exists bool) {
	if m.tenant != nil {
		return *m.tenant, true
	}
	return
}

// TenantIDs returns the "tenant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TenantID instead. It exists only for internal usage by the builders.
func (m *JournalEntryMutation) TenantIDs() (ids []int) {
	if id := m.tenant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTenant resets all changes to the "tenant" edge.
func (m *JournalEntryMutation) ResetTenant() {
	m.tenant = nil
	m.clearedtenant = false
}

// SetTransactionID sets the "transaction" edge to the Transaction entity by id.
func (m *JournalEntryMutation) SetTransactionID(id int) {
	m.transaction = &id
}

// ClearTransaction clears the "transaction" edge to the Transaction entity.
func (m *JournalEntryMutation) ClearTransaction() {
	m.clearedtransaction = true
}

// TransactionCleared reports if the "transaction" edge to the Transaction entity was cleared.
func (m *JournalEntryMutation) TransactionCleared() bool {
	return m.clearedtransaction
}

// TransactionID returns the "transaction" edge ID in the mutation.
func (m *JournalEntryMutation) TransactionID() (id int, exists bool) {
	if m.transaction != nil {
		return *m.transaction, true
	}
	return
}

// TransactionIDs returns the "transaction" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TransactionID instead. It exists only for internal usage by the builders.
func (m *JournalEntryMutation) TransactionIDs() (ids []int) {
	if id := m.transaction; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTransaction resets all changes to the "transaction" edge.
func (m *JournalEntryMutation) ResetTransaction() {
	m.transaction = nil
	m.clearedtransaction = false
}

// ClearApprovedBy clears the "approved_by" edge to the User entity.
func (m *JournalEntryMutation) ClearApprovedBy() {
	m.clearedapproved_by = true
	m.clearedFields[journalentry.FieldApprovedByID] = struct{}{}
}

// ApprovedByCleared reports if the "approved_by" edge to the User entity was cleared.
func (m *JournalEntryMutation) ApprovedByCleared() bool {
	return m.ApprovedByIDCleared() || m.clearedapproved_by
}

// ApprovedByIDs returns the "approved_by" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ApprovedByID instead. It exists only for internal usage by the builders.
func (m *JournalEntryMutation) ApprovedByIDs() (ids []int) {
	if id := m.approved_by; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetApprovedBy resets all changes to the "approved_by" edge.
func (m *JournalEntryMutation) ResetApprovedBy() {
	m.approved_by = nil
	m.clearedapproved_by = false
}

// Where appends a list predicates to the JournalEntryMutation builder.
func (m *JournalEntryMutation) Where(ps ...predicate.JournalEntry) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the JournalEntryMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *JournalEntryMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.JournalEntry, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *JournalEntryMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *JournalEntryMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (JournalEntry).
func (m *JournalEntryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *JournalEntryMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.amount != nil {
		fields = append(fields, journalentry.FieldAmount)
	}
	if m.direction != nil {
		fields = append(fields, journalentry.FieldDirection)
	}
	if m.created_at != nil {
		fields = append(fields, journalentry.FieldCreatedAt)
	}
	if m.description != nil {
		fields = append(fields, journalentry.FieldDescription)
	}
	if m.approval_status != nil {
		fields = append(fields, journalentry.FieldApprovalStatus)
	}
	if m.approved_by != nil {
		fields = append(fields, journalentry.FieldApprovedByID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *JournalEntryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case journalentry.FieldAmount:
		return m.Amount()
	case journalentry.FieldDirection:
		return m.Direction()
	case journalentry.FieldCreatedAt:
		return m.CreatedAt()
	case journalentry.FieldDescription:
		return m.Description()
	case journalentry.FieldApprovalStatus:
		return m.ApprovalStatus()
	case journalentry.FieldApprovedByID:
		return m.ApprovedByID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *JournalEntryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case journalentry.FieldAmount:
		return m.OldAmount(ctx)
	case journalentry.FieldDirection:
		return m.OldDirection(ctx)
	case journalentry.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case journalentry.FieldDescription:
		return m.OldDescription(ctx)
	case journalentry.FieldApprovalStatus:
		return m.OldApprovalStatus(ctx)
	case journalentry.FieldApprovedByID:
		return m.OldApprovedByID(ctx)
	}
	return nil, fmt.Errorf("unknown JournalEntry field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *JournalEntryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case journalentry.FieldAmount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAmount(v)
		return nil
	case journalentry.FieldDirection:
		v, ok := value.(journalentry.Direction)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDirection(v)
		return nil
	case journalentry.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case journalentry.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case journalentry.FieldApprovalStatus:
		v, ok := value.(journalentry.ApprovalStatus)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetApprovalStatus(v)
		return nil
	case journalentry.FieldApprovedByID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetApprovedByID(v)
		return nil
	}
	return fmt.Errorf("unknown JournalEntry field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *JournalEntryMutation) AddedFields() []string {
	var fields []string
	if m.addamount != nil {
		fields = append(fields, journalentry.FieldAmount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *JournalEntryMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case journalentry.FieldAmount:
		return m.AddedAmount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *JournalEntryMutation) AddField(name string, value ent.Value) error {
	switch name {
	case journalentry.FieldAmount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAmount(v)
		return nil
	}
	return fmt.Errorf("unknown JournalEntry numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *JournalEntryMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(journalentry.FieldDescription) {
		fields = append(fields, journalentry.FieldDescription)
	}
	if m.FieldCleared(journalentry.FieldApprovedByID) {
		fields = append(fields, journalentry.FieldApprovedByID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *JournalEntryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *JournalEntryMutation) ClearField(name string) error {
	switch name {
	case journalentry.FieldDescription:
		m.ClearDescription()
		return nil
	case journalentry.FieldApprovedByID:
		m.ClearApprovedByID()
		return nil
	}
	return fmt.Errorf("unknown JournalEntry nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *JournalEntryMutation) ResetField(name string) error {
	switch name {
	case journalentry.FieldAmount:
		m.ResetAmount()
		return nil
	case journalentry.FieldDirection:
		m.ResetDirection()
		return nil
	case journalentry.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case journalentry.FieldDescription:
		m.ResetDescription()
		return nil
	case journalentry.FieldApprovalStatus:
		m.ResetApprovalStatus()
		return nil
	case journalentry.FieldApprovedByID:
		m.ResetApprovedByID()
		return nil
	}
	return fmt.Errorf("unknown JournalEntry field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *JournalEntryMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.account != nil {
		edges = append(edges, journalentry.EdgeAccount)
	}
	if m.tenant != nil {
		edges = append(edges, journalentry.EdgeTenant)
	}
	if m.transaction != nil {
		edges = append(edges, journalentry.EdgeTransaction)
	}
	if m.approved_by != nil {
		edges = append(edges, journalentry.EdgeApprovedBy)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *JournalEntryMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case journalentry.EdgeAccount:
		if id := m.account; id != nil {
			return []ent.Value{*id}
		}
	case journalentry.EdgeTenant:
		if id := m.tenant; id != nil {
			return []ent.Value{*id}
		}
	case journalentry.EdgeTransaction:
		if id := m.transaction; id != nil {
			return []ent.Value{*id}
		}
	case journalentry.EdgeApprovedBy:
		if id := m.approved_by; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *JournalEntryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *JournalEntryMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *JournalEntryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedaccount {
		edges = append(edges, journalentry.EdgeAccount)
	}
	if m.clearedtenant {
		edges = append(edges, journalentry.EdgeTenant)
	}
	if m.clearedtransaction {
		edges = append(edges, journalentry.EdgeTransaction)
	}
	if m.clearedapproved_by {
		edges = append(edges, journalentry.EdgeApprovedBy)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *JournalEntryMutation) EdgeCleared(name string) bool {
	switch name {
	case journalentry.EdgeAccount:
		return m.clearedaccount
	case journalentry.EdgeTenant:
		return m.clearedtenant
	case journalentry.EdgeTransaction:
		return m.clearedtransaction
	case journalentry.EdgeApprovedBy:
		return m.clearedapproved_by
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *JournalEntryMutation) ClearEdge(name string) error {
	switch name {
	case journalentry.EdgeAccount:
		m.ClearAccount()
		return nil
	case journalentry.EdgeTenant:
		m.ClearTenant()
		return nil
	case journalentry.EdgeTransaction:
		m.ClearTransaction()
		return nil
	case journalentry.EdgeApprovedBy:
		m.ClearApprovedBy()
		return nil
	}
	return fmt.Errorf("unknown JournalEntry unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *JournalEntryMutation) ResetEdge(name string) error {
	switch name {
	case journalentry.EdgeAccount:
		m.ResetAccount()
		return nil
	case journalentry.EdgeTenant:
		m.ResetTenant()
		return nil
	case journalentry.EdgeTransaction:
		m.ResetTransaction()
		return nil
	case journalentry.EdgeApprovedBy:
		m.ResetApprovedBy()
		return nil
	}
	return fmt.Errorf("unknown JournalEntry edge %s", name)
}

// LedgerEntryMutation represents an operation that mutates the LedgerEntry nodes in the graph.
type LedgerEntryMutation struct {
	config
	op                 Op
	typ                string
	id                 *int
	amount             *float64
	addamount          *float64
	direction          *ledgerentry.Direction
	created_at         *time.Time
	clearedFields      map[string]struct{}
	transaction        *int
	clearedtransaction bool
	account            *int
	clearedaccount     bool
	tenant             *int
	clearedtenant      bool
	done               bool
	oldValue           func(context.Context) (*LedgerEntry, error)
	predicates         []predicate.LedgerEntry
}

var _ ent.Mutation = (*LedgerEntryMutation)(nil)

// ledgerentryOption allows management of the mutation configuration using functional options.
type ledgerentryOption func(*LedgerEntryMutation)

// newLedgerEntryMutation creates new mutation for the LedgerEntry entity.
func newLedgerEntryMutation(c config, op Op, opts ...ledgerentryOption) *LedgerEntryMutation {
	m := &LedgerEntryMutation{
		config:        c,
		op:            op,
		typ:           TypeLedgerEntry,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withLedgerEntryID sets the ID field of the mutation.
func withLedgerEntryID(id int) ledgerentryOption {
	return func(m *LedgerEntryMutation) {
		var (
			err   error
			once  sync.Once
			value *LedgerEntry
		)
		m.oldValue = func(ctx context.Context) (*LedgerEntry, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().LedgerEntry.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withLedgerEntry sets the old LedgerEntry of the mutation.
func withLedgerEntry(node *LedgerEntry) ledgerentryOption {
	return func(m *LedgerEntryMutation) {
		m.oldValue = func(context.Context) (*LedgerEntry, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m LedgerEntryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m LedgerEntryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *LedgerEntryMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *LedgerEntryMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().LedgerEntry.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetAmount sets the "amount" field.
func (m *LedgerEntryMutation) SetAmount(f float64) {
	m.amount = &f
	m.addamount = nil
}

// Amount returns the value of the "amount" field in the mutation.
func (m *LedgerEntryMutation) Amount() (r float64, exists bool) {
	v := m.amount
	if v == nil {
		return
	}
	return *v, true
}

// OldAmount returns the old "amount" field's value of the LedgerEntry entity.
// If the LedgerEntry object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LedgerEntryMutation) OldAmount(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAmount: %w", err)
	}
	return oldValue.Amount, nil
}

// AddAmount adds f to the "amount" field.
func (m *LedgerEntryMutation) AddAmount(f float64) {
	if m.addamount != nil {
		*m.addamount += f
	} else {
		m.addamount = &f
	}
}

// AddedAmount returns the value that was added to the "amount" field in this mutation.
func (m *LedgerEntryMutation) AddedAmount() (r float64, exists bool) {
	v := m.addamount
	if v == nil {
		return
	}
	return *v, true
}

// ResetAmount resets all changes to the "amount" field.
func (m *LedgerEntryMutation) ResetAmount() {
	m.amount = nil
	m.addamount = nil
}

// SetDirection sets the "direction" field.
func (m *LedgerEntryMutation) SetDirection(l ledgerentry.Direction) {
	m.direction = &l
}

// Direction returns the value of the "direction" field in the mutation.
func (m *LedgerEntryMutation) Direction() (r ledgerentry.Direction, exists bool) {
	v := m.direction
	if v == nil {
		return
	}
	return *v, true
}

// OldDirection returns the old "direction" field's value of the LedgerEntry entity.
// If the LedgerEntry object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LedgerEntryMutation) OldDirection(ctx context.Context) (v ledgerentry.Direction, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDirection is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDirection requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDirection: %w", err)
	}
	return oldValue.Direction, nil
}

// ResetDirection resets all changes to the "direction" field.
func (m *LedgerEntryMutation) ResetDirection() {
	m.direction = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *LedgerEntryMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *LedgerEntryMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the LedgerEntry entity.
// If the LedgerEntry object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LedgerEntryMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *LedgerEntryMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetTransactionID sets the "transaction" edge to the Transaction entity by id.
func (m *LedgerEntryMutation) SetTransactionID(id int) {
	m.transaction = &id
}

// ClearTransaction clears the "transaction" edge to the Transaction entity.
func (m *LedgerEntryMutation) ClearTransaction() {
	m.clearedtransaction = true
}

// TransactionCleared reports if the "transaction" edge to the Transaction entity was cleared.
func (m *LedgerEntryMutation) TransactionCleared() bool {
	return m.clearedtransaction
}

// TransactionID returns the "transaction" edge ID in the mutation.
func (m *LedgerEntryMutation) TransactionID() (id int, exists bool) {
	if m.transaction != nil {
		return *m.transaction, true
	}
	return
}

// TransactionIDs returns the "transaction" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TransactionID instead. It exists only for internal usage by the builders.
func (m *LedgerEntryMutation) TransactionIDs() (ids []int) {
	if id := m.transaction; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTransaction resets all changes to the "transaction" edge.
func (m *LedgerEntryMutation) ResetTransaction() {
	m.transaction = nil
	m.clearedtransaction = false
}

// SetAccountID sets the "account" edge to the Account entity by id.
func (m *LedgerEntryMutation) SetAccountID(id int) {
	m.account = &id
}

// ClearAccount clears the "account" edge to the Account entity.
func (m *LedgerEntryMutation) ClearAccount() {
	m.clearedaccount = true
}

// AccountCleared reports if the "account" edge to the Account entity was cleared.
func (m *LedgerEntryMutation) AccountCleared() bool {
	return m.clearedaccount
}

// AccountID returns the "account" edge ID in the mutation.
func (m *LedgerEntryMutation) AccountID() (id int, exists bool) {
	if m.account != nil {
		return *m.account, true
	}
	return
}

// AccountIDs returns the "account" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AccountID instead. It exists only for internal usage by the builders.
func (m *LedgerEntryMutation) AccountIDs() (ids []int) {
	if id := m.account; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAccount resets all changes to the "account" edge.
func (m *LedgerEntryMutation) ResetAccount() {
	m.account = nil
	m.clearedaccount = false
}

// SetTenantID sets the "tenant" edge to the Tenant entity by id.
func (m *LedgerEntryMutation) SetTenantID(id int) {
	m.tenant = &id
}

// ClearTenant clears the "tenant" edge to the Tenant entity.
func (m *LedgerEntryMutation) ClearTenant() {
	m.clearedtenant = true
}

// TenantCleared reports if the "tenant" edge to the Tenant entity was cleared.
func (m *LedgerEntryMutation) TenantCleared() bool {
	return m.clearedtenant
}

// TenantID returns the "tenant" edge ID in the mutation.
func (m *LedgerEntryMutation) TenantID() (id int, exists bool) {
	if m.tenant != nil {
		return *m.tenant, true
	}
	return
}

// TenantIDs returns the "tenant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TenantID instead. It exists only for internal usage by the builders.
func (m *LedgerEntryMutation) TenantIDs() (ids []int) {
	if id := m.tenant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTenant resets all changes to the "tenant" edge.
func (m *LedgerEntryMutation) ResetTenant() {
	m.tenant = nil
	m.clearedtenant = false
}

// Where appends a list predicates to the LedgerEntryMutation builder.
func (m *LedgerEntryMutation) Where(ps ...predicate.LedgerEntry) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the LedgerEntryMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *LedgerEntryMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.LedgerEntry, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *LedgerEntryMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *LedgerEntryMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (LedgerEntry).
func (m *LedgerEntryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *LedgerEntryMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.amount != nil {
		fields = append(fields, ledgerentry.FieldAmount)
	}
	if m.direction != nil {
		fields = append(fields, ledgerentry.FieldDirection)
	}
	if m.created_at != nil {
		fields = append(fields, ledgerentry.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *LedgerEntryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case ledgerentry.FieldAmount:
		return m.Amount()
	case ledgerentry.FieldDirection:
		return m.Direction()
	case ledgerentry.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *LedgerEntryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case ledgerentry.FieldAmount:
		return m.OldAmount(ctx)
	case ledgerentry.FieldDirection:
		return m.OldDirection(ctx)
	case ledgerentry.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown LedgerEntry field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LedgerEntryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case ledgerentry.FieldAmount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAmount(v)
		return nil
	case ledgerentry.FieldDirection:
		v, ok := value.(ledgerentry.Direction)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDirection(v)
		return nil
	case ledgerentry.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown LedgerEntry field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *LedgerEntryMutation) AddedFields() []string {
	var fields []string
	if m.addamount != nil {
		fields = append(fields, ledgerentry.FieldAmount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *LedgerEntryMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case ledgerentry.FieldAmount:
		return m.AddedAmount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LedgerEntryMutation) AddField(name string, value ent.Value) error {
	switch name {
	case ledgerentry.FieldAmount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAmount(v)
		return nil
	}
	return fmt.Errorf("unknown LedgerEntry numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *LedgerEntryMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *LedgerEntryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *LedgerEntryMutation) ClearField(name string) error {
	return fmt.Errorf("unknown LedgerEntry nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *LedgerEntryMutation) ResetField(name string) error {
	switch name {
	case ledgerentry.FieldAmount:
		m.ResetAmount()
		return nil
	case ledgerentry.FieldDirection:
		m.ResetDirection()
		return nil
	case ledgerentry.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown LedgerEntry field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *LedgerEntryMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.transaction != nil {
		edges = append(edges, ledgerentry.EdgeTransaction)
	}
	if m.account != nil {
		edges = append(edges, ledgerentry.EdgeAccount)
	}
	if m.tenant != nil {
		edges = append(edges, ledgerentry.EdgeTenant)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *LedgerEntryMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case ledgerentry.EdgeTransaction:
		if id := m.transaction; id != nil {
			return []ent.Value{*id}
		}
	case ledgerentry.EdgeAccount:
		if id := m.account; id != nil {
			return []ent.Value{*id}
		}
	case ledgerentry.EdgeTenant:
		if id := m.tenant; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *LedgerEntryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *LedgerEntryMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *LedgerEntryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedtransaction {
		edges = append(edges, ledgerentry.EdgeTransaction)
	}
	if m.clearedaccount {
		edges = append(edges, ledgerentry.EdgeAccount)
	}
	if m.clearedtenant {
		edges = append(edges, ledgerentry.EdgeTenant)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *LedgerEntryMutation) EdgeCleared(name string) bool {
	switch name {
	case ledgerentry.EdgeTransaction:
		return m.clearedtransaction
	case ledgerentry.EdgeAccount:
		return m.clearedaccount
	case ledgerentry.EdgeTenant:
		return m.clearedtenant
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *LedgerEntryMutation) ClearEdge(name string) error {
	switch name {
	case ledgerentry.EdgeTransaction:
		m.ClearTransaction()
		return nil
	case ledgerentry.EdgeAccount:
		m.ClearAccount()
		return nil
	case ledgerentry.EdgeTenant:
		m.ClearTenant()
		return nil
	}
	return fmt.Errorf("unknown LedgerEntry unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *LedgerEntryMutation) ResetEdge(name string) error {
	switch name {
	case ledgerentry.EdgeTransaction:
		m.ResetTransaction()
		return nil
	case ledgerentry.EdgeAccount:
		m.ResetAccount()
		return nil
	case ledgerentry.EdgeTenant:
		m.ResetTenant()
		return nil
	}
	return fmt.Errorf("unknown LedgerEntry edge %s", name)
}

// NetworkBackupMutation represents an operation that mutates the NetworkBackup nodes in the graph.
type NetworkBackupMutation struct {
	config
	op            Op
	typ           string
	id            *int
	content_hash  *string
	vault_path    *string
	created_at    *time.Time
	clearedFields map[string]struct{}
	device        *int
	cleareddevice bool
	done          bool
	oldValue      func(context.Context) (*NetworkBackup, error)
	predicates    []predicate.NetworkBackup
}

var _ ent.Mutation = (*NetworkBackupMutation)(nil)

// networkbackupOption allows management of the mutation configuration using functional options.
type networkbackupOption func(*NetworkBackupMutation)

// newNetworkBackupMutation creates new mutation for the NetworkBackup entity.
func newNetworkBackupMutation(c config, op Op, opts ...networkbackupOption) *NetworkBackupMutation {
	m := &NetworkBackupMutation{
		config:        c,
		op:            op,
		typ:           TypeNetworkBackup,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withNetworkBackupID sets the ID field of the mutation.
func withNetworkBackupID(id int) networkbackupOption {
	return func(m *NetworkBackupMutation) {
		var (
			err   error
			once  sync.Once
			value *NetworkBackup
		)
		m.oldValue = func(ctx context.Context) (*NetworkBackup, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().NetworkBackup.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withNetworkBackup sets the old NetworkBackup of the mutation.
func withNetworkBackup(node *NetworkBackup) networkbackupOption {
	return func(m *NetworkBackupMutation) {
		m.oldValue = func(context.Context) (*NetworkBackup, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m NetworkBackupMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m NetworkBackupMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *NetworkBackupMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *NetworkBackupMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().NetworkBackup.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetContentHash sets the "content_hash" field.
func (m *NetworkBackupMutation) SetContentHash(s string) {
	m.content_hash = &s
}

// ContentHash returns the value of the "content_hash" field in the mutation.
func (m *NetworkBackupMutation) ContentHash() (r string, exists bool) {
	v := m.content_hash
	if v == nil {
		return
	}
	return *v, true
}

// OldContentHash returns the old "content_hash" field's value of the NetworkBackup entity.
// If the NetworkBackup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NetworkBackupMutation) OldContentHash(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContentHash is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContentHash requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContentHash: %w", err)
	}
	return oldValue.ContentHash, nil
}

// ResetContentHash resets all changes to the "content_hash" field.
func (m *NetworkBackupMutation) ResetContentHash() {
	m.content_hash = nil
}

// SetVaultPath sets the "vault_path" field.
func (m *NetworkBackupMutation) SetVaultPath(s string) {
	m.vault_path = &s
}

// VaultPath returns the value of the "vault_path" field in the mutation.
func (m *NetworkBackupMutation) VaultPath() (r string, exists bool) {
	v := m.vault_path
	if v == nil {
		return
	}
	return *v, true
}

// OldVaultPath returns the old "vault_path" field's value of the NetworkBackup entity.
// If the NetworkBackup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NetworkBackupMutation) OldVaultPath(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVaultPath is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVaultPath requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVaultPath: %w", err)
	}
	return oldValue.VaultPath, nil
}

// ResetVaultPath resets all changes to the "vault_path" field.
func (m *NetworkBackupMutation) ResetVaultPath() {
	m.vault_path = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *NetworkBackupMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *NetworkBackupMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the NetworkBackup entity.
// If the NetworkBackup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NetworkBackupMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *NetworkBackupMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetDeviceID sets the "device" edge to the NetworkDevice entity by id.
func (m *NetworkBackupMutation) SetDeviceID(id int) {
	m.device = &id
}

// ClearDevice clears the "device" edge to the NetworkDevice entity.
func (m *NetworkBackupMutation) ClearDevice() {
	m.cleareddevice = true
}

// DeviceCleared reports if the "device" edge to the NetworkDevice entity was cleared.
func (m *NetworkBackupMutation) DeviceCleared() bool {
	return m.cleareddevice
}

// DeviceID returns the "device" edge ID in the mutation.
func (m *NetworkBackupMutation) DeviceID() (id int, exists bool) {
	if m.device != nil {
		return *m.device, true
	}
	return
}

// DeviceIDs returns the "device" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// DeviceID instead. It exists only for internal usage by the builders.
func (m *NetworkBackupMutation) DeviceIDs() (ids []int) {
	if id := m.device; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDevice resets all changes to the "device" edge.
func (m *NetworkBackupMutation) ResetDevice() {
	m.device = nil
	m.cleareddevice = false
}

// Where appends a list predicates to the NetworkBackupMutation builder.
func (m *NetworkBackupMutation) Where(ps ...predicate.NetworkBackup) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the NetworkBackupMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *NetworkBackupMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.NetworkBackup, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *NetworkBackupMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *NetworkBackupMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (NetworkBackup).
func (m *NetworkBackupMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *NetworkBackupMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.content_hash != nil {
		fields = append(fields, networkbackup.FieldContentHash)
	}
	if m.vault_path != nil {
		fields = append(fields, networkbackup.FieldVaultPath)
	}
	if m.created_at != nil {
		fields = append(fields, networkbackup.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *NetworkBackupMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case networkbackup.FieldContentHash:
		return m.ContentHash()
	case networkbackup.FieldVaultPath:
		return m.VaultPath()
	case networkbackup.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *NetworkBackupMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case networkbackup.FieldContentHash:
		return m.OldContentHash(ctx)
	case networkbackup.FieldVaultPath:
		return m.OldVaultPath(ctx)
	case networkbackup.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown NetworkBackup field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NetworkBackupMutation) SetField(name string, value ent.Value) error {
	switch name {
	case networkbackup.FieldContentHash:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContentHash(v)
		return nil
	case networkbackup.FieldVaultPath:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVaultPath(v)
		return nil
	case networkbackup.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown NetworkBackup field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *NetworkBackupMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *NetworkBackupMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NetworkBackupMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown NetworkBackup numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *NetworkBackupMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *NetworkBackupMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *NetworkBackupMutation) ClearField(name string) error {
	return fmt.Errorf("unknown NetworkBackup nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *NetworkBackupMutation) ResetField(name string) error {
	switch name {
	case networkbackup.FieldContentHash:
		m.ResetContentHash()
		return nil
	case networkbackup.FieldVaultPath:
		m.ResetVaultPath()
		return nil
	case networkbackup.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown NetworkBackup field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *NetworkBackupMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.device != nil {
		edges = append(edges, networkbackup.EdgeDevice)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *NetworkBackupMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case networkbackup.EdgeDevice:
		if id := m.device; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *NetworkBackupMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *NetworkBackupMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *NetworkBackupMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareddevice {
		edges = append(edges, networkbackup.EdgeDevice)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *NetworkBackupMutation) EdgeCleared(name string) bool {
	switch name {
	case networkbackup.EdgeDevice:
		return m.cleareddevice
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *NetworkBackupMutation) ClearEdge(name string) error {
	switch name {
	case networkbackup.EdgeDevice:
		m.ClearDevice()
		return nil
	}
	return fmt.Errorf("unknown NetworkBackup unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *NetworkBackupMutation) ResetEdge(name string) error {
	switch name {
	case networkbackup.EdgeDevice:
		m.ResetDevice()
		return nil
	}
	return fmt.Errorf("unknown NetworkBackup edge %s", name)
}

// NetworkDeviceMutation represents an operation that mutates the NetworkDevice nodes in the graph.
type NetworkDeviceMutation struct {
	config
	op               Op
	typ              string
	id               *int
	name             *string
	ip_address       *string
	vendor           *string
	model            *string
	software_version *string
	status           *networkdevice.Status
	last_polled      *time.Time
	created_at       *time.Time
	updated_at       *time.Time
	clearedFields    map[string]struct{}
	ports            map[int]struct{}
	removedports     map[int]struct{}
	clearedports     bool
	backups          map[int]struct{}
	removedbackups   map[int]struct{}
	clearedbackups   bool
	done             bool
	oldValue         func(context.Context) (*NetworkDevice, error)
	predicates       []predicate.NetworkDevice
}

var _ ent.Mutation = (*NetworkDeviceMutation)(nil)

// networkdeviceOption allows management of the mutation configuration using functional options.
type networkdeviceOption func(*NetworkDeviceMutation)

// newNetworkDeviceMutation creates new mutation for the NetworkDevice entity.
func newNetworkDeviceMutation(c config, op Op, opts ...networkdeviceOption) *NetworkDeviceMutation {
	m := &NetworkDeviceMutation{
		config:        c,
		op:            op,
		typ:           TypeNetworkDevice,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withNetworkDeviceID sets the ID field of the mutation.
func withNetworkDeviceID(id int) networkdeviceOption {
	return func(m *NetworkDeviceMutation) {
		var (
			err   error
			once  sync.Once
			value *NetworkDevice
		)
		m.oldValue = func(ctx context.Context) (*NetworkDevice, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().NetworkDevice.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withNetworkDevice sets the old NetworkDevice of the mutation.
func withNetworkDevice(node *NetworkDevice) networkdeviceOption {
	return func(m *NetworkDeviceMutation) {
		m.oldValue = func(context.Context) (*NetworkDevice, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m NetworkDeviceMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m NetworkDeviceMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *NetworkDeviceMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *NetworkDeviceMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().NetworkDevice.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *NetworkDeviceMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *NetworkDeviceMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the NetworkDevice entity.
// If the NetworkDevice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NetworkDeviceMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *NetworkDeviceMutation) ResetName() {
	m.name = nil
}

// SetIPAddress sets the "ip_address" field.
func (m *NetworkDeviceMutation) SetIPAddress(s string) {
	m.ip_address = &s
}

// IPAddress returns the value of the "ip_address" field in the mutation.
func (m *NetworkDeviceMutation) IPAddress() (r string, exists bool) {
	v := m.ip_address
	if v == nil {
		return
	}
	return *v, true
}

// OldIPAddress returns the old "ip_address" field's value of the NetworkDevice entity.
// If the NetworkDevice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NetworkDeviceMutation) OldIPAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIPAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIPAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIPAddress: %w", err)
	}
	return oldValue.IPAddress, nil
}

// ResetIPAddress resets all changes to the "ip_address" field.
func (m *NetworkDeviceMutation) ResetIPAddress() {
	m.ip_address = nil
}

// SetVendor sets the "vendor" field.
func (m *NetworkDeviceMutation) SetVendor(s string) {
	m.vendor = &s
}

// Vendor returns the value of the "vendor" field in the mutation.
func (m *NetworkDeviceMutation) Vendor() (r string, exists bool) {
	v := m.vendor
	if v == nil {
		return
	}
	return *v, true
}

// OldVendor returns the old "vendor" field's value of the NetworkDevice entity.
// If the NetworkDevice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NetworkDeviceMutation) OldVendor(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVendor is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVendor requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVendor: %w", err)
	}
	return oldValue.Vendor, nil
}

// ResetVendor resets all changes to the "vendor" field.
func (m *NetworkDeviceMutation) ResetVendor() {
	m.vendor = nil
}

// SetModel sets the "model" field.
func (m *NetworkDeviceMutation) SetModel(s string) {
	m.model = &s
}

// Model returns the value of the "model" field in the mutation.
func (m *NetworkDeviceMutation) Model() (r string, exists bool) {
	v := m.model
	if v == nil {
		return
	}
	return *v, true
}

// OldModel returns the old "model" field's value of the NetworkDevice entity.
// If the NetworkDevice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NetworkDeviceMutation) OldModel(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldModel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldModel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldModel: %w", err)
	}
	return oldValue.Model, nil
}

// ClearModel clears the value of the "model" field.
func (m *NetworkDeviceMutation) ClearModel() {
	m.model = nil
	m.clearedFields[networkdevice.FieldModel] = struct{}{}
}

// ModelCleared returns if the "model" field was cleared in this mutation.
func (m *NetworkDeviceMutation) ModelCleared() bool {
	_, ok := m.clearedFields[networkdevice.FieldModel]
	return ok
}

// ResetModel resets all changes to the "model" field.
func (m *NetworkDeviceMutation) ResetModel() {
	m.model = nil
	delete(m.clearedFields, networkdevice.FieldModel)
}

// SetSoftwareVersion sets the "software_version" field.
func (m *NetworkDeviceMutation) SetSoftwareVersion(s string) {
	m.software_version = &s
}

// SoftwareVersion returns the value of the "software_version" field in the mutation.
func (m *NetworkDeviceMutation) SoftwareVersion() (r string, exists bool) {
	v := m.software_version
	if v == nil {
		return
	}
	return *v, true
}

// OldSoftwareVersion returns the old "software_version" field's value of the NetworkDevice entity.
// If the NetworkDevice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NetworkDeviceMutation) OldSoftwareVersion(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSoftwareVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSoftwareVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSoftwareVersion: %w", err)
	}
	return oldValue.SoftwareVersion, nil
}

// ClearSoftwareVersion clears the value of the "software_version" field.
func (m *NetworkDeviceMutation) ClearSoftwareVersion() {
	m.software_version = nil
	m.clearedFields[networkdevice.FieldSoftwareVersion] = struct{}{}
}

// SoftwareVersionCleared returns if the "software_version" field was cleared in this mutation.
func (m *NetworkDeviceMutation) SoftwareVersionCleared() bool {
	_, ok := m.clearedFields[networkdevice.FieldSoftwareVersion]
	return ok
}

// ResetSoftwareVersion resets all changes to the "software_version" field.
func (m *NetworkDeviceMutation) ResetSoftwareVersion() {
	m.software_version = nil
	delete(m.clearedFields, networkdevice.FieldSoftwareVersion)
}

// SetStatus sets the "status" field.
func (m *NetworkDeviceMutation) SetStatus(n networkdevice.Status) {
	m.status = &n
}

// Status returns the value of the "status" field in the mutation.
func (m *NetworkDeviceMutation) Status() (r networkdevice.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the NetworkDevice entity.
// If the NetworkDevice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NetworkDeviceMutation) OldStatus(ctx context.Context) (v networkdevice.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *NetworkDeviceMutation) ResetStatus() {
	m.status = nil
}

// SetLastPolled sets the "last_polled" field.
func (m *NetworkDeviceMutation) SetLastPolled(t time.Time) {
	m.last_polled = &t
}

// LastPolled returns the value of the "last_polled" field in the mutation.
func (m *NetworkDeviceMutation) LastPolled() (r time.Time, exists bool) {
	v := m.last_polled
	if v == nil {
		return
	}
	return *v, true
}

// OldLastPolled returns the old "last_polled" field's value of the NetworkDevice entity.
// If the NetworkDevice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NetworkDeviceMutation) OldLastPolled(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastPolled is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastPolled requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastPolled: %w", err)
	}
	return oldValue.LastPolled, nil
}

// ClearLastPolled clears the value of the "last_polled" field.
func (m *NetworkDeviceMutation) ClearLastPolled() {
	m.last_polled = nil
	m.clearedFields[networkdevice.FieldLastPolled] = struct{}{}
}

// LastPolledCleared returns if the "last_polled" field was cleared in this mutation.
func (m *NetworkDeviceMutation) LastPolledCleared() bool {
	_, ok := m.clearedFields[networkdevice.FieldLastPolled]
	return ok
}

// ResetLastPolled resets all changes to the "last_polled" field.
func (m *NetworkDeviceMutation) ResetLastPolled() {
	m.last_polled = nil
	delete(m.clearedFields, networkdevice.FieldLastPolled)
}

// SetCreatedAt sets the "created_at" field.
func (m *NetworkDeviceMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *NetworkDeviceMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the NetworkDevice entity.
// If the NetworkDevice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NetworkDeviceMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *NetworkDeviceMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *NetworkDeviceMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *NetworkDeviceMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the NetworkDevice entity.
// If the NetworkDevice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NetworkDeviceMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *NetworkDeviceMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// AddPortIDs adds the "ports" edge to the NetworkPort entity by ids.
func (m *NetworkDeviceMutation) AddPortIDs(ids ...int) {
	if m.ports == nil {
		m.ports = make(map[int]struct{})
	}
	for i := range ids {
		m.ports[ids[i]] = struct{}{}
	}
}

// ClearPorts clears the "ports" edge to the NetworkPort entity.
func (m *NetworkDeviceMutation) ClearPorts() {
	m.clearedports = true
}

// PortsCleared reports if the "ports" edge to the NetworkPort entity was cleared.
func (m *NetworkDeviceMutation) PortsCleared() bool {
	return m.clearedports
}

// RemovePortIDs removes the "ports" edge to the NetworkPort entity by IDs.
func (m *NetworkDeviceMutation) RemovePortIDs(ids ...int) {
	if m.removedports == nil {
		m.removedports = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.ports, ids[i])
		m.removedports[ids[i]] = struct{}{}
	}
}

// RemovedPorts returns the removed IDs of the "ports" edge to the NetworkPort entity.
func (m *NetworkDeviceMutation) RemovedPortsIDs() (ids []int) {
	for id := range m.removedports {
		ids = append(ids, id)
	}
	return
}

// PortsIDs returns the "ports" edge IDs in the mutation.
func (m *NetworkDeviceMutation) PortsIDs() (ids []int) {
	for id := range m.ports {
		ids = append(ids, id)
	}
	return
}

// ResetPorts resets all changes to the "ports" edge.
func (m *NetworkDeviceMutation) ResetPorts() {
	m.ports = nil
	m.clearedports = false
	m.removedports = nil
}

// AddBackupIDs adds the "backups" edge to the NetworkBackup entity by ids.
func (m *NetworkDeviceMutation) AddBackupIDs(ids ...int) {
	if m.backups == nil {
		m.backups = make(map[int]struct{})
	}
	for i := range ids {
		m.backups[ids[i]] = struct{}{}
	}
}

// ClearBackups clears the "backups" edge to the NetworkBackup entity.
func (m *NetworkDeviceMutation) ClearBackups() {
	m.clearedbackups = true
}

// BackupsCleared reports if the "backups" edge to the NetworkBackup entity was cleared.
func (m *NetworkDeviceMutation) BackupsCleared() bool {
	return m.clearedbackups
}

// RemoveBackupIDs removes the "backups" edge to the NetworkBackup entity by IDs.
func (m *NetworkDeviceMutation) RemoveBackupIDs(ids ...int) {
	if m.removedbackups == nil {
		m.removedbackups = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.backups, ids[i])
		m.removedbackups[ids[i]] = struct{}{}
	}
}

// RemovedBackups returns the removed IDs of the "backups" edge to the NetworkBackup entity.
func (m *NetworkDeviceMutation) RemovedBackupsIDs() (ids []int) {
	for id := range m.removedbackups {
		ids = append(ids, id)
	}
	return
}

// BackupsIDs returns the "backups" edge IDs in the mutation.
func (m *NetworkDeviceMutation) BackupsIDs() (ids []int) {
	for id := range m.backups {
		ids = append(ids, id)
	}
	return
}

// ResetBackups resets all changes to the "backups" edge.
func (m *NetworkDeviceMutation) ResetBackups() {
	m.backups = nil
	m.clearedbackups = false
	m.removedbackups = nil
}

// Where appends a list predicates to the NetworkDeviceMutation builder.
func (m *NetworkDeviceMutation) Where(ps ...predicate.NetworkDevice) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the NetworkDeviceMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *NetworkDeviceMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.NetworkDevice, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *NetworkDeviceMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *NetworkDeviceMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (NetworkDevice).
func (m *NetworkDeviceMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *NetworkDeviceMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.name != nil {
		fields = append(fields, networkdevice.FieldName)
	}
	if m.ip_address != nil {
		fields = append(fields, networkdevice.FieldIPAddress)
	}
	if m.vendor != nil {
		fields = append(fields, networkdevice.FieldVendor)
	}
	if m.model != nil {
		fields = append(fields, networkdevice.FieldModel)
	}
	if m.software_version != nil {
		fields = append(fields, networkdevice.FieldSoftwareVersion)
	}
	if m.status != nil {
		fields = append(fields, networkdevice.FieldStatus)
	}
	if m.last_polled != nil {
		fields = append(fields, networkdevice.FieldLastPolled)
	}
	if m.created_at != nil {
		fields = append(fields, networkdevice.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, networkdevice.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *NetworkDeviceMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case networkdevice.FieldName:
		return m.Name()
	case networkdevice.FieldIPAddress:
		return m.IPAddress()
	case networkdevice.FieldVendor:
		return m.Vendor()
	case networkdevice.FieldModel:
		return m.Model()
	case networkdevice.FieldSoftwareVersion:
		return m.SoftwareVersion()
	case networkdevice.FieldStatus:
		return m.Status()
	case networkdevice.FieldLastPolled:
		return m.LastPolled()
	case networkdevice.FieldCreatedAt:
		return m.CreatedAt()
	case networkdevice.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *NetworkDeviceMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case networkdevice.FieldName:
		return m.OldName(ctx)
	case networkdevice.FieldIPAddress:
		return m.OldIPAddress(ctx)
	case networkdevice.FieldVendor:
		return m.OldVendor(ctx)
	case networkdevice.FieldModel:
		return m.OldModel(ctx)
	case networkdevice.FieldSoftwareVersion:
		return m.OldSoftwareVersion(ctx)
	case networkdevice.FieldStatus:
		return m.OldStatus(ctx)
	case networkdevice.FieldLastPolled:
		return m.OldLastPolled(ctx)
	case networkdevice.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case networkdevice.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown NetworkDevice field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NetworkDeviceMutation) SetField(name string, value ent.Value) error {
	switch name {
	case networkdevice.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case networkdevice.FieldIPAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIPAddress(v)
		return nil
	case networkdevice.FieldVendor:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVendor(v)
		return nil
	case networkdevice.FieldModel:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetModel(v)
		return nil
	case networkdevice.FieldSoftwareVersion:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSoftwareVersion(v)
		return nil
	case networkdevice.FieldStatus:
		v, ok := value.(networkdevice.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case networkdevice.FieldLastPolled:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastPolled(v)
		return nil
	case networkdevice.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case networkdevice.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown NetworkDevice field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *NetworkDeviceMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *NetworkDeviceMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NetworkDeviceMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown NetworkDevice numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *NetworkDeviceMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(networkdevice.FieldModel) {
		fields = append(fields, networkdevice.FieldModel)
	}
	if m.FieldCleared(networkdevice.FieldSoftwareVersion) {
		fields = append(fields, networkdevice.FieldSoftwareVersion)
	}
	if m.FieldCleared(networkdevice.FieldLastPolled) {
		fields = append(fields, networkdevice.FieldLastPolled)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *NetworkDeviceMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *NetworkDeviceMutation) ClearField(name string) error {
	switch name {
	case networkdevice.FieldModel:
		m.ClearModel()
		return nil
	case networkdevice.FieldSoftwareVersion:
		m.ClearSoftwareVersion()
		return nil
	case networkdevice.FieldLastPolled:
		m.ClearLastPolled()
		return nil
	}
	return fmt.Errorf("unknown NetworkDevice nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *NetworkDeviceMutation) ResetField(name string) error {
	switch name {
	case networkdevice.FieldName:
		m.ResetName()
		return nil
	case networkdevice.FieldIPAddress:
		m.ResetIPAddress()
		return nil
	case networkdevice.FieldVendor:
		m.ResetVendor()
		return nil
	case networkdevice.FieldModel:
		m.ResetModel()
		return nil
	case networkdevice.FieldSoftwareVersion:
		m.ResetSoftwareVersion()
		return nil
	case networkdevice.FieldStatus:
		m.ResetStatus()
		return nil
	case networkdevice.FieldLastPolled:
		m.ResetLastPolled()
		return nil
	case networkdevice.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case networkdevice.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown NetworkDevice field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *NetworkDeviceMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.ports != nil {
		edges = append(edges, networkdevice.EdgePorts)
	}
	if m.backups != nil {
		edges = append(edges, networkdevice.EdgeBackups)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *NetworkDeviceMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case networkdevice.EdgePorts:
		ids := make([]ent.Value, 0, len(m.ports))
		for id := range m.ports {
			ids = append(ids, id)
		}
		return ids
	case networkdevice.EdgeBackups:
		ids := make([]ent.Value, 0, len(m.backups))
		for id := range m.backups {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *NetworkDeviceMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedports != nil {
		edges = append(edges, networkdevice.EdgePorts)
	}
	if m.removedbackups != nil {
		edges = append(edges, networkdevice.EdgeBackups)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *NetworkDeviceMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case networkdevice.EdgePorts:
		ids := make([]ent.Value, 0, len(m.removedports))
		for id := range m.removedports {
			ids = append(ids, id)
		}
		return ids
	case networkdevice.EdgeBackups:
		ids := make([]ent.Value, 0, len(m.removedbackups))
		for id := range m.removedbackups {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *NetworkDeviceMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedports {
		edges = append(edges, networkdevice.EdgePorts)
	}
	if m.clearedbackups {
		edges = append(edges, networkdevice.EdgeBackups)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *NetworkDeviceMutation) EdgeCleared(name string) bool {
	switch name {
	case networkdevice.EdgePorts:
		return m.clearedports
	case networkdevice.EdgeBackups:
		return m.clearedbackups
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *NetworkDeviceMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown NetworkDevice unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *NetworkDeviceMutation) ResetEdge(name string) error {
	switch name {
	case networkdevice.EdgePorts:
		m.ResetPorts()
		return nil
	case networkdevice.EdgeBackups:
		m.ResetBackups()
		return nil
	}
	return fmt.Errorf("unknown NetworkDevice edge %s", name)
}

// NetworkLinkMutation represents an operation that mutates the NetworkLink nodes in the graph.
type NetworkLinkMutation struct {
	config
	op                 Op
	typ                string
	id                 *int
	protocol           *string
	last_seen          *time.Time
	clearedFields      map[string]struct{}
	source_port        *int
	clearedsource_port bool
	target_port        *int
	clearedtarget_port bool
	done               bool
	oldValue           func(context.Context) (*NetworkLink, error)
	predicates         []predicate.NetworkLink
}

var _ ent.Mutation = (*NetworkLinkMutation)(nil)

// networklinkOption allows management of the mutation configuration using functional options.
type networklinkOption func(*NetworkLinkMutation)

// newNetworkLinkMutation creates new mutation for the NetworkLink entity.
func newNetworkLinkMutation(c config, op Op, opts ...networklinkOption) *NetworkLinkMutation {
	m := &NetworkLinkMutation{
		config:        c,
		op:            op,
		typ:           TypeNetworkLink,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withNetworkLinkID sets the ID field of the mutation.
func withNetworkLinkID(id int) networklinkOption {
	return func(m *NetworkLinkMutation) {
		var (
			err   error
			once  sync.Once
			value *NetworkLink
		)
		m.oldValue = func(ctx context.Context) (*NetworkLink, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().NetworkLink.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withNetworkLink sets the old NetworkLink of the mutation.
func withNetworkLink(node *NetworkLink) networklinkOption {
	return func(m *NetworkLinkMutation) {
		m.oldValue = func(context.Context) (*NetworkLink, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m NetworkLinkMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m NetworkLinkMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *NetworkLinkMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *NetworkLinkMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().NetworkLink.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetProtocol sets the "protocol" field.
func (m *NetworkLinkMutation) SetProtocol(s string) {
	m.protocol = &s
}

// Protocol returns the value of the "protocol" field in the mutation.
func (m *NetworkLinkMutation) Protocol() (r string, exists bool) {
	v := m.protocol
	if v == nil {
		return
	}
	return *v, true
}

// OldProtocol returns the old "protocol" field's value of the NetworkLink entity.
// If the NetworkLink object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NetworkLinkMutation) OldProtocol(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProtocol is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProtocol requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProtocol: %w", err)
	}
	return oldValue.Protocol, nil
}

// ResetProtocol resets all changes to the "protocol" field.
func (m *NetworkLinkMutation) ResetProtocol() {
	m.protocol = nil
}

// SetLastSeen sets the "last_seen" field.
func (m *NetworkLinkMutation) SetLastSeen(t time.Time) {
	m.last_seen = &t
}

// LastSeen returns the value of the "last_seen" field in the mutation.
func (m *NetworkLinkMutation) LastSeen() (r time.Time, exists bool) {
	v := m.last_seen
	if v == nil {
		return
	}
	return *v, true
}

// OldLastSeen returns the old "last_seen" field's value of the NetworkLink entity.
// If the NetworkLink object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NetworkLinkMutation) OldLastSeen(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastSeen is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastSeen requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastSeen: %w", err)
	}
	return oldValue.LastSeen, nil
}

// ResetLastSeen resets all changes to the "last_seen" field.
func (m *NetworkLinkMutation) ResetLastSeen() {
	m.last_seen = nil
}

// SetSourcePortID sets the "source_port" edge to the NetworkPort entity by id.
func (m *NetworkLinkMutation) SetSourcePortID(id int) {
	m.source_port = &id
}

// ClearSourcePort clears the "source_port" edge to the NetworkPort entity.
func (m *NetworkLinkMutation) ClearSourcePort() {
	m.clearedsource_port = true
}

// SourcePortCleared reports if the "source_port" edge to the NetworkPort entity was cleared.
func (m *NetworkLinkMutation) SourcePortCleared() bool {
	return m.clearedsource_port
}

// SourcePortID returns the "source_port" edge ID in the mutation.
func (m *NetworkLinkMutation) SourcePortID() (id int, exists bool) {
	if m.source_port != nil {
		return *m.source_port, true
	}
	return
}

// SourcePortIDs returns the "source_port" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SourcePortID instead. It exists only for internal usage by the builders.
func (m *NetworkLinkMutation) SourcePortIDs() (ids []int) {
	if id := m.source_port; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSourcePort resets all changes to the "source_port" edge.
func (m *NetworkLinkMutation) ResetSourcePort() {
	m.source_port = nil
	m.clearedsource_port = false
}

// SetTargetPortID sets the "target_port" edge to the NetworkPort entity by id.
func (m *NetworkLinkMutation) SetTargetPortID(id int) {
	m.target_port = &id
}

// ClearTargetPort clears the "target_port" edge to the NetworkPort entity.
func (m *NetworkLinkMutation) ClearTargetPort() {
	m.clearedtarget_port = true
}

// TargetPortCleared reports if the "target_port" edge to the NetworkPort entity was cleared.
func (m *NetworkLinkMutation) TargetPortCleared() bool {
	return m.clearedtarget_port
}

// TargetPortID returns the "target_port" edge ID in the mutation.
func (m *NetworkLinkMutation) TargetPortID() (id int, exists bool) {
	if m.target_port != nil {
		return *m.target_port, true
	}
	return
}

// TargetPortIDs returns the "target_port" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TargetPortID instead. It exists only for internal usage by the builders.
func (m *NetworkLinkMutation) TargetPortIDs() (ids []int) {
	if id := m.target_port; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTargetPort resets all changes to the "target_port" edge.
func (m *NetworkLinkMutation) ResetTargetPort() {
	m.target_port = nil
	m.clearedtarget_port = false
}

// Where appends a list predicates to the NetworkLinkMutation builder.
func (m *NetworkLinkMutation) Where(ps ...predicate.NetworkLink) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the NetworkLinkMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *NetworkLinkMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.NetworkLink, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *NetworkLinkMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *NetworkLinkMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (NetworkLink).
func (m *NetworkLinkMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *NetworkLinkMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.protocol != nil {
		fields = append(fields, networklink.FieldProtocol)
	}
	if m.last_seen != nil {
		fields = append(fields, networklink.FieldLastSeen)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *NetworkLinkMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case networklink.FieldProtocol:
		return m.Protocol()
	case networklink.FieldLastSeen:
		return m.LastSeen()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *NetworkLinkMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case networklink.FieldProtocol:
		return m.OldProtocol(ctx)
	case networklink.FieldLastSeen:
		return m.OldLastSeen(ctx)
	}
	return nil, fmt.Errorf("unknown NetworkLink field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NetworkLinkMutation) SetField(name string, value ent.Value) error {
	switch name {
	case networklink.FieldProtocol:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProtocol(v)
		return nil
	case networklink.FieldLastSeen:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastSeen(v)
		return nil
	}
	return fmt.Errorf("unknown NetworkLink field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *NetworkLinkMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *NetworkLinkMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NetworkLinkMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown NetworkLink numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *NetworkLinkMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *NetworkLinkMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *NetworkLinkMutation) ClearField(name string) error {
	return fmt.Errorf("unknown NetworkLink nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *NetworkLinkMutation) ResetField(name string) error {
	switch name {
	case networklink.FieldProtocol:
		m.ResetProtocol()
		return nil
	case networklink.FieldLastSeen:
		m.ResetLastSeen()
		return nil
	}
	return fmt.Errorf("unknown NetworkLink field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *NetworkLinkMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.source_port != nil {
		edges = append(edges, networklink.EdgeSourcePort)
	}
	if m.target_port != nil {
		edges = append(edges, networklink.EdgeTargetPort)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *NetworkLinkMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case networklink.EdgeSourcePort:
		if id := m.source_port; id != nil {
			return []ent.Value{*id}
		}
	case networklink.EdgeTargetPort:
		if id := m.target_port; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *NetworkLinkMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *NetworkLinkMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *NetworkLinkMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedsource_port {
		edges = append(edges, networklink.EdgeSourcePort)
	}
	if m.clearedtarget_port {
		edges = append(edges, networklink.EdgeTargetPort)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *NetworkLinkMutation) EdgeCleared(name string) bool {
	switch name {
	case networklink.EdgeSourcePort:
		return m.clearedsource_port
	case networklink.EdgeTargetPort:
		return m.clearedtarget_port
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *NetworkLinkMutation) ClearEdge(name string) error {
	switch name {
	case networklink.EdgeSourcePort:
		m.ClearSourcePort()
		return nil
	case networklink.EdgeTargetPort:
		m.ClearTargetPort()
		return nil
	}
	return fmt.Errorf("unknown NetworkLink unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *NetworkLinkMutation) ResetEdge(name string) error {
	switch name {
	case networklink.EdgeSourcePort:
		m.ResetSourcePort()
		return nil
	case networklink.EdgeTargetPort:
		m.ResetTargetPort()
		return nil
	}
	return fmt.Errorf("unknown NetworkLink edge %s", name)
}

// NetworkPortMutation represents an operation that mutates the NetworkPort nodes in the graph.
type NetworkPortMutation struct {
	config
	op                  Op
	typ                 string
	id                  *int
	name                *string
	_type               *string
	status              *string
	vlan                *int
	addvlan             *int
	mac_address         *string
	poe_enabled         *bool
	poe_wattage         *float64
	addpoe_wattage      *float64
	description         *string
	clearedFields       map[string]struct{}
	device              *int
	cleareddevice       bool
	connected_to        map[int]struct{}
	removedconnected_to map[int]struct{}
	clearedconnected_to bool
	done                bool
	oldValue            func(context.Context) (*NetworkPort, error)
	predicates          []predicate.NetworkPort
}

var _ ent.Mutation = (*NetworkPortMutation)(nil)

// networkportOption allows management of the mutation configuration using functional options.
type networkportOption func(*NetworkPortMutation)

// newNetworkPortMutation creates new mutation for the NetworkPort entity.
func newNetworkPortMutation(c config, op Op, opts ...networkportOption) *NetworkPortMutation {
	m := &NetworkPortMutation{
		config:        c,
		op:            op,
		typ:           TypeNetworkPort,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withNetworkPortID sets the ID field of the mutation.
func withNetworkPortID(id int) networkportOption {
	return func(m *NetworkPortMutation) {
		var (
			err   error
			once  sync.Once
			value *NetworkPort
		)
		m.oldValue = func(ctx context.Context) (*NetworkPort, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().NetworkPort.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withNetworkPort sets the old NetworkPort of the mutation.
func withNetworkPort(node *NetworkPort) networkportOption {
	return func(m *NetworkPortMutation) {
		m.oldValue = func(context.Context) (*NetworkPort, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m NetworkPortMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m NetworkPortMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *NetworkPortMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *NetworkPortMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().NetworkPort.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *NetworkPortMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *NetworkPortMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the NetworkPort entity.
// If the NetworkPort object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NetworkPortMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *NetworkPortMutation) ResetName() {
	m.name = nil
}

// SetType sets the "type" field.
func (m *NetworkPortMutation) SetType(s string) {
	m._type = &s
}

// GetType returns the value of the "type" field in the mutation.
func (m *NetworkPortMutation) GetType() (r string, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the NetworkPort entity.
// If the NetworkPort object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NetworkPortMutation) OldType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *NetworkPortMutation) ResetType() {
	m._type = nil
}

// SetStatus sets the "status" field.
func (m *NetworkPortMutation) SetStatus(s string) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *NetworkPortMutation) Status() (r string, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the NetworkPort entity.
// If the NetworkPort object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NetworkPortMutation) OldStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *NetworkPortMutation) ResetStatus() {
	m.status = nil
}

// SetVlan sets the "vlan" field.
func (m *NetworkPortMutation) SetVlan(i int) {
	m.vlan = &i
	m.addvlan = nil
}

// Vlan returns the value of the "vlan" field in the mutation.
func (m *NetworkPortMutation) Vlan() (r int, exists bool) {
	v := m.vlan
	if v == nil {
		return
	}
	return *v, true
}

// OldVlan returns the old "vlan" field's value of the NetworkPort entity.
// If the NetworkPort object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NetworkPortMutation) OldVlan(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVlan is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVlan requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVlan: %w", err)
	}
	return oldValue.Vlan, nil
}

// AddVlan adds i to the "vlan" field.
func (m *NetworkPortMutation) AddVlan(i int) {
	if m.addvlan != nil {
		*m.addvlan += i
	} else {
		m.addvlan = &i
	}
}

// AddedVlan returns the value that was added to the "vlan" field in this mutation.
func (m *NetworkPortMutation) AddedVlan() (r int, exists bool) {
	v := m.addvlan
	if v == nil {
		return
	}
	return *v, true
}

// ResetVlan resets all changes to the "vlan" field.
func (m *NetworkPortMutation) ResetVlan() {
	m.vlan = nil
	m.addvlan = nil
}

// SetMACAddress sets the "mac_address" field.
func (m *NetworkPortMutation) SetMACAddress(s string) {
	m.mac_address = &s
}

// MACAddress returns the value of the "mac_address" field in the mutation.
func (m *NetworkPortMutation) MACAddress() (r string, exists bool) {
	v := m.mac_address
	if v == nil {
		return
	}
	return *v, true
}

// OldMACAddress returns the old "mac_address" field's value of the NetworkPort entity.
// If the NetworkPort object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NetworkPortMutation) OldMACAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMACAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMACAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMACAddress: %w", err)
	}
	return oldValue.MACAddress, nil
}

// ClearMACAddress clears the value of the "mac_address" field.
func (m *NetworkPortMutation) ClearMACAddress() {
	m.mac_address = nil
	m.clearedFields[networkport.FieldMACAddress] = struct{}{}
}

// MACAddressCleared returns if the "mac_address" field was cleared in this mutation.
func (m *NetworkPortMutation) MACAddressCleared() bool {
	_, ok := m.clearedFields[networkport.FieldMACAddress]
	return ok
}

// ResetMACAddress resets all changes to the "mac_address" field.
func (m *NetworkPortMutation) ResetMACAddress() {
	m.mac_address = nil
	delete(m.clearedFields, networkport.FieldMACAddress)
}

// SetPoeEnabled sets the "poe_enabled" field.
func (m *NetworkPortMutation) SetPoeEnabled(b bool) {
	m.poe_enabled = &b
}

// PoeEnabled returns the value of the "poe_enabled" field in the mutation.
func (m *NetworkPortMutation) PoeEnabled() (r bool, exists bool) {
	v := m.poe_enabled
	if v == nil {
		return
	}
	return *v, true
}

// OldPoeEnabled returns the old "poe_enabled" field's value of the NetworkPort entity.
// If the NetworkPort object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NetworkPortMutation) OldPoeEnabled(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPoeEnabled is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPoeEnabled requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPoeEnabled: %w", err)
	}
	return oldValue.PoeEnabled, nil
}

// ResetPoeEnabled resets all changes to the "poe_enabled" field.
func (m *NetworkPortMutation) ResetPoeEnabled() {
	m.poe_enabled = nil
}

// SetPoeWattage sets the "poe_wattage" field.
func (m *NetworkPortMutation) SetPoeWattage(f float64) {
	m.poe_wattage = &f
	m.addpoe_wattage = nil
}

// PoeWattage returns the value of the "poe_wattage" field in the mutation.
func (m *NetworkPortMutation) PoeWattage() (r float64, exists bool) {
	v := m.poe_wattage
	if v == nil {
		return
	}
	return *v, true
}

// OldPoeWattage returns the old "poe_wattage" field's value of the NetworkPort entity.
// If the NetworkPort object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NetworkPortMutation) OldPoeWattage(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPoeWattage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPoeWattage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPoeWattage: %w", err)
	}
	return oldValue.PoeWattage, nil
}

// AddPoeWattage adds f to the "poe_wattage" field.
func (m *NetworkPortMutation) AddPoeWattage(f float64) {
	if m.addpoe_wattage != nil {
		*m.addpoe_wattage += f
	} else {
		m.addpoe_wattage = &f
	}
}

// AddedPoeWattage returns the value that was added to the "poe_wattage" field in this mutation.
func (m *NetworkPortMutation) AddedPoeWattage() (r float64, exists bool) {
	v := m.addpoe_wattage
	if v == nil {
		return
	}
	return *v, true
}

// ResetPoeWattage resets all changes to the "poe_wattage" field.
func (m *NetworkPortMutation) ResetPoeWattage() {
	m.poe_wattage = nil
	m.addpoe_wattage = nil
}

// SetDescription sets the "description" field.
func (m *NetworkPortMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *NetworkPortMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the NetworkPort entity.
// If the NetworkPort object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NetworkPortMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *NetworkPortMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[networkport.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *NetworkPortMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[networkport.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *NetworkPortMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, networkport.FieldDescription)
}

// SetDeviceID sets the "device" edge to the NetworkDevice entity by id.
func (m *NetworkPortMutation) SetDeviceID(id int) {
	m.device = &id
}

// ClearDevice clears the "device" edge to the NetworkDevice entity.
func (m *NetworkPortMutation) ClearDevice() {
	m.cleareddevice = true
}

// DeviceCleared reports if the "device" edge to the NetworkDevice entity was cleared.
func (m *NetworkPortMutation) DeviceCleared() bool {
	return m.cleareddevice
}

// DeviceID returns the "device" edge ID in the mutation.
func (m *NetworkPortMutation) DeviceID() (id int, exists bool) {
	if m.device != nil {
		return *m.device, true
	}
	return
}

// DeviceIDs returns the "device" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// DeviceID instead. It exists only for internal usage by the builders.
func (m *NetworkPortMutation) DeviceIDs() (ids []int) {
	if id := m.device; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDevice resets all changes to the "device" edge.
func (m *NetworkPortMutation) ResetDevice() {
	m.device = nil
	m.cleareddevice = false
}

// AddConnectedToIDs adds the "connected_to" edge to the NetworkLink entity by ids.
func (m *NetworkPortMutation) AddConnectedToIDs(ids ...int) {
	if m.connected_to == nil {
		m.connected_to = make(map[int]struct{})
	}
	for i := range ids {
		m.connected_to[ids[i]] = struct{}{}
	}
}

// ClearConnectedTo clears the "connected_to" edge to the NetworkLink entity.
func (m *NetworkPortMutation) ClearConnectedTo() {
	m.clearedconnected_to = true
}

// ConnectedToCleared reports if the "connected_to" edge to the NetworkLink entity was cleared.
func (m *NetworkPortMutation) ConnectedToCleared() bool {
	return m.clearedconnected_to
}

// RemoveConnectedToIDs removes the "connected_to" edge to the NetworkLink entity by IDs.
func (m *NetworkPortMutation) RemoveConnectedToIDs(ids ...int) {
	if m.removedconnected_to == nil {
		m.removedconnected_to = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.connected_to, ids[i])
		m.removedconnected_to[ids[i]] = struct{}{}
	}
}

// RemovedConnectedTo returns the removed IDs of the "connected_to" edge to the NetworkLink entity.
func (m *NetworkPortMutation) RemovedConnectedToIDs() (ids []int) {
	for id := range m.removedconnected_to {
		ids = append(ids, id)
	}
	return
}

// ConnectedToIDs returns the "connected_to" edge IDs in the mutation.
func (m *NetworkPortMutation) ConnectedToIDs() (ids []int) {
	for id := range m.connected_to {
		ids = append(ids, id)
	}
	return
}

// ResetConnectedTo resets all changes to the "connected_to" edge.
func (m *NetworkPortMutation) ResetConnectedTo() {
	m.connected_to = nil
	m.clearedconnected_to = false
	m.removedconnected_to = nil
}

// Where appends a list predicates to the NetworkPortMutation builder.
func (m *NetworkPortMutation) Where(ps ...predicate.NetworkPort) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the NetworkPortMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *NetworkPortMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.NetworkPort, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *NetworkPortMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *NetworkPortMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (NetworkPort).
func (m *NetworkPortMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *NetworkPortMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.name != nil {
		fields = append(fields, networkport.FieldName)
	}
	if m._type != nil {
		fields = append(fields, networkport.FieldType)
	}
	if m.status != nil {
		fields = append(fields, networkport.FieldStatus)
	}
	if m.vlan != nil {
		fields = append(fields, networkport.FieldVlan)
	}
	if m.mac_address != nil {
		fields = append(fields, networkport.FieldMACAddress)
	}
	if m.poe_enabled != nil {
		fields = append(fields, networkport.FieldPoeEnabled)
	}
	if m.poe_wattage != nil {
		fields = append(fields, networkport.FieldPoeWattage)
	}
	if m.description != nil {
		fields = append(fields, networkport.FieldDescription)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *NetworkPortMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case networkport.FieldName:
		return m.Name()
	case networkport.FieldType:
		return m.GetType()
	case networkport.FieldStatus:
		return m.Status()
	case networkport.FieldVlan:
		return m.Vlan()
	case networkport.FieldMACAddress:
		return m.MACAddress()
	case networkport.FieldPoeEnabled:
		return m.PoeEnabled()
	case networkport.FieldPoeWattage:
		return m.PoeWattage()
	case networkport.FieldDescription:
		return m.Description()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *NetworkPortMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case networkport.FieldName:
		return m.OldName(ctx)
	case networkport.FieldType:
		return m.OldType(ctx)
	case networkport.FieldStatus:
		return m.OldStatus(ctx)
	case networkport.FieldVlan:
		return m.OldVlan(ctx)
	case networkport.FieldMACAddress:
		return m.OldMACAddress(ctx)
	case networkport.FieldPoeEnabled:
		return m.OldPoeEnabled(ctx)
	case networkport.FieldPoeWattage:
		return m.OldPoeWattage(ctx)
	case networkport.FieldDescription:
		return m.OldDescription(ctx)
	}
	return nil, fmt.Errorf("unknown NetworkPort field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NetworkPortMutation) SetField(name string, value ent.Value) error {
	switch name {
	case networkport.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case networkport.FieldType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case networkport.FieldStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case networkport.FieldVlan:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVlan(v)
		return nil
	case networkport.FieldMACAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMACAddress(v)
		return nil
	case networkport.FieldPoeEnabled:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPoeEnabled(v)
		return nil
	case networkport.FieldPoeWattage:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPoeWattage(v)
		return nil
	case networkport.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	}
	return fmt.Errorf("unknown NetworkPort field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *NetworkPortMutation) AddedFields() []string {
	var fields []string
	if m.addvlan != nil {
		fields = append(fields, networkport.FieldVlan)
	}
	if m.addpoe_wattage != nil {
		fields = append(fields, networkport.FieldPoeWattage)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *NetworkPortMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case networkport.FieldVlan:
		return m.AddedVlan()
	case networkport.FieldPoeWattage:
		return m.AddedPoeWattage()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NetworkPortMutation) AddField(name string, value ent.Value) error {
	switch name {
	case networkport.FieldVlan:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddVlan(v)
		return nil
	case networkport.FieldPoeWattage:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPoeWattage(v)
		return nil
	}
	return fmt.Errorf("unknown NetworkPort numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *NetworkPortMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(networkport.FieldMACAddress) {
		fields = append(fields, networkport.FieldMACAddress)
	}
	if m.FieldCleared(networkport.FieldDescription) {
		fields = append(fields, networkport.FieldDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *NetworkPortMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *NetworkPortMutation) ClearField(name string) error {
	switch name {
	case networkport.FieldMACAddress:
		m.ClearMACAddress()
		return nil
	case networkport.FieldDescription:
		m.ClearDescription()
		return nil
	}
	return fmt.Errorf("unknown NetworkPort nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *NetworkPortMutation) ResetField(name string) error {
	switch name {
	case networkport.FieldName:
		m.ResetName()
		return nil
	case networkport.FieldType:
		m.ResetType()
		return nil
	case networkport.FieldStatus:
		m.ResetStatus()
		return nil
	case networkport.FieldVlan:
		m.ResetVlan()
		return nil
	case networkport.FieldMACAddress:
		m.ResetMACAddress()
		return nil
	case networkport.FieldPoeEnabled:
		m.ResetPoeEnabled()
		return nil
	case networkport.FieldPoeWattage:
		m.ResetPoeWattage()
		return nil
	case networkport.FieldDescription:
		m.ResetDescription()
		return nil
	}
	return fmt.Errorf("unknown NetworkPort field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *NetworkPortMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.device != nil {
		edges = append(edges, networkport.EdgeDevice)
	}
	if m.connected_to != nil {
		edges = append(edges, networkport.EdgeConnectedTo)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *NetworkPortMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case networkport.EdgeDevice:
		if id := m.device; id != nil {
			return []ent.Value{*id}
		}
	case networkport.EdgeConnectedTo:
		ids := make([]ent.Value, 0, len(m.connected_to))
		for id := range m.connected_to {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *NetworkPortMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedconnected_to != nil {
		edges = append(edges, networkport.EdgeConnectedTo)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *NetworkPortMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case networkport.EdgeConnectedTo:
		ids := make([]ent.Value, 0, len(m.removedconnected_to))
		for id := range m.removedconnected_to {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *NetworkPortMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleareddevice {
		edges = append(edges, networkport.EdgeDevice)
	}
	if m.clearedconnected_to {
		edges = append(edges, networkport.EdgeConnectedTo)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *NetworkPortMutation) EdgeCleared(name string) bool {
	switch name {
	case networkport.EdgeDevice:
		return m.cleareddevice
	case networkport.EdgeConnectedTo:
		return m.clearedconnected_to
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *NetworkPortMutation) ClearEdge(name string) error {
	switch name {
	case networkport.EdgeDevice:
		m.ClearDevice()
		return nil
	}
	return fmt.Errorf("unknown NetworkPort unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *NetworkPortMutation) ResetEdge(name string) error {
	switch name {
	case networkport.EdgeDevice:
		m.ResetDevice()
		return nil
	case networkport.EdgeConnectedTo:
		m.ResetConnectedTo()
		return nil
	}
	return fmt.Errorf("unknown NetworkPort edge %s", name)
}

// NexusAuditMutation represents an operation that mutates the NexusAudit nodes in the graph.
type NexusAuditMutation struct {
	config
	op            Op
	typ           string
	id            *int
	action        *string
	actor_id      *string
	credential_id *string
	reason_code   *string
	ticket_id     *string
	timestamp     *time.Time
	metadata      *map[string]interface{}
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*NexusAudit, error)
	predicates    []predicate.NexusAudit
}

var _ ent.Mutation = (*NexusAuditMutation)(nil)

// nexusauditOption allows management of the mutation configuration using functional options.
type nexusauditOption func(*NexusAuditMutation)

// newNexusAuditMutation creates new mutation for the NexusAudit entity.
func newNexusAuditMutation(c config, op Op, opts ...nexusauditOption) *NexusAuditMutation {
	m := &NexusAuditMutation{
		config:        c,
		op:            op,
		typ:           TypeNexusAudit,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withNexusAuditID sets the ID field of the mutation.
func withNexusAuditID(id int) nexusauditOption {
	return func(m *NexusAuditMutation) {
		var (
			err   error
			once  sync.Once
			value *NexusAudit
		)
		m.oldValue = func(ctx context.Context) (*NexusAudit, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().NexusAudit.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withNexusAudit sets the old NexusAudit of the mutation.
func withNexusAudit(node *NexusAudit) nexusauditOption {
	return func(m *NexusAuditMutation) {
		m.oldValue = func(context.Context) (*NexusAudit, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m NexusAuditMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m NexusAuditMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *NexusAuditMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *NexusAuditMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().NexusAudit.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetAction sets the "action" field.
func (m *NexusAuditMutation) SetAction(s string) {
	m.action = &s
}

// Action returns the value of the "action" field in the mutation.
func (m *NexusAuditMutation) Action() (r string, exists bool) {
	v := m.action
	if v == nil {
		return
	}
	return *v, true
}

// OldAction returns the old "action" field's value of the NexusAudit entity.
// If the NexusAudit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NexusAuditMutation) OldAction(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAction is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAction requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAction: %w", err)
	}
	return oldValue.Action, nil
}

// ResetAction resets all changes to the "action" field.
func (m *NexusAuditMutation) ResetAction() {
	m.action = nil
}

// SetActorID sets the "actor_id" field.
func (m *NexusAuditMutation) SetActorID(s string) {
	m.actor_id = &s
}

// ActorID returns the value of the "actor_id" field in the mutation.
func (m *NexusAuditMutation) ActorID() (r string, exists bool) {
	v := m.actor_id
	if v == nil {
		return
	}
	return *v, true
}

// OldActorID returns the old "actor_id" field's value of the NexusAudit entity.
// If the NexusAudit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NexusAuditMutation) OldActorID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldActorID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldActorID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldActorID: %w", err)
	}
	return oldValue.ActorID, nil
}

// ResetActorID resets all changes to the "actor_id" field.
func (m *NexusAuditMutation) ResetActorID() {
	m.actor_id = nil
}

// SetCredentialID sets the "credential_id" field.
func (m *NexusAuditMutation) SetCredentialID(s string) {
	m.credential_id = &s
}

// CredentialID returns the value of the "credential_id" field in the mutation.
func (m *NexusAuditMutation) CredentialID() (r string, exists bool) {
	v := m.credential_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCredentialID returns the old "credential_id" field's value of the NexusAudit entity.
// If the NexusAudit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NexusAuditMutation) OldCredentialID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCredentialID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCredentialID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCredentialID: %w", err)
	}
	return oldValue.CredentialID, nil
}

// ClearCredentialID clears the value of the "credential_id" field.
func (m *NexusAuditMutation) ClearCredentialID() {
	m.credential_id = nil
	m.clearedFields[nexusaudit.FieldCredentialID] = struct{}{}
}

// CredentialIDCleared returns if the "credential_id" field was cleared in this mutation.
func (m *NexusAuditMutation) CredentialIDCleared() bool {
	_, ok := m.clearedFields[nexusaudit.FieldCredentialID]
	return ok
}

// ResetCredentialID resets all changes to the "credential_id" field.
func (m *NexusAuditMutation) ResetCredentialID() {
	m.credential_id = nil
	delete(m.clearedFields, nexusaudit.FieldCredentialID)
}

// SetReasonCode sets the "reason_code" field.
func (m *NexusAuditMutation) SetReasonCode(s string) {
	m.reason_code = &s
}

// ReasonCode returns the value of the "reason_code" field in the mutation.
func (m *NexusAuditMutation) ReasonCode() (r string, exists bool) {
	v := m.reason_code
	if v == nil {
		return
	}
	return *v, true
}

// OldReasonCode returns the old "reason_code" field's value of the NexusAudit entity.
// If the NexusAudit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NexusAuditMutation) OldReasonCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReasonCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReasonCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReasonCode: %w", err)
	}
	return oldValue.ReasonCode, nil
}

// ClearReasonCode clears the value of the "reason_code" field.
func (m *NexusAuditMutation) ClearReasonCode() {
	m.reason_code = nil
	m.clearedFields[nexusaudit.FieldReasonCode] = struct{}{}
}

// ReasonCodeCleared returns if the "reason_code" field was cleared in this mutation.
func (m *NexusAuditMutation) ReasonCodeCleared() bool {
	_, ok := m.clearedFields[nexusaudit.FieldReasonCode]
	return ok
}

// ResetReasonCode resets all changes to the "reason_code" field.
func (m *NexusAuditMutation) ResetReasonCode() {
	m.reason_code = nil
	delete(m.clearedFields, nexusaudit.FieldReasonCode)
}

// SetTicketID sets the "ticket_id" field.
func (m *NexusAuditMutation) SetTicketID(s string) {
	m.ticket_id = &s
}

// TicketID returns the value of the "ticket_id" field in the mutation.
func (m *NexusAuditMutation) TicketID() (r string, exists bool) {
	v := m.ticket_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTicketID returns the old "ticket_id" field's value of the NexusAudit entity.
// If the NexusAudit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NexusAuditMutation) OldTicketID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTicketID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTicketID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTicketID: %w", err)
	}
	return oldValue.TicketID, nil
}

// ClearTicketID clears the value of the "ticket_id" field.
func (m *NexusAuditMutation) ClearTicketID() {
	m.ticket_id = nil
	m.clearedFields[nexusaudit.FieldTicketID] = struct{}{}
}

// TicketIDCleared returns if the "ticket_id" field was cleared in this mutation.
func (m *NexusAuditMutation) TicketIDCleared() bool {
	_, ok := m.clearedFields[nexusaudit.FieldTicketID]
	return ok
}

// ResetTicketID resets all changes to the "ticket_id" field.
func (m *NexusAuditMutation) ResetTicketID() {
	m.ticket_id = nil
	delete(m.clearedFields, nexusaudit.FieldTicketID)
}

// SetTimestamp sets the "timestamp" field.
func (m *NexusAuditMutation) SetTimestamp(t time.Time) {
	m.timestamp = &t
}

// Timestamp returns the value of the "timestamp" field in the mutation.
func (m *NexusAuditMutation) Timestamp() (r time.Time, exists bool) {
	v := m.timestamp
	if v == nil {
		return
	}
	return *v, true
}

// OldTimestamp returns the old "timestamp" field's value of the NexusAudit entity.
// If the NexusAudit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NexusAuditMutation) OldTimestamp(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTimestamp is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTimestamp requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTimestamp: %w", err)
	}
	return oldValue.Timestamp, nil
}

// ResetTimestamp resets all changes to the "timestamp" field.
func (m *NexusAuditMutation) ResetTimestamp() {
	m.timestamp = nil
}

// SetMetadata sets the "metadata" field.
func (m *NexusAuditMutation) SetMetadata(value map[string]interface{}) {
	m.metadata = &value
}

// Metadata returns the value of the "metadata" field in the mutation.
func (m *NexusAuditMutation) Metadata() (r map[string]interface{}, exists bool) {
	v := m.metadata
	if v == nil {
		return
	}
	return *v, true
}

// OldMetadata returns the old "metadata" field's value of the NexusAudit entity.
// If the NexusAudit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NexusAuditMutation) OldMetadata(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMetadata is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMetadata requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetadata: %w", err)
	}
	return oldValue.Metadata, nil
}

// ClearMetadata clears the value of the "metadata" field.
func (m *NexusAuditMutation) ClearMetadata() {
	m.metadata = nil
	m.clearedFields[nexusaudit.FieldMetadata] = struct{}{}
}

// MetadataCleared returns if the "metadata" field was cleared in this mutation.
func (m *NexusAuditMutation) MetadataCleared() bool {
	_, ok := m.clearedFields[nexusaudit.FieldMetadata]
	return ok
}

// ResetMetadata resets all changes to the "metadata" field.
func (m *NexusAuditMutation) ResetMetadata() {
	m.metadata = nil
	delete(m.clearedFields, nexusaudit.FieldMetadata)
}

// Where appends a list predicates to the NexusAuditMutation builder.
func (m *NexusAuditMutation) Where(ps ...predicate.NexusAudit) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the NexusAuditMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *NexusAuditMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.NexusAudit, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *NexusAuditMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *NexusAuditMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (NexusAudit).
func (m *NexusAuditMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *NexusAuditMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.action != nil {
		fields = append(fields, nexusaudit.FieldAction)
	}
	if m.actor_id != nil {
		fields = append(fields, nexusaudit.FieldActorID)
	}
	if m.credential_id != nil {
		fields = append(fields, nexusaudit.FieldCredentialID)
	}
	if m.reason_code != nil {
		fields = append(fields, nexusaudit.FieldReasonCode)
	}
	if m.ticket_id != nil {
		fields = append(fields, nexusaudit.FieldTicketID)
	}
	if m.timestamp != nil {
		fields = append(fields, nexusaudit.FieldTimestamp)
	}
	if m.metadata != nil {
		fields = append(fields, nexusaudit.FieldMetadata)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *NexusAuditMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case nexusaudit.FieldAction:
		return m.Action()
	case nexusaudit.FieldActorID:
		return m.ActorID()
	case nexusaudit.FieldCredentialID:
		return m.CredentialID()
	case nexusaudit.FieldReasonCode:
		return m.ReasonCode()
	case nexusaudit.FieldTicketID:
		return m.TicketID()
	case nexusaudit.FieldTimestamp:
		return m.Timestamp()
	case nexusaudit.FieldMetadata:
		return m.Metadata()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *NexusAuditMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case nexusaudit.FieldAction:
		return m.OldAction(ctx)
	case nexusaudit.FieldActorID:
		return m.OldActorID(ctx)
	case nexusaudit.FieldCredentialID:
		return m.OldCredentialID(ctx)
	case nexusaudit.FieldReasonCode:
		return m.OldReasonCode(ctx)
	case nexusaudit.FieldTicketID:
		return m.OldTicketID(ctx)
	case nexusaudit.FieldTimestamp:
		return m.OldTimestamp(ctx)
	case nexusaudit.FieldMetadata:
		return m.OldMetadata(ctx)
	}
	return nil, fmt.Errorf("unknown NexusAudit field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NexusAuditMutation) SetField(name string, value ent.Value) error {
	switch name {
	case nexusaudit.FieldAction:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAction(v)
		return nil
	case nexusaudit.FieldActorID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetActorID(v)
		return nil
	case nexusaudit.FieldCredentialID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCredentialID(v)
		return nil
	case nexusaudit.FieldReasonCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReasonCode(v)
		return nil
	case nexusaudit.FieldTicketID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTicketID(v)
		return nil
	case nexusaudit.FieldTimestamp:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTimestamp(v)
		return nil
	case nexusaudit.FieldMetadata:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetadata(v)
		return nil
	}
	return fmt.Errorf("unknown NexusAudit field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *NexusAuditMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *NexusAuditMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NexusAuditMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown NexusAudit numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *NexusAuditMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(nexusaudit.FieldCredentialID) {
		fields = append(fields, nexusaudit.FieldCredentialID)
	}
	if m.FieldCleared(nexusaudit.FieldReasonCode) {
		fields = append(fields, nexusaudit.FieldReasonCode)
	}
	if m.FieldCleared(nexusaudit.FieldTicketID) {
		fields = append(fields, nexusaudit.FieldTicketID)
	}
	if m.FieldCleared(nexusaudit.FieldMetadata) {
		fields = append(fields, nexusaudit.FieldMetadata)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *NexusAuditMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *NexusAuditMutation) ClearField(name string) error {
	switch name {
	case nexusaudit.FieldCredentialID:
		m.ClearCredentialID()
		return nil
	case nexusaudit.FieldReasonCode:
		m.ClearReasonCode()
		return nil
	case nexusaudit.FieldTicketID:
		m.ClearTicketID()
		return nil
	case nexusaudit.FieldMetadata:
		m.ClearMetadata()
		return nil
	}
	return fmt.Errorf("unknown NexusAudit nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *NexusAuditMutation) ResetField(name string) error {
	switch name {
	case nexusaudit.FieldAction:
		m.ResetAction()
		return nil
	case nexusaudit.FieldActorID:
		m.ResetActorID()
		return nil
	case nexusaudit.FieldCredentialID:
		m.ResetCredentialID()
		return nil
	case nexusaudit.FieldReasonCode:
		m.ResetReasonCode()
		return nil
	case nexusaudit.FieldTicketID:
		m.ResetTicketID()
		return nil
	case nexusaudit.FieldTimestamp:
		m.ResetTimestamp()
		return nil
	case nexusaudit.FieldMetadata:
		m.ResetMetadata()
		return nil
	}
	return fmt.Errorf("unknown NexusAudit field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *NexusAuditMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *NexusAuditMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *NexusAuditMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *NexusAuditMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *NexusAuditMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *NexusAuditMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *NexusAuditMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown NexusAudit unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *NexusAuditMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown NexusAudit edge %s", name)
}

// OneTimeLinkMutation represents an operation that mutates the OneTimeLink nodes in the graph.
type OneTimeLinkMutation struct {
	config
	op                Op
	typ               string
	id                *int
	token             *string
	expires_at        *time.Time
	consumed          *bool
	created_at        *time.Time
	clearedFields     map[string]struct{}
	credential        *int
	clearedcredential bool
	tenant            *int
	clearedtenant     bool
	done              bool
	oldValue          func(context.Context) (*OneTimeLink, error)
	predicates        []predicate.OneTimeLink
}

var _ ent.Mutation = (*OneTimeLinkMutation)(nil)

// onetimelinkOption allows management of the mutation configuration using functional options.
type onetimelinkOption func(*OneTimeLinkMutation)

// newOneTimeLinkMutation creates new mutation for the OneTimeLink entity.
func newOneTimeLinkMutation(c config, op Op, opts ...onetimelinkOption) *OneTimeLinkMutation {
	m := &OneTimeLinkMutation{
		config:        c,
		op:            op,
		typ:           TypeOneTimeLink,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOneTimeLinkID sets the ID field of the mutation.
func withOneTimeLinkID(id int) onetimelinkOption {
	return func(m *OneTimeLinkMutation) {
		var (
			err   error
			once  sync.Once
			value *OneTimeLink
		)
		m.oldValue = func(ctx context.Context) (*OneTimeLink, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().OneTimeLink.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOneTimeLink sets the old OneTimeLink of the mutation.
func withOneTimeLink(node *OneTimeLink) onetimelinkOption {
	return func(m *OneTimeLinkMutation) {
		m.oldValue = func(context.Context) (*OneTimeLink, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m OneTimeLinkMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m OneTimeLinkMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *OneTimeLinkMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *OneTimeLinkMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().OneTimeLink.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTenantID sets the "tenant_id" field.
func (m *OneTimeLinkMutation) SetTenantID(i int) {
	m.tenant = &i
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *OneTimeLinkMutation) TenantID() (r int, exists bool) {
	v := m.tenant
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the OneTimeLink entity.
// If the OneTimeLink object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OneTimeLinkMutation) OldTenantID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *OneTimeLinkMutation) ResetTenantID() {
	m.tenant = nil
}

// SetCredentialID sets the "credential_id" field.
func (m *OneTimeLinkMutation) SetCredentialID(i int) {
	m.credential = &i
}

// CredentialID returns the value of the "credential_id" field in the mutation.
func (m *OneTimeLinkMutation) CredentialID() (r int, exists bool) {
	v := m.credential
	if v == nil {
		return
	}
	return *v, true
}

// OldCredentialID returns the old "credential_id" field's value of the OneTimeLink entity.
// If the OneTimeLink object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OneTimeLinkMutation) OldCredentialID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCredentialID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCredentialID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCredentialID: %w", err)
	}
	return oldValue.CredentialID, nil
}

// ResetCredentialID resets all changes to the "credential_id" field.
func (m *OneTimeLinkMutation) ResetCredentialID() {
	m.credential = nil
}

// SetToken sets the "token" field.
func (m *OneTimeLinkMutation) SetToken(s string) {
	m.token = &s
}

// Token returns the value of the "token" field in the mutation.
func (m *OneTimeLinkMutation) Token() (r string, exists bool) {
	v := m.token
	if v == nil {
		return
	}
	return *v, true
}

// OldToken returns the old "token" field's value of the OneTimeLink entity.
// If the OneTimeLink object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OneTimeLinkMutation) OldToken(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldToken is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldToken requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldToken: %w", err)
	}
	return oldValue.Token, nil
}

// ResetToken resets all changes to the "token" field.
func (m *OneTimeLinkMutation) ResetToken() {
	m.token = nil
}

// SetExpiresAt sets the "expires_at" field.
func (m *OneTimeLinkMutation) SetExpiresAt(t time.Time) {
	m.expires_at = &t
}

// ExpiresAt returns the value of the "expires_at" field in the mutation.
func (m *OneTimeLinkMutation) ExpiresAt() (r time.Time, exists bool) {
	v := m.expires_at
	if v == nil {
		return
	}
	return *v, true
}

// OldExpiresAt returns the old "expires_at" field's value of the OneTimeLink entity.
// If the OneTimeLink object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OneTimeLinkMutation) OldExpiresAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpiresAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpiresAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpiresAt: %w", err)
	}
	return oldValue.ExpiresAt, nil
}

// ResetExpiresAt resets all changes to the "expires_at" field.
func (m *OneTimeLinkMutation) ResetExpiresAt() {
	m.expires_at = nil
}

// SetConsumed sets the "consumed" field.
func (m *OneTimeLinkMutation) SetConsumed(b bool) {
	m.consumed = &b
}

// Consumed returns the value of the "consumed" field in the mutation.
func (m *OneTimeLinkMutation) Consumed() (r bool, exists bool) {
	v := m.consumed
	if v == nil {
		return
	}
	return *v, true
}

// OldConsumed returns the old "consumed" field's value of the OneTimeLink entity.
// If the OneTimeLink object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OneTimeLinkMutation) OldConsumed(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldConsumed is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldConsumed requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldConsumed: %w", err)
	}
	return oldValue.Consumed, nil
}

// ResetConsumed resets all changes to the "consumed" field.
func (m *OneTimeLinkMutation) ResetConsumed() {
	m.consumed = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *OneTimeLinkMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *OneTimeLinkMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the OneTimeLink entity.
// If the OneTimeLink object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OneTimeLinkMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *OneTimeLinkMutation) ResetCreatedAt() {
	m.created_at = nil
}

// ClearCredential clears the "credential" edge to the Credential entity.
func (m *OneTimeLinkMutation) ClearCredential() {
	m.clearedcredential = true
	m.clearedFields[onetimelink.FieldCredentialID] = struct{}{}
}

// CredentialCleared reports if the "credential" edge to the Credential entity was cleared.
func (m *OneTimeLinkMutation) CredentialCleared() bool {
	return m.clearedcredential
}

// CredentialIDs returns the "credential" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CredentialID instead. It exists only for internal usage by the builders.
func (m *OneTimeLinkMutation) CredentialIDs() (ids []int) {
	if id := m.credential; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCredential resets all changes to the "credential" edge.
func (m *OneTimeLinkMutation) ResetCredential() {
	m.credential = nil
	m.clearedcredential = false
}

// ClearTenant clears the "tenant" edge to the Tenant entity.
func (m *OneTimeLinkMutation) ClearTenant() {
	m.clearedtenant = true
	m.clearedFields[onetimelink.FieldTenantID] = struct{}{}
}

// TenantCleared reports if the "tenant" edge to the Tenant entity was cleared.
func (m *OneTimeLinkMutation) TenantCleared() bool {
	return m.clearedtenant
}

// TenantIDs returns the "tenant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TenantID instead. It exists only for internal usage by the builders.
func (m *OneTimeLinkMutation) TenantIDs() (ids []int) {
	if id := m.tenant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTenant resets all changes to the "tenant" edge.
func (m *OneTimeLinkMutation) ResetTenant() {
	m.tenant = nil
	m.clearedtenant = false
}

// Where appends a list predicates to the OneTimeLinkMutation builder.
func (m *OneTimeLinkMutation) Where(ps ...predicate.OneTimeLink) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the OneTimeLinkMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *OneTimeLinkMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.OneTimeLink, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *OneTimeLinkMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *OneTimeLinkMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (OneTimeLink).
func (m *OneTimeLinkMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *OneTimeLinkMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.tenant != nil {
		fields = append(fields, onetimelink.FieldTenantID)
	}
	if m.credential != nil {
		fields = append(fields, onetimelink.FieldCredentialID)
	}
	if m.token != nil {
		fields = append(fields, onetimelink.FieldToken)
	}
	if m.expires_at != nil {
		fields = append(fields, onetimelink.FieldExpiresAt)
	}
	if m.consumed != nil {
		fields = append(fields, onetimelink.FieldConsumed)
	}
	if m.created_at != nil {
		fields = append(fields, onetimelink.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *OneTimeLinkMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case onetimelink.FieldTenantID:
		return m.TenantID()
	case onetimelink.FieldCredentialID:
		return m.CredentialID()
	case onetimelink.FieldToken:
		return m.Token()
	case onetimelink.FieldExpiresAt:
		return m.ExpiresAt()
	case onetimelink.FieldConsumed:
		return m.Consumed()
	case onetimelink.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *OneTimeLinkMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case onetimelink.FieldTenantID:
		return m.OldTenantID(ctx)
	case onetimelink.FieldCredentialID:
		return m.OldCredentialID(ctx)
	case onetimelink.FieldToken:
		return m.OldToken(ctx)
	case onetimelink.FieldExpiresAt:
		return m.OldExpiresAt(ctx)
	case onetimelink.FieldConsumed:
		return m.OldConsumed(ctx)
	case onetimelink.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown OneTimeLink field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OneTimeLinkMutation) SetField(name string, value ent.Value) error {
	switch name {
	case onetimelink.FieldTenantID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case onetimelink.FieldCredentialID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCredentialID(v)
		return nil
	case onetimelink.FieldToken:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetToken(v)
		return nil
	case onetimelink.FieldExpiresAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpiresAt(v)
		return nil
	case onetimelink.FieldConsumed:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetConsumed(v)
		return nil
	case onetimelink.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown OneTimeLink field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *OneTimeLinkMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *OneTimeLinkMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OneTimeLinkMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown OneTimeLink numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *OneTimeLinkMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *OneTimeLinkMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *OneTimeLinkMutation) ClearField(name string) error {
	return fmt.Errorf("unknown OneTimeLink nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *OneTimeLinkMutation) ResetField(name string) error {
	switch name {
	case onetimelink.FieldTenantID:
		m.ResetTenantID()
		return nil
	case onetimelink.FieldCredentialID:
		m.ResetCredentialID()
		return nil
	case onetimelink.FieldToken:
		m.ResetToken()
		return nil
	case onetimelink.FieldExpiresAt:
		m.ResetExpiresAt()
		return nil
	case onetimelink.FieldConsumed:
		m.ResetConsumed()
		return nil
	case onetimelink.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown OneTimeLink field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *OneTimeLinkMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.credential != nil {
		edges = append(edges, onetimelink.EdgeCredential)
	}
	if m.tenant != nil {
		edges = append(edges, onetimelink.EdgeTenant)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *OneTimeLinkMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case onetimelink.EdgeCredential:
		if id := m.credential; id != nil {
			return []ent.Value{*id}
		}
	case onetimelink.EdgeTenant:
		if id := m.tenant; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *OneTimeLinkMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *OneTimeLinkMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *OneTimeLinkMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedcredential {
		edges = append(edges, onetimelink.EdgeCredential)
	}
	if m.clearedtenant {
		edges = append(edges, onetimelink.EdgeTenant)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *OneTimeLinkMutation) EdgeCleared(name string) bool {
	switch name {
	case onetimelink.EdgeCredential:
		return m.clearedcredential
	case onetimelink.EdgeTenant:
		return m.clearedtenant
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *OneTimeLinkMutation) ClearEdge(name string) error {
	switch name {
	case onetimelink.EdgeCredential:
		m.ClearCredential()
		return nil
	case onetimelink.EdgeTenant:
		m.ClearTenant()
		return nil
	}
	return fmt.Errorf("unknown OneTimeLink unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *OneTimeLinkMutation) ResetEdge(name string) error {
	switch name {
	case onetimelink.EdgeCredential:
		m.ResetCredential()
		return nil
	case onetimelink.EdgeTenant:
		m.ResetTenant()
		return nil
	}
	return fmt.Errorf("unknown OneTimeLink edge %s", name)
}

// PermissionMutation represents an operation that mutates the Permission nodes in the graph.
type PermissionMutation struct {
	config
	op            Op
	typ           string
	id            *int
	name          *string
	code          *string
	clearedFields map[string]struct{}
	users         map[int]struct{}
	removedusers  map[int]struct{}
	clearedusers  bool
	done          bool
	oldValue      func(context.Context) (*Permission, error)
	predicates    []predicate.Permission
}

var _ ent.Mutation = (*PermissionMutation)(nil)

// permissionOption allows management of the mutation configuration using functional options.
type permissionOption func(*PermissionMutation)

// newPermissionMutation creates new mutation for the Permission entity.
func newPermissionMutation(c config, op Op, opts ...permissionOption) *PermissionMutation {
	m := &PermissionMutation{
		config:        c,
		op:            op,
		typ:           TypePermission,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPermissionID sets the ID field of the mutation.
func withPermissionID(id int) permissionOption {
	return func(m *PermissionMutation) {
		var (
			err   error
			once  sync.Once
			value *Permission
		)
		m.oldValue = func(ctx context.Context) (*Permission, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Permission.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPermission sets the old Permission of the mutation.
func withPermission(node *Permission) permissionOption {
	return func(m *PermissionMutation) {
		m.oldValue = func(context.Context) (*Permission, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PermissionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PermissionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PermissionMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PermissionMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Permission.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *PermissionMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *PermissionMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Permission entity.
// If the Permission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PermissionMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *PermissionMutation) ResetName() {
	m.name = nil
}

// SetCode sets the "code" field.
func (m *PermissionMutation) SetCode(s string) {
	m.code = &s
}

// Code returns the value of the "code" field in the mutation.
func (m *PermissionMutation) Code() (r string, exists bool) {
	v := m.code
	if v == nil {
		return
	}
	return *v, true
}

// OldCode returns the old "code" field's value of the Permission entity.
// If the Permission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PermissionMutation) OldCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCode: %w", err)
	}
	return oldValue.Code, nil
}

// ResetCode resets all changes to the "code" field.
func (m *PermissionMutation) ResetCode() {
	m.code = nil
}

// AddUserIDs adds the "users" edge to the User entity by ids.
func (m *PermissionMutation) AddUserIDs(ids ...int) {
	if m.users == nil {
		m.users = make(map[int]struct{})
	}
	for i := range ids {
		m.users[ids[i]] = struct{}{}
	}
}

// ClearUsers clears the "users" edge to the User entity.
func (m *PermissionMutation) ClearUsers() {
	m.clearedusers = true
}

// UsersCleared reports if the "users" edge to the User entity was cleared.
func (m *PermissionMutation) UsersCleared() bool {
	return m.clearedusers
}

// RemoveUserIDs removes the "users" edge to the User entity by IDs.
func (m *PermissionMutation) RemoveUserIDs(ids ...int) {
	if m.removedusers == nil {
		m.removedusers = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.users, ids[i])
		m.removedusers[ids[i]] = struct{}{}
	}
}

// RemovedUsers returns the removed IDs of the "users" edge to the User entity.
func (m *PermissionMutation) RemovedUsersIDs() (ids []int) {
	for id := range m.removedusers {
		ids = append(ids, id)
	}
	return
}

// UsersIDs returns the "users" edge IDs in the mutation.
func (m *PermissionMutation) UsersIDs() (ids []int) {
	for id := range m.users {
		ids = append(ids, id)
	}
	return
}

// ResetUsers resets all changes to the "users" edge.
func (m *PermissionMutation) ResetUsers() {
	m.users = nil
	m.clearedusers = false
	m.removedusers = nil
}

// Where appends a list predicates to the PermissionMutation builder.
func (m *PermissionMutation) Where(ps ...predicate.Permission) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PermissionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PermissionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Permission, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PermissionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PermissionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Permission).
func (m *PermissionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PermissionMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.name != nil {
		fields = append(fields, permission.FieldName)
	}
	if m.code != nil {
		fields = append(fields, permission.FieldCode)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PermissionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case permission.FieldName:
		return m.Name()
	case permission.FieldCode:
		return m.Code()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PermissionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case permission.FieldName:
		return m.OldName(ctx)
	case permission.FieldCode:
		return m.OldCode(ctx)
	}
	return nil, fmt.Errorf("unknown Permission field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PermissionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case permission.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case permission.FieldCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCode(v)
		return nil
	}
	return fmt.Errorf("unknown Permission field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PermissionMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PermissionMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PermissionMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Permission numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PermissionMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PermissionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PermissionMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Permission nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PermissionMutation) ResetField(name string) error {
	switch name {
	case permission.FieldName:
		m.ResetName()
		return nil
	case permission.FieldCode:
		m.ResetCode()
		return nil
	}
	return fmt.Errorf("unknown Permission field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PermissionMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.users != nil {
		edges = append(edges, permission.EdgeUsers)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PermissionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case permission.EdgeUsers:
		ids := make([]ent.Value, 0, len(m.users))
		for id := range m.users {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PermissionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedusers != nil {
		edges = append(edges, permission.EdgeUsers)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PermissionMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case permission.EdgeUsers:
		ids := make([]ent.Value, 0, len(m.removedusers))
		for id := range m.removedusers {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PermissionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedusers {
		edges = append(edges, permission.EdgeUsers)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PermissionMutation) EdgeCleared(name string) bool {
	switch name {
	case permission.EdgeUsers:
		return m.clearedusers
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PermissionMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Permission unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PermissionMutation) ResetEdge(name string) error {
	switch name {
	case permission.EdgeUsers:
		m.ResetUsers()
		return nil
	}
	return fmt.Errorf("unknown Permission edge %s", name)
}

// ProductMutation represents an operation that mutates the Product nodes in the graph.
type ProductMutation struct {
	config
	op                  Op
	typ                 string
	id                  *int
	sku                 *string
	name                *string
	description         *string
	unit_cost           *float64
	addunit_cost        *float64
	quantity            *float64
	addquantity         *float64
	attributes          *map[string]interface{}
	created_at          *time.Time
	updated_at          *time.Time
	clearedFields       map[string]struct{}
	tenant              *int
	clearedtenant       bool
	movements           map[int]struct{}
	removedmovements    map[int]struct{}
	clearedmovements    bool
	reservations        map[int]struct{}
	removedreservations map[int]struct{}
	clearedreservations bool
	vendor              *int
	clearedvendor       bool
	done                bool
	oldValue            func(context.Context) (*Product, error)
	predicates          []predicate.Product
}

var _ ent.Mutation = (*ProductMutation)(nil)

// productOption allows management of the mutation configuration using functional options.
type productOption func(*ProductMutation)

// newProductMutation creates new mutation for the Product entity.
func newProductMutation(c config, op Op, opts ...productOption) *ProductMutation {
	m := &ProductMutation{
		config:        c,
		op:            op,
		typ:           TypeProduct,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withProductID sets the ID field of the mutation.
func withProductID(id int) productOption {
	return func(m *ProductMutation) {
		var (
			err   error
			once  sync.Once
			value *Product
		)
		m.oldValue = func(ctx context.Context) (*Product, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Product.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProduct sets the old Product of the mutation.
func withProduct(node *Product) productOption {
	return func(m *ProductMutation) {
		m.oldValue = func(context.Context) (*Product, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProductMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProductMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ProductMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ProductMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Product.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetSku sets the "sku" field.
func (m *ProductMutation) SetSku(s string) {
	m.sku = &s
}

// Sku returns the value of the "sku" field in the mutation.
func (m *ProductMutation) Sku() (r string, exists bool) {
	v := m.sku
	if v == nil {
		return
	}
	return *v, true
}

// OldSku returns the old "sku" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldSku(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSku is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSku requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSku: %w", err)
	}
	return oldValue.Sku, nil
}

// ResetSku resets all changes to the "sku" field.
func (m *ProductMutation) ResetSku() {
	m.sku = nil
}

// SetName sets the "name" field.
func (m *ProductMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ProductMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ProductMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *ProductMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *ProductMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *ProductMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[product.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *ProductMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[product.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *ProductMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, product.FieldDescription)
}

// SetUnitCost sets the "unit_cost" field.
func (m *ProductMutation) SetUnitCost(f float64) {
	m.unit_cost = &f
	m.addunit_cost = nil
}

// UnitCost returns the value of the "unit_cost" field in the mutation.
func (m *ProductMutation) UnitCost() (r float64, exists bool) {
	v := m.unit_cost
	if v == nil {
		return
	}
	return *v, true
}

// OldUnitCost returns the old "unit_cost" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldUnitCost(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUnitCost is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUnitCost requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUnitCost: %w", err)
	}
	return oldValue.UnitCost, nil
}

// AddUnitCost adds f to the "unit_cost" field.
func (m *ProductMutation) AddUnitCost(f float64) {
	if m.addunit_cost != nil {
		*m.addunit_cost += f
	} else {
		m.addunit_cost = &f
	}
}

// AddedUnitCost returns the value that was added to the "unit_cost" field in this mutation.
func (m *ProductMutation) AddedUnitCost() (r float64, exists bool) {
	v := m.addunit_cost
	if v == nil {
		return
	}
	return *v, true
}

// ResetUnitCost resets all changes to the "unit_cost" field.
func (m *ProductMutation) ResetUnitCost() {
	m.unit_cost = nil
	m.addunit_cost = nil
}

// SetQuantity sets the "quantity" field.
func (m *ProductMutation) SetQuantity(f float64) {
	m.quantity = &f
	m.addquantity = nil
}

// Quantity returns the value of the "quantity" field in the mutation.
func (m *ProductMutation) Quantity() (r float64, exists bool) {
	v := m.quantity
	if v == nil {
		return
	}
	return *v, true
}

// OldQuantity returns the old "quantity" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldQuantity(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldQuantity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldQuantity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldQuantity: %w", err)
	}
	return oldValue.Quantity, nil
}

// AddQuantity adds f to the "quantity" field.
func (m *ProductMutation) AddQuantity(f float64) {
	if m.addquantity != nil {
		*m.addquantity += f
	} else {
		m.addquantity = &f
	}
}

// AddedQuantity returns the value that was added to the "quantity" field in this mutation.
func (m *ProductMutation) AddedQuantity() (r float64, exists bool) {
	v := m.addquantity
	if v == nil {
		return
	}
	return *v, true
}

// ResetQuantity resets all changes to the "quantity" field.
func (m *ProductMutation) ResetQuantity() {
	m.quantity = nil
	m.addquantity = nil
}

// SetAttributes sets the "attributes" field.
func (m *ProductMutation) SetAttributes(value map[string]interface{}) {
	m.attributes = &value
}

// Attributes returns the value of the "attributes" field in the mutation.
func (m *ProductMutation) Attributes() (r map[string]interface{}, exists bool) {
	v := m.attributes
	if v == nil {
		return
	}
	return *v, true
}

// OldAttributes returns the old "attributes" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldAttributes(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAttributes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAttributes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAttributes: %w", err)
	}
	return oldValue.Attributes, nil
}

// ClearAttributes clears the value of the "attributes" field.
func (m *ProductMutation) ClearAttributes() {
	m.attributes = nil
	m.clearedFields[product.FieldAttributes] = struct{}{}
}

// AttributesCleared returns if the "attributes" field was cleared in this mutation.
func (m *ProductMutation) AttributesCleared() bool {
	_, ok := m.clearedFields[product.FieldAttributes]
	return ok
}

// ResetAttributes resets all changes to the "attributes" field.
func (m *ProductMutation) ResetAttributes() {
	m.attributes = nil
	delete(m.clearedFields, product.FieldAttributes)
}

// SetCreatedAt sets the "created_at" field.
func (m *ProductMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ProductMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ProductMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ProductMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ProductMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ProductMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetTenantID sets the "tenant" edge to the Tenant entity by id.
func (m *ProductMutation) SetTenantID(id int) {
	m.tenant = &id
}

// ClearTenant clears the "tenant" edge to the Tenant entity.
func (m *ProductMutation) ClearTenant() {
	m.clearedtenant = true
}

// TenantCleared reports if the "tenant" edge to the Tenant entity was cleared.
func (m *ProductMutation) TenantCleared() bool {
	return m.clearedtenant
}

// TenantID returns the "tenant" edge ID in the mutation.
func (m *ProductMutation) TenantID() (id int, exists bool) {
	if m.tenant != nil {
		return *m.tenant, true
	}
	return
}

// TenantIDs returns the "tenant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TenantID instead. It exists only for internal usage by the builders.
func (m *ProductMutation) TenantIDs() (ids []int) {
	if id := m.tenant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTenant resets all changes to the "tenant" edge.
func (m *ProductMutation) ResetTenant() {
	m.tenant = nil
	m.clearedtenant = false
}

// AddMovementIDs adds the "movements" edge to the StockMovement entity by ids.
func (m *ProductMutation) AddMovementIDs(ids ...int) {
	if m.movements == nil {
		m.movements = make(map[int]struct{})
	}
	for i := range ids {
		m.movements[ids[i]] = struct{}{}
	}
}

// ClearMovements clears the "movements" edge to the StockMovement entity.
func (m *ProductMutation) ClearMovements() {
	m.clearedmovements = true
}

// MovementsCleared reports if the "movements" edge to the StockMovement entity was cleared.
func (m *ProductMutation) MovementsCleared() bool {
	return m.clearedmovements
}

// RemoveMovementIDs removes the "movements" edge to the StockMovement entity by IDs.
func (m *ProductMutation) RemoveMovementIDs(ids ...int) {
	if m.removedmovements == nil {
		m.removedmovements = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.movements, ids[i])
		m.removedmovements[ids[i]] = struct{}{}
	}
}

// RemovedMovements returns the removed IDs of the "movements" edge to the StockMovement entity.
func (m *ProductMutation) RemovedMovementsIDs() (ids []int) {
	for id := range m.removedmovements {
		ids = append(ids, id)
	}
	return
}

// MovementsIDs returns the "movements" edge IDs in the mutation.
func (m *ProductMutation) MovementsIDs() (ids []int) {
	for id := range m.movements {
		ids = append(ids, id)
	}
	return
}

// ResetMovements resets all changes to the "movements" edge.
func (m *ProductMutation) ResetMovements() {
	m.movements = nil
	m.clearedmovements = false
	m.removedmovements = nil
}

// AddReservationIDs adds the "reservations" edge to the InventoryReservation entity by ids.
func (m *ProductMutation) AddReservationIDs(ids ...int) {
	if m.reservations == nil {
		m.reservations = make(map[int]struct{})
	}
	for i := range ids {
		m.reservations[ids[i]] = struct{}{}
	}
}

// ClearReservations clears the "reservations" edge to the InventoryReservation entity.
func (m *ProductMutation) ClearReservations() {
	m.clearedreservations = true
}

// ReservationsCleared reports if the "reservations" edge to the InventoryReservation entity was cleared.
func (m *ProductMutation) ReservationsCleared() bool {
	return m.clearedreservations
}

// RemoveReservationIDs removes the "reservations" edge to the InventoryReservation entity by IDs.
func (m *ProductMutation) RemoveReservationIDs(ids ...int) {
	if m.removedreservations == nil {
		m.removedreservations = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.reservations, ids[i])
		m.removedreservations[ids[i]] = struct{}{}
	}
}

// RemovedReservations returns the removed IDs of the "reservations" edge to the InventoryReservation entity.
func (m *ProductMutation) RemovedReservationsIDs() (ids []int) {
	for id := range m.removedreservations {
		ids = append(ids, id)
	}
	return
}

// ReservationsIDs returns the "reservations" edge IDs in the mutation.
func (m *ProductMutation) ReservationsIDs() (ids []int) {
	for id := range m.reservations {
		ids = append(ids, id)
	}
	return
}

// ResetReservations resets all changes to the "reservations" edge.
func (m *ProductMutation) ResetReservations() {
	m.reservations = nil
	m.clearedreservations = false
	m.removedreservations = nil
}

// SetVendorID sets the "vendor" edge to the Account entity by id.
func (m *ProductMutation) SetVendorID(id int) {
	m.vendor = &id
}

// ClearVendor clears the "vendor" edge to the Account entity.
func (m *ProductMutation) ClearVendor() {
	m.clearedvendor = true
}

// VendorCleared reports if the "vendor" edge to the Account entity was cleared.
func (m *ProductMutation) VendorCleared() bool {
	return m.clearedvendor
}

// VendorID returns the "vendor" edge ID in the mutation.
func (m *ProductMutation) VendorID() (id int, exists bool) {
	if m.vendor != nil {
		return *m.vendor, true
	}
	return
}

// VendorIDs returns the "vendor" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// VendorID instead. It exists only for internal usage by the builders.
func (m *ProductMutation) VendorIDs() (ids []int) {
	if id := m.vendor; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetVendor resets all changes to the "vendor" edge.
func (m *ProductMutation) ResetVendor() {
	m.vendor = nil
	m.clearedvendor = false
}

// Where appends a list predicates to the ProductMutation builder.
func (m *ProductMutation) Where(ps ...predicate.Product) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ProductMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ProductMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Product, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ProductMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ProductMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Product).
func (m *ProductMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ProductMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.sku != nil {
		fields = append(fields, product.FieldSku)
	}
	if m.name != nil {
		fields = append(fields, product.FieldName)
	}
	if m.description != nil {
		fields = append(fields, product.FieldDescription)
	}
	if m.unit_cost != nil {
		fields = append(fields, product.FieldUnitCost)
	}
	if m.quantity != nil {
		fields = append(fields, product.FieldQuantity)
	}
	if m.attributes != nil {
		fields = append(fields, product.FieldAttributes)
	}
	if m.created_at != nil {
		fields = append(fields, product.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, product.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ProductMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case product.FieldSku:
		return m.Sku()
	case product.FieldName:
		return m.Name()
	case product.FieldDescription:
		return m.Description()
	case product.FieldUnitCost:
		return m.UnitCost()
	case product.FieldQuantity:
		return m.Quantity()
	case product.FieldAttributes:
		return m.Attributes()
	case product.FieldCreatedAt:
		return m.CreatedAt()
	case product.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ProductMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case product.FieldSku:
		return m.OldSku(ctx)
	case product.FieldName:
		return m.OldName(ctx)
	case product.FieldDescription:
		return m.OldDescription(ctx)
	case product.FieldUnitCost:
		return m.OldUnitCost(ctx)
	case product.FieldQuantity:
		return m.OldQuantity(ctx)
	case product.FieldAttributes:
		return m.OldAttributes(ctx)
	case product.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case product.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Product field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProductMutation) SetField(name string, value ent.Value) error {
	switch name {
	case product.FieldSku:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSku(v)
		return nil
	case product.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case product.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case product.FieldUnitCost:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUnitCost(v)
		return nil
	case product.FieldQuantity:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetQuantity(v)
		return nil
	case product.FieldAttributes:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAttributes(v)
		return nil
	case product.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case product.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Product field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ProductMutation) AddedFields() []string {
	var fields []string
	if m.addunit_cost != nil {
		fields = append(fields, product.FieldUnitCost)
	}
	if m.addquantity != nil {
		fields = append(fields, product.FieldQuantity)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ProductMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case product.FieldUnitCost:
		return m.AddedUnitCost()
	case product.FieldQuantity:
		return m.AddedQuantity()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProductMutation) AddField(name string, value ent.Value) error {
	switch name {
	case product.FieldUnitCost:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUnitCost(v)
		return nil
	case product.FieldQuantity:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddQuantity(v)
		return nil
	}
	return fmt.Errorf("unknown Product numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ProductMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(product.FieldDescription) {
		fields = append(fields, product.FieldDescription)
	}
	if m.FieldCleared(product.FieldAttributes) {
		fields = append(fields, product.FieldAttributes)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ProductMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProductMutation) ClearField(name string) error {
	switch name {
	case product.FieldDescription:
		m.ClearDescription()
		return nil
	case product.FieldAttributes:
		m.ClearAttributes()
		return nil
	}
	return fmt.Errorf("unknown Product nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ProductMutation) ResetField(name string) error {
	switch name {
	case product.FieldSku:
		m.ResetSku()
		return nil
	case product.FieldName:
		m.ResetName()
		return nil
	case product.FieldDescription:
		m.ResetDescription()
		return nil
	case product.FieldUnitCost:
		m.ResetUnitCost()
		return nil
	case product.FieldQuantity:
		m.ResetQuantity()
		return nil
	case product.FieldAttributes:
		m.ResetAttributes()
		return nil
	case product.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case product.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Product field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ProductMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.tenant != nil {
		edges = append(edges, product.EdgeTenant)
	}
	if m.movements != nil {
		edges = append(edges, product.EdgeMovements)
	}
	if m.reservations != nil {
		edges = append(edges, product.EdgeReservations)
	}
	if m.vendor != nil {
		edges = append(edges, product.EdgeVendor)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ProductMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case product.EdgeTenant:
		if id := m.tenant; id != nil {
			return []ent.Value{*id}
		}
	case product.EdgeMovements:
		ids := make([]ent.Value, 0, len(m.movements))
		for id := range m.movements {
			ids = append(ids, id)
		}
		return ids
	case product.EdgeReservations:
		ids := make([]ent.Value, 0, len(m.reservations))
		for id := range m.reservations {
			ids = append(ids, id)
		}
		return ids
	case product.EdgeVendor:
		if id := m.vendor; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ProductMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedmovements != nil {
		edges = append(edges, product.EdgeMovements)
	}
	if m.removedreservations != nil {
		edges = append(edges, product.EdgeReservations)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ProductMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case product.EdgeMovements:
		ids := make([]ent.Value, 0, len(m.removedmovements))
		for id := range m.removedmovements {
			ids = append(ids, id)
		}
		return ids
	case product.EdgeReservations:
		ids := make([]ent.Value, 0, len(m.removedreservations))
		for id := range m.removedreservations {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ProductMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedtenant {
		edges = append(edges, product.EdgeTenant)
	}
	if m.clearedmovements {
		edges = append(edges, product.EdgeMovements)
	}
	if m.clearedreservations {
		edges = append(edges, product.EdgeReservations)
	}
	if m.clearedvendor {
		edges = append(edges, product.EdgeVendor)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ProductMutation) EdgeCleared(name string) bool {
	switch name {
	case product.EdgeTenant:
		return m.clearedtenant
	case product.EdgeMovements:
		return m.clearedmovements
	case product.EdgeReservations:
		return m.clearedreservations
	case product.EdgeVendor:
		return m.clearedvendor
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ProductMutation) ClearEdge(name string) error {
	switch name {
	case product.EdgeTenant:
		m.ClearTenant()
		return nil
	case product.EdgeVendor:
		m.ClearVendor()
		return nil
	}
	return fmt.Errorf("unknown Product unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ProductMutation) ResetEdge(name string) error {
	switch name {
	case product.EdgeTenant:
		m.ResetTenant()
		return nil
	case product.EdgeMovements:
		m.ResetMovements()
		return nil
	case product.EdgeReservations:
		m.ResetReservations()
		return nil
	case product.EdgeVendor:
		m.ResetVendor()
		return nil
	}
	return fmt.Errorf("unknown Product edge %s", name)
}

// RecordingMutation represents an operation that mutates the Recording nodes in the graph.
type RecordingMutation struct {
	config
	op            Op
	typ           string
	id            *int
	_path         *string
	start_time    *time.Time
	end_time      *time.Time
	size_bytes    *float64
	addsize_bytes *float64
	_type         *string
	clearedFields map[string]struct{}
	camera        *int
	clearedcamera bool
	done          bool
	oldValue      func(context.Context) (*Recording, error)
	predicates    []predicate.Recording
}

var _ ent.Mutation = (*RecordingMutation)(nil)

// recordingOption allows management of the mutation configuration using functional options.
type recordingOption func(*RecordingMutation)

// newRecordingMutation creates new mutation for the Recording entity.
func newRecordingMutation(c config, op Op, opts ...recordingOption) *RecordingMutation {
	m := &RecordingMutation{
		config:        c,
		op:            op,
		typ:           TypeRecording,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRecordingID sets the ID field of the mutation.
func withRecordingID(id int) recordingOption {
	return func(m *RecordingMutation) {
		var (
			err   error
			once  sync.Once
			value *Recording
		)
		m.oldValue = func(ctx context.Context) (*Recording, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Recording.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRecording sets the old Recording of the mutation.
func withRecording(node *Recording) recordingOption {
	return func(m *RecordingMutation) {
		m.oldValue = func(context.Context) (*Recording, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RecordingMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RecordingMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *RecordingMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *RecordingMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Recording.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetPath sets the "path" field.
func (m *RecordingMutation) SetPath(s string) {
	m._path = &s
}

// Path returns the value of the "path" field in the mutation.
func (m *RecordingMutation) Path() (r string, exists bool) {
	v := m._path
	if v == nil {
		return
	}
	return *v, true
}

// OldPath returns the old "path" field's value of the Recording entity.
// If the Recording object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RecordingMutation) OldPath(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPath is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPath requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPath: %w", err)
	}
	return oldValue.Path, nil
}

// ResetPath resets all changes to the "path" field.
func (m *RecordingMutation) ResetPath() {
	m._path = nil
}

// SetStartTime sets the "start_time" field.
func (m *RecordingMutation) SetStartTime(t time.Time) {
	m.start_time = &t
}

// StartTime returns the value of the "start_time" field in the mutation.
func (m *RecordingMutation) StartTime() (r time.Time, exists bool) {
	v := m.start_time
	if v == nil {
		return
	}
	return *v, true
}

// OldStartTime returns the old "start_time" field's value of the Recording entity.
// If the Recording object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RecordingMutation) OldStartTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartTime: %w", err)
	}
	return oldValue.StartTime, nil
}

// ResetStartTime resets all changes to the "start_time" field.
func (m *RecordingMutation) ResetStartTime() {
	m.start_time = nil
}

// SetEndTime sets the "end_time" field.
func (m *RecordingMutation) SetEndTime(t time.Time) {
	m.end_time = &t
}

// EndTime returns the value of the "end_time" field in the mutation.
func (m *RecordingMutation) EndTime() (r time.Time, exists bool) {
	v := m.end_time
	if v == nil {
		return
	}
	return *v, true
}

// OldEndTime returns the old "end_time" field's value of the Recording entity.
// If the Recording object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RecordingMutation) OldEndTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEndTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEndTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndTime: %w", err)
	}
	return oldValue.EndTime, nil
}

// ClearEndTime clears the value of the "end_time" field.
func (m *RecordingMutation) ClearEndTime() {
	m.end_time = nil
	m.clearedFields[recording.FieldEndTime] = struct{}{}
}

// EndTimeCleared returns if the "end_time" field was cleared in this mutation.
func (m *RecordingMutation) EndTimeCleared() bool {
	_, ok := m.clearedFields[recording.FieldEndTime]
	return ok
}

// ResetEndTime resets all changes to the "end_time" field.
func (m *RecordingMutation) ResetEndTime() {
	m.end_time = nil
	delete(m.clearedFields, recording.FieldEndTime)
}

// SetSizeBytes sets the "size_bytes" field.
func (m *RecordingMutation) SetSizeBytes(f float64) {
	m.size_bytes = &f
	m.addsize_bytes = nil
}

// SizeBytes returns the value of the "size_bytes" field in the mutation.
func (m *RecordingMutation) SizeBytes() (r float64, exists bool) {
	v := m.size_bytes
	if v == nil {
		return
	}
	return *v, true
}

// OldSizeBytes returns the old "size_bytes" field's value of the Recording entity.
// If the Recording object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RecordingMutation) OldSizeBytes(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSizeBytes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSizeBytes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSizeBytes: %w", err)
	}
	return oldValue.SizeBytes, nil
}

// AddSizeBytes adds f to the "size_bytes" field.
func (m *RecordingMutation) AddSizeBytes(f float64) {
	if m.addsize_bytes != nil {
		*m.addsize_bytes += f
	} else {
		m.addsize_bytes = &f
	}
}

// AddedSizeBytes returns the value that was added to the "size_bytes" field in this mutation.
func (m *RecordingMutation) AddedSizeBytes() (r float64, exists bool) {
	v := m.addsize_bytes
	if v == nil {
		return
	}
	return *v, true
}

// ClearSizeBytes clears the value of the "size_bytes" field.
func (m *RecordingMutation) ClearSizeBytes() {
	m.size_bytes = nil
	m.addsize_bytes = nil
	m.clearedFields[recording.FieldSizeBytes] = struct{}{}
}

// SizeBytesCleared returns if the "size_bytes" field was cleared in this mutation.
func (m *RecordingMutation) SizeBytesCleared() bool {
	_, ok := m.clearedFields[recording.FieldSizeBytes]
	return ok
}

// ResetSizeBytes resets all changes to the "size_bytes" field.
func (m *RecordingMutation) ResetSizeBytes() {
	m.size_bytes = nil
	m.addsize_bytes = nil
	delete(m.clearedFields, recording.FieldSizeBytes)
}

// SetType sets the "type" field.
func (m *RecordingMutation) SetType(s string) {
	m._type = &s
}

// GetType returns the value of the "type" field in the mutation.
func (m *RecordingMutation) GetType() (r string, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Recording entity.
// If the Recording object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RecordingMutation) OldType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *RecordingMutation) ResetType() {
	m._type = nil
}

// SetCameraID sets the "camera" edge to the Camera entity by id.
func (m *RecordingMutation) SetCameraID(id int) {
	m.camera = &id
}

// ClearCamera clears the "camera" edge to the Camera entity.
func (m *RecordingMutation) ClearCamera() {
	m.clearedcamera = true
}

// CameraCleared reports if the "camera" edge to the Camera entity was cleared.
func (m *RecordingMutation) CameraCleared() bool {
	return m.clearedcamera
}

// CameraID returns the "camera" edge ID in the mutation.
func (m *RecordingMutation) CameraID() (id int, exists bool) {
	if m.camera != nil {
		return *m.camera, true
	}
	return
}

// CameraIDs returns the "camera" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CameraID instead. It exists only for internal usage by the builders.
func (m *RecordingMutation) CameraIDs() (ids []int) {
	if id := m.camera; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCamera resets all changes to the "camera" edge.
func (m *RecordingMutation) ResetCamera() {
	m.camera = nil
	m.clearedcamera = false
}

// Where appends a list predicates to the RecordingMutation builder.
func (m *RecordingMutation) Where(ps ...predicate.Recording) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the RecordingMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *RecordingMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Recording, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *RecordingMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *RecordingMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Recording).
func (m *RecordingMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *RecordingMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m._path != nil {
		fields = append(fields, recording.FieldPath)
	}
	if m.start_time != nil {
		fields = append(fields, recording.FieldStartTime)
	}
	if m.end_time != nil {
		fields = append(fields, recording.FieldEndTime)
	}
	if m.size_bytes != nil {
		fields = append(fields, recording.FieldSizeBytes)
	}
	if m._type != nil {
		fields = append(fields, recording.FieldType)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *RecordingMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case recording.FieldPath:
		return m.Path()
	case recording.FieldStartTime:
		return m.StartTime()
	case recording.FieldEndTime:
		return m.EndTime()
	case recording.FieldSizeBytes:
		return m.SizeBytes()
	case recording.FieldType:
		return m.GetType()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *RecordingMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case recording.FieldPath:
		return m.OldPath(ctx)
	case recording.FieldStartTime:
		return m.OldStartTime(ctx)
	case recording.FieldEndTime:
		return m.OldEndTime(ctx)
	case recording.FieldSizeBytes:
		return m.OldSizeBytes(ctx)
	case recording.FieldType:
		return m.OldType(ctx)
	}
	return nil, fmt.Errorf("unknown Recording field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RecordingMutation) SetField(name string, value ent.Value) error {
	switch name {
	case recording.FieldPath:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPath(v)
		return nil
	case recording.FieldStartTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartTime(v)
		return nil
	case recording.FieldEndTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndTime(v)
		return nil
	case recording.FieldSizeBytes:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSizeBytes(v)
		return nil
	case recording.FieldType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	}
	return fmt.Errorf("unknown Recording field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *RecordingMutation) AddedFields() []string {
	var fields []string
	if m.addsize_bytes != nil {
		fields = append(fields, recording.FieldSizeBytes)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *RecordingMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case recording.FieldSizeBytes:
		return m.AddedSizeBytes()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RecordingMutation) AddField(name string, value ent.Value) error {
	switch name {
	case recording.FieldSizeBytes:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSizeBytes(v)
		return nil
	}
	return fmt.Errorf("unknown Recording numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *RecordingMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(recording.FieldEndTime) {
		fields = append(fields, recording.FieldEndTime)
	}
	if m.FieldCleared(recording.FieldSizeBytes) {
		fields = append(fields, recording.FieldSizeBytes)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *RecordingMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *RecordingMutation) ClearField(name string) error {
	switch name {
	case recording.FieldEndTime:
		m.ClearEndTime()
		return nil
	case recording.FieldSizeBytes:
		m.ClearSizeBytes()
		return nil
	}
	return fmt.Errorf("unknown Recording nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *RecordingMutation) ResetField(name string) error {
	switch name {
	case recording.FieldPath:
		m.ResetPath()
		return nil
	case recording.FieldStartTime:
		m.ResetStartTime()
		return nil
	case recording.FieldEndTime:
		m.ResetEndTime()
		return nil
	case recording.FieldSizeBytes:
		m.ResetSizeBytes()
		return nil
	case recording.FieldType:
		m.ResetType()
		return nil
	}
	return fmt.Errorf("unknown Recording field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *RecordingMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.camera != nil {
		edges = append(edges, recording.EdgeCamera)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *RecordingMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case recording.EdgeCamera:
		if id := m.camera; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *RecordingMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *RecordingMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *RecordingMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedcamera {
		edges = append(edges, recording.EdgeCamera)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *RecordingMutation) EdgeCleared(name string) bool {
	switch name {
	case recording.EdgeCamera:
		return m.clearedcamera
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *RecordingMutation) ClearEdge(name string) error {
	switch name {
	case recording.EdgeCamera:
		m.ClearCamera()
		return nil
	}
	return fmt.Errorf("unknown Recording unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *RecordingMutation) ResetEdge(name string) error {
	switch name {
	case recording.EdgeCamera:
		m.ResetCamera()
		return nil
	}
	return fmt.Errorf("unknown Recording edge %s", name)
}

// RecurringInvoiceMutation represents an operation that mutates the RecurringInvoice nodes in the graph.
type RecurringInvoiceMutation struct {
	config
	op             Op
	typ            string
	id             *int
	description    *string
	amount         *float64
	addamount      *float64
	currency       *string
	frequency      *string
	next_run_date  *time.Time
	last_run_date  *time.Time
	is_active      *bool
	created_at     *time.Time
	clearedFields  map[string]struct{}
	tenant         *int
	clearedtenant  bool
	account        *int
	clearedaccount bool
	done           bool
	oldValue       func(context.Context) (*RecurringInvoice, error)
	predicates     []predicate.RecurringInvoice
}

var _ ent.Mutation = (*RecurringInvoiceMutation)(nil)

// recurringinvoiceOption allows management of the mutation configuration using functional options.
type recurringinvoiceOption func(*RecurringInvoiceMutation)

// newRecurringInvoiceMutation creates new mutation for the RecurringInvoice entity.
func newRecurringInvoiceMutation(c config, op Op, opts ...recurringinvoiceOption) *RecurringInvoiceMutation {
	m := &RecurringInvoiceMutation{
		config:        c,
		op:            op,
		typ:           TypeRecurringInvoice,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRecurringInvoiceID sets the ID field of the mutation.
func withRecurringInvoiceID(id int) recurringinvoiceOption {
	return func(m *RecurringInvoiceMutation) {
		var (
			err   error
			once  sync.Once
			value *RecurringInvoice
		)
		m.oldValue = func(ctx context.Context) (*RecurringInvoice, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().RecurringInvoice.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRecurringInvoice sets the old RecurringInvoice of the mutation.
func withRecurringInvoice(node *RecurringInvoice) recurringinvoiceOption {
	return func(m *RecurringInvoiceMutation) {
		m.oldValue = func(context.Context) (*RecurringInvoice, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RecurringInvoiceMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RecurringInvoiceMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *RecurringInvoiceMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *RecurringInvoiceMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().RecurringInvoice.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetDescription sets the "description" field.
func (m *RecurringInvoiceMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *RecurringInvoiceMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the RecurringInvoice entity.
// If the RecurringInvoice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RecurringInvoiceMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *RecurringInvoiceMutation) ResetDescription() {
	m.description = nil
}

// SetAmount sets the "amount" field.
func (m *RecurringInvoiceMutation) SetAmount(f float64) {
	m.amount = &f
	m.addamount = nil
}

// Amount returns the value of the "amount" field in the mutation.
func (m *RecurringInvoiceMutation) Amount() (r float64, exists bool) {
	v := m.amount
	if v == nil {
		return
	}
	return *v, true
}

// OldAmount returns the old "amount" field's value of the RecurringInvoice entity.
// If the RecurringInvoice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RecurringInvoiceMutation) OldAmount(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAmount: %w", err)
	}
	return oldValue.Amount, nil
}

// AddAmount adds f to the "amount" field.
func (m *RecurringInvoiceMutation) AddAmount(f float64) {
	if m.addamount != nil {
		*m.addamount += f
	} else {
		m.addamount = &f
	}
}

// AddedAmount returns the value that was added to the "amount" field in this mutation.
func (m *RecurringInvoiceMutation) AddedAmount() (r float64, exists bool) {
	v := m.addamount
	if v == nil {
		return
	}
	return *v, true
}

// ResetAmount resets all changes to the "amount" field.
func (m *RecurringInvoiceMutation) ResetAmount() {
	m.amount = nil
	m.addamount = nil
}

// SetCurrency sets the "currency" field.
func (m *RecurringInvoiceMutation) SetCurrency(s string) {
	m.currency = &s
}

// Currency returns the value of the "currency" field in the mutation.
func (m *RecurringInvoiceMutation) Currency() (r string, exists bool) {
	v := m.currency
	if v == nil {
		return
	}
	return *v, true
}

// OldCurrency returns the old "currency" field's value of the RecurringInvoice entity.
// If the RecurringInvoice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RecurringInvoiceMutation) OldCurrency(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCurrency is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCurrency requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCurrency: %w", err)
	}
	return oldValue.Currency, nil
}

// ResetCurrency resets all changes to the "currency" field.
func (m *RecurringInvoiceMutation) ResetCurrency() {
	m.currency = nil
}

// SetFrequency sets the "frequency" field.
func (m *RecurringInvoiceMutation) SetFrequency(s string) {
	m.frequency = &s
}

// Frequency returns the value of the "frequency" field in the mutation.
func (m *RecurringInvoiceMutation) Frequency() (r string, exists bool) {
	v := m.frequency
	if v == nil {
		return
	}
	return *v, true
}

// OldFrequency returns the old "frequency" field's value of the RecurringInvoice entity.
// If the RecurringInvoice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RecurringInvoiceMutation) OldFrequency(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFrequency is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFrequency requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFrequency: %w", err)
	}
	return oldValue.Frequency, nil
}

// ResetFrequency resets all changes to the "frequency" field.
func (m *RecurringInvoiceMutation) ResetFrequency() {
	m.frequency = nil
}

// SetNextRunDate sets the "next_run_date" field.
func (m *RecurringInvoiceMutation) SetNextRunDate(t time.Time) {
	m.next_run_date = &t
}

// NextRunDate returns the value of the "next_run_date" field in the mutation.
func (m *RecurringInvoiceMutation) NextRunDate() (r time.Time, exists bool) {
	v := m.next_run_date
	if v == nil {
		return
	}
	return *v, true
}

// OldNextRunDate returns the old "next_run_date" field's value of the RecurringInvoice entity.
// If the RecurringInvoice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RecurringInvoiceMutation) OldNextRunDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNextRunDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNextRunDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNextRunDate: %w", err)
	}
	return oldValue.NextRunDate, nil
}

// ResetNextRunDate resets all changes to the "next_run_date" field.
func (m *RecurringInvoiceMutation) ResetNextRunDate() {
	m.next_run_date = nil
}

// SetLastRunDate sets the "last_run_date" field.
func (m *RecurringInvoiceMutation) SetLastRunDate(t time.Time) {
	m.last_run_date = &t
}

// LastRunDate returns the value of the "last_run_date" field in the mutation.
func (m *RecurringInvoiceMutation) LastRunDate() (r time.Time, exists bool) {
	v := m.last_run_date
	if v == nil {
		return
	}
	return *v, true
}

// OldLastRunDate returns the old "last_run_date" field's value of the RecurringInvoice entity.
// If the RecurringInvoice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RecurringInvoiceMutation) OldLastRunDate(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastRunDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastRunDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastRunDate: %w", err)
	}
	return oldValue.LastRunDate, nil
}

// ClearLastRunDate clears the value of the "last_run_date" field.
func (m *RecurringInvoiceMutation) ClearLastRunDate() {
	m.last_run_date = nil
	m.clearedFields[recurringinvoice.FieldLastRunDate] = struct{}{}
}

// LastRunDateCleared returns if the "last_run_date" field was cleared in this mutation.
func (m *RecurringInvoiceMutation) LastRunDateCleared() bool {
	_, ok := m.clearedFields[recurringinvoice.FieldLastRunDate]
	return ok
}

// ResetLastRunDate resets all changes to the "last_run_date" field.
func (m *RecurringInvoiceMutation) ResetLastRunDate() {
	m.last_run_date = nil
	delete(m.clearedFields, recurringinvoice.FieldLastRunDate)
}

// SetIsActive sets the "is_active" field.
func (m *RecurringInvoiceMutation) SetIsActive(b bool) {
	m.is_active = &b
}

// IsActive returns the value of the "is_active" field in the mutation.
func (m *RecurringInvoiceMutation) IsActive() (r bool, exists bool) {
	v := m.is_active
	if v == nil {
		return
	}
	return *v, true
}

// OldIsActive returns the old "is_active" field's value of the RecurringInvoice entity.
// If the RecurringInvoice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RecurringInvoiceMutation) OldIsActive(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsActive is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsActive requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsActive: %w", err)
	}
	return oldValue.IsActive, nil
}

// ResetIsActive resets all changes to the "is_active" field.
func (m *RecurringInvoiceMutation) ResetIsActive() {
	m.is_active = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *RecurringInvoiceMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *RecurringInvoiceMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the RecurringInvoice entity.
// If the RecurringInvoice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RecurringInvoiceMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *RecurringInvoiceMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetTenantID sets the "tenant" edge to the Tenant entity by id.
func (m *RecurringInvoiceMutation) SetTenantID(id int) {
	m.tenant = &id
}

// ClearTenant clears the "tenant" edge to the Tenant entity.
func (m *RecurringInvoiceMutation) ClearTenant() {
	m.clearedtenant = true
}

// TenantCleared reports if the "tenant" edge to the Tenant entity was cleared.
func (m *RecurringInvoiceMutation) TenantCleared() bool {
	return m.clearedtenant
}

// TenantID returns the "tenant" edge ID in the mutation.
func (m *RecurringInvoiceMutation) TenantID() (id int, exists bool) {
	if m.tenant != nil {
		return *m.tenant, true
	}
	return
}

// TenantIDs returns the "tenant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TenantID instead. It exists only for internal usage by the builders.
func (m *RecurringInvoiceMutation) TenantIDs() (ids []int) {
	if id := m.tenant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTenant resets all changes to the "tenant" edge.
func (m *RecurringInvoiceMutation) ResetTenant() {
	m.tenant = nil
	m.clearedtenant = false
}

// SetAccountID sets the "account" edge to the Account entity by id.
func (m *RecurringInvoiceMutation) SetAccountID(id int) {
	m.account = &id
}

// ClearAccount clears the "account" edge to the Account entity.
func (m *RecurringInvoiceMutation) ClearAccount() {
	m.clearedaccount = true
}

// AccountCleared reports if the "account" edge to the Account entity was cleared.
func (m *RecurringInvoiceMutation) AccountCleared() bool {
	return m.clearedaccount
}

// AccountID returns the "account" edge ID in the mutation.
func (m *RecurringInvoiceMutation) AccountID() (id int, exists bool) {
	if m.account != nil {
		return *m.account, true
	}
	return
}

// AccountIDs returns the "account" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AccountID instead. It exists only for internal usage by the builders.
func (m *RecurringInvoiceMutation) AccountIDs() (ids []int) {
	if id := m.account; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAccount resets all changes to the "account" edge.
func (m *RecurringInvoiceMutation) ResetAccount() {
	m.account = nil
	m.clearedaccount = false
}

// Where appends a list predicates to the RecurringInvoiceMutation builder.
func (m *RecurringInvoiceMutation) Where(ps ...predicate.RecurringInvoice) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the RecurringInvoiceMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *RecurringInvoiceMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.RecurringInvoice, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *RecurringInvoiceMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *RecurringInvoiceMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (RecurringInvoice).
func (m *RecurringInvoiceMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *RecurringInvoiceMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.description != nil {
		fields = append(fields, recurringinvoice.FieldDescription)
	}
	if m.amount != nil {
		fields = append(fields, recurringinvoice.FieldAmount)
	}
	if m.currency != nil {
		fields = append(fields, recurringinvoice.FieldCurrency)
	}
	if m.frequency != nil {
		fields = append(fields, recurringinvoice.FieldFrequency)
	}
	if m.next_run_date != nil {
		fields = append(fields, recurringinvoice.FieldNextRunDate)
	}
	if m.last_run_date != nil {
		fields = append(fields, recurringinvoice.FieldLastRunDate)
	}
	if m.is_active != nil {
		fields = append(fields, recurringinvoice.FieldIsActive)
	}
	if m.created_at != nil {
		fields = append(fields, recurringinvoice.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *RecurringInvoiceMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case recurringinvoice.FieldDescription:
		return m.Description()
	case recurringinvoice.FieldAmount:
		return m.Amount()
	case recurringinvoice.FieldCurrency:
		return m.Currency()
	case recurringinvoice.FieldFrequency:
		return m.Frequency()
	case recurringinvoice.FieldNextRunDate:
		return m.NextRunDate()
	case recurringinvoice.FieldLastRunDate:
		return m.LastRunDate()
	case recurringinvoice.FieldIsActive:
		return m.IsActive()
	case recurringinvoice.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *RecurringInvoiceMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case recurringinvoice.FieldDescription:
		return m.OldDescription(ctx)
	case recurringinvoice.FieldAmount:
		return m.OldAmount(ctx)
	case recurringinvoice.FieldCurrency:
		return m.OldCurrency(ctx)
	case recurringinvoice.FieldFrequency:
		return m.OldFrequency(ctx)
	case recurringinvoice.FieldNextRunDate:
		return m.OldNextRunDate(ctx)
	case recurringinvoice.FieldLastRunDate:
		return m.OldLastRunDate(ctx)
	case recurringinvoice.FieldIsActive:
		return m.OldIsActive(ctx)
	case recurringinvoice.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown RecurringInvoice field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RecurringInvoiceMutation) SetField(name string, value ent.Value) error {
	switch name {
	case recurringinvoice.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case recurringinvoice.FieldAmount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAmount(v)
		return nil
	case recurringinvoice.FieldCurrency:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCurrency(v)
		return nil
	case recurringinvoice.FieldFrequency:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFrequency(v)
		return nil
	case recurringinvoice.FieldNextRunDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNextRunDate(v)
		return nil
	case recurringinvoice.FieldLastRunDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastRunDate(v)
		return nil
	case recurringinvoice.FieldIsActive:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsActive(v)
		return nil
	case recurringinvoice.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown RecurringInvoice field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *RecurringInvoiceMutation) AddedFields() []string {
	var fields []string
	if m.addamount != nil {
		fields = append(fields, recurringinvoice.FieldAmount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *RecurringInvoiceMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case recurringinvoice.FieldAmount:
		return m.AddedAmount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RecurringInvoiceMutation) AddField(name string, value ent.Value) error {
	switch name {
	case recurringinvoice.FieldAmount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAmount(v)
		return nil
	}
	return fmt.Errorf("unknown RecurringInvoice numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *RecurringInvoiceMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(recurringinvoice.FieldLastRunDate) {
		fields = append(fields, recurringinvoice.FieldLastRunDate)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *RecurringInvoiceMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *RecurringInvoiceMutation) ClearField(name string) error {
	switch name {
	case recurringinvoice.FieldLastRunDate:
		m.ClearLastRunDate()
		return nil
	}
	return fmt.Errorf("unknown RecurringInvoice nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *RecurringInvoiceMutation) ResetField(name string) error {
	switch name {
	case recurringinvoice.FieldDescription:
		m.ResetDescription()
		return nil
	case recurringinvoice.FieldAmount:
		m.ResetAmount()
		return nil
	case recurringinvoice.FieldCurrency:
		m.ResetCurrency()
		return nil
	case recurringinvoice.FieldFrequency:
		m.ResetFrequency()
		return nil
	case recurringinvoice.FieldNextRunDate:
		m.ResetNextRunDate()
		return nil
	case recurringinvoice.FieldLastRunDate:
		m.ResetLastRunDate()
		return nil
	case recurringinvoice.FieldIsActive:
		m.ResetIsActive()
		return nil
	case recurringinvoice.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown RecurringInvoice field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *RecurringInvoiceMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.tenant != nil {
		edges = append(edges, recurringinvoice.EdgeTenant)
	}
	if m.account != nil {
		edges = append(edges, recurringinvoice.EdgeAccount)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *RecurringInvoiceMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case recurringinvoice.EdgeTenant:
		if id := m.tenant; id != nil {
			return []ent.Value{*id}
		}
	case recurringinvoice.EdgeAccount:
		if id := m.account; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *RecurringInvoiceMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *RecurringInvoiceMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *RecurringInvoiceMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedtenant {
		edges = append(edges, recurringinvoice.EdgeTenant)
	}
	if m.clearedaccount {
		edges = append(edges, recurringinvoice.EdgeAccount)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *RecurringInvoiceMutation) EdgeCleared(name string) bool {
	switch name {
	case recurringinvoice.EdgeTenant:
		return m.clearedtenant
	case recurringinvoice.EdgeAccount:
		return m.clearedaccount
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *RecurringInvoiceMutation) ClearEdge(name string) error {
	switch name {
	case recurringinvoice.EdgeTenant:
		m.ClearTenant()
		return nil
	case recurringinvoice.EdgeAccount:
		m.ClearAccount()
		return nil
	}
	return fmt.Errorf("unknown RecurringInvoice unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *RecurringInvoiceMutation) ResetEdge(name string) error {
	switch name {
	case recurringinvoice.EdgeTenant:
		m.ResetTenant()
		return nil
	case recurringinvoice.EdgeAccount:
		m.ResetAccount()
		return nil
	}
	return fmt.Errorf("unknown RecurringInvoice edge %s", name)
}

// RemediationStepMutation represents an operation that mutates the RemediationStep nodes in the graph.
type RemediationStepMutation struct {
	config
	op                Op
	typ               string
	id                *int
	action_name       *string
	sequence          *int
	addsequence       *int
	status            *remediationstep.Status
	output            *string
	execution_context *map[string]interface{}
	clearedFields     map[string]struct{}
	ticket            *int
	clearedticket     bool
	done              bool
	oldValue          func(context.Context) (*RemediationStep, error)
	predicates        []predicate.RemediationStep
}

var _ ent.Mutation = (*RemediationStepMutation)(nil)

// remediationstepOption allows management of the mutation configuration using functional options.
type remediationstepOption func(*RemediationStepMutation)

// newRemediationStepMutation creates new mutation for the RemediationStep entity.
func newRemediationStepMutation(c config, op Op, opts ...remediationstepOption) *RemediationStepMutation {
	m := &RemediationStepMutation{
		config:        c,
		op:            op,
		typ:           TypeRemediationStep,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRemediationStepID sets the ID field of the mutation.
func withRemediationStepID(id int) remediationstepOption {
	return func(m *RemediationStepMutation) {
		var (
			err   error
			once  sync.Once
			value *RemediationStep
		)
		m.oldValue = func(ctx context.Context) (*RemediationStep, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().RemediationStep.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRemediationStep sets the old RemediationStep of the mutation.
func withRemediationStep(node *RemediationStep) remediationstepOption {
	return func(m *RemediationStepMutation) {
		m.oldValue = func(context.Context) (*RemediationStep, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RemediationStepMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RemediationStepMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *RemediationStepMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *RemediationStepMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().RemediationStep.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetActionName sets the "action_name" field.
func (m *RemediationStepMutation) SetActionName(s string) {
	m.action_name = &s
}

// ActionName returns the value of the "action_name" field in the mutation.
func (m *RemediationStepMutation) ActionName() (r string, exists bool) {
	v := m.action_name
	if v == nil {
		return
	}
	return *v, true
}

// OldActionName returns the old "action_name" field's value of the RemediationStep entity.
// If the RemediationStep object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RemediationStepMutation) OldActionName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldActionName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldActionName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldActionName: %w", err)
	}
	return oldValue.ActionName, nil
}

// ResetActionName resets all changes to the "action_name" field.
func (m *RemediationStepMutation) ResetActionName() {
	m.action_name = nil
}

// SetSequence sets the "sequence" field.
func (m *RemediationStepMutation) SetSequence(i int) {
	m.sequence = &i
	m.addsequence = nil
}

// Sequence returns the value of the "sequence" field in the mutation.
func (m *RemediationStepMutation) Sequence() (r int, exists bool) {
	v := m.sequence
	if v == nil {
		return
	}
	return *v, true
}

// OldSequence returns the old "sequence" field's value of the RemediationStep entity.
// If the RemediationStep object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RemediationStepMutation) OldSequence(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSequence is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSequence requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSequence: %w", err)
	}
	return oldValue.Sequence, nil
}

// AddSequence adds i to the "sequence" field.
func (m *RemediationStepMutation) AddSequence(i int) {
	if m.addsequence != nil {
		*m.addsequence += i
	} else {
		m.addsequence = &i
	}
}

// AddedSequence returns the value that was added to the "sequence" field in this mutation.
func (m *RemediationStepMutation) AddedSequence() (r int, exists bool) {
	v := m.addsequence
	if v == nil {
		return
	}
	return *v, true
}

// ResetSequence resets all changes to the "sequence" field.
func (m *RemediationStepMutation) ResetSequence() {
	m.sequence = nil
	m.addsequence = nil
}

// SetStatus sets the "status" field.
func (m *RemediationStepMutation) SetStatus(r remediationstep.Status) {
	m.status = &r
}

// Status returns the value of the "status" field in the mutation.
func (m *RemediationStepMutation) Status() (r remediationstep.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the RemediationStep entity.
// If the RemediationStep object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RemediationStepMutation) OldStatus(ctx context.Context) (v remediationstep.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *RemediationStepMutation) ResetStatus() {
	m.status = nil
}

// SetOutput sets the "output" field.
func (m *RemediationStepMutation) SetOutput(s string) {
	m.output = &s
}

// Output returns the value of the "output" field in the mutation.
func (m *RemediationStepMutation) Output() (r string, exists bool) {
	v := m.output
	if v == nil {
		return
	}
	return *v, true
}

// OldOutput returns the old "output" field's value of the RemediationStep entity.
// If the RemediationStep object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RemediationStepMutation) OldOutput(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOutput is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOutput requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOutput: %w", err)
	}
	return oldValue.Output, nil
}

// ClearOutput clears the value of the "output" field.
func (m *RemediationStepMutation) ClearOutput() {
	m.output = nil
	m.clearedFields[remediationstep.FieldOutput] = struct{}{}
}

// OutputCleared returns if the "output" field was cleared in this mutation.
func (m *RemediationStepMutation) OutputCleared() bool {
	_, ok := m.clearedFields[remediationstep.FieldOutput]
	return ok
}

// ResetOutput resets all changes to the "output" field.
func (m *RemediationStepMutation) ResetOutput() {
	m.output = nil
	delete(m.clearedFields, remediationstep.FieldOutput)
}

// SetExecutionContext sets the "execution_context" field.
func (m *RemediationStepMutation) SetExecutionContext(value map[string]interface{}) {
	m.execution_context = &value
}

// ExecutionContext returns the value of the "execution_context" field in the mutation.
func (m *RemediationStepMutation) ExecutionContext() (r map[string]interface{}, exists bool) {
	v := m.execution_context
	if v == nil {
		return
	}
	return *v, true
}

// OldExecutionContext returns the old "execution_context" field's value of the RemediationStep entity.
// If the RemediationStep object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RemediationStepMutation) OldExecutionContext(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExecutionContext is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExecutionContext requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExecutionContext: %w", err)
	}
	return oldValue.ExecutionContext, nil
}

// ClearExecutionContext clears the value of the "execution_context" field.
func (m *RemediationStepMutation) ClearExecutionContext() {
	m.execution_context = nil
	m.clearedFields[remediationstep.FieldExecutionContext] = struct{}{}
}

// ExecutionContextCleared returns if the "execution_context" field was cleared in this mutation.
func (m *RemediationStepMutation) ExecutionContextCleared() bool {
	_, ok := m.clearedFields[remediationstep.FieldExecutionContext]
	return ok
}

// ResetExecutionContext resets all changes to the "execution_context" field.
func (m *RemediationStepMutation) ResetExecutionContext() {
	m.execution_context = nil
	delete(m.clearedFields, remediationstep.FieldExecutionContext)
}

// SetTicketID sets the "ticket" edge to the Ticket entity by id.
func (m *RemediationStepMutation) SetTicketID(id int) {
	m.ticket = &id
}

// ClearTicket clears the "ticket" edge to the Ticket entity.
func (m *RemediationStepMutation) ClearTicket() {
	m.clearedticket = true
}

// TicketCleared reports if the "ticket" edge to the Ticket entity was cleared.
func (m *RemediationStepMutation) TicketCleared() bool {
	return m.clearedticket
}

// TicketID returns the "ticket" edge ID in the mutation.
func (m *RemediationStepMutation) TicketID() (id int, exists bool) {
	if m.ticket != nil {
		return *m.ticket, true
	}
	return
}

// TicketIDs returns the "ticket" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TicketID instead. It exists only for internal usage by the builders.
func (m *RemediationStepMutation) TicketIDs() (ids []int) {
	if id := m.ticket; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTicket resets all changes to the "ticket" edge.
func (m *RemediationStepMutation) ResetTicket() {
	m.ticket = nil
	m.clearedticket = false
}

// Where appends a list predicates to the RemediationStepMutation builder.
func (m *RemediationStepMutation) Where(ps ...predicate.RemediationStep) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the RemediationStepMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *RemediationStepMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.RemediationStep, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *RemediationStepMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *RemediationStepMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (RemediationStep).
func (m *RemediationStepMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *RemediationStepMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.action_name != nil {
		fields = append(fields, remediationstep.FieldActionName)
	}
	if m.sequence != nil {
		fields = append(fields, remediationstep.FieldSequence)
	}
	if m.status != nil {
		fields = append(fields, remediationstep.FieldStatus)
	}
	if m.output != nil {
		fields = append(fields, remediationstep.FieldOutput)
	}
	if m.execution_context != nil {
		fields = append(fields, remediationstep.FieldExecutionContext)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *RemediationStepMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case remediationstep.FieldActionName:
		return m.ActionName()
	case remediationstep.FieldSequence:
		return m.Sequence()
	case remediationstep.FieldStatus:
		return m.Status()
	case remediationstep.FieldOutput:
		return m.Output()
	case remediationstep.FieldExecutionContext:
		return m.ExecutionContext()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *RemediationStepMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case remediationstep.FieldActionName:
		return m.OldActionName(ctx)
	case remediationstep.FieldSequence:
		return m.OldSequence(ctx)
	case remediationstep.FieldStatus:
		return m.OldStatus(ctx)
	case remediationstep.FieldOutput:
		return m.OldOutput(ctx)
	case remediationstep.FieldExecutionContext:
		return m.OldExecutionContext(ctx)
	}
	return nil, fmt.Errorf("unknown RemediationStep field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RemediationStepMutation) SetField(name string, value ent.Value) error {
	switch name {
	case remediationstep.FieldActionName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetActionName(v)
		return nil
	case remediationstep.FieldSequence:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSequence(v)
		return nil
	case remediationstep.FieldStatus:
		v, ok := value.(remediationstep.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case remediationstep.FieldOutput:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOutput(v)
		return nil
	case remediationstep.FieldExecutionContext:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExecutionContext(v)
		return nil
	}
	return fmt.Errorf("unknown RemediationStep field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *RemediationStepMutation) AddedFields() []string {
	var fields []string
	if m.addsequence != nil {
		fields = append(fields, remediationstep.FieldSequence)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *RemediationStepMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case remediationstep.FieldSequence:
		return m.AddedSequence()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RemediationStepMutation) AddField(name string, value ent.Value) error {
	switch name {
	case remediationstep.FieldSequence:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSequence(v)
		return nil
	}
	return fmt.Errorf("unknown RemediationStep numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *RemediationStepMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(remediationstep.FieldOutput) {
		fields = append(fields, remediationstep.FieldOutput)
	}
	if m.FieldCleared(remediationstep.FieldExecutionContext) {
		fields = append(fields, remediationstep.FieldExecutionContext)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *RemediationStepMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *RemediationStepMutation) ClearField(name string) error {
	switch name {
	case remediationstep.FieldOutput:
		m.ClearOutput()
		return nil
	case remediationstep.FieldExecutionContext:
		m.ClearExecutionContext()
		return nil
	}
	return fmt.Errorf("unknown RemediationStep nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *RemediationStepMutation) ResetField(name string) error {
	switch name {
	case remediationstep.FieldActionName:
		m.ResetActionName()
		return nil
	case remediationstep.FieldSequence:
		m.ResetSequence()
		return nil
	case remediationstep.FieldStatus:
		m.ResetStatus()
		return nil
	case remediationstep.FieldOutput:
		m.ResetOutput()
		return nil
	case remediationstep.FieldExecutionContext:
		m.ResetExecutionContext()
		return nil
	}
	return fmt.Errorf("unknown RemediationStep field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *RemediationStepMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.ticket != nil {
		edges = append(edges, remediationstep.EdgeTicket)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *RemediationStepMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case remediationstep.EdgeTicket:
		if id := m.ticket; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *RemediationStepMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *RemediationStepMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *RemediationStepMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedticket {
		edges = append(edges, remediationstep.EdgeTicket)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *RemediationStepMutation) EdgeCleared(name string) bool {
	switch name {
	case remediationstep.EdgeTicket:
		return m.clearedticket
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *RemediationStepMutation) ClearEdge(name string) error {
	switch name {
	case remediationstep.EdgeTicket:
		m.ClearTicket()
		return nil
	}
	return fmt.Errorf("unknown RemediationStep unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *RemediationStepMutation) ResetEdge(name string) error {
	switch name {
	case remediationstep.EdgeTicket:
		m.ResetTicket()
		return nil
	}
	return fmt.Errorf("unknown RemediationStep edge %s", name)
}

// SOPMutation represents an operation that mutates the SOP nodes in the graph.
type SOPMutation struct {
	config
	op            Op
	typ           string
	id            *int
	title         *string
	content       *map[string]interface{}
	version       *int
	addversion    *int
	created_at    *time.Time
	updated_at    *time.Time
	clearedFields map[string]struct{}
	tenant        *int
	clearedtenant bool
	asset         *int
	clearedasset  bool
	author        *int
	clearedauthor bool
	done          bool
	oldValue      func(context.Context) (*SOP, error)
	predicates    []predicate.SOP
}

var _ ent.Mutation = (*SOPMutation)(nil)

// sopOption allows management of the mutation configuration using functional options.
type sopOption func(*SOPMutation)

// newSOPMutation creates new mutation for the SOP entity.
func newSOPMutation(c config, op Op, opts ...sopOption) *SOPMutation {
	m := &SOPMutation{
		config:        c,
		op:            op,
		typ:           TypeSOP,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSOPID sets the ID field of the mutation.
func withSOPID(id int) sopOption {
	return func(m *SOPMutation) {
		var (
			err   error
			once  sync.Once
			value *SOP
		)
		m.oldValue = func(ctx context.Context) (*SOP, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().SOP.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSOP sets the old SOP of the mutation.
func withSOP(node *SOP) sopOption {
	return func(m *SOPMutation) {
		m.oldValue = func(context.Context) (*SOP, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SOPMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SOPMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SOPMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SOPMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().SOP.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTitle sets the "title" field.
func (m *SOPMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *SOPMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the SOP entity.
// If the SOP object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SOPMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *SOPMutation) ResetTitle() {
	m.title = nil
}

// SetContent sets the "content" field.
func (m *SOPMutation) SetContent(value map[string]interface{}) {
	m.content = &value
}

// Content returns the value of the "content" field in the mutation.
func (m *SOPMutation) Content() (r map[string]interface{}, exists bool) {
	v := m.content
	if v == nil {
		return
	}
	return *v, true
}

// OldContent returns the old "content" field's value of the SOP entity.
// If the SOP object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SOPMutation) OldContent(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContent: %w", err)
	}
	return oldValue.Content, nil
}

// ClearContent clears the value of the "content" field.
func (m *SOPMutation) ClearContent() {
	m.content = nil
	m.clearedFields[sop.FieldContent] = struct{}{}
}

// ContentCleared returns if the "content" field was cleared in this mutation.
func (m *SOPMutation) ContentCleared() bool {
	_, ok := m.clearedFields[sop.FieldContent]
	return ok
}

// ResetContent resets all changes to the "content" field.
func (m *SOPMutation) ResetContent() {
	m.content = nil
	delete(m.clearedFields, sop.FieldContent)
}

// SetVersion sets the "version" field.
func (m *SOPMutation) SetVersion(i int) {
	m.version = &i
	m.addversion = nil
}

// Version returns the value of the "version" field in the mutation.
func (m *SOPMutation) Version() (r int, exists bool) {
	v := m.version
	if v == nil {
		return
	}
	return *v, true
}

// OldVersion returns the old "version" field's value of the SOP entity.
// If the SOP object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SOPMutation) OldVersion(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVersion: %w", err)
	}
	return oldValue.Version, nil
}

// AddVersion adds i to the "version" field.
func (m *SOPMutation) AddVersion(i int) {
	if m.addversion != nil {
		*m.addversion += i
	} else {
		m.addversion = &i
	}
}

// AddedVersion returns the value that was added to the "version" field in this mutation.
func (m *SOPMutation) AddedVersion() (r int, exists bool) {
	v := m.addversion
	if v == nil {
		return
	}
	return *v, true
}

// ResetVersion resets all changes to the "version" field.
func (m *SOPMutation) ResetVersion() {
	m.version = nil
	m.addversion = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *SOPMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *SOPMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the SOP entity.
// If the SOP object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SOPMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *SOPMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *SOPMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *SOPMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the SOP entity.
// If the SOP object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SOPMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *SOPMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetTenantID sets the "tenant" edge to the Tenant entity by id.
func (m *SOPMutation) SetTenantID(id int) {
	m.tenant = &id
}

// ClearTenant clears the "tenant" edge to the Tenant entity.
func (m *SOPMutation) ClearTenant() {
	m.clearedtenant = true
}

// TenantCleared reports if the "tenant" edge to the Tenant entity was cleared.
func (m *SOPMutation) TenantCleared() bool {
	return m.clearedtenant
}

// TenantID returns the "tenant" edge ID in the mutation.
func (m *SOPMutation) TenantID() (id int, exists bool) {
	if m.tenant != nil {
		return *m.tenant, true
	}
	return
}

// TenantIDs returns the "tenant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TenantID instead. It exists only for internal usage by the builders.
func (m *SOPMutation) TenantIDs() (ids []int) {
	if id := m.tenant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTenant resets all changes to the "tenant" edge.
func (m *SOPMutation) ResetTenant() {
	m.tenant = nil
	m.clearedtenant = false
}

// SetAssetID sets the "asset" edge to the Asset entity by id.
func (m *SOPMutation) SetAssetID(id int) {
	m.asset = &id
}

// ClearAsset clears the "asset" edge to the Asset entity.
func (m *SOPMutation) ClearAsset() {
	m.clearedasset = true
}

// AssetCleared reports if the "asset" edge to the Asset entity was cleared.
func (m *SOPMutation) AssetCleared() bool {
	return m.clearedasset
}

// AssetID returns the "asset" edge ID in the mutation.
func (m *SOPMutation) AssetID() (id int, exists bool) {
	if m.asset != nil {
		return *m.asset, true
	}
	return
}

// AssetIDs returns the "asset" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AssetID instead. It exists only for internal usage by the builders.
func (m *SOPMutation) AssetIDs() (ids []int) {
	if id := m.asset; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAsset resets all changes to the "asset" edge.
func (m *SOPMutation) ResetAsset() {
	m.asset = nil
	m.clearedasset = false
}

// SetAuthorID sets the "author" edge to the User entity by id.
func (m *SOPMutation) SetAuthorID(id int) {
	m.author = &id
}

// ClearAuthor clears the "author" edge to the User entity.
func (m *SOPMutation) ClearAuthor() {
	m.clearedauthor = true
}

// AuthorCleared reports if the "author" edge to the User entity was cleared.
func (m *SOPMutation) AuthorCleared() bool {
	return m.clearedauthor
}

// AuthorID returns the "author" edge ID in the mutation.
func (m *SOPMutation) AuthorID() (id int, exists bool) {
	if m.author != nil {
		return *m.author, true
	}
	return
}

// AuthorIDs returns the "author" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AuthorID instead. It exists only for internal usage by the builders.
func (m *SOPMutation) AuthorIDs() (ids []int) {
	if id := m.author; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAuthor resets all changes to the "author" edge.
func (m *SOPMutation) ResetAuthor() {
	m.author = nil
	m.clearedauthor = false
}

// Where appends a list predicates to the SOPMutation builder.
func (m *SOPMutation) Where(ps ...predicate.SOP) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SOPMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SOPMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.SOP, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SOPMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SOPMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (SOP).
func (m *SOPMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SOPMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.title != nil {
		fields = append(fields, sop.FieldTitle)
	}
	if m.content != nil {
		fields = append(fields, sop.FieldContent)
	}
	if m.version != nil {
		fields = append(fields, sop.FieldVersion)
	}
	if m.created_at != nil {
		fields = append(fields, sop.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, sop.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SOPMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case sop.FieldTitle:
		return m.Title()
	case sop.FieldContent:
		return m.Content()
	case sop.FieldVersion:
		return m.Version()
	case sop.FieldCreatedAt:
		return m.CreatedAt()
	case sop.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SOPMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case sop.FieldTitle:
		return m.OldTitle(ctx)
	case sop.FieldContent:
		return m.OldContent(ctx)
	case sop.FieldVersion:
		return m.OldVersion(ctx)
	case sop.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case sop.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown SOP field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SOPMutation) SetField(name string, value ent.Value) error {
	switch name {
	case sop.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case sop.FieldContent:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContent(v)
		return nil
	case sop.FieldVersion:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVersion(v)
		return nil
	case sop.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case sop.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown SOP field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SOPMutation) AddedFields() []string {
	var fields []string
	if m.addversion != nil {
		fields = append(fields, sop.FieldVersion)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SOPMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case sop.FieldVersion:
		return m.AddedVersion()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SOPMutation) AddField(name string, value ent.Value) error {
	switch name {
	case sop.FieldVersion:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddVersion(v)
		return nil
	}
	return fmt.Errorf("unknown SOP numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SOPMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(sop.FieldContent) {
		fields = append(fields, sop.FieldContent)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SOPMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SOPMutation) ClearField(name string) error {
	switch name {
	case sop.FieldContent:
		m.ClearContent()
		return nil
	}
	return fmt.Errorf("unknown SOP nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SOPMutation) ResetField(name string) error {
	switch name {
	case sop.FieldTitle:
		m.ResetTitle()
		return nil
	case sop.FieldContent:
		m.ResetContent()
		return nil
	case sop.FieldVersion:
		m.ResetVersion()
		return nil
	case sop.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case sop.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown SOP field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SOPMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.tenant != nil {
		edges = append(edges, sop.EdgeTenant)
	}
	if m.asset != nil {
		edges = append(edges, sop.EdgeAsset)
	}
	if m.author != nil {
		edges = append(edges, sop.EdgeAuthor)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SOPMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case sop.EdgeTenant:
		if id := m.tenant; id != nil {
			return []ent.Value{*id}
		}
	case sop.EdgeAsset:
		if id := m.asset; id != nil {
			return []ent.Value{*id}
		}
	case sop.EdgeAuthor:
		if id := m.author; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SOPMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SOPMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SOPMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedtenant {
		edges = append(edges, sop.EdgeTenant)
	}
	if m.clearedasset {
		edges = append(edges, sop.EdgeAsset)
	}
	if m.clearedauthor {
		edges = append(edges, sop.EdgeAuthor)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SOPMutation) EdgeCleared(name string) bool {
	switch name {
	case sop.EdgeTenant:
		return m.clearedtenant
	case sop.EdgeAsset:
		return m.clearedasset
	case sop.EdgeAuthor:
		return m.clearedauthor
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SOPMutation) ClearEdge(name string) error {
	switch name {
	case sop.EdgeTenant:
		m.ClearTenant()
		return nil
	case sop.EdgeAsset:
		m.ClearAsset()
		return nil
	case sop.EdgeAuthor:
		m.ClearAuthor()
		return nil
	}
	return fmt.Errorf("unknown SOP unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SOPMutation) ResetEdge(name string) error {
	switch name {
	case sop.EdgeTenant:
		m.ResetTenant()
		return nil
	case sop.EdgeAsset:
		m.ResetAsset()
		return nil
	case sop.EdgeAuthor:
		m.ResetAuthor()
		return nil
	}
	return fmt.Errorf("unknown SOP edge %s", name)
}

// SaaSAppMutation represents an operation that mutates the SaaSApp nodes in the graph.
type SaaSAppMutation struct {
	config
	op                Op
	typ               string
	id                *int
	name              *string
	provider          *string
	category          *string
	url               *string
	is_managed        *bool
	_config           *map[string]interface{}
	created_at        *time.Time
	updated_at        *time.Time
	clearedFields     map[string]struct{}
	identities        map[int]struct{}
	removedidentities map[int]struct{}
	clearedidentities bool
	filters           map[int]struct{}
	removedfilters    map[int]struct{}
	clearedfilters    bool
	tenant            *int
	clearedtenant     bool
	done              bool
	oldValue          func(context.Context) (*SaaSApp, error)
	predicates        []predicate.SaaSApp
}

var _ ent.Mutation = (*SaaSAppMutation)(nil)

// saasappOption allows management of the mutation configuration using functional options.
type saasappOption func(*SaaSAppMutation)

// newSaaSAppMutation creates new mutation for the SaaSApp entity.
func newSaaSAppMutation(c config, op Op, opts ...saasappOption) *SaaSAppMutation {
	m := &SaaSAppMutation{
		config:        c,
		op:            op,
		typ:           TypeSaaSApp,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSaaSAppID sets the ID field of the mutation.
func withSaaSAppID(id int) saasappOption {
	return func(m *SaaSAppMutation) {
		var (
			err   error
			once  sync.Once
			value *SaaSApp
		)
		m.oldValue = func(ctx context.Context) (*SaaSApp, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().SaaSApp.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSaaSApp sets the old SaaSApp of the mutation.
func withSaaSApp(node *SaaSApp) saasappOption {
	return func(m *SaaSAppMutation) {
		m.oldValue = func(context.Context) (*SaaSApp, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SaaSAppMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SaaSAppMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SaaSAppMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SaaSAppMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().SaaSApp.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *SaaSAppMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *SaaSAppMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the SaaSApp entity.
// If the SaaSApp object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SaaSAppMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *SaaSAppMutation) ResetName() {
	m.name = nil
}

// SetProvider sets the "provider" field.
func (m *SaaSAppMutation) SetProvider(s string) {
	m.provider = &s
}

// Provider returns the value of the "provider" field in the mutation.
func (m *SaaSAppMutation) Provider() (r string, exists bool) {
	v := m.provider
	if v == nil {
		return
	}
	return *v, true
}

// OldProvider returns the old "provider" field's value of the SaaSApp entity.
// If the SaaSApp object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SaaSAppMutation) OldProvider(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProvider is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProvider requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProvider: %w", err)
	}
	return oldValue.Provider, nil
}

// ResetProvider resets all changes to the "provider" field.
func (m *SaaSAppMutation) ResetProvider() {
	m.provider = nil
}

// SetCategory sets the "category" field.
func (m *SaaSAppMutation) SetCategory(s string) {
	m.category = &s
}

// Category returns the value of the "category" field in the mutation.
func (m *SaaSAppMutation) Category() (r string, exists bool) {
	v := m.category
	if v == nil {
		return
	}
	return *v, true
}

// OldCategory returns the old "category" field's value of the SaaSApp entity.
// If the SaaSApp object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SaaSAppMutation) OldCategory(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCategory is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCategory requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCategory: %w", err)
	}
	return oldValue.Category, nil
}

// ClearCategory clears the value of the "category" field.
func (m *SaaSAppMutation) ClearCategory() {
	m.category = nil
	m.clearedFields[saasapp.FieldCategory] = struct{}{}
}

// CategoryCleared returns if the "category" field was cleared in this mutation.
func (m *SaaSAppMutation) CategoryCleared() bool {
	_, ok := m.clearedFields[saasapp.FieldCategory]
	return ok
}

// ResetCategory resets all changes to the "category" field.
func (m *SaaSAppMutation) ResetCategory() {
	m.category = nil
	delete(m.clearedFields, saasapp.FieldCategory)
}

// SetURL sets the "url" field.
func (m *SaaSAppMutation) SetURL(s string) {
	m.url = &s
}

// URL returns the value of the "url" field in the mutation.
func (m *SaaSAppMutation) URL() (r string, exists bool) {
	v := m.url
	if v == nil {
		return
	}
	return *v, true
}

// OldURL returns the old "url" field's value of the SaaSApp entity.
// If the SaaSApp object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SaaSAppMutation) OldURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldURL: %w", err)
	}
	return oldValue.URL, nil
}

// ClearURL clears the value of the "url" field.
func (m *SaaSAppMutation) ClearURL() {
	m.url = nil
	m.clearedFields[saasapp.FieldURL] = struct{}{}
}

// URLCleared returns if the "url" field was cleared in this mutation.
func (m *SaaSAppMutation) URLCleared() bool {
	_, ok := m.clearedFields[saasapp.FieldURL]
	return ok
}

// ResetURL resets all changes to the "url" field.
func (m *SaaSAppMutation) ResetURL() {
	m.url = nil
	delete(m.clearedFields, saasapp.FieldURL)
}

// SetIsManaged sets the "is_managed" field.
func (m *SaaSAppMutation) SetIsManaged(b bool) {
	m.is_managed = &b
}

// IsManaged returns the value of the "is_managed" field in the mutation.
func (m *SaaSAppMutation) IsManaged() (r bool, exists bool) {
	v := m.is_managed
	if v == nil {
		return
	}
	return *v, true
}

// OldIsManaged returns the old "is_managed" field's value of the SaaSApp entity.
// If the SaaSApp object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SaaSAppMutation) OldIsManaged(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsManaged is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsManaged requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsManaged: %w", err)
	}
	return oldValue.IsManaged, nil
}

// ResetIsManaged resets all changes to the "is_managed" field.
func (m *SaaSAppMutation) ResetIsManaged() {
	m.is_managed = nil
}

// SetConfig sets the "config" field.
func (m *SaaSAppMutation) SetConfig(value map[string]interface{}) {
	m._config = &value
}

// Config returns the value of the "config" field in the mutation.
func (m *SaaSAppMutation) Config() (r map[string]interface{}, exists bool) {
	v := m._config
	if v == nil {
		return
	}
	return *v, true
}

// OldConfig returns the old "config" field's value of the SaaSApp entity.
// If the SaaSApp object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SaaSAppMutation) OldConfig(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldConfig is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldConfig requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldConfig: %w", err)
	}
	return oldValue.Config, nil
}

// ResetConfig resets all changes to the "config" field.
func (m *SaaSAppMutation) ResetConfig() {
	m._config = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *SaaSAppMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *SaaSAppMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the SaaSApp entity.
// If the SaaSApp object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SaaSAppMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *SaaSAppMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *SaaSAppMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *SaaSAppMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the SaaSApp entity.
// If the SaaSApp object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SaaSAppMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *SaaSAppMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// AddIdentityIDs adds the "identities" edge to the SaaSIdentity entity by ids.
func (m *SaaSAppMutation) AddIdentityIDs(ids ...int) {
	if m.identities == nil {
		m.identities = make(map[int]struct{})
	}
	for i := range ids {
		m.identities[ids[i]] = struct{}{}
	}
}

// ClearIdentities clears the "identities" edge to the SaaSIdentity entity.
func (m *SaaSAppMutation) ClearIdentities() {
	m.clearedidentities = true
}

// IdentitiesCleared reports if the "identities" edge to the SaaSIdentity entity was cleared.
func (m *SaaSAppMutation) IdentitiesCleared() bool {
	return m.clearedidentities
}

// RemoveIdentityIDs removes the "identities" edge to the SaaSIdentity entity by IDs.
func (m *SaaSAppMutation) RemoveIdentityIDs(ids ...int) {
	if m.removedidentities == nil {
		m.removedidentities = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.identities, ids[i])
		m.removedidentities[ids[i]] = struct{}{}
	}
}

// RemovedIdentities returns the removed IDs of the "identities" edge to the SaaSIdentity entity.
func (m *SaaSAppMutation) RemovedIdentitiesIDs() (ids []int) {
	for id := range m.removedidentities {
		ids = append(ids, id)
	}
	return
}

// IdentitiesIDs returns the "identities" edge IDs in the mutation.
func (m *SaaSAppMutation) IdentitiesIDs() (ids []int) {
	for id := range m.identities {
		ids = append(ids, id)
	}
	return
}

// ResetIdentities resets all changes to the "identities" edge.
func (m *SaaSAppMutation) ResetIdentities() {
	m.identities = nil
	m.clearedidentities = false
	m.removedidentities = nil
}

// AddFilterIDs adds the "filters" edge to the SaaSFilter entity by ids.
func (m *SaaSAppMutation) AddFilterIDs(ids ...int) {
	if m.filters == nil {
		m.filters = make(map[int]struct{})
	}
	for i := range ids {
		m.filters[ids[i]] = struct{}{}
	}
}

// ClearFilters clears the "filters" edge to the SaaSFilter entity.
func (m *SaaSAppMutation) ClearFilters() {
	m.clearedfilters = true
}

// FiltersCleared reports if the "filters" edge to the SaaSFilter entity was cleared.
func (m *SaaSAppMutation) FiltersCleared() bool {
	return m.clearedfilters
}

// RemoveFilterIDs removes the "filters" edge to the SaaSFilter entity by IDs.
func (m *SaaSAppMutation) RemoveFilterIDs(ids ...int) {
	if m.removedfilters == nil {
		m.removedfilters = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.filters, ids[i])
		m.removedfilters[ids[i]] = struct{}{}
	}
}

// RemovedFilters returns the removed IDs of the "filters" edge to the SaaSFilter entity.
func (m *SaaSAppMutation) RemovedFiltersIDs() (ids []int) {
	for id := range m.removedfilters {
		ids = append(ids, id)
	}
	return
}

// FiltersIDs returns the "filters" edge IDs in the mutation.
func (m *SaaSAppMutation) FiltersIDs() (ids []int) {
	for id := range m.filters {
		ids = append(ids, id)
	}
	return
}

// ResetFilters resets all changes to the "filters" edge.
func (m *SaaSAppMutation) ResetFilters() {
	m.filters = nil
	m.clearedfilters = false
	m.removedfilters = nil
}

// SetTenantID sets the "tenant" edge to the Tenant entity by id.
func (m *SaaSAppMutation) SetTenantID(id int) {
	m.tenant = &id
}

// ClearTenant clears the "tenant" edge to the Tenant entity.
func (m *SaaSAppMutation) ClearTenant() {
	m.clearedtenant = true
}

// TenantCleared reports if the "tenant" edge to the Tenant entity was cleared.
func (m *SaaSAppMutation) TenantCleared() bool {
	return m.clearedtenant
}

// TenantID returns the "tenant" edge ID in the mutation.
func (m *SaaSAppMutation) TenantID() (id int, exists bool) {
	if m.tenant != nil {
		return *m.tenant, true
	}
	return
}

// TenantIDs returns the "tenant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TenantID instead. It exists only for internal usage by the builders.
func (m *SaaSAppMutation) TenantIDs() (ids []int) {
	if id := m.tenant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTenant resets all changes to the "tenant" edge.
func (m *SaaSAppMutation) ResetTenant() {
	m.tenant = nil
	m.clearedtenant = false
}

// Where appends a list predicates to the SaaSAppMutation builder.
func (m *SaaSAppMutation) Where(ps ...predicate.SaaSApp) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SaaSAppMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SaaSAppMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.SaaSApp, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SaaSAppMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SaaSAppMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (SaaSApp).
func (m *SaaSAppMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SaaSAppMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.name != nil {
		fields = append(fields, saasapp.FieldName)
	}
	if m.provider != nil {
		fields = append(fields, saasapp.FieldProvider)
	}
	if m.category != nil {
		fields = append(fields, saasapp.FieldCategory)
	}
	if m.url != nil {
		fields = append(fields, saasapp.FieldURL)
	}
	if m.is_managed != nil {
		fields = append(fields, saasapp.FieldIsManaged)
	}
	if m._config != nil {
		fields = append(fields, saasapp.FieldConfig)
	}
	if m.created_at != nil {
		fields = append(fields, saasapp.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, saasapp.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SaaSAppMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case saasapp.FieldName:
		return m.Name()
	case saasapp.FieldProvider:
		return m.Provider()
	case saasapp.FieldCategory:
		return m.Category()
	case saasapp.FieldURL:
		return m.URL()
	case saasapp.FieldIsManaged:
		return m.IsManaged()
	case saasapp.FieldConfig:
		return m.Config()
	case saasapp.FieldCreatedAt:
		return m.CreatedAt()
	case saasapp.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SaaSAppMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case saasapp.FieldName:
		return m.OldName(ctx)
	case saasapp.FieldProvider:
		return m.OldProvider(ctx)
	case saasapp.FieldCategory:
		return m.OldCategory(ctx)
	case saasapp.FieldURL:
		return m.OldURL(ctx)
	case saasapp.FieldIsManaged:
		return m.OldIsManaged(ctx)
	case saasapp.FieldConfig:
		return m.OldConfig(ctx)
	case saasapp.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case saasapp.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown SaaSApp field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SaaSAppMutation) SetField(name string, value ent.Value) error {
	switch name {
	case saasapp.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case saasapp.FieldProvider:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProvider(v)
		return nil
	case saasapp.FieldCategory:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCategory(v)
		return nil
	case saasapp.FieldURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetURL(v)
		return nil
	case saasapp.FieldIsManaged:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsManaged(v)
		return nil
	case saasapp.FieldConfig:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetConfig(v)
		return nil
	case saasapp.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case saasapp.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown SaaSApp field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SaaSAppMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SaaSAppMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SaaSAppMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown SaaSApp numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SaaSAppMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(saasapp.FieldCategory) {
		fields = append(fields, saasapp.FieldCategory)
	}
	if m.FieldCleared(saasapp.FieldURL) {
		fields = append(fields, saasapp.FieldURL)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SaaSAppMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SaaSAppMutation) ClearField(name string) error {
	switch name {
	case saasapp.FieldCategory:
		m.ClearCategory()
		return nil
	case saasapp.FieldURL:
		m.ClearURL()
		return nil
	}
	return fmt.Errorf("unknown SaaSApp nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SaaSAppMutation) ResetField(name string) error {
	switch name {
	case saasapp.FieldName:
		m.ResetName()
		return nil
	case saasapp.FieldProvider:
		m.ResetProvider()
		return nil
	case saasapp.FieldCategory:
		m.ResetCategory()
		return nil
	case saasapp.FieldURL:
		m.ResetURL()
		return nil
	case saasapp.FieldIsManaged:
		m.ResetIsManaged()
		return nil
	case saasapp.FieldConfig:
		m.ResetConfig()
		return nil
	case saasapp.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case saasapp.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown SaaSApp field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SaaSAppMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.identities != nil {
		edges = append(edges, saasapp.EdgeIdentities)
	}
	if m.filters != nil {
		edges = append(edges, saasapp.EdgeFilters)
	}
	if m.tenant != nil {
		edges = append(edges, saasapp.EdgeTenant)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SaaSAppMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case saasapp.EdgeIdentities:
		ids := make([]ent.Value, 0, len(m.identities))
		for id := range m.identities {
			ids = append(ids, id)
		}
		return ids
	case saasapp.EdgeFilters:
		ids := make([]ent.Value, 0, len(m.filters))
		for id := range m.filters {
			ids = append(ids, id)
		}
		return ids
	case saasapp.EdgeTenant:
		if id := m.tenant; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SaaSAppMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedidentities != nil {
		edges = append(edges, saasapp.EdgeIdentities)
	}
	if m.removedfilters != nil {
		edges = append(edges, saasapp.EdgeFilters)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SaaSAppMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case saasapp.EdgeIdentities:
		ids := make([]ent.Value, 0, len(m.removedidentities))
		for id := range m.removedidentities {
			ids = append(ids, id)
		}
		return ids
	case saasapp.EdgeFilters:
		ids := make([]ent.Value, 0, len(m.removedfilters))
		for id := range m.removedfilters {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SaaSAppMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedidentities {
		edges = append(edges, saasapp.EdgeIdentities)
	}
	if m.clearedfilters {
		edges = append(edges, saasapp.EdgeFilters)
	}
	if m.clearedtenant {
		edges = append(edges, saasapp.EdgeTenant)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SaaSAppMutation) EdgeCleared(name string) bool {
	switch name {
	case saasapp.EdgeIdentities:
		return m.clearedidentities
	case saasapp.EdgeFilters:
		return m.clearedfilters
	case saasapp.EdgeTenant:
		return m.clearedtenant
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SaaSAppMutation) ClearEdge(name string) error {
	switch name {
	case saasapp.EdgeTenant:
		m.ClearTenant()
		return nil
	}
	return fmt.Errorf("unknown SaaSApp unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SaaSAppMutation) ResetEdge(name string) error {
	switch name {
	case saasapp.EdgeIdentities:
		m.ResetIdentities()
		return nil
	case saasapp.EdgeFilters:
		m.ResetFilters()
		return nil
	case saasapp.EdgeTenant:
		m.ResetTenant()
		return nil
	}
	return fmt.Errorf("unknown SaaSApp edge %s", name)
}

// SaaSFilterMutation represents an operation that mutates the SaaSFilter nodes in the graph.
type SaaSFilterMutation struct {
	config
	op             Op
	typ            string
	id             *int
	domain_pattern *string
	action         *saasfilter.Action
	reason         *string
	is_sni_based   *bool
	created_at     *time.Time
	updated_at     *time.Time
	clearedFields  map[string]struct{}
	app            *int
	clearedapp     bool
	tenant         *int
	clearedtenant  bool
	done           bool
	oldValue       func(context.Context) (*SaaSFilter, error)
	predicates     []predicate.SaaSFilter
}

var _ ent.Mutation = (*SaaSFilterMutation)(nil)

// saasfilterOption allows management of the mutation configuration using functional options.
type saasfilterOption func(*SaaSFilterMutation)

// newSaaSFilterMutation creates new mutation for the SaaSFilter entity.
func newSaaSFilterMutation(c config, op Op, opts ...saasfilterOption) *SaaSFilterMutation {
	m := &SaaSFilterMutation{
		config:        c,
		op:            op,
		typ:           TypeSaaSFilter,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSaaSFilterID sets the ID field of the mutation.
func withSaaSFilterID(id int) saasfilterOption {
	return func(m *SaaSFilterMutation) {
		var (
			err   error
			once  sync.Once
			value *SaaSFilter
		)
		m.oldValue = func(ctx context.Context) (*SaaSFilter, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().SaaSFilter.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSaaSFilter sets the old SaaSFilter of the mutation.
func withSaaSFilter(node *SaaSFilter) saasfilterOption {
	return func(m *SaaSFilterMutation) {
		m.oldValue = func(context.Context) (*SaaSFilter, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SaaSFilterMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SaaSFilterMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SaaSFilterMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SaaSFilterMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().SaaSFilter.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetDomainPattern sets the "domain_pattern" field.
func (m *SaaSFilterMutation) SetDomainPattern(s string) {
	m.domain_pattern = &s
}

// DomainPattern returns the value of the "domain_pattern" field in the mutation.
func (m *SaaSFilterMutation) DomainPattern() (r string, exists bool) {
	v := m.domain_pattern
	if v == nil {
		return
	}
	return *v, true
}

// OldDomainPattern returns the old "domain_pattern" field's value of the SaaSFilter entity.
// If the SaaSFilter object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SaaSFilterMutation) OldDomainPattern(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDomainPattern is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDomainPattern requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDomainPattern: %w", err)
	}
	return oldValue.DomainPattern, nil
}

// ResetDomainPattern resets all changes to the "domain_pattern" field.
func (m *SaaSFilterMutation) ResetDomainPattern() {
	m.domain_pattern = nil
}

// SetAction sets the "action" field.
func (m *SaaSFilterMutation) SetAction(s saasfilter.Action) {
	m.action = &s
}

// Action returns the value of the "action" field in the mutation.
func (m *SaaSFilterMutation) Action() (r saasfilter.Action, exists bool) {
	v := m.action
	if v == nil {
		return
	}
	return *v, true
}

// OldAction returns the old "action" field's value of the SaaSFilter entity.
// If the SaaSFilter object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SaaSFilterMutation) OldAction(ctx context.Context) (v saasfilter.Action, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAction is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAction requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAction: %w", err)
	}
	return oldValue.Action, nil
}

// ResetAction resets all changes to the "action" field.
func (m *SaaSFilterMutation) ResetAction() {
	m.action = nil
}

// SetReason sets the "reason" field.
func (m *SaaSFilterMutation) SetReason(s string) {
	m.reason = &s
}

// Reason returns the value of the "reason" field in the mutation.
func (m *SaaSFilterMutation) Reason() (r string, exists bool) {
	v := m.reason
	if v == nil {
		return
	}
	return *v, true
}

// OldReason returns the old "reason" field's value of the SaaSFilter entity.
// If the SaaSFilter object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SaaSFilterMutation) OldReason(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReason is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReason requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReason: %w", err)
	}
	return oldValue.Reason, nil
}

// ClearReason clears the value of the "reason" field.
func (m *SaaSFilterMutation) ClearReason() {
	m.reason = nil
	m.clearedFields[saasfilter.FieldReason] = struct{}{}
}

// ReasonCleared returns if the "reason" field was cleared in this mutation.
func (m *SaaSFilterMutation) ReasonCleared() bool {
	_, ok := m.clearedFields[saasfilter.FieldReason]
	return ok
}

// ResetReason resets all changes to the "reason" field.
func (m *SaaSFilterMutation) ResetReason() {
	m.reason = nil
	delete(m.clearedFields, saasfilter.FieldReason)
}

// SetIsSniBased sets the "is_sni_based" field.
func (m *SaaSFilterMutation) SetIsSniBased(b bool) {
	m.is_sni_based = &b
}

// IsSniBased returns the value of the "is_sni_based" field in the mutation.
func (m *SaaSFilterMutation) IsSniBased() (r bool, exists bool) {
	v := m.is_sni_based
	if v == nil {
		return
	}
	return *v, true
}

// OldIsSniBased returns the old "is_sni_based" field's value of the SaaSFilter entity.
// If the SaaSFilter object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SaaSFilterMutation) OldIsSniBased(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsSniBased is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsSniBased requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsSniBased: %w", err)
	}
	return oldValue.IsSniBased, nil
}

// ResetIsSniBased resets all changes to the "is_sni_based" field.
func (m *SaaSFilterMutation) ResetIsSniBased() {
	m.is_sni_based = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *SaaSFilterMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *SaaSFilterMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the SaaSFilter entity.
// If the SaaSFilter object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SaaSFilterMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *SaaSFilterMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *SaaSFilterMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *SaaSFilterMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the SaaSFilter entity.
// If the SaaSFilter object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SaaSFilterMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *SaaSFilterMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetAppID sets the "app" edge to the SaaSApp entity by id.
func (m *SaaSFilterMutation) SetAppID(id int) {
	m.app = &id
}

// ClearApp clears the "app" edge to the SaaSApp entity.
func (m *SaaSFilterMutation) ClearApp() {
	m.clearedapp = true
}

// AppCleared reports if the "app" edge to the SaaSApp entity was cleared.
func (m *SaaSFilterMutation) AppCleared() bool {
	return m.clearedapp
}

// AppID returns the "app" edge ID in the mutation.
func (m *SaaSFilterMutation) AppID() (id int, exists bool) {
	if m.app != nil {
		return *m.app, true
	}
	return
}

// AppIDs returns the "app" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AppID instead. It exists only for internal usage by the builders.
func (m *SaaSFilterMutation) AppIDs() (ids []int) {
	if id := m.app; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetApp resets all changes to the "app" edge.
func (m *SaaSFilterMutation) ResetApp() {
	m.app = nil
	m.clearedapp = false
}

// SetTenantID sets the "tenant" edge to the Tenant entity by id.
func (m *SaaSFilterMutation) SetTenantID(id int) {
	m.tenant = &id
}

// ClearTenant clears the "tenant" edge to the Tenant entity.
func (m *SaaSFilterMutation) ClearTenant() {
	m.clearedtenant = true
}

// TenantCleared reports if the "tenant" edge to the Tenant entity was cleared.
func (m *SaaSFilterMutation) TenantCleared() bool {
	return m.clearedtenant
}

// TenantID returns the "tenant" edge ID in the mutation.
func (m *SaaSFilterMutation) TenantID() (id int, exists bool) {
	if m.tenant != nil {
		return *m.tenant, true
	}
	return
}

// TenantIDs returns the "tenant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TenantID instead. It exists only for internal usage by the builders.
func (m *SaaSFilterMutation) TenantIDs() (ids []int) {
	if id := m.tenant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTenant resets all changes to the "tenant" edge.
func (m *SaaSFilterMutation) ResetTenant() {
	m.tenant = nil
	m.clearedtenant = false
}

// Where appends a list predicates to the SaaSFilterMutation builder.
func (m *SaaSFilterMutation) Where(ps ...predicate.SaaSFilter) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SaaSFilterMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SaaSFilterMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.SaaSFilter, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SaaSFilterMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SaaSFilterMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (SaaSFilter).
func (m *SaaSFilterMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SaaSFilterMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.domain_pattern != nil {
		fields = append(fields, saasfilter.FieldDomainPattern)
	}
	if m.action != nil {
		fields = append(fields, saasfilter.FieldAction)
	}
	if m.reason != nil {
		fields = append(fields, saasfilter.FieldReason)
	}
	if m.is_sni_based != nil {
		fields = append(fields, saasfilter.FieldIsSniBased)
	}
	if m.created_at != nil {
		fields = append(fields, saasfilter.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, saasfilter.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SaaSFilterMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case saasfilter.FieldDomainPattern:
		return m.DomainPattern()
	case saasfilter.FieldAction:
		return m.Action()
	case saasfilter.FieldReason:
		return m.Reason()
	case saasfilter.FieldIsSniBased:
		return m.IsSniBased()
	case saasfilter.FieldCreatedAt:
		return m.CreatedAt()
	case saasfilter.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SaaSFilterMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case saasfilter.FieldDomainPattern:
		return m.OldDomainPattern(ctx)
	case saasfilter.FieldAction:
		return m.OldAction(ctx)
	case saasfilter.FieldReason:
		return m.OldReason(ctx)
	case saasfilter.FieldIsSniBased:
		return m.OldIsSniBased(ctx)
	case saasfilter.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case saasfilter.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown SaaSFilter field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SaaSFilterMutation) SetField(name string, value ent.Value) error {
	switch name {
	case saasfilter.FieldDomainPattern:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDomainPattern(v)
		return nil
	case saasfilter.FieldAction:
		v, ok := value.(saasfilter.Action)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAction(v)
		return nil
	case saasfilter.FieldReason:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReason(v)
		return nil
	case saasfilter.FieldIsSniBased:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsSniBased(v)
		return nil
	case saasfilter.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case saasfilter.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown SaaSFilter field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SaaSFilterMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SaaSFilterMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SaaSFilterMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown SaaSFilter numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SaaSFilterMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(saasfilter.FieldReason) {
		fields = append(fields, saasfilter.FieldReason)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SaaSFilterMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SaaSFilterMutation) ClearField(name string) error {
	switch name {
	case saasfilter.FieldReason:
		m.ClearReason()
		return nil
	}
	return fmt.Errorf("unknown SaaSFilter nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SaaSFilterMutation) ResetField(name string) error {
	switch name {
	case saasfilter.FieldDomainPattern:
		m.ResetDomainPattern()
		return nil
	case saasfilter.FieldAction:
		m.ResetAction()
		return nil
	case saasfilter.FieldReason:
		m.ResetReason()
		return nil
	case saasfilter.FieldIsSniBased:
		m.ResetIsSniBased()
		return nil
	case saasfilter.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case saasfilter.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown SaaSFilter field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SaaSFilterMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.app != nil {
		edges = append(edges, saasfilter.EdgeApp)
	}
	if m.tenant != nil {
		edges = append(edges, saasfilter.EdgeTenant)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SaaSFilterMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case saasfilter.EdgeApp:
		if id := m.app; id != nil {
			return []ent.Value{*id}
		}
	case saasfilter.EdgeTenant:
		if id := m.tenant; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SaaSFilterMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SaaSFilterMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SaaSFilterMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedapp {
		edges = append(edges, saasfilter.EdgeApp)
	}
	if m.clearedtenant {
		edges = append(edges, saasfilter.EdgeTenant)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SaaSFilterMutation) EdgeCleared(name string) bool {
	switch name {
	case saasfilter.EdgeApp:
		return m.clearedapp
	case saasfilter.EdgeTenant:
		return m.clearedtenant
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SaaSFilterMutation) ClearEdge(name string) error {
	switch name {
	case saasfilter.EdgeApp:
		m.ClearApp()
		return nil
	case saasfilter.EdgeTenant:
		m.ClearTenant()
		return nil
	}
	return fmt.Errorf("unknown SaaSFilter unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SaaSFilterMutation) ResetEdge(name string) error {
	switch name {
	case saasfilter.EdgeApp:
		m.ResetApp()
		return nil
	case saasfilter.EdgeTenant:
		m.ResetTenant()
		return nil
	}
	return fmt.Errorf("unknown SaaSFilter edge %s", name)
}

// SaaSIdentityMutation represents an operation that mutates the SaaSIdentity nodes in the graph.
type SaaSIdentityMutation struct {
	config
	op            Op
	typ           string
	id            *int
	external_id   *string
	email         *string
	display_name  *string
	current_plan  *string
	metadata      *map[string]interface{}
	mfa_enabled   *bool
	last_login    *time.Time
	created_at    *time.Time
	updated_at    *time.Time
	clearedFields map[string]struct{}
	user          *int
	cleareduser   bool
	app           *int
	clearedapp    bool
	usages        map[int]struct{}
	removedusages map[int]struct{}
	clearedusages bool
	done          bool
	oldValue      func(context.Context) (*SaaSIdentity, error)
	predicates    []predicate.SaaSIdentity
}

var _ ent.Mutation = (*SaaSIdentityMutation)(nil)

// saasidentityOption allows management of the mutation configuration using functional options.
type saasidentityOption func(*SaaSIdentityMutation)

// newSaaSIdentityMutation creates new mutation for the SaaSIdentity entity.
func newSaaSIdentityMutation(c config, op Op, opts ...saasidentityOption) *SaaSIdentityMutation {
	m := &SaaSIdentityMutation{
		config:        c,
		op:            op,
		typ:           TypeSaaSIdentity,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSaaSIdentityID sets the ID field of the mutation.
func withSaaSIdentityID(id int) saasidentityOption {
	return func(m *SaaSIdentityMutation) {
		var (
			err   error
			once  sync.Once
			value *SaaSIdentity
		)
		m.oldValue = func(ctx context.Context) (*SaaSIdentity, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().SaaSIdentity.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSaaSIdentity sets the old SaaSIdentity of the mutation.
func withSaaSIdentity(node *SaaSIdentity) saasidentityOption {
	return func(m *SaaSIdentityMutation) {
		m.oldValue = func(context.Context) (*SaaSIdentity, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SaaSIdentityMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SaaSIdentityMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SaaSIdentityMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SaaSIdentityMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().SaaSIdentity.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetExternalID sets the "external_id" field.
func (m *SaaSIdentityMutation) SetExternalID(s string) {
	m.external_id = &s
}

// ExternalID returns the value of the "external_id" field in the mutation.
func (m *SaaSIdentityMutation) ExternalID() (r string, exists bool) {
	v := m.external_id
	if v == nil {
		return
	}
	return *v, true
}

// OldExternalID returns the old "external_id" field's value of the SaaSIdentity entity.
// If the SaaSIdentity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SaaSIdentityMutation) OldExternalID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExternalID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExternalID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExternalID: %w", err)
	}
	return oldValue.ExternalID, nil
}

// ResetExternalID resets all changes to the "external_id" field.
func (m *SaaSIdentityMutation) ResetExternalID() {
	m.external_id = nil
}

// SetEmail sets the "email" field.
func (m *SaaSIdentityMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *SaaSIdentityMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the SaaSIdentity entity.
// If the SaaSIdentity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SaaSIdentityMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail resets all changes to the "email" field.
func (m *SaaSIdentityMutation) ResetEmail() {
	m.email = nil
}

// SetDisplayName sets the "display_name" field.
func (m *SaaSIdentityMutation) SetDisplayName(s string) {
	m.display_name = &s
}

// DisplayName returns the value of the "display_name" field in the mutation.
func (m *SaaSIdentityMutation) DisplayName() (r string, exists bool) {
	v := m.display_name
	if v == nil {
		return
	}
	return *v, true
}

// OldDisplayName returns the old "display_name" field's value of the SaaSIdentity entity.
// If the SaaSIdentity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SaaSIdentityMutation) OldDisplayName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisplayName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisplayName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisplayName: %w", err)
	}
	return oldValue.DisplayName, nil
}

// ClearDisplayName clears the value of the "display_name" field.
func (m *SaaSIdentityMutation) ClearDisplayName() {
	m.display_name = nil
	m.clearedFields[saasidentity.FieldDisplayName] = struct{}{}
}

// DisplayNameCleared returns if the "display_name" field was cleared in this mutation.
func (m *SaaSIdentityMutation) DisplayNameCleared() bool {
	_, ok := m.clearedFields[saasidentity.FieldDisplayName]
	return ok
}

// ResetDisplayName resets all changes to the "display_name" field.
func (m *SaaSIdentityMutation) ResetDisplayName() {
	m.display_name = nil
	delete(m.clearedFields, saasidentity.FieldDisplayName)
}

// SetCurrentPlan sets the "current_plan" field.
func (m *SaaSIdentityMutation) SetCurrentPlan(s string) {
	m.current_plan = &s
}

// CurrentPlan returns the value of the "current_plan" field in the mutation.
func (m *SaaSIdentityMutation) CurrentPlan() (r string, exists bool) {
	v := m.current_plan
	if v == nil {
		return
	}
	return *v, true
}

// OldCurrentPlan returns the old "current_plan" field's value of the SaaSIdentity entity.
// If the SaaSIdentity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SaaSIdentityMutation) OldCurrentPlan(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCurrentPlan is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCurrentPlan requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCurrentPlan: %w", err)
	}
	return oldValue.CurrentPlan, nil
}

// ClearCurrentPlan clears the value of the "current_plan" field.
func (m *SaaSIdentityMutation) ClearCurrentPlan() {
	m.current_plan = nil
	m.clearedFields[saasidentity.FieldCurrentPlan] = struct{}{}
}

// CurrentPlanCleared returns if the "current_plan" field was cleared in this mutation.
func (m *SaaSIdentityMutation) CurrentPlanCleared() bool {
	_, ok := m.clearedFields[saasidentity.FieldCurrentPlan]
	return ok
}

// ResetCurrentPlan resets all changes to the "current_plan" field.
func (m *SaaSIdentityMutation) ResetCurrentPlan() {
	m.current_plan = nil
	delete(m.clearedFields, saasidentity.FieldCurrentPlan)
}

// SetMetadata sets the "metadata" field.
func (m *SaaSIdentityMutation) SetMetadata(value map[string]interface{}) {
	m.metadata = &value
}

// Metadata returns the value of the "metadata" field in the mutation.
func (m *SaaSIdentityMutation) Metadata() (r map[string]interface{}, exists bool) {
	v := m.metadata
	if v == nil {
		return
	}
	return *v, true
}

// OldMetadata returns the old "metadata" field's value of the SaaSIdentity entity.
// If the SaaSIdentity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SaaSIdentityMutation) OldMetadata(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMetadata is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMetadata requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetadata: %w", err)
	}
	return oldValue.Metadata, nil
}

// ResetMetadata resets all changes to the "metadata" field.
func (m *SaaSIdentityMutation) ResetMetadata() {
	m.metadata = nil
}

// SetMfaEnabled sets the "mfa_enabled" field.
func (m *SaaSIdentityMutation) SetMfaEnabled(b bool) {
	m.mfa_enabled = &b
}

// MfaEnabled returns the value of the "mfa_enabled" field in the mutation.
func (m *SaaSIdentityMutation) MfaEnabled() (r bool, exists bool) {
	v := m.mfa_enabled
	if v == nil {
		return
	}
	return *v, true
}

// OldMfaEnabled returns the old "mfa_enabled" field's value of the SaaSIdentity entity.
// If the SaaSIdentity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SaaSIdentityMutation) OldMfaEnabled(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMfaEnabled is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMfaEnabled requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMfaEnabled: %w", err)
	}
	return oldValue.MfaEnabled, nil
}

// ResetMfaEnabled resets all changes to the "mfa_enabled" field.
func (m *SaaSIdentityMutation) ResetMfaEnabled() {
	m.mfa_enabled = nil
}

// SetLastLogin sets the "last_login" field.
func (m *SaaSIdentityMutation) SetLastLogin(t time.Time) {
	m.last_login = &t
}

// LastLogin returns the value of the "last_login" field in the mutation.
func (m *SaaSIdentityMutation) LastLogin() (r time.Time, exists bool) {
	v := m.last_login
	if v == nil {
		return
	}
	return *v, true
}

// OldLastLogin returns the old "last_login" field's value of the SaaSIdentity entity.
// If the SaaSIdentity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SaaSIdentityMutation) OldLastLogin(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastLogin is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastLogin requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastLogin: %w", err)
	}
	return oldValue.LastLogin, nil
}

// ClearLastLogin clears the value of the "last_login" field.
func (m *SaaSIdentityMutation) ClearLastLogin() {
	m.last_login = nil
	m.clearedFields[saasidentity.FieldLastLogin] = struct{}{}
}

// LastLoginCleared returns if the "last_login" field was cleared in this mutation.
func (m *SaaSIdentityMutation) LastLoginCleared() bool {
	_, ok := m.clearedFields[saasidentity.FieldLastLogin]
	return ok
}

// ResetLastLogin resets all changes to the "last_login" field.
func (m *SaaSIdentityMutation) ResetLastLogin() {
	m.last_login = nil
	delete(m.clearedFields, saasidentity.FieldLastLogin)
}

// SetCreatedAt sets the "created_at" field.
func (m *SaaSIdentityMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *SaaSIdentityMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the SaaSIdentity entity.
// If the SaaSIdentity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SaaSIdentityMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *SaaSIdentityMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *SaaSIdentityMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *SaaSIdentityMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the SaaSIdentity entity.
// If the SaaSIdentity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SaaSIdentityMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *SaaSIdentityMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetUserID sets the "user" edge to the User entity by id.
func (m *SaaSIdentityMutation) SetUserID(id int) {
	m.user = &id
}

// ClearUser clears the "user" edge to the User entity.
func (m *SaaSIdentityMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *SaaSIdentityMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *SaaSIdentityMutation) UserID() (id int, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *SaaSIdentityMutation) UserIDs() (ids []int) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *SaaSIdentityMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// SetAppID sets the "app" edge to the SaaSApp entity by id.
func (m *SaaSIdentityMutation) SetAppID(id int) {
	m.app = &id
}

// ClearApp clears the "app" edge to the SaaSApp entity.
func (m *SaaSIdentityMutation) ClearApp() {
	m.clearedapp = true
}

// AppCleared reports if the "app" edge to the SaaSApp entity was cleared.
func (m *SaaSIdentityMutation) AppCleared() bool {
	return m.clearedapp
}

// AppID returns the "app" edge ID in the mutation.
func (m *SaaSIdentityMutation) AppID() (id int, exists bool) {
	if m.app != nil {
		return *m.app, true
	}
	return
}

// AppIDs returns the "app" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AppID instead. It exists only for internal usage by the builders.
func (m *SaaSIdentityMutation) AppIDs() (ids []int) {
	if id := m.app; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetApp resets all changes to the "app" edge.
func (m *SaaSIdentityMutation) ResetApp() {
	m.app = nil
	m.clearedapp = false
}

// AddUsageIDs adds the "usages" edge to the SaaSUsage entity by ids.
func (m *SaaSIdentityMutation) AddUsageIDs(ids ...int) {
	if m.usages == nil {
		m.usages = make(map[int]struct{})
	}
	for i := range ids {
		m.usages[ids[i]] = struct{}{}
	}
}

// ClearUsages clears the "usages" edge to the SaaSUsage entity.
func (m *SaaSIdentityMutation) ClearUsages() {
	m.clearedusages = true
}

// UsagesCleared reports if the "usages" edge to the SaaSUsage entity was cleared.
func (m *SaaSIdentityMutation) UsagesCleared() bool {
	return m.clearedusages
}

// RemoveUsageIDs removes the "usages" edge to the SaaSUsage entity by IDs.
func (m *SaaSIdentityMutation) RemoveUsageIDs(ids ...int) {
	if m.removedusages == nil {
		m.removedusages = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.usages, ids[i])
		m.removedusages[ids[i]] = struct{}{}
	}
}

// RemovedUsages returns the removed IDs of the "usages" edge to the SaaSUsage entity.
func (m *SaaSIdentityMutation) RemovedUsagesIDs() (ids []int) {
	for id := range m.removedusages {
		ids = append(ids, id)
	}
	return
}

// UsagesIDs returns the "usages" edge IDs in the mutation.
func (m *SaaSIdentityMutation) UsagesIDs() (ids []int) {
	for id := range m.usages {
		ids = append(ids, id)
	}
	return
}

// ResetUsages resets all changes to the "usages" edge.
func (m *SaaSIdentityMutation) ResetUsages() {
	m.usages = nil
	m.clearedusages = false
	m.removedusages = nil
}

// Where appends a list predicates to the SaaSIdentityMutation builder.
func (m *SaaSIdentityMutation) Where(ps ...predicate.SaaSIdentity) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SaaSIdentityMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SaaSIdentityMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.SaaSIdentity, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SaaSIdentityMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SaaSIdentityMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (SaaSIdentity).
func (m *SaaSIdentityMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SaaSIdentityMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.external_id != nil {
		fields = append(fields, saasidentity.FieldExternalID)
	}
	if m.email != nil {
		fields = append(fields, saasidentity.FieldEmail)
	}
	if m.display_name != nil {
		fields = append(fields, saasidentity.FieldDisplayName)
	}
	if m.current_plan != nil {
		fields = append(fields, saasidentity.FieldCurrentPlan)
	}
	if m.metadata != nil {
		fields = append(fields, saasidentity.FieldMetadata)
	}
	if m.mfa_enabled != nil {
		fields = append(fields, saasidentity.FieldMfaEnabled)
	}
	if m.last_login != nil {
		fields = append(fields, saasidentity.FieldLastLogin)
	}
	if m.created_at != nil {
		fields = append(fields, saasidentity.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, saasidentity.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SaaSIdentityMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case saasidentity.FieldExternalID:
		return m.ExternalID()
	case saasidentity.FieldEmail:
		return m.Email()
	case saasidentity.FieldDisplayName:
		return m.DisplayName()
	case saasidentity.FieldCurrentPlan:
		return m.CurrentPlan()
	case saasidentity.FieldMetadata:
		return m.Metadata()
	case saasidentity.FieldMfaEnabled:
		return m.MfaEnabled()
	case saasidentity.FieldLastLogin:
		return m.LastLogin()
	case saasidentity.FieldCreatedAt:
		return m.CreatedAt()
	case saasidentity.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SaaSIdentityMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case saasidentity.FieldExternalID:
		return m.OldExternalID(ctx)
	case saasidentity.FieldEmail:
		return m.OldEmail(ctx)
	case saasidentity.FieldDisplayName:
		return m.OldDisplayName(ctx)
	case saasidentity.FieldCurrentPlan:
		return m.OldCurrentPlan(ctx)
	case saasidentity.FieldMetadata:
		return m.OldMetadata(ctx)
	case saasidentity.FieldMfaEnabled:
		return m.OldMfaEnabled(ctx)
	case saasidentity.FieldLastLogin:
		return m.OldLastLogin(ctx)
	case saasidentity.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case saasidentity.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown SaaSIdentity field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SaaSIdentityMutation) SetField(name string, value ent.Value) error {
	switch name {
	case saasidentity.FieldExternalID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExternalID(v)
		return nil
	case saasidentity.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case saasidentity.FieldDisplayName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisplayName(v)
		return nil
	case saasidentity.FieldCurrentPlan:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCurrentPlan(v)
		return nil
	case saasidentity.FieldMetadata:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetadata(v)
		return nil
	case saasidentity.FieldMfaEnabled:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMfaEnabled(v)
		return nil
	case saasidentity.FieldLastLogin:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastLogin(v)
		return nil
	case saasidentity.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case saasidentity.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown SaaSIdentity field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SaaSIdentityMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SaaSIdentityMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SaaSIdentityMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown SaaSIdentity numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SaaSIdentityMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(saasidentity.FieldDisplayName) {
		fields = append(fields, saasidentity.FieldDisplayName)
	}
	if m.FieldCleared(saasidentity.FieldCurrentPlan) {
		fields = append(fields, saasidentity.FieldCurrentPlan)
	}
	if m.FieldCleared(saasidentity.FieldLastLogin) {
		fields = append(fields, saasidentity.FieldLastLogin)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SaaSIdentityMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SaaSIdentityMutation) ClearField(name string) error {
	switch name {
	case saasidentity.FieldDisplayName:
		m.ClearDisplayName()
		return nil
	case saasidentity.FieldCurrentPlan:
		m.ClearCurrentPlan()
		return nil
	case saasidentity.FieldLastLogin:
		m.ClearLastLogin()
		return nil
	}
	return fmt.Errorf("unknown SaaSIdentity nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SaaSIdentityMutation) ResetField(name string) error {
	switch name {
	case saasidentity.FieldExternalID:
		m.ResetExternalID()
		return nil
	case saasidentity.FieldEmail:
		m.ResetEmail()
		return nil
	case saasidentity.FieldDisplayName:
		m.ResetDisplayName()
		return nil
	case saasidentity.FieldCurrentPlan:
		m.ResetCurrentPlan()
		return nil
	case saasidentity.FieldMetadata:
		m.ResetMetadata()
		return nil
	case saasidentity.FieldMfaEnabled:
		m.ResetMfaEnabled()
		return nil
	case saasidentity.FieldLastLogin:
		m.ResetLastLogin()
		return nil
	case saasidentity.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case saasidentity.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown SaaSIdentity field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SaaSIdentityMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.user != nil {
		edges = append(edges, saasidentity.EdgeUser)
	}
	if m.app != nil {
		edges = append(edges, saasidentity.EdgeApp)
	}
	if m.usages != nil {
		edges = append(edges, saasidentity.EdgeUsages)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SaaSIdentityMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case saasidentity.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case saasidentity.EdgeApp:
		if id := m.app; id != nil {
			return []ent.Value{*id}
		}
	case saasidentity.EdgeUsages:
		ids := make([]ent.Value, 0, len(m.usages))
		for id := range m.usages {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SaaSIdentityMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedusages != nil {
		edges = append(edges, saasidentity.EdgeUsages)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SaaSIdentityMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case saasidentity.EdgeUsages:
		ids := make([]ent.Value, 0, len(m.removedusages))
		for id := range m.removedusages {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SaaSIdentityMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.cleareduser {
		edges = append(edges, saasidentity.EdgeUser)
	}
	if m.clearedapp {
		edges = append(edges, saasidentity.EdgeApp)
	}
	if m.clearedusages {
		edges = append(edges, saasidentity.EdgeUsages)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SaaSIdentityMutation) EdgeCleared(name string) bool {
	switch name {
	case saasidentity.EdgeUser:
		return m.cleareduser
	case saasidentity.EdgeApp:
		return m.clearedapp
	case saasidentity.EdgeUsages:
		return m.clearedusages
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SaaSIdentityMutation) ClearEdge(name string) error {
	switch name {
	case saasidentity.EdgeUser:
		m.ClearUser()
		return nil
	case saasidentity.EdgeApp:
		m.ClearApp()
		return nil
	}
	return fmt.Errorf("unknown SaaSIdentity unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SaaSIdentityMutation) ResetEdge(name string) error {
	switch name {
	case saasidentity.EdgeUser:
		m.ResetUser()
		return nil
	case saasidentity.EdgeApp:
		m.ResetApp()
		return nil
	case saasidentity.EdgeUsages:
		m.ResetUsages()
		return nil
	}
	return fmt.Errorf("unknown SaaSIdentity edge %s", name)
}

// SaaSUsageMutation represents an operation that mutates the SaaSUsage nodes in the graph.
type SaaSUsageMutation struct {
	config
	op              Op
	typ             string
	id              *int
	timestamp       *time.Time
	feature_name    *string
	count           *int
	addcount        *int
	metadata        *map[string]interface{}
	clearedFields   map[string]struct{}
	identity        *int
	clearedidentity bool
	done            bool
	oldValue        func(context.Context) (*SaaSUsage, error)
	predicates      []predicate.SaaSUsage
}

var _ ent.Mutation = (*SaaSUsageMutation)(nil)

// saasusageOption allows management of the mutation configuration using functional options.
type saasusageOption func(*SaaSUsageMutation)

// newSaaSUsageMutation creates new mutation for the SaaSUsage entity.
func newSaaSUsageMutation(c config, op Op, opts ...saasusageOption) *SaaSUsageMutation {
	m := &SaaSUsageMutation{
		config:        c,
		op:            op,
		typ:           TypeSaaSUsage,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSaaSUsageID sets the ID field of the mutation.
func withSaaSUsageID(id int) saasusageOption {
	return func(m *SaaSUsageMutation) {
		var (
			err   error
			once  sync.Once
			value *SaaSUsage
		)
		m.oldValue = func(ctx context.Context) (*SaaSUsage, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().SaaSUsage.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSaaSUsage sets the old SaaSUsage of the mutation.
func withSaaSUsage(node *SaaSUsage) saasusageOption {
	return func(m *SaaSUsageMutation) {
		m.oldValue = func(context.Context) (*SaaSUsage, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SaaSUsageMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SaaSUsageMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SaaSUsageMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SaaSUsageMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().SaaSUsage.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTimestamp sets the "timestamp" field.
func (m *SaaSUsageMutation) SetTimestamp(t time.Time) {
	m.timestamp = &t
}

// Timestamp returns the value of the "timestamp" field in the mutation.
func (m *SaaSUsageMutation) Timestamp() (r time.Time, exists bool) {
	v := m.timestamp
	if v == nil {
		return
	}
	return *v, true
}

// OldTimestamp returns the old "timestamp" field's value of the SaaSUsage entity.
// If the SaaSUsage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SaaSUsageMutation) OldTimestamp(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTimestamp is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTimestamp requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTimestamp: %w", err)
	}
	return oldValue.Timestamp, nil
}

// ResetTimestamp resets all changes to the "timestamp" field.
func (m *SaaSUsageMutation) ResetTimestamp() {
	m.timestamp = nil
}

// SetFeatureName sets the "feature_name" field.
func (m *SaaSUsageMutation) SetFeatureName(s string) {
	m.feature_name = &s
}

// FeatureName returns the value of the "feature_name" field in the mutation.
func (m *SaaSUsageMutation) FeatureName() (r string, exists bool) {
	v := m.feature_name
	if v == nil {
		return
	}
	return *v, true
}

// OldFeatureName returns the old "feature_name" field's value of the SaaSUsage entity.
// If the SaaSUsage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SaaSUsageMutation) OldFeatureName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFeatureName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFeatureName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFeatureName: %w", err)
	}
	return oldValue.FeatureName, nil
}

// ResetFeatureName resets all changes to the "feature_name" field.
func (m *SaaSUsageMutation) ResetFeatureName() {
	m.feature_name = nil
}

// SetCount sets the "count" field.
func (m *SaaSUsageMutation) SetCount(i int) {
	m.count = &i
	m.addcount = nil
}

// Count returns the value of the "count" field in the mutation.
func (m *SaaSUsageMutation) Count() (r int, exists bool) {
	v := m.count
	if v == nil {
		return
	}
	return *v, true
}

// OldCount returns the old "count" field's value of the SaaSUsage entity.
// If the SaaSUsage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SaaSUsageMutation) OldCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCount: %w", err)
	}
	return oldValue.Count, nil
}

// AddCount adds i to the "count" field.
func (m *SaaSUsageMutation) AddCount(i int) {
	if m.addcount != nil {
		*m.addcount += i
	} else {
		m.addcount = &i
	}
}

// AddedCount returns the value that was added to the "count" field in this mutation.
func (m *SaaSUsageMutation) AddedCount() (r int, exists bool) {
	v := m.addcount
	if v == nil {
		return
	}
	return *v, true
}

// ResetCount resets all changes to the "count" field.
func (m *SaaSUsageMutation) ResetCount() {
	m.count = nil
	m.addcount = nil
}

// SetMetadata sets the "metadata" field.
func (m *SaaSUsageMutation) SetMetadata(value map[string]interface{}) {
	m.metadata = &value
}

// Metadata returns the value of the "metadata" field in the mutation.
func (m *SaaSUsageMutation) Metadata() (r map[string]interface{}, exists bool) {
	v := m.metadata
	if v == nil {
		return
	}
	return *v, true
}

// OldMetadata returns the old "metadata" field's value of the SaaSUsage entity.
// If the SaaSUsage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SaaSUsageMutation) OldMetadata(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMetadata is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMetadata requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetadata: %w", err)
	}
	return oldValue.Metadata, nil
}

// ResetMetadata resets all changes to the "metadata" field.
func (m *SaaSUsageMutation) ResetMetadata() {
	m.metadata = nil
}

// SetIdentityID sets the "identity" edge to the SaaSIdentity entity by id.
func (m *SaaSUsageMutation) SetIdentityID(id int) {
	m.identity = &id
}

// ClearIdentity clears the "identity" edge to the SaaSIdentity entity.
func (m *SaaSUsageMutation) ClearIdentity() {
	m.clearedidentity = true
}

// IdentityCleared reports if the "identity" edge to the SaaSIdentity entity was cleared.
func (m *SaaSUsageMutation) IdentityCleared() bool {
	return m.clearedidentity
}

// IdentityID returns the "identity" edge ID in the mutation.
func (m *SaaSUsageMutation) IdentityID() (id int, exists bool) {
	if m.identity != nil {
		return *m.identity, true
	}
	return
}

// IdentityIDs returns the "identity" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// IdentityID instead. It exists only for internal usage by the builders.
func (m *SaaSUsageMutation) IdentityIDs() (ids []int) {
	if id := m.identity; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetIdentity resets all changes to the "identity" edge.
func (m *SaaSUsageMutation) ResetIdentity() {
	m.identity = nil
	m.clearedidentity = false
}

// Where appends a list predicates to the SaaSUsageMutation builder.
func (m *SaaSUsageMutation) Where(ps ...predicate.SaaSUsage) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SaaSUsageMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SaaSUsageMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.SaaSUsage, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SaaSUsageMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SaaSUsageMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (SaaSUsage).
func (m *SaaSUsageMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SaaSUsageMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.timestamp != nil {
		fields = append(fields, saasusage.FieldTimestamp)
	}
	if m.feature_name != nil {
		fields = append(fields, saasusage.FieldFeatureName)
	}
	if m.count != nil {
		fields = append(fields, saasusage.FieldCount)
	}
	if m.metadata != nil {
		fields = append(fields, saasusage.FieldMetadata)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SaaSUsageMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case saasusage.FieldTimestamp:
		return m.Timestamp()
	case saasusage.FieldFeatureName:
		return m.FeatureName()
	case saasusage.FieldCount:
		return m.Count()
	case saasusage.FieldMetadata:
		return m.Metadata()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SaaSUsageMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case saasusage.FieldTimestamp:
		return m.OldTimestamp(ctx)
	case saasusage.FieldFeatureName:
		return m.OldFeatureName(ctx)
	case saasusage.FieldCount:
		return m.OldCount(ctx)
	case saasusage.FieldMetadata:
		return m.OldMetadata(ctx)
	}
	return nil, fmt.Errorf("unknown SaaSUsage field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SaaSUsageMutation) SetField(name string, value ent.Value) error {
	switch name {
	case saasusage.FieldTimestamp:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTimestamp(v)
		return nil
	case saasusage.FieldFeatureName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFeatureName(v)
		return nil
	case saasusage.FieldCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCount(v)
		return nil
	case saasusage.FieldMetadata:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetadata(v)
		return nil
	}
	return fmt.Errorf("unknown SaaSUsage field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SaaSUsageMutation) AddedFields() []string {
	var fields []string
	if m.addcount != nil {
		fields = append(fields, saasusage.FieldCount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SaaSUsageMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case saasusage.FieldCount:
		return m.AddedCount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SaaSUsageMutation) AddField(name string, value ent.Value) error {
	switch name {
	case saasusage.FieldCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCount(v)
		return nil
	}
	return fmt.Errorf("unknown SaaSUsage numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SaaSUsageMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SaaSUsageMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SaaSUsageMutation) ClearField(name string) error {
	return fmt.Errorf("unknown SaaSUsage nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SaaSUsageMutation) ResetField(name string) error {
	switch name {
	case saasusage.FieldTimestamp:
		m.ResetTimestamp()
		return nil
	case saasusage.FieldFeatureName:
		m.ResetFeatureName()
		return nil
	case saasusage.FieldCount:
		m.ResetCount()
		return nil
	case saasusage.FieldMetadata:
		m.ResetMetadata()
		return nil
	}
	return fmt.Errorf("unknown SaaSUsage field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SaaSUsageMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.identity != nil {
		edges = append(edges, saasusage.EdgeIdentity)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SaaSUsageMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case saasusage.EdgeIdentity:
		if id := m.identity; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SaaSUsageMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SaaSUsageMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SaaSUsageMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedidentity {
		edges = append(edges, saasusage.EdgeIdentity)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SaaSUsageMutation) EdgeCleared(name string) bool {
	switch name {
	case saasusage.EdgeIdentity:
		return m.clearedidentity
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SaaSUsageMutation) ClearEdge(name string) error {
	switch name {
	case saasusage.EdgeIdentity:
		m.ClearIdentity()
		return nil
	}
	return fmt.Errorf("unknown SaaSUsage unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SaaSUsageMutation) ResetEdge(name string) error {
	switch name {
	case saasusage.EdgeIdentity:
		m.ResetIdentity()
		return nil
	}
	return fmt.Errorf("unknown SaaSUsage edge %s", name)
}

// ServiceRateMutation represents an operation that mutates the ServiceRate nodes in the graph.
type ServiceRateMutation struct {
	config
	op            Op
	typ           string
	id            *int
	work_type     *string
	rate          *float64
	addrate       *float64
	description   *string
	clearedFields map[string]struct{}
	tenant        *int
	clearedtenant bool
	done          bool
	oldValue      func(context.Context) (*ServiceRate, error)
	predicates    []predicate.ServiceRate
}

var _ ent.Mutation = (*ServiceRateMutation)(nil)

// servicerateOption allows management of the mutation configuration using functional options.
type servicerateOption func(*ServiceRateMutation)

// newServiceRateMutation creates new mutation for the ServiceRate entity.
func newServiceRateMutation(c config, op Op, opts ...servicerateOption) *ServiceRateMutation {
	m := &ServiceRateMutation{
		config:        c,
		op:            op,
		typ:           TypeServiceRate,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withServiceRateID sets the ID field of the mutation.
func withServiceRateID(id int) servicerateOption {
	return func(m *ServiceRateMutation) {
		var (
			err   error
			once  sync.Once
			value *ServiceRate
		)
		m.oldValue = func(ctx context.Context) (*ServiceRate, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ServiceRate.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withServiceRate sets the old ServiceRate of the mutation.
func withServiceRate(node *ServiceRate) servicerateOption {
	return func(m *ServiceRateMutation) {
		m.oldValue = func(context.Context) (*ServiceRate, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ServiceRateMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ServiceRateMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ServiceRateMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ServiceRateMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ServiceRate.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetWorkType sets the "work_type" field.
func (m *ServiceRateMutation) SetWorkType(s string) {
	m.work_type = &s
}

// WorkType returns the value of the "work_type" field in the mutation.
func (m *ServiceRateMutation) WorkType() (r string, exists bool) {
	v := m.work_type
	if v == nil {
		return
	}
	return *v, true
}

// OldWorkType returns the old "work_type" field's value of the ServiceRate entity.
// If the ServiceRate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceRateMutation) OldWorkType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWorkType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWorkType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWorkType: %w", err)
	}
	return oldValue.WorkType, nil
}

// ResetWorkType resets all changes to the "work_type" field.
func (m *ServiceRateMutation) ResetWorkType() {
	m.work_type = nil
}

// SetRate sets the "rate" field.
func (m *ServiceRateMutation) SetRate(f float64) {
	m.rate = &f
	m.addrate = nil
}

// Rate returns the value of the "rate" field in the mutation.
func (m *ServiceRateMutation) Rate() (r float64, exists bool) {
	v := m.rate
	if v == nil {
		return
	}
	return *v, true
}

// OldRate returns the old "rate" field's value of the ServiceRate entity.
// If the ServiceRate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceRateMutation) OldRate(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRate: %w", err)
	}
	return oldValue.Rate, nil
}

// AddRate adds f to the "rate" field.
func (m *ServiceRateMutation) AddRate(f float64) {
	if m.addrate != nil {
		*m.addrate += f
	} else {
		m.addrate = &f
	}
}

// AddedRate returns the value that was added to the "rate" field in this mutation.
func (m *ServiceRateMutation) AddedRate() (r float64, exists bool) {
	v := m.addrate
	if v == nil {
		return
	}
	return *v, true
}

// ResetRate resets all changes to the "rate" field.
func (m *ServiceRateMutation) ResetRate() {
	m.rate = nil
	m.addrate = nil
}

// SetDescription sets the "description" field.
func (m *ServiceRateMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *ServiceRateMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the ServiceRate entity.
// If the ServiceRate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceRateMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *ServiceRateMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[servicerate.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *ServiceRateMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[servicerate.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *ServiceRateMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, servicerate.FieldDescription)
}

// SetTenantID sets the "tenant" edge to the Tenant entity by id.
func (m *ServiceRateMutation) SetTenantID(id int) {
	m.tenant = &id
}

// ClearTenant clears the "tenant" edge to the Tenant entity.
func (m *ServiceRateMutation) ClearTenant() {
	m.clearedtenant = true
}

// TenantCleared reports if the "tenant" edge to the Tenant entity was cleared.
func (m *ServiceRateMutation) TenantCleared() bool {
	return m.clearedtenant
}

// TenantID returns the "tenant" edge ID in the mutation.
func (m *ServiceRateMutation) TenantID() (id int, exists bool) {
	if m.tenant != nil {
		return *m.tenant, true
	}
	return
}

// TenantIDs returns the "tenant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TenantID instead. It exists only for internal usage by the builders.
func (m *ServiceRateMutation) TenantIDs() (ids []int) {
	if id := m.tenant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTenant resets all changes to the "tenant" edge.
func (m *ServiceRateMutation) ResetTenant() {
	m.tenant = nil
	m.clearedtenant = false
}

// Where appends a list predicates to the ServiceRateMutation builder.
func (m *ServiceRateMutation) Where(ps ...predicate.ServiceRate) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ServiceRateMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ServiceRateMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ServiceRate, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ServiceRateMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ServiceRateMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ServiceRate).
func (m *ServiceRateMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ServiceRateMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.work_type != nil {
		fields = append(fields, servicerate.FieldWorkType)
	}
	if m.rate != nil {
		fields = append(fields, servicerate.FieldRate)
	}
	if m.description != nil {
		fields = append(fields, servicerate.FieldDescription)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ServiceRateMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case servicerate.FieldWorkType:
		return m.WorkType()
	case servicerate.FieldRate:
		return m.Rate()
	case servicerate.FieldDescription:
		return m.Description()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ServiceRateMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case servicerate.FieldWorkType:
		return m.OldWorkType(ctx)
	case servicerate.FieldRate:
		return m.OldRate(ctx)
	case servicerate.FieldDescription:
		return m.OldDescription(ctx)
	}
	return nil, fmt.Errorf("unknown ServiceRate field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ServiceRateMutation) SetField(name string, value ent.Value) error {
	switch name {
	case servicerate.FieldWorkType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWorkType(v)
		return nil
	case servicerate.FieldRate:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRate(v)
		return nil
	case servicerate.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	}
	return fmt.Errorf("unknown ServiceRate field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ServiceRateMutation) AddedFields() []string {
	var fields []string
	if m.addrate != nil {
		fields = append(fields, servicerate.FieldRate)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ServiceRateMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case servicerate.FieldRate:
		return m.AddedRate()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ServiceRateMutation) AddField(name string, value ent.Value) error {
	switch name {
	case servicerate.FieldRate:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRate(v)
		return nil
	}
	return fmt.Errorf("unknown ServiceRate numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ServiceRateMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(servicerate.FieldDescription) {
		fields = append(fields, servicerate.FieldDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ServiceRateMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ServiceRateMutation) ClearField(name string) error {
	switch name {
	case servicerate.FieldDescription:
		m.ClearDescription()
		return nil
	}
	return fmt.Errorf("unknown ServiceRate nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ServiceRateMutation) ResetField(name string) error {
	switch name {
	case servicerate.FieldWorkType:
		m.ResetWorkType()
		return nil
	case servicerate.FieldRate:
		m.ResetRate()
		return nil
	case servicerate.FieldDescription:
		m.ResetDescription()
		return nil
	}
	return fmt.Errorf("unknown ServiceRate field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ServiceRateMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.tenant != nil {
		edges = append(edges, servicerate.EdgeTenant)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ServiceRateMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case servicerate.EdgeTenant:
		if id := m.tenant; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ServiceRateMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ServiceRateMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ServiceRateMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedtenant {
		edges = append(edges, servicerate.EdgeTenant)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ServiceRateMutation) EdgeCleared(name string) bool {
	switch name {
	case servicerate.EdgeTenant:
		return m.clearedtenant
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ServiceRateMutation) ClearEdge(name string) error {
	switch name {
	case servicerate.EdgeTenant:
		m.ClearTenant()
		return nil
	}
	return fmt.Errorf("unknown ServiceRate unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ServiceRateMutation) ResetEdge(name string) error {
	switch name {
	case servicerate.EdgeTenant:
		m.ResetTenant()
		return nil
	}
	return fmt.Errorf("unknown ServiceRate edge %s", name)
}

// StockMovementMutation represents an operation that mutates the StockMovement nodes in the graph.
type StockMovementMutation struct {
	config
	op                    Op
	typ                   string
	id                    *int
	quantity              *float64
	addquantity           *float64
	movement_type         *stockmovement.MovementType
	reason                *string
	unit_cost             *float64
	addunit_cost          *float64
	remaining_quantity    *float64
	addremaining_quantity *float64
	calculated_cogs       *float64
	addcalculated_cogs    *float64
	metadata              *map[string]interface{}
	created_at            *time.Time
	clearedFields         map[string]struct{}
	product               *int
	clearedproduct        bool
	tenant                *int
	clearedtenant         bool
	done                  bool
	oldValue              func(context.Context) (*StockMovement, error)
	predicates            []predicate.StockMovement
}

var _ ent.Mutation = (*StockMovementMutation)(nil)

// stockmovementOption allows management of the mutation configuration using functional options.
type stockmovementOption func(*StockMovementMutation)

// newStockMovementMutation creates new mutation for the StockMovement entity.
func newStockMovementMutation(c config, op Op, opts ...stockmovementOption) *StockMovementMutation {
	m := &StockMovementMutation{
		config:        c,
		op:            op,
		typ:           TypeStockMovement,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withStockMovementID sets the ID field of the mutation.
func withStockMovementID(id int) stockmovementOption {
	return func(m *StockMovementMutation) {
		var (
			err   error
			once  sync.Once
			value *StockMovement
		)
		m.oldValue = func(ctx context.Context) (*StockMovement, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().StockMovement.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withStockMovement sets the old StockMovement of the mutation.
func withStockMovement(node *StockMovement) stockmovementOption {
	return func(m *StockMovementMutation) {
		m.oldValue = func(context.Context) (*StockMovement, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m StockMovementMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m StockMovementMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *StockMovementMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *StockMovementMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().StockMovement.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetQuantity sets the "quantity" field.
func (m *StockMovementMutation) SetQuantity(f float64) {
	m.quantity = &f
	m.addquantity = nil
}

// Quantity returns the value of the "quantity" field in the mutation.
func (m *StockMovementMutation) Quantity() (r float64, exists bool) {
	v := m.quantity
	if v == nil {
		return
	}
	return *v, true
}

// OldQuantity returns the old "quantity" field's value of the StockMovement entity.
// If the StockMovement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StockMovementMutation) OldQuantity(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldQuantity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldQuantity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldQuantity: %w", err)
	}
	return oldValue.Quantity, nil
}

// AddQuantity adds f to the "quantity" field.
func (m *StockMovementMutation) AddQuantity(f float64) {
	if m.addquantity != nil {
		*m.addquantity += f
	} else {
		m.addquantity = &f
	}
}

// AddedQuantity returns the value that was added to the "quantity" field in this mutation.
func (m *StockMovementMutation) AddedQuantity() (r float64, exists bool) {
	v := m.addquantity
	if v == nil {
		return
	}
	return *v, true
}

// ResetQuantity resets all changes to the "quantity" field.
func (m *StockMovementMutation) ResetQuantity() {
	m.quantity = nil
	m.addquantity = nil
}

// SetMovementType sets the "movement_type" field.
func (m *StockMovementMutation) SetMovementType(st stockmovement.MovementType) {
	m.movement_type = &st
}

// MovementType returns the value of the "movement_type" field in the mutation.
func (m *StockMovementMutation) MovementType() (r stockmovement.MovementType, exists bool) {
	v := m.movement_type
	if v == nil {
		return
	}
	return *v, true
}

// OldMovementType returns the old "movement_type" field's value of the StockMovement entity.
// If the StockMovement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StockMovementMutation) OldMovementType(ctx context.Context) (v stockmovement.MovementType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMovementType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMovementType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMovementType: %w", err)
	}
	return oldValue.MovementType, nil
}

// ResetMovementType resets all changes to the "movement_type" field.
func (m *StockMovementMutation) ResetMovementType() {
	m.movement_type = nil
}

// SetReason sets the "reason" field.
func (m *StockMovementMutation) SetReason(s string) {
	m.reason = &s
}

// Reason returns the value of the "reason" field in the mutation.
func (m *StockMovementMutation) Reason() (r string, exists bool) {
	v := m.reason
	if v == nil {
		return
	}
	return *v, true
}

// OldReason returns the old "reason" field's value of the StockMovement entity.
// If the StockMovement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StockMovementMutation) OldReason(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReason is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReason requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReason: %w", err)
	}
	return oldValue.Reason, nil
}

// ClearReason clears the value of the "reason" field.
func (m *StockMovementMutation) ClearReason() {
	m.reason = nil
	m.clearedFields[stockmovement.FieldReason] = struct{}{}
}

// ReasonCleared returns if the "reason" field was cleared in this mutation.
func (m *StockMovementMutation) ReasonCleared() bool {
	_, ok := m.clearedFields[stockmovement.FieldReason]
	return ok
}

// ResetReason resets all changes to the "reason" field.
func (m *StockMovementMutation) ResetReason() {
	m.reason = nil
	delete(m.clearedFields, stockmovement.FieldReason)
}

// SetUnitCost sets the "unit_cost" field.
func (m *StockMovementMutation) SetUnitCost(f float64) {
	m.unit_cost = &f
	m.addunit_cost = nil
}

// UnitCost returns the value of the "unit_cost" field in the mutation.
func (m *StockMovementMutation) UnitCost() (r float64, exists bool) {
	v := m.unit_cost
	if v == nil {
		return
	}
	return *v, true
}

// OldUnitCost returns the old "unit_cost" field's value of the StockMovement entity.
// If the StockMovement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StockMovementMutation) OldUnitCost(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUnitCost is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUnitCost requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUnitCost: %w", err)
	}
	return oldValue.UnitCost, nil
}

// AddUnitCost adds f to the "unit_cost" field.
func (m *StockMovementMutation) AddUnitCost(f float64) {
	if m.addunit_cost != nil {
		*m.addunit_cost += f
	} else {
		m.addunit_cost = &f
	}
}

// AddedUnitCost returns the value that was added to the "unit_cost" field in this mutation.
func (m *StockMovementMutation) AddedUnitCost() (r float64, exists bool) {
	v := m.addunit_cost
	if v == nil {
		return
	}
	return *v, true
}

// ClearUnitCost clears the value of the "unit_cost" field.
func (m *StockMovementMutation) ClearUnitCost() {
	m.unit_cost = nil
	m.addunit_cost = nil
	m.clearedFields[stockmovement.FieldUnitCost] = struct{}{}
}

// UnitCostCleared returns if the "unit_cost" field was cleared in this mutation.
func (m *StockMovementMutation) UnitCostCleared() bool {
	_, ok := m.clearedFields[stockmovement.FieldUnitCost]
	return ok
}

// ResetUnitCost resets all changes to the "unit_cost" field.
func (m *StockMovementMutation) ResetUnitCost() {
	m.unit_cost = nil
	m.addunit_cost = nil
	delete(m.clearedFields, stockmovement.FieldUnitCost)
}

// SetRemainingQuantity sets the "remaining_quantity" field.
func (m *StockMovementMutation) SetRemainingQuantity(f float64) {
	m.remaining_quantity = &f
	m.addremaining_quantity = nil
}

// RemainingQuantity returns the value of the "remaining_quantity" field in the mutation.
func (m *StockMovementMutation) RemainingQuantity() (r float64, exists bool) {
	v := m.remaining_quantity
	if v == nil {
		return
	}
	return *v, true
}

// OldRemainingQuantity returns the old "remaining_quantity" field's value of the StockMovement entity.
// If the StockMovement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StockMovementMutation) OldRemainingQuantity(ctx context.Context) (v *float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRemainingQuantity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRemainingQuantity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemainingQuantity: %w", err)
	}
	return oldValue.RemainingQuantity, nil
}

// AddRemainingQuantity adds f to the "remaining_quantity" field.
func (m *StockMovementMutation) AddRemainingQuantity(f float64) {
	if m.addremaining_quantity != nil {
		*m.addremaining_quantity += f
	} else {
		m.addremaining_quantity = &f
	}
}

// AddedRemainingQuantity returns the value that was added to the "remaining_quantity" field in this mutation.
func (m *StockMovementMutation) AddedRemainingQuantity() (r float64, exists bool) {
	v := m.addremaining_quantity
	if v == nil {
		return
	}
	return *v, true
}

// ClearRemainingQuantity clears the value of the "remaining_quantity" field.
func (m *StockMovementMutation) ClearRemainingQuantity() {
	m.remaining_quantity = nil
	m.addremaining_quantity = nil
	m.clearedFields[stockmovement.FieldRemainingQuantity] = struct{}{}
}

// RemainingQuantityCleared returns if the "remaining_quantity" field was cleared in this mutation.
func (m *StockMovementMutation) RemainingQuantityCleared() bool {
	_, ok := m.clearedFields[stockmovement.FieldRemainingQuantity]
	return ok
}

// ResetRemainingQuantity resets all changes to the "remaining_quantity" field.
func (m *StockMovementMutation) ResetRemainingQuantity() {
	m.remaining_quantity = nil
	m.addremaining_quantity = nil
	delete(m.clearedFields, stockmovement.FieldRemainingQuantity)
}

// SetCalculatedCogs sets the "calculated_cogs" field.
func (m *StockMovementMutation) SetCalculatedCogs(f float64) {
	m.calculated_cogs = &f
	m.addcalculated_cogs = nil
}

// CalculatedCogs returns the value of the "calculated_cogs" field in the mutation.
func (m *StockMovementMutation) CalculatedCogs() (r float64, exists bool) {
	v := m.calculated_cogs
	if v == nil {
		return
	}
	return *v, true
}

// OldCalculatedCogs returns the old "calculated_cogs" field's value of the StockMovement entity.
// If the StockMovement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StockMovementMutation) OldCalculatedCogs(ctx context.Context) (v *float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCalculatedCogs is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCalculatedCogs requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCalculatedCogs: %w", err)
	}
	return oldValue.CalculatedCogs, nil
}

// AddCalculatedCogs adds f to the "calculated_cogs" field.
func (m *StockMovementMutation) AddCalculatedCogs(f float64) {
	if m.addcalculated_cogs != nil {
		*m.addcalculated_cogs += f
	} else {
		m.addcalculated_cogs = &f
	}
}

// AddedCalculatedCogs returns the value that was added to the "calculated_cogs" field in this mutation.
func (m *StockMovementMutation) AddedCalculatedCogs() (r float64, exists bool) {
	v := m.addcalculated_cogs
	if v == nil {
		return
	}
	return *v, true
}

// ClearCalculatedCogs clears the value of the "calculated_cogs" field.
func (m *StockMovementMutation) ClearCalculatedCogs() {
	m.calculated_cogs = nil
	m.addcalculated_cogs = nil
	m.clearedFields[stockmovement.FieldCalculatedCogs] = struct{}{}
}

// CalculatedCogsCleared returns if the "calculated_cogs" field was cleared in this mutation.
func (m *StockMovementMutation) CalculatedCogsCleared() bool {
	_, ok := m.clearedFields[stockmovement.FieldCalculatedCogs]
	return ok
}

// ResetCalculatedCogs resets all changes to the "calculated_cogs" field.
func (m *StockMovementMutation) ResetCalculatedCogs() {
	m.calculated_cogs = nil
	m.addcalculated_cogs = nil
	delete(m.clearedFields, stockmovement.FieldCalculatedCogs)
}

// SetMetadata sets the "metadata" field.
func (m *StockMovementMutation) SetMetadata(value map[string]interface{}) {
	m.metadata = &value
}

// Metadata returns the value of the "metadata" field in the mutation.
func (m *StockMovementMutation) Metadata() (r map[string]interface{}, exists bool) {
	v := m.metadata
	if v == nil {
		return
	}
	return *v, true
}

// OldMetadata returns the old "metadata" field's value of the StockMovement entity.
// If the StockMovement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StockMovementMutation) OldMetadata(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMetadata is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMetadata requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetadata: %w", err)
	}
	return oldValue.Metadata, nil
}

// ClearMetadata clears the value of the "metadata" field.
func (m *StockMovementMutation) ClearMetadata() {
	m.metadata = nil
	m.clearedFields[stockmovement.FieldMetadata] = struct{}{}
}

// MetadataCleared returns if the "metadata" field was cleared in this mutation.
func (m *StockMovementMutation) MetadataCleared() bool {
	_, ok := m.clearedFields[stockmovement.FieldMetadata]
	return ok
}

// ResetMetadata resets all changes to the "metadata" field.
func (m *StockMovementMutation) ResetMetadata() {
	m.metadata = nil
	delete(m.clearedFields, stockmovement.FieldMetadata)
}

// SetCreatedAt sets the "created_at" field.
func (m *StockMovementMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *StockMovementMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the StockMovement entity.
// If the StockMovement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StockMovementMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *StockMovementMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetProductID sets the "product" edge to the Product entity by id.
func (m *StockMovementMutation) SetProductID(id int) {
	m.product = &id
}

// ClearProduct clears the "product" edge to the Product entity.
func (m *StockMovementMutation) ClearProduct() {
	m.clearedproduct = true
}

// ProductCleared reports if the "product" edge to the Product entity was cleared.
func (m *StockMovementMutation) ProductCleared() bool {
	return m.clearedproduct
}

// ProductID returns the "product" edge ID in the mutation.
func (m *StockMovementMutation) ProductID() (id int, exists bool) {
	if m.product != nil {
		return *m.product, true
	}
	return
}

// ProductIDs returns the "product" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProductID instead. It exists only for internal usage by the builders.
func (m *StockMovementMutation) ProductIDs() (ids []int) {
	if id := m.product; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProduct resets all changes to the "product" edge.
func (m *StockMovementMutation) ResetProduct() {
	m.product = nil
	m.clearedproduct = false
}

// SetTenantID sets the "tenant" edge to the Tenant entity by id.
func (m *StockMovementMutation) SetTenantID(id int) {
	m.tenant = &id
}

// ClearTenant clears the "tenant" edge to the Tenant entity.
func (m *StockMovementMutation) ClearTenant() {
	m.clearedtenant = true
}

// TenantCleared reports if the "tenant" edge to the Tenant entity was cleared.
func (m *StockMovementMutation) TenantCleared() bool {
	return m.clearedtenant
}

// TenantID returns the "tenant" edge ID in the mutation.
func (m *StockMovementMutation) TenantID() (id int, exists bool) {
	if m.tenant != nil {
		return *m.tenant, true
	}
	return
}

// TenantIDs returns the "tenant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TenantID instead. It exists only for internal usage by the builders.
func (m *StockMovementMutation) TenantIDs() (ids []int) {
	if id := m.tenant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTenant resets all changes to the "tenant" edge.
func (m *StockMovementMutation) ResetTenant() {
	m.tenant = nil
	m.clearedtenant = false
}

// Where appends a list predicates to the StockMovementMutation builder.
func (m *StockMovementMutation) Where(ps ...predicate.StockMovement) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the StockMovementMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *StockMovementMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.StockMovement, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *StockMovementMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *StockMovementMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (StockMovement).
func (m *StockMovementMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *StockMovementMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.quantity != nil {
		fields = append(fields, stockmovement.FieldQuantity)
	}
	if m.movement_type != nil {
		fields = append(fields, stockmovement.FieldMovementType)
	}
	if m.reason != nil {
		fields = append(fields, stockmovement.FieldReason)
	}
	if m.unit_cost != nil {
		fields = append(fields, stockmovement.FieldUnitCost)
	}
	if m.remaining_quantity != nil {
		fields = append(fields, stockmovement.FieldRemainingQuantity)
	}
	if m.calculated_cogs != nil {
		fields = append(fields, stockmovement.FieldCalculatedCogs)
	}
	if m.metadata != nil {
		fields = append(fields, stockmovement.FieldMetadata)
	}
	if m.created_at != nil {
		fields = append(fields, stockmovement.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *StockMovementMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case stockmovement.FieldQuantity:
		return m.Quantity()
	case stockmovement.FieldMovementType:
		return m.MovementType()
	case stockmovement.FieldReason:
		return m.Reason()
	case stockmovement.FieldUnitCost:
		return m.UnitCost()
	case stockmovement.FieldRemainingQuantity:
		return m.RemainingQuantity()
	case stockmovement.FieldCalculatedCogs:
		return m.CalculatedCogs()
	case stockmovement.FieldMetadata:
		return m.Metadata()
	case stockmovement.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *StockMovementMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case stockmovement.FieldQuantity:
		return m.OldQuantity(ctx)
	case stockmovement.FieldMovementType:
		return m.OldMovementType(ctx)
	case stockmovement.FieldReason:
		return m.OldReason(ctx)
	case stockmovement.FieldUnitCost:
		return m.OldUnitCost(ctx)
	case stockmovement.FieldRemainingQuantity:
		return m.OldRemainingQuantity(ctx)
	case stockmovement.FieldCalculatedCogs:
		return m.OldCalculatedCogs(ctx)
	case stockmovement.FieldMetadata:
		return m.OldMetadata(ctx)
	case stockmovement.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown StockMovement field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *StockMovementMutation) SetField(name string, value ent.Value) error {
	switch name {
	case stockmovement.FieldQuantity:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetQuantity(v)
		return nil
	case stockmovement.FieldMovementType:
		v, ok := value.(stockmovement.MovementType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMovementType(v)
		return nil
	case stockmovement.FieldReason:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReason(v)
		return nil
	case stockmovement.FieldUnitCost:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUnitCost(v)
		return nil
	case stockmovement.FieldRemainingQuantity:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemainingQuantity(v)
		return nil
	case stockmovement.FieldCalculatedCogs:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCalculatedCogs(v)
		return nil
	case stockmovement.FieldMetadata:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetadata(v)
		return nil
	case stockmovement.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown StockMovement field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *StockMovementMutation) AddedFields() []string {
	var fields []string
	if m.addquantity != nil {
		fields = append(fields, stockmovement.FieldQuantity)
	}
	if m.addunit_cost != nil {
		fields = append(fields, stockmovement.FieldUnitCost)
	}
	if m.addremaining_quantity != nil {
		fields = append(fields, stockmovement.FieldRemainingQuantity)
	}
	if m.addcalculated_cogs != nil {
		fields = append(fields, stockmovement.FieldCalculatedCogs)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *StockMovementMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case stockmovement.FieldQuantity:
		return m.AddedQuantity()
	case stockmovement.FieldUnitCost:
		return m.AddedUnitCost()
	case stockmovement.FieldRemainingQuantity:
		return m.AddedRemainingQuantity()
	case stockmovement.FieldCalculatedCogs:
		return m.AddedCalculatedCogs()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *StockMovementMutation) AddField(name string, value ent.Value) error {
	switch name {
	case stockmovement.FieldQuantity:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddQuantity(v)
		return nil
	case stockmovement.FieldUnitCost:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUnitCost(v)
		return nil
	case stockmovement.FieldRemainingQuantity:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRemainingQuantity(v)
		return nil
	case stockmovement.FieldCalculatedCogs:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCalculatedCogs(v)
		return nil
	}
	return fmt.Errorf("unknown StockMovement numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *StockMovementMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(stockmovement.FieldReason) {
		fields = append(fields, stockmovement.FieldReason)
	}
	if m.FieldCleared(stockmovement.FieldUnitCost) {
		fields = append(fields, stockmovement.FieldUnitCost)
	}
	if m.FieldCleared(stockmovement.FieldRemainingQuantity) {
		fields = append(fields, stockmovement.FieldRemainingQuantity)
	}
	if m.FieldCleared(stockmovement.FieldCalculatedCogs) {
		fields = append(fields, stockmovement.FieldCalculatedCogs)
	}
	if m.FieldCleared(stockmovement.FieldMetadata) {
		fields = append(fields, stockmovement.FieldMetadata)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *StockMovementMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *StockMovementMutation) ClearField(name string) error {
	switch name {
	case stockmovement.FieldReason:
		m.ClearReason()
		return nil
	case stockmovement.FieldUnitCost:
		m.ClearUnitCost()
		return nil
	case stockmovement.FieldRemainingQuantity:
		m.ClearRemainingQuantity()
		return nil
	case stockmovement.FieldCalculatedCogs:
		m.ClearCalculatedCogs()
		return nil
	case stockmovement.FieldMetadata:
		m.ClearMetadata()
		return nil
	}
	return fmt.Errorf("unknown StockMovement nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *StockMovementMutation) ResetField(name string) error {
	switch name {
	case stockmovement.FieldQuantity:
		m.ResetQuantity()
		return nil
	case stockmovement.FieldMovementType:
		m.ResetMovementType()
		return nil
	case stockmovement.FieldReason:
		m.ResetReason()
		return nil
	case stockmovement.FieldUnitCost:
		m.ResetUnitCost()
		return nil
	case stockmovement.FieldRemainingQuantity:
		m.ResetRemainingQuantity()
		return nil
	case stockmovement.FieldCalculatedCogs:
		m.ResetCalculatedCogs()
		return nil
	case stockmovement.FieldMetadata:
		m.ResetMetadata()
		return nil
	case stockmovement.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown StockMovement field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *StockMovementMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.product != nil {
		edges = append(edges, stockmovement.EdgeProduct)
	}
	if m.tenant != nil {
		edges = append(edges, stockmovement.EdgeTenant)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *StockMovementMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case stockmovement.EdgeProduct:
		if id := m.product; id != nil {
			return []ent.Value{*id}
		}
	case stockmovement.EdgeTenant:
		if id := m.tenant; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *StockMovementMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *StockMovementMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *StockMovementMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedproduct {
		edges = append(edges, stockmovement.EdgeProduct)
	}
	if m.clearedtenant {
		edges = append(edges, stockmovement.EdgeTenant)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *StockMovementMutation) EdgeCleared(name string) bool {
	switch name {
	case stockmovement.EdgeProduct:
		return m.clearedproduct
	case stockmovement.EdgeTenant:
		return m.clearedtenant
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *StockMovementMutation) ClearEdge(name string) error {
	switch name {
	case stockmovement.EdgeProduct:
		m.ClearProduct()
		return nil
	case stockmovement.EdgeTenant:
		m.ClearTenant()
		return nil
	}
	return fmt.Errorf("unknown StockMovement unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *StockMovementMutation) ResetEdge(name string) error {
	switch name {
	case stockmovement.EdgeProduct:
		m.ResetProduct()
		return nil
	case stockmovement.EdgeTenant:
		m.ResetTenant()
		return nil
	}
	return fmt.Errorf("unknown StockMovement edge %s", name)
}

// StrategicRoadmapMutation represents an operation that mutates the StrategicRoadmap nodes in the graph.
type StrategicRoadmapMutation struct {
	config
	op                   Op
	typ                  string
	id                   *int
	project_name         *string
	description          *string
	priority             *strategicroadmap.Priority
	status               *strategicroadmap.Status
	estimated_cost       *float64
	addestimated_cost    *float64
	target_date          *time.Time
	strategic_commentary *string
	created_at           *time.Time
	updated_at           *time.Time
	clearedFields        map[string]struct{}
	tenant               *int
	clearedtenant        bool
	done                 bool
	oldValue             func(context.Context) (*StrategicRoadmap, error)
	predicates           []predicate.StrategicRoadmap
}

var _ ent.Mutation = (*StrategicRoadmapMutation)(nil)

// strategicroadmapOption allows management of the mutation configuration using functional options.
type strategicroadmapOption func(*StrategicRoadmapMutation)

// newStrategicRoadmapMutation creates new mutation for the StrategicRoadmap entity.
func newStrategicRoadmapMutation(c config, op Op, opts ...strategicroadmapOption) *StrategicRoadmapMutation {
	m := &StrategicRoadmapMutation{
		config:        c,
		op:            op,
		typ:           TypeStrategicRoadmap,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withStrategicRoadmapID sets the ID field of the mutation.
func withStrategicRoadmapID(id int) strategicroadmapOption {
	return func(m *StrategicRoadmapMutation) {
		var (
			err   error
			once  sync.Once
			value *StrategicRoadmap
		)
		m.oldValue = func(ctx context.Context) (*StrategicRoadmap, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().StrategicRoadmap.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withStrategicRoadmap sets the old StrategicRoadmap of the mutation.
func withStrategicRoadmap(node *StrategicRoadmap) strategicroadmapOption {
	return func(m *StrategicRoadmapMutation) {
		m.oldValue = func(context.Context) (*StrategicRoadmap, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m StrategicRoadmapMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m StrategicRoadmapMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *StrategicRoadmapMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *StrategicRoadmapMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().StrategicRoadmap.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetProjectName sets the "project_name" field.
func (m *StrategicRoadmapMutation) SetProjectName(s string) {
	m.project_name = &s
}

// ProjectName returns the value of the "project_name" field in the mutation.
func (m *StrategicRoadmapMutation) ProjectName() (r string, exists bool) {
	v := m.project_name
	if v == nil {
		return
	}
	return *v, true
}

// OldProjectName returns the old "project_name" field's value of the StrategicRoadmap entity.
// If the StrategicRoadmap object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StrategicRoadmapMutation) OldProjectName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProjectName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProjectName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProjectName: %w", err)
	}
	return oldValue.ProjectName, nil
}

// ResetProjectName resets all changes to the "project_name" field.
func (m *StrategicRoadmapMutation) ResetProjectName() {
	m.project_name = nil
}

// SetDescription sets the "description" field.
func (m *StrategicRoadmapMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *StrategicRoadmapMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the StrategicRoadmap entity.
// If the StrategicRoadmap object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StrategicRoadmapMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *StrategicRoadmapMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[strategicroadmap.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *StrategicRoadmapMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[strategicroadmap.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *StrategicRoadmapMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, strategicroadmap.FieldDescription)
}

// SetPriority sets the "priority" field.
func (m *StrategicRoadmapMutation) SetPriority(s strategicroadmap.Priority) {
	m.priority = &s
}

// Priority returns the value of the "priority" field in the mutation.
func (m *StrategicRoadmapMutation) Priority() (r strategicroadmap.Priority, exists bool) {
	v := m.priority
	if v == nil {
		return
	}
	return *v, true
}

// OldPriority returns the old "priority" field's value of the StrategicRoadmap entity.
// If the StrategicRoadmap object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StrategicRoadmapMutation) OldPriority(ctx context.Context) (v strategicroadmap.Priority, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPriority is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPriority requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPriority: %w", err)
	}
	return oldValue.Priority, nil
}

// ResetPriority resets all changes to the "priority" field.
func (m *StrategicRoadmapMutation) ResetPriority() {
	m.priority = nil
}

// SetStatus sets the "status" field.
func (m *StrategicRoadmapMutation) SetStatus(s strategicroadmap.Status) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *StrategicRoadmapMutation) Status() (r strategicroadmap.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the StrategicRoadmap entity.
// If the StrategicRoadmap object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StrategicRoadmapMutation) OldStatus(ctx context.Context) (v strategicroadmap.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *StrategicRoadmapMutation) ResetStatus() {
	m.status = nil
}

// SetEstimatedCost sets the "estimated_cost" field.
func (m *StrategicRoadmapMutation) SetEstimatedCost(f float64) {
	m.estimated_cost = &f
	m.addestimated_cost = nil
}

// EstimatedCost returns the value of the "estimated_cost" field in the mutation.
func (m *StrategicRoadmapMutation) EstimatedCost() (r float64, exists bool) {
	v := m.estimated_cost
	if v == nil {
		return
	}
	return *v, true
}

// OldEstimatedCost returns the old "estimated_cost" field's value of the StrategicRoadmap entity.
// If the StrategicRoadmap object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StrategicRoadmapMutation) OldEstimatedCost(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEstimatedCost is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEstimatedCost requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEstimatedCost: %w", err)
	}
	return oldValue.EstimatedCost, nil
}

// AddEstimatedCost adds f to the "estimated_cost" field.
func (m *StrategicRoadmapMutation) AddEstimatedCost(f float64) {
	if m.addestimated_cost != nil {
		*m.addestimated_cost += f
	} else {
		m.addestimated_cost = &f
	}
}

// AddedEstimatedCost returns the value that was added to the "estimated_cost" field in this mutation.
func (m *StrategicRoadmapMutation) AddedEstimatedCost() (r float64, exists bool) {
	v := m.addestimated_cost
	if v == nil {
		return
	}
	return *v, true
}

// ResetEstimatedCost resets all changes to the "estimated_cost" field.
func (m *StrategicRoadmapMutation) ResetEstimatedCost() {
	m.estimated_cost = nil
	m.addestimated_cost = nil
}

// SetTargetDate sets the "target_date" field.
func (m *StrategicRoadmapMutation) SetTargetDate(t time.Time) {
	m.target_date = &t
}

// TargetDate returns the value of the "target_date" field in the mutation.
func (m *StrategicRoadmapMutation) TargetDate() (r time.Time, exists bool) {
	v := m.target_date
	if v == nil {
		return
	}
	return *v, true
}

// OldTargetDate returns the old "target_date" field's value of the StrategicRoadmap entity.
// If the StrategicRoadmap object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StrategicRoadmapMutation) OldTargetDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTargetDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTargetDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTargetDate: %w", err)
	}
	return oldValue.TargetDate, nil
}

// ResetTargetDate resets all changes to the "target_date" field.
func (m *StrategicRoadmapMutation) ResetTargetDate() {
	m.target_date = nil
}

// SetStrategicCommentary sets the "strategic_commentary" field.
func (m *StrategicRoadmapMutation) SetStrategicCommentary(s string) {
	m.strategic_commentary = &s
}

// StrategicCommentary returns the value of the "strategic_commentary" field in the mutation.
func (m *StrategicRoadmapMutation) StrategicCommentary() (r string, exists bool) {
	v := m.strategic_commentary
	if v == nil {
		return
	}
	return *v, true
}

// OldStrategicCommentary returns the old "strategic_commentary" field's value of the StrategicRoadmap entity.
// If the StrategicRoadmap object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StrategicRoadmapMutation) OldStrategicCommentary(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStrategicCommentary is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStrategicCommentary requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStrategicCommentary: %w", err)
	}
	return oldValue.StrategicCommentary, nil
}

// ClearStrategicCommentary clears the value of the "strategic_commentary" field.
func (m *StrategicRoadmapMutation) ClearStrategicCommentary() {
	m.strategic_commentary = nil
	m.clearedFields[strategicroadmap.FieldStrategicCommentary] = struct{}{}
}

// StrategicCommentaryCleared returns if the "strategic_commentary" field was cleared in this mutation.
func (m *StrategicRoadmapMutation) StrategicCommentaryCleared() bool {
	_, ok := m.clearedFields[strategicroadmap.FieldStrategicCommentary]
	return ok
}

// ResetStrategicCommentary resets all changes to the "strategic_commentary" field.
func (m *StrategicRoadmapMutation) ResetStrategicCommentary() {
	m.strategic_commentary = nil
	delete(m.clearedFields, strategicroadmap.FieldStrategicCommentary)
}

// SetCreatedAt sets the "created_at" field.
func (m *StrategicRoadmapMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *StrategicRoadmapMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the StrategicRoadmap entity.
// If the StrategicRoadmap object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StrategicRoadmapMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *StrategicRoadmapMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *StrategicRoadmapMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *StrategicRoadmapMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the StrategicRoadmap entity.
// If the StrategicRoadmap object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StrategicRoadmapMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *StrategicRoadmapMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetTenantID sets the "tenant" edge to the Tenant entity by id.
func (m *StrategicRoadmapMutation) SetTenantID(id int) {
	m.tenant = &id
}

// ClearTenant clears the "tenant" edge to the Tenant entity.
func (m *StrategicRoadmapMutation) ClearTenant() {
	m.clearedtenant = true
}

// TenantCleared reports if the "tenant" edge to the Tenant entity was cleared.
func (m *StrategicRoadmapMutation) TenantCleared() bool {
	return m.clearedtenant
}

// TenantID returns the "tenant" edge ID in the mutation.
func (m *StrategicRoadmapMutation) TenantID() (id int, exists bool) {
	if m.tenant != nil {
		return *m.tenant, true
	}
	return
}

// TenantIDs returns the "tenant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TenantID instead. It exists only for internal usage by the builders.
func (m *StrategicRoadmapMutation) TenantIDs() (ids []int) {
	if id := m.tenant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTenant resets all changes to the "tenant" edge.
func (m *StrategicRoadmapMutation) ResetTenant() {
	m.tenant = nil
	m.clearedtenant = false
}

// Where appends a list predicates to the StrategicRoadmapMutation builder.
func (m *StrategicRoadmapMutation) Where(ps ...predicate.StrategicRoadmap) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the StrategicRoadmapMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *StrategicRoadmapMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.StrategicRoadmap, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *StrategicRoadmapMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *StrategicRoadmapMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (StrategicRoadmap).
func (m *StrategicRoadmapMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *StrategicRoadmapMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.project_name != nil {
		fields = append(fields, strategicroadmap.FieldProjectName)
	}
	if m.description != nil {
		fields = append(fields, strategicroadmap.FieldDescription)
	}
	if m.priority != nil {
		fields = append(fields, strategicroadmap.FieldPriority)
	}
	if m.status != nil {
		fields = append(fields, strategicroadmap.FieldStatus)
	}
	if m.estimated_cost != nil {
		fields = append(fields, strategicroadmap.FieldEstimatedCost)
	}
	if m.target_date != nil {
		fields = append(fields, strategicroadmap.FieldTargetDate)
	}
	if m.strategic_commentary != nil {
		fields = append(fields, strategicroadmap.FieldStrategicCommentary)
	}
	if m.created_at != nil {
		fields = append(fields, strategicroadmap.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, strategicroadmap.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *StrategicRoadmapMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case strategicroadmap.FieldProjectName:
		return m.ProjectName()
	case strategicroadmap.FieldDescription:
		return m.Description()
	case strategicroadmap.FieldPriority:
		return m.Priority()
	case strategicroadmap.FieldStatus:
		return m.Status()
	case strategicroadmap.FieldEstimatedCost:
		return m.EstimatedCost()
	case strategicroadmap.FieldTargetDate:
		return m.TargetDate()
	case strategicroadmap.FieldStrategicCommentary:
		return m.StrategicCommentary()
	case strategicroadmap.FieldCreatedAt:
		return m.CreatedAt()
	case strategicroadmap.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *StrategicRoadmapMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case strategicroadmap.FieldProjectName:
		return m.OldProjectName(ctx)
	case strategicroadmap.FieldDescription:
		return m.OldDescription(ctx)
	case strategicroadmap.FieldPriority:
		return m.OldPriority(ctx)
	case strategicroadmap.FieldStatus:
		return m.OldStatus(ctx)
	case strategicroadmap.FieldEstimatedCost:
		return m.OldEstimatedCost(ctx)
	case strategicroadmap.FieldTargetDate:
		return m.OldTargetDate(ctx)
	case strategicroadmap.FieldStrategicCommentary:
		return m.OldStrategicCommentary(ctx)
	case strategicroadmap.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case strategicroadmap.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown StrategicRoadmap field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *StrategicRoadmapMutation) SetField(name string, value ent.Value) error {
	switch name {
	case strategicroadmap.FieldProjectName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProjectName(v)
		return nil
	case strategicroadmap.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case strategicroadmap.FieldPriority:
		v, ok := value.(strategicroadmap.Priority)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPriority(v)
		return nil
	case strategicroadmap.FieldStatus:
		v, ok := value.(strategicroadmap.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case strategicroadmap.FieldEstimatedCost:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEstimatedCost(v)
		return nil
	case strategicroadmap.FieldTargetDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTargetDate(v)
		return nil
	case strategicroadmap.FieldStrategicCommentary:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStrategicCommentary(v)
		return nil
	case strategicroadmap.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case strategicroadmap.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown StrategicRoadmap field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *StrategicRoadmapMutation) AddedFields() []string {
	var fields []string
	if m.addestimated_cost != nil {
		fields = append(fields, strategicroadmap.FieldEstimatedCost)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *StrategicRoadmapMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case strategicroadmap.FieldEstimatedCost:
		return m.AddedEstimatedCost()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *StrategicRoadmapMutation) AddField(name string, value ent.Value) error {
	switch name {
	case strategicroadmap.FieldEstimatedCost:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddEstimatedCost(v)
		return nil
	}
	return fmt.Errorf("unknown StrategicRoadmap numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *StrategicRoadmapMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(strategicroadmap.FieldDescription) {
		fields = append(fields, strategicroadmap.FieldDescription)
	}
	if m.FieldCleared(strategicroadmap.FieldStrategicCommentary) {
		fields = append(fields, strategicroadmap.FieldStrategicCommentary)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *StrategicRoadmapMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *StrategicRoadmapMutation) ClearField(name string) error {
	switch name {
	case strategicroadmap.FieldDescription:
		m.ClearDescription()
		return nil
	case strategicroadmap.FieldStrategicCommentary:
		m.ClearStrategicCommentary()
		return nil
	}
	return fmt.Errorf("unknown StrategicRoadmap nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *StrategicRoadmapMutation) ResetField(name string) error {
	switch name {
	case strategicroadmap.FieldProjectName:
		m.ResetProjectName()
		return nil
	case strategicroadmap.FieldDescription:
		m.ResetDescription()
		return nil
	case strategicroadmap.FieldPriority:
		m.ResetPriority()
		return nil
	case strategicroadmap.FieldStatus:
		m.ResetStatus()
		return nil
	case strategicroadmap.FieldEstimatedCost:
		m.ResetEstimatedCost()
		return nil
	case strategicroadmap.FieldTargetDate:
		m.ResetTargetDate()
		return nil
	case strategicroadmap.FieldStrategicCommentary:
		m.ResetStrategicCommentary()
		return nil
	case strategicroadmap.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case strategicroadmap.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown StrategicRoadmap field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *StrategicRoadmapMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.tenant != nil {
		edges = append(edges, strategicroadmap.EdgeTenant)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *StrategicRoadmapMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case strategicroadmap.EdgeTenant:
		if id := m.tenant; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *StrategicRoadmapMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *StrategicRoadmapMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *StrategicRoadmapMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedtenant {
		edges = append(edges, strategicroadmap.EdgeTenant)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *StrategicRoadmapMutation) EdgeCleared(name string) bool {
	switch name {
	case strategicroadmap.EdgeTenant:
		return m.clearedtenant
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *StrategicRoadmapMutation) ClearEdge(name string) error {
	switch name {
	case strategicroadmap.EdgeTenant:
		m.ClearTenant()
		return nil
	}
	return fmt.Errorf("unknown StrategicRoadmap unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *StrategicRoadmapMutation) ResetEdge(name string) error {
	switch name {
	case strategicroadmap.EdgeTenant:
		m.ResetTenant()
		return nil
	}
	return fmt.Errorf("unknown StrategicRoadmap edge %s", name)
}

// SuccessionMapMutation represents an operation that mutates the SuccessionMap nodes in the graph.
type SuccessionMapMutation struct {
	config
	op                      Op
	typ                     string
	id                      *int
	readiness_level         *successionmap.ReadinessLevel
	notes                   *string
	created_at              *time.Time
	clearedFields           map[string]struct{}
	employee                *int
	clearedemployee         bool
	backup_candidate        *int
	clearedbackup_candidate bool
	done                    bool
	oldValue                func(context.Context) (*SuccessionMap, error)
	predicates              []predicate.SuccessionMap
}

var _ ent.Mutation = (*SuccessionMapMutation)(nil)

// successionmapOption allows management of the mutation configuration using functional options.
type successionmapOption func(*SuccessionMapMutation)

// newSuccessionMapMutation creates new mutation for the SuccessionMap entity.
func newSuccessionMapMutation(c config, op Op, opts ...successionmapOption) *SuccessionMapMutation {
	m := &SuccessionMapMutation{
		config:        c,
		op:            op,
		typ:           TypeSuccessionMap,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSuccessionMapID sets the ID field of the mutation.
func withSuccessionMapID(id int) successionmapOption {
	return func(m *SuccessionMapMutation) {
		var (
			err   error
			once  sync.Once
			value *SuccessionMap
		)
		m.oldValue = func(ctx context.Context) (*SuccessionMap, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().SuccessionMap.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSuccessionMap sets the old SuccessionMap of the mutation.
func withSuccessionMap(node *SuccessionMap) successionmapOption {
	return func(m *SuccessionMapMutation) {
		m.oldValue = func(context.Context) (*SuccessionMap, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SuccessionMapMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SuccessionMapMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SuccessionMapMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SuccessionMapMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().SuccessionMap.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetReadinessLevel sets the "readiness_level" field.
func (m *SuccessionMapMutation) SetReadinessLevel(sl successionmap.ReadinessLevel) {
	m.readiness_level = &sl
}

// ReadinessLevel returns the value of the "readiness_level" field in the mutation.
func (m *SuccessionMapMutation) ReadinessLevel() (r successionmap.ReadinessLevel, exists bool) {
	v := m.readiness_level
	if v == nil {
		return
	}
	return *v, true
}

// OldReadinessLevel returns the old "readiness_level" field's value of the SuccessionMap entity.
// If the SuccessionMap object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SuccessionMapMutation) OldReadinessLevel(ctx context.Context) (v successionmap.ReadinessLevel, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReadinessLevel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReadinessLevel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReadinessLevel: %w", err)
	}
	return oldValue.ReadinessLevel, nil
}

// ResetReadinessLevel resets all changes to the "readiness_level" field.
func (m *SuccessionMapMutation) ResetReadinessLevel() {
	m.readiness_level = nil
}

// SetNotes sets the "notes" field.
func (m *SuccessionMapMutation) SetNotes(s string) {
	m.notes = &s
}

// Notes returns the value of the "notes" field in the mutation.
func (m *SuccessionMapMutation) Notes() (r string, exists bool) {
	v := m.notes
	if v == nil {
		return
	}
	return *v, true
}

// OldNotes returns the old "notes" field's value of the SuccessionMap entity.
// If the SuccessionMap object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SuccessionMapMutation) OldNotes(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNotes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNotes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNotes: %w", err)
	}
	return oldValue.Notes, nil
}

// ClearNotes clears the value of the "notes" field.
func (m *SuccessionMapMutation) ClearNotes() {
	m.notes = nil
	m.clearedFields[successionmap.FieldNotes] = struct{}{}
}

// NotesCleared returns if the "notes" field was cleared in this mutation.
func (m *SuccessionMapMutation) NotesCleared() bool {
	_, ok := m.clearedFields[successionmap.FieldNotes]
	return ok
}

// ResetNotes resets all changes to the "notes" field.
func (m *SuccessionMapMutation) ResetNotes() {
	m.notes = nil
	delete(m.clearedFields, successionmap.FieldNotes)
}

// SetCreatedAt sets the "created_at" field.
func (m *SuccessionMapMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *SuccessionMapMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the SuccessionMap entity.
// If the SuccessionMap object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SuccessionMapMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *SuccessionMapMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetEmployeeID sets the "employee" edge to the Employee entity by id.
func (m *SuccessionMapMutation) SetEmployeeID(id int) {
	m.employee = &id
}

// ClearEmployee clears the "employee" edge to the Employee entity.
func (m *SuccessionMapMutation) ClearEmployee() {
	m.clearedemployee = true
}

// EmployeeCleared reports if the "employee" edge to the Employee entity was cleared.
func (m *SuccessionMapMutation) EmployeeCleared() bool {
	return m.clearedemployee
}

// EmployeeID returns the "employee" edge ID in the mutation.
func (m *SuccessionMapMutation) EmployeeID() (id int, exists bool) {
	if m.employee != nil {
		return *m.employee, true
	}
	return
}

// EmployeeIDs returns the "employee" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// EmployeeID instead. It exists only for internal usage by the builders.
func (m *SuccessionMapMutation) EmployeeIDs() (ids []int) {
	if id := m.employee; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEmployee resets all changes to the "employee" edge.
func (m *SuccessionMapMutation) ResetEmployee() {
	m.employee = nil
	m.clearedemployee = false
}

// SetBackupCandidateID sets the "backup_candidate" edge to the Employee entity by id.
func (m *SuccessionMapMutation) SetBackupCandidateID(id int) {
	m.backup_candidate = &id
}

// ClearBackupCandidate clears the "backup_candidate" edge to the Employee entity.
func (m *SuccessionMapMutation) ClearBackupCandidate() {
	m.clearedbackup_candidate = true
}

// BackupCandidateCleared reports if the "backup_candidate" edge to the Employee entity was cleared.
func (m *SuccessionMapMutation) BackupCandidateCleared() bool {
	return m.clearedbackup_candidate
}

// BackupCandidateID returns the "backup_candidate" edge ID in the mutation.
func (m *SuccessionMapMutation) BackupCandidateID() (id int, exists bool) {
	if m.backup_candidate != nil {
		return *m.backup_candidate, true
	}
	return
}

// BackupCandidateIDs returns the "backup_candidate" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BackupCandidateID instead. It exists only for internal usage by the builders.
func (m *SuccessionMapMutation) BackupCandidateIDs() (ids []int) {
	if id := m.backup_candidate; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBackupCandidate resets all changes to the "backup_candidate" edge.
func (m *SuccessionMapMutation) ResetBackupCandidate() {
	m.backup_candidate = nil
	m.clearedbackup_candidate = false
}

// Where appends a list predicates to the SuccessionMapMutation builder.
func (m *SuccessionMapMutation) Where(ps ...predicate.SuccessionMap) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SuccessionMapMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SuccessionMapMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.SuccessionMap, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SuccessionMapMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SuccessionMapMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (SuccessionMap).
func (m *SuccessionMapMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SuccessionMapMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.readiness_level != nil {
		fields = append(fields, successionmap.FieldReadinessLevel)
	}
	if m.notes != nil {
		fields = append(fields, successionmap.FieldNotes)
	}
	if m.created_at != nil {
		fields = append(fields, successionmap.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SuccessionMapMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case successionmap.FieldReadinessLevel:
		return m.ReadinessLevel()
	case successionmap.FieldNotes:
		return m.Notes()
	case successionmap.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SuccessionMapMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case successionmap.FieldReadinessLevel:
		return m.OldReadinessLevel(ctx)
	case successionmap.FieldNotes:
		return m.OldNotes(ctx)
	case successionmap.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown SuccessionMap field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SuccessionMapMutation) SetField(name string, value ent.Value) error {
	switch name {
	case successionmap.FieldReadinessLevel:
		v, ok := value.(successionmap.ReadinessLevel)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReadinessLevel(v)
		return nil
	case successionmap.FieldNotes:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNotes(v)
		return nil
	case successionmap.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown SuccessionMap field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SuccessionMapMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SuccessionMapMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SuccessionMapMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown SuccessionMap numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SuccessionMapMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(successionmap.FieldNotes) {
		fields = append(fields, successionmap.FieldNotes)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SuccessionMapMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SuccessionMapMutation) ClearField(name string) error {
	switch name {
	case successionmap.FieldNotes:
		m.ClearNotes()
		return nil
	}
	return fmt.Errorf("unknown SuccessionMap nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SuccessionMapMutation) ResetField(name string) error {
	switch name {
	case successionmap.FieldReadinessLevel:
		m.ResetReadinessLevel()
		return nil
	case successionmap.FieldNotes:
		m.ResetNotes()
		return nil
	case successionmap.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown SuccessionMap field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SuccessionMapMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.employee != nil {
		edges = append(edges, successionmap.EdgeEmployee)
	}
	if m.backup_candidate != nil {
		edges = append(edges, successionmap.EdgeBackupCandidate)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SuccessionMapMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case successionmap.EdgeEmployee:
		if id := m.employee; id != nil {
			return []ent.Value{*id}
		}
	case successionmap.EdgeBackupCandidate:
		if id := m.backup_candidate; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SuccessionMapMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SuccessionMapMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SuccessionMapMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedemployee {
		edges = append(edges, successionmap.EdgeEmployee)
	}
	if m.clearedbackup_candidate {
		edges = append(edges, successionmap.EdgeBackupCandidate)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SuccessionMapMutation) EdgeCleared(name string) bool {
	switch name {
	case successionmap.EdgeEmployee:
		return m.clearedemployee
	case successionmap.EdgeBackupCandidate:
		return m.clearedbackup_candidate
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SuccessionMapMutation) ClearEdge(name string) error {
	switch name {
	case successionmap.EdgeEmployee:
		m.ClearEmployee()
		return nil
	case successionmap.EdgeBackupCandidate:
		m.ClearBackupCandidate()
		return nil
	}
	return fmt.Errorf("unknown SuccessionMap unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SuccessionMapMutation) ResetEdge(name string) error {
	switch name {
	case successionmap.EdgeEmployee:
		m.ResetEmployee()
		return nil
	case successionmap.EdgeBackupCandidate:
		m.ResetBackupCandidate()
		return nil
	}
	return fmt.Errorf("unknown SuccessionMap edge %s", name)
}

// TenantMutation represents an operation that mutates the Tenant nodes in the graph.
type TenantMutation struct {
	config
	op                             Op
	typ                            string
	id                             *int
	name                           *string
	domain                         *string
	created_at                     *time.Time
	active                         *bool
	transaction_limit              *float64
	addtransaction_limit           *float64
	clearedFields                  map[string]struct{}
	parent                         *int
	clearedparent                  bool
	children                       map[int]struct{}
	removedchildren                map[int]struct{}
	clearedchildren                bool
	users                          map[int]struct{}
	removedusers                   map[int]struct{}
	clearedusers                   bool
	accounts                       map[int]struct{}
	removedaccounts                map[int]struct{}
	clearedaccounts                bool
	transactions                   map[int]struct{}
	removedtransactions            map[int]struct{}
	clearedtransactions            bool
	ledger_entries                 map[int]struct{}
	removedledger_entries          map[int]struct{}
	clearedledger_entries          bool
	products                       map[int]struct{}
	removedproducts                map[int]struct{}
	clearedproducts                bool
	stock_movements                map[int]struct{}
	removedstock_movements         map[int]struct{}
	clearedstock_movements         bool
	audit_logs                     map[int]struct{}
	removedaudit_logs              map[int]struct{}
	clearedaudit_logs              bool
	agents                         map[int]struct{}
	removedagents                  map[int]struct{}
	clearedagents                  bool
	discovery_entries              map[int]struct{}
	removeddiscovery_entries       map[int]struct{}
	cleareddiscovery_entries       bool
	assets                         map[int]struct{}
	removedassets                  map[int]struct{}
	clearedassets                  bool
	credentials                    map[int]struct{}
	removedcredentials             map[int]struct{}
	clearedcredentials             bool
	one_time_links                 map[int]struct{}
	removedone_time_links          map[int]struct{}
	clearedone_time_links          bool
	sops                           map[int]struct{}
	removedsops                    map[int]struct{}
	clearedsops                    bool
	cameras                        map[int]struct{}
	removedcameras                 map[int]struct{}
	clearedcameras                 bool
	tickets                        map[int]struct{}
	removedtickets                 map[int]struct{}
	clearedtickets                 bool
	contracts                      map[int]struct{}
	removedcontracts               map[int]struct{}
	clearedcontracts               bool
	saas_apps                      map[int]struct{}
	removedsaas_apps               map[int]struct{}
	clearedsaas_apps               bool
	saas_filters                   map[int]struct{}
	removedsaas_filters            map[int]struct{}
	clearedsaas_filters            bool
	call_logs                      map[int]struct{}
	removedcall_logs               map[int]struct{}
	clearedcall_logs               bool
	ivr_flows                      map[int]struct{}
	removedivr_flows               map[int]struct{}
	clearedivr_flows               bool
	voicemails                     map[int]struct{}
	removedvoicemails              map[int]struct{}
	clearedvoicemails              bool
	health_snapshots               map[int]struct{}
	removedhealth_snapshots        map[int]struct{}
	clearedhealth_snapshots        bool
	roadmaps                       map[int]struct{}
	removedroadmaps                map[int]struct{}
	clearedroadmaps                bool
	service_rates                  map[int]struct{}
	removedservice_rates           map[int]struct{}
	clearedservice_rates           bool
	budget_forecasts               map[int]struct{}
	removedbudget_forecasts        map[int]struct{}
	clearedbudget_forecasts        bool
	employees                      map[int]struct{}
	removedemployees               map[int]struct{}
	clearedemployees               bool
	compensation_agreements        map[int]struct{}
	removedcompensation_agreements map[int]struct{}
	clearedcompensation_agreements bool
	vault_items                    map[int]struct{}
	removedvault_items             map[int]struct{}
	clearedvault_items             bool
	journal_entries                map[int]struct{}
	removedjournal_entries         map[int]struct{}
	clearedjournal_entries         bool
	recurring_invoices             map[int]struct{}
	removedrecurring_invoices      map[int]struct{}
	clearedrecurring_invoices      bool
	inventory_reservations         map[int]struct{}
	removedinventory_reservations  map[int]struct{}
	clearedinventory_reservations  bool
	customer_account               *int
	clearedcustomer_account        bool
	done                           bool
	oldValue                       func(context.Context) (*Tenant, error)
	predicates                     []predicate.Tenant
}

var _ ent.Mutation = (*TenantMutation)(nil)

// tenantOption allows management of the mutation configuration using functional options.
type tenantOption func(*TenantMutation)

// newTenantMutation creates new mutation for the Tenant entity.
func newTenantMutation(c config, op Op, opts ...tenantOption) *TenantMutation {
	m := &TenantMutation{
		config:        c,
		op:            op,
		typ:           TypeTenant,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTenantID sets the ID field of the mutation.
func withTenantID(id int) tenantOption {
	return func(m *TenantMutation) {
		var (
			err   error
			once  sync.Once
			value *Tenant
		)
		m.oldValue = func(ctx context.Context) (*Tenant, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Tenant.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTenant sets the old Tenant of the mutation.
func withTenant(node *Tenant) tenantOption {
	return func(m *TenantMutation) {
		m.oldValue = func(context.Context) (*Tenant, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TenantMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TenantMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TenantMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TenantMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Tenant.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *TenantMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *TenantMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Tenant entity.
// If the Tenant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenantMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *TenantMutation) ResetName() {
	m.name = nil
}

// SetDomain sets the "domain" field.
func (m *TenantMutation) SetDomain(s string) {
	m.domain = &s
}

// Domain returns the value of the "domain" field in the mutation.
func (m *TenantMutation) Domain() (r string, exists bool) {
	v := m.domain
	if v == nil {
		return
	}
	return *v, true
}

// OldDomain returns the old "domain" field's value of the Tenant entity.
// If the Tenant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenantMutation) OldDomain(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDomain is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDomain requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDomain: %w", err)
	}
	return oldValue.Domain, nil
}

// ResetDomain resets all changes to the "domain" field.
func (m *TenantMutation) ResetDomain() {
	m.domain = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *TenantMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *TenantMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Tenant entity.
// If the Tenant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenantMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *TenantMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetActive sets the "active" field.
func (m *TenantMutation) SetActive(b bool) {
	m.active = &b
}

// Active returns the value of the "active" field in the mutation.
func (m *TenantMutation) Active() (r bool, exists bool) {
	v := m.active
	if v == nil {
		return
	}
	return *v, true
}

// OldActive returns the old "active" field's value of the Tenant entity.
// If the Tenant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenantMutation) OldActive(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldActive is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldActive requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldActive: %w", err)
	}
	return oldValue.Active, nil
}

// ResetActive resets all changes to the "active" field.
func (m *TenantMutation) ResetActive() {
	m.active = nil
}

// SetTransactionLimit sets the "transaction_limit" field.
func (m *TenantMutation) SetTransactionLimit(f float64) {
	m.transaction_limit = &f
	m.addtransaction_limit = nil
}

// TransactionLimit returns the value of the "transaction_limit" field in the mutation.
func (m *TenantMutation) TransactionLimit() (r float64, exists bool) {
	v := m.transaction_limit
	if v == nil {
		return
	}
	return *v, true
}

// OldTransactionLimit returns the old "transaction_limit" field's value of the Tenant entity.
// If the Tenant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenantMutation) OldTransactionLimit(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTransactionLimit is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTransactionLimit requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTransactionLimit: %w", err)
	}
	return oldValue.TransactionLimit, nil
}

// AddTransactionLimit adds f to the "transaction_limit" field.
func (m *TenantMutation) AddTransactionLimit(f float64) {
	if m.addtransaction_limit != nil {
		*m.addtransaction_limit += f
	} else {
		m.addtransaction_limit = &f
	}
}

// AddedTransactionLimit returns the value that was added to the "transaction_limit" field in this mutation.
func (m *TenantMutation) AddedTransactionLimit() (r float64, exists bool) {
	v := m.addtransaction_limit
	if v == nil {
		return
	}
	return *v, true
}

// ResetTransactionLimit resets all changes to the "transaction_limit" field.
func (m *TenantMutation) ResetTransactionLimit() {
	m.transaction_limit = nil
	m.addtransaction_limit = nil
}

// SetParentID sets the "parent" edge to the Tenant entity by id.
func (m *TenantMutation) SetParentID(id int) {
	m.parent = &id
}

// ClearParent clears the "parent" edge to the Tenant entity.
func (m *TenantMutation) ClearParent() {
	m.clearedparent = true
}

// ParentCleared reports if the "parent" edge to the Tenant entity was cleared.
func (m *TenantMutation) ParentCleared() bool {
	return m.clearedparent
}

// ParentID returns the "parent" edge ID in the mutation.
func (m *TenantMutation) ParentID() (id int, exists bool) {
	if m.parent != nil {
		return *m.parent, true
	}
	return
}

// ParentIDs returns the "parent" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ParentID instead. It exists only for internal usage by the builders.
func (m *TenantMutation) ParentIDs() (ids []int) {
	if id := m.parent; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetParent resets all changes to the "parent" edge.
func (m *TenantMutation) ResetParent() {
	m.parent = nil
	m.clearedparent = false
}

// AddChildIDs adds the "children" edge to the Tenant entity by ids.
func (m *TenantMutation) AddChildIDs(ids ...int) {
	if m.children == nil {
		m.children = make(map[int]struct{})
	}
	for i := range ids {
		m.children[ids[i]] = struct{}{}
	}
}

// ClearChildren clears the "children" edge to the Tenant entity.
func (m *TenantMutation) ClearChildren() {
	m.clearedchildren = true
}

// ChildrenCleared reports if the "children" edge to the Tenant entity was cleared.
func (m *TenantMutation) ChildrenCleared() bool {
	return m.clearedchildren
}

// RemoveChildIDs removes the "children" edge to the Tenant entity by IDs.
func (m *TenantMutation) RemoveChildIDs(ids ...int) {
	if m.removedchildren == nil {
		m.removedchildren = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.children, ids[i])
		m.removedchildren[ids[i]] = struct{}{}
	}
}

// RemovedChildren returns the removed IDs of the "children" edge to the Tenant entity.
func (m *TenantMutation) RemovedChildrenIDs() (ids []int) {
	for id := range m.removedchildren {
		ids = append(ids, id)
	}
	return
}

// ChildrenIDs returns the "children" edge IDs in the mutation.
func (m *TenantMutation) ChildrenIDs() (ids []int) {
	for id := range m.children {
		ids = append(ids, id)
	}
	return
}

// ResetChildren resets all changes to the "children" edge.
func (m *TenantMutation) ResetChildren() {
	m.children = nil
	m.clearedchildren = false
	m.removedchildren = nil
}

// AddUserIDs adds the "users" edge to the User entity by ids.
func (m *TenantMutation) AddUserIDs(ids ...int) {
	if m.users == nil {
		m.users = make(map[int]struct{})
	}
	for i := range ids {
		m.users[ids[i]] = struct{}{}
	}
}

// ClearUsers clears the "users" edge to the User entity.
func (m *TenantMutation) ClearUsers() {
	m.clearedusers = true
}

// UsersCleared reports if the "users" edge to the User entity was cleared.
func (m *TenantMutation) UsersCleared() bool {
	return m.clearedusers
}

// RemoveUserIDs removes the "users" edge to the User entity by IDs.
func (m *TenantMutation) RemoveUserIDs(ids ...int) {
	if m.removedusers == nil {
		m.removedusers = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.users, ids[i])
		m.removedusers[ids[i]] = struct{}{}
	}
}

// RemovedUsers returns the removed IDs of the "users" edge to the User entity.
func (m *TenantMutation) RemovedUsersIDs() (ids []int) {
	for id := range m.removedusers {
		ids = append(ids, id)
	}
	return
}

// UsersIDs returns the "users" edge IDs in the mutation.
func (m *TenantMutation) UsersIDs() (ids []int) {
	for id := range m.users {
		ids = append(ids, id)
	}
	return
}

// ResetUsers resets all changes to the "users" edge.
func (m *TenantMutation) ResetUsers() {
	m.users = nil
	m.clearedusers = false
	m.removedusers = nil
}

// AddAccountIDs adds the "accounts" edge to the Account entity by ids.
func (m *TenantMutation) AddAccountIDs(ids ...int) {
	if m.accounts == nil {
		m.accounts = make(map[int]struct{})
	}
	for i := range ids {
		m.accounts[ids[i]] = struct{}{}
	}
}

// ClearAccounts clears the "accounts" edge to the Account entity.
func (m *TenantMutation) ClearAccounts() {
	m.clearedaccounts = true
}

// AccountsCleared reports if the "accounts" edge to the Account entity was cleared.
func (m *TenantMutation) AccountsCleared() bool {
	return m.clearedaccounts
}

// RemoveAccountIDs removes the "accounts" edge to the Account entity by IDs.
func (m *TenantMutation) RemoveAccountIDs(ids ...int) {
	if m.removedaccounts == nil {
		m.removedaccounts = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.accounts, ids[i])
		m.removedaccounts[ids[i]] = struct{}{}
	}
}

// RemovedAccounts returns the removed IDs of the "accounts" edge to the Account entity.
func (m *TenantMutation) RemovedAccountsIDs() (ids []int) {
	for id := range m.removedaccounts {
		ids = append(ids, id)
	}
	return
}

// AccountsIDs returns the "accounts" edge IDs in the mutation.
func (m *TenantMutation) AccountsIDs() (ids []int) {
	for id := range m.accounts {
		ids = append(ids, id)
	}
	return
}

// ResetAccounts resets all changes to the "accounts" edge.
func (m *TenantMutation) ResetAccounts() {
	m.accounts = nil
	m.clearedaccounts = false
	m.removedaccounts = nil
}

// AddTransactionIDs adds the "transactions" edge to the Transaction entity by ids.
func (m *TenantMutation) AddTransactionIDs(ids ...int) {
	if m.transactions == nil {
		m.transactions = make(map[int]struct{})
	}
	for i := range ids {
		m.transactions[ids[i]] = struct{}{}
	}
}

// ClearTransactions clears the "transactions" edge to the Transaction entity.
func (m *TenantMutation) ClearTransactions() {
	m.clearedtransactions = true
}

// TransactionsCleared reports if the "transactions" edge to the Transaction entity was cleared.
func (m *TenantMutation) TransactionsCleared() bool {
	return m.clearedtransactions
}

// RemoveTransactionIDs removes the "transactions" edge to the Transaction entity by IDs.
func (m *TenantMutation) RemoveTransactionIDs(ids ...int) {
	if m.removedtransactions == nil {
		m.removedtransactions = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.transactions, ids[i])
		m.removedtransactions[ids[i]] = struct{}{}
	}
}

// RemovedTransactions returns the removed IDs of the "transactions" edge to the Transaction entity.
func (m *TenantMutation) RemovedTransactionsIDs() (ids []int) {
	for id := range m.removedtransactions {
		ids = append(ids, id)
	}
	return
}

// TransactionsIDs returns the "transactions" edge IDs in the mutation.
func (m *TenantMutation) TransactionsIDs() (ids []int) {
	for id := range m.transactions {
		ids = append(ids, id)
	}
	return
}

// ResetTransactions resets all changes to the "transactions" edge.
func (m *TenantMutation) ResetTransactions() {
	m.transactions = nil
	m.clearedtransactions = false
	m.removedtransactions = nil
}

// AddLedgerEntryIDs adds the "ledger_entries" edge to the LedgerEntry entity by ids.
func (m *TenantMutation) AddLedgerEntryIDs(ids ...int) {
	if m.ledger_entries == nil {
		m.ledger_entries = make(map[int]struct{})
	}
	for i := range ids {
		m.ledger_entries[ids[i]] = struct{}{}
	}
}

// ClearLedgerEntries clears the "ledger_entries" edge to the LedgerEntry entity.
func (m *TenantMutation) ClearLedgerEntries() {
	m.clearedledger_entries = true
}

// LedgerEntriesCleared reports if the "ledger_entries" edge to the LedgerEntry entity was cleared.
func (m *TenantMutation) LedgerEntriesCleared() bool {
	return m.clearedledger_entries
}

// RemoveLedgerEntryIDs removes the "ledger_entries" edge to the LedgerEntry entity by IDs.
func (m *TenantMutation) RemoveLedgerEntryIDs(ids ...int) {
	if m.removedledger_entries == nil {
		m.removedledger_entries = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.ledger_entries, ids[i])
		m.removedledger_entries[ids[i]] = struct{}{}
	}
}

// RemovedLedgerEntries returns the removed IDs of the "ledger_entries" edge to the LedgerEntry entity.
func (m *TenantMutation) RemovedLedgerEntriesIDs() (ids []int) {
	for id := range m.removedledger_entries {
		ids = append(ids, id)
	}
	return
}

// LedgerEntriesIDs returns the "ledger_entries" edge IDs in the mutation.
func (m *TenantMutation) LedgerEntriesIDs() (ids []int) {
	for id := range m.ledger_entries {
		ids = append(ids, id)
	}
	return
}

// ResetLedgerEntries resets all changes to the "ledger_entries" edge.
func (m *TenantMutation) ResetLedgerEntries() {
	m.ledger_entries = nil
	m.clearedledger_entries = false
	m.removedledger_entries = nil
}

// AddProductIDs adds the "products" edge to the Product entity by ids.
func (m *TenantMutation) AddProductIDs(ids ...int) {
	if m.products == nil {
		m.products = make(map[int]struct{})
	}
	for i := range ids {
		m.products[ids[i]] = struct{}{}
	}
}

// ClearProducts clears the "products" edge to the Product entity.
func (m *TenantMutation) ClearProducts() {
	m.clearedproducts = true
}

// ProductsCleared reports if the "products" edge to the Product entity was cleared.
func (m *TenantMutation) ProductsCleared() bool {
	return m.clearedproducts
}

// RemoveProductIDs removes the "products" edge to the Product entity by IDs.
func (m *TenantMutation) RemoveProductIDs(ids ...int) {
	if m.removedproducts == nil {
		m.removedproducts = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.products, ids[i])
		m.removedproducts[ids[i]] = struct{}{}
	}
}

// RemovedProducts returns the removed IDs of the "products" edge to the Product entity.
func (m *TenantMutation) RemovedProductsIDs() (ids []int) {
	for id := range m.removedproducts {
		ids = append(ids, id)
	}
	return
}

// ProductsIDs returns the "products" edge IDs in the mutation.
func (m *TenantMutation) ProductsIDs() (ids []int) {
	for id := range m.products {
		ids = append(ids, id)
	}
	return
}

// ResetProducts resets all changes to the "products" edge.
func (m *TenantMutation) ResetProducts() {
	m.products = nil
	m.clearedproducts = false
	m.removedproducts = nil
}

// AddStockMovementIDs adds the "stock_movements" edge to the StockMovement entity by ids.
func (m *TenantMutation) AddStockMovementIDs(ids ...int) {
	if m.stock_movements == nil {
		m.stock_movements = make(map[int]struct{})
	}
	for i := range ids {
		m.stock_movements[ids[i]] = struct{}{}
	}
}

// ClearStockMovements clears the "stock_movements" edge to the StockMovement entity.
func (m *TenantMutation) ClearStockMovements() {
	m.clearedstock_movements = true
}

// StockMovementsCleared reports if the "stock_movements" edge to the StockMovement entity was cleared.
func (m *TenantMutation) StockMovementsCleared() bool {
	return m.clearedstock_movements
}

// RemoveStockMovementIDs removes the "stock_movements" edge to the StockMovement entity by IDs.
func (m *TenantMutation) RemoveStockMovementIDs(ids ...int) {
	if m.removedstock_movements == nil {
		m.removedstock_movements = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.stock_movements, ids[i])
		m.removedstock_movements[ids[i]] = struct{}{}
	}
}

// RemovedStockMovements returns the removed IDs of the "stock_movements" edge to the StockMovement entity.
func (m *TenantMutation) RemovedStockMovementsIDs() (ids []int) {
	for id := range m.removedstock_movements {
		ids = append(ids, id)
	}
	return
}

// StockMovementsIDs returns the "stock_movements" edge IDs in the mutation.
func (m *TenantMutation) StockMovementsIDs() (ids []int) {
	for id := range m.stock_movements {
		ids = append(ids, id)
	}
	return
}

// ResetStockMovements resets all changes to the "stock_movements" edge.
func (m *TenantMutation) ResetStockMovements() {
	m.stock_movements = nil
	m.clearedstock_movements = false
	m.removedstock_movements = nil
}

// AddAuditLogIDs adds the "audit_logs" edge to the AuditLog entity by ids.
func (m *TenantMutation) AddAuditLogIDs(ids ...int) {
	if m.audit_logs == nil {
		m.audit_logs = make(map[int]struct{})
	}
	for i := range ids {
		m.audit_logs[ids[i]] = struct{}{}
	}
}

// ClearAuditLogs clears the "audit_logs" edge to the AuditLog entity.
func (m *TenantMutation) ClearAuditLogs() {
	m.clearedaudit_logs = true
}

// AuditLogsCleared reports if the "audit_logs" edge to the AuditLog entity was cleared.
func (m *TenantMutation) AuditLogsCleared() bool {
	return m.clearedaudit_logs
}

// RemoveAuditLogIDs removes the "audit_logs" edge to the AuditLog entity by IDs.
func (m *TenantMutation) RemoveAuditLogIDs(ids ...int) {
	if m.removedaudit_logs == nil {
		m.removedaudit_logs = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.audit_logs, ids[i])
		m.removedaudit_logs[ids[i]] = struct{}{}
	}
}

// RemovedAuditLogs returns the removed IDs of the "audit_logs" edge to the AuditLog entity.
func (m *TenantMutation) RemovedAuditLogsIDs() (ids []int) {
	for id := range m.removedaudit_logs {
		ids = append(ids, id)
	}
	return
}

// AuditLogsIDs returns the "audit_logs" edge IDs in the mutation.
func (m *TenantMutation) AuditLogsIDs() (ids []int) {
	for id := range m.audit_logs {
		ids = append(ids, id)
	}
	return
}

// ResetAuditLogs resets all changes to the "audit_logs" edge.
func (m *TenantMutation) ResetAuditLogs() {
	m.audit_logs = nil
	m.clearedaudit_logs = false
	m.removedaudit_logs = nil
}

// AddAgentIDs adds the "agents" edge to the Agent entity by ids.
func (m *TenantMutation) AddAgentIDs(ids ...int) {
	if m.agents == nil {
		m.agents = make(map[int]struct{})
	}
	for i := range ids {
		m.agents[ids[i]] = struct{}{}
	}
}

// ClearAgents clears the "agents" edge to the Agent entity.
func (m *TenantMutation) ClearAgents() {
	m.clearedagents = true
}

// AgentsCleared reports if the "agents" edge to the Agent entity was cleared.
func (m *TenantMutation) AgentsCleared() bool {
	return m.clearedagents
}

// RemoveAgentIDs removes the "agents" edge to the Agent entity by IDs.
func (m *TenantMutation) RemoveAgentIDs(ids ...int) {
	if m.removedagents == nil {
		m.removedagents = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.agents, ids[i])
		m.removedagents[ids[i]] = struct{}{}
	}
}

// RemovedAgents returns the removed IDs of the "agents" edge to the Agent entity.
func (m *TenantMutation) RemovedAgentsIDs() (ids []int) {
	for id := range m.removedagents {
		ids = append(ids, id)
	}
	return
}

// AgentsIDs returns the "agents" edge IDs in the mutation.
func (m *TenantMutation) AgentsIDs() (ids []int) {
	for id := range m.agents {
		ids = append(ids, id)
	}
	return
}

// ResetAgents resets all changes to the "agents" edge.
func (m *TenantMutation) ResetAgents() {
	m.agents = nil
	m.clearedagents = false
	m.removedagents = nil
}

// AddDiscoveryEntryIDs adds the "discovery_entries" edge to the DiscoveryEntry entity by ids.
func (m *TenantMutation) AddDiscoveryEntryIDs(ids ...int) {
	if m.discovery_entries == nil {
		m.discovery_entries = make(map[int]struct{})
	}
	for i := range ids {
		m.discovery_entries[ids[i]] = struct{}{}
	}
}

// ClearDiscoveryEntries clears the "discovery_entries" edge to the DiscoveryEntry entity.
func (m *TenantMutation) ClearDiscoveryEntries() {
	m.cleareddiscovery_entries = true
}

// DiscoveryEntriesCleared reports if the "discovery_entries" edge to the DiscoveryEntry entity was cleared.
func (m *TenantMutation) DiscoveryEntriesCleared() bool {
	return m.cleareddiscovery_entries
}

// RemoveDiscoveryEntryIDs removes the "discovery_entries" edge to the DiscoveryEntry entity by IDs.
func (m *TenantMutation) RemoveDiscoveryEntryIDs(ids ...int) {
	if m.removeddiscovery_entries == nil {
		m.removeddiscovery_entries = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.discovery_entries, ids[i])
		m.removeddiscovery_entries[ids[i]] = struct{}{}
	}
}

// RemovedDiscoveryEntries returns the removed IDs of the "discovery_entries" edge to the DiscoveryEntry entity.
func (m *TenantMutation) RemovedDiscoveryEntriesIDs() (ids []int) {
	for id := range m.removeddiscovery_entries {
		ids = append(ids, id)
	}
	return
}

// DiscoveryEntriesIDs returns the "discovery_entries" edge IDs in the mutation.
func (m *TenantMutation) DiscoveryEntriesIDs() (ids []int) {
	for id := range m.discovery_entries {
		ids = append(ids, id)
	}
	return
}

// ResetDiscoveryEntries resets all changes to the "discovery_entries" edge.
func (m *TenantMutation) ResetDiscoveryEntries() {
	m.discovery_entries = nil
	m.cleareddiscovery_entries = false
	m.removeddiscovery_entries = nil
}

// AddAssetIDs adds the "assets" edge to the Asset entity by ids.
func (m *TenantMutation) AddAssetIDs(ids ...int) {
	if m.assets == nil {
		m.assets = make(map[int]struct{})
	}
	for i := range ids {
		m.assets[ids[i]] = struct{}{}
	}
}

// ClearAssets clears the "assets" edge to the Asset entity.
func (m *TenantMutation) ClearAssets() {
	m.clearedassets = true
}

// AssetsCleared reports if the "assets" edge to the Asset entity was cleared.
func (m *TenantMutation) AssetsCleared() bool {
	return m.clearedassets
}

// RemoveAssetIDs removes the "assets" edge to the Asset entity by IDs.
func (m *TenantMutation) RemoveAssetIDs(ids ...int) {
	if m.removedassets == nil {
		m.removedassets = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.assets, ids[i])
		m.removedassets[ids[i]] = struct{}{}
	}
}

// RemovedAssets returns the removed IDs of the "assets" edge to the Asset entity.
func (m *TenantMutation) RemovedAssetsIDs() (ids []int) {
	for id := range m.removedassets {
		ids = append(ids, id)
	}
	return
}

// AssetsIDs returns the "assets" edge IDs in the mutation.
func (m *TenantMutation) AssetsIDs() (ids []int) {
	for id := range m.assets {
		ids = append(ids, id)
	}
	return
}

// ResetAssets resets all changes to the "assets" edge.
func (m *TenantMutation) ResetAssets() {
	m.assets = nil
	m.clearedassets = false
	m.removedassets = nil
}

// AddCredentialIDs adds the "credentials" edge to the Credential entity by ids.
func (m *TenantMutation) AddCredentialIDs(ids ...int) {
	if m.credentials == nil {
		m.credentials = make(map[int]struct{})
	}
	for i := range ids {
		m.credentials[ids[i]] = struct{}{}
	}
}

// ClearCredentials clears the "credentials" edge to the Credential entity.
func (m *TenantMutation) ClearCredentials() {
	m.clearedcredentials = true
}

// CredentialsCleared reports if the "credentials" edge to the Credential entity was cleared.
func (m *TenantMutation) CredentialsCleared() bool {
	return m.clearedcredentials
}

// RemoveCredentialIDs removes the "credentials" edge to the Credential entity by IDs.
func (m *TenantMutation) RemoveCredentialIDs(ids ...int) {
	if m.removedcredentials == nil {
		m.removedcredentials = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.credentials, ids[i])
		m.removedcredentials[ids[i]] = struct{}{}
	}
}

// RemovedCredentials returns the removed IDs of the "credentials" edge to the Credential entity.
func (m *TenantMutation) RemovedCredentialsIDs() (ids []int) {
	for id := range m.removedcredentials {
		ids = append(ids, id)
	}
	return
}

// CredentialsIDs returns the "credentials" edge IDs in the mutation.
func (m *TenantMutation) CredentialsIDs() (ids []int) {
	for id := range m.credentials {
		ids = append(ids, id)
	}
	return
}

// ResetCredentials resets all changes to the "credentials" edge.
func (m *TenantMutation) ResetCredentials() {
	m.credentials = nil
	m.clearedcredentials = false
	m.removedcredentials = nil
}

// AddOneTimeLinkIDs adds the "one_time_links" edge to the OneTimeLink entity by ids.
func (m *TenantMutation) AddOneTimeLinkIDs(ids ...int) {
	if m.one_time_links == nil {
		m.one_time_links = make(map[int]struct{})
	}
	for i := range ids {
		m.one_time_links[ids[i]] = struct{}{}
	}
}

// ClearOneTimeLinks clears the "one_time_links" edge to the OneTimeLink entity.
func (m *TenantMutation) ClearOneTimeLinks() {
	m.clearedone_time_links = true
}

// OneTimeLinksCleared reports if the "one_time_links" edge to the OneTimeLink entity was cleared.
func (m *TenantMutation) OneTimeLinksCleared() bool {
	return m.clearedone_time_links
}

// RemoveOneTimeLinkIDs removes the "one_time_links" edge to the OneTimeLink entity by IDs.
func (m *TenantMutation) RemoveOneTimeLinkIDs(ids ...int) {
	if m.removedone_time_links == nil {
		m.removedone_time_links = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.one_time_links, ids[i])
		m.removedone_time_links[ids[i]] = struct{}{}
	}
}

// RemovedOneTimeLinks returns the removed IDs of the "one_time_links" edge to the OneTimeLink entity.
func (m *TenantMutation) RemovedOneTimeLinksIDs() (ids []int) {
	for id := range m.removedone_time_links {
		ids = append(ids, id)
	}
	return
}

// OneTimeLinksIDs returns the "one_time_links" edge IDs in the mutation.
func (m *TenantMutation) OneTimeLinksIDs() (ids []int) {
	for id := range m.one_time_links {
		ids = append(ids, id)
	}
	return
}

// ResetOneTimeLinks resets all changes to the "one_time_links" edge.
func (m *TenantMutation) ResetOneTimeLinks() {
	m.one_time_links = nil
	m.clearedone_time_links = false
	m.removedone_time_links = nil
}

// AddSopIDs adds the "sops" edge to the SOP entity by ids.
func (m *TenantMutation) AddSopIDs(ids ...int) {
	if m.sops == nil {
		m.sops = make(map[int]struct{})
	}
	for i := range ids {
		m.sops[ids[i]] = struct{}{}
	}
}

// ClearSops clears the "sops" edge to the SOP entity.
func (m *TenantMutation) ClearSops() {
	m.clearedsops = true
}

// SopsCleared reports if the "sops" edge to the SOP entity was cleared.
func (m *TenantMutation) SopsCleared() bool {
	return m.clearedsops
}

// RemoveSopIDs removes the "sops" edge to the SOP entity by IDs.
func (m *TenantMutation) RemoveSopIDs(ids ...int) {
	if m.removedsops == nil {
		m.removedsops = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.sops, ids[i])
		m.removedsops[ids[i]] = struct{}{}
	}
}

// RemovedSops returns the removed IDs of the "sops" edge to the SOP entity.
func (m *TenantMutation) RemovedSopsIDs() (ids []int) {
	for id := range m.removedsops {
		ids = append(ids, id)
	}
	return
}

// SopsIDs returns the "sops" edge IDs in the mutation.
func (m *TenantMutation) SopsIDs() (ids []int) {
	for id := range m.sops {
		ids = append(ids, id)
	}
	return
}

// ResetSops resets all changes to the "sops" edge.
func (m *TenantMutation) ResetSops() {
	m.sops = nil
	m.clearedsops = false
	m.removedsops = nil
}

// AddCameraIDs adds the "cameras" edge to the Camera entity by ids.
func (m *TenantMutation) AddCameraIDs(ids ...int) {
	if m.cameras == nil {
		m.cameras = make(map[int]struct{})
	}
	for i := range ids {
		m.cameras[ids[i]] = struct{}{}
	}
}

// ClearCameras clears the "cameras" edge to the Camera entity.
func (m *TenantMutation) ClearCameras() {
	m.clearedcameras = true
}

// CamerasCleared reports if the "cameras" edge to the Camera entity was cleared.
func (m *TenantMutation) CamerasCleared() bool {
	return m.clearedcameras
}

// RemoveCameraIDs removes the "cameras" edge to the Camera entity by IDs.
func (m *TenantMutation) RemoveCameraIDs(ids ...int) {
	if m.removedcameras == nil {
		m.removedcameras = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.cameras, ids[i])
		m.removedcameras[ids[i]] = struct{}{}
	}
}

// RemovedCameras returns the removed IDs of the "cameras" edge to the Camera entity.
func (m *TenantMutation) RemovedCamerasIDs() (ids []int) {
	for id := range m.removedcameras {
		ids = append(ids, id)
	}
	return
}

// CamerasIDs returns the "cameras" edge IDs in the mutation.
func (m *TenantMutation) CamerasIDs() (ids []int) {
	for id := range m.cameras {
		ids = append(ids, id)
	}
	return
}

// ResetCameras resets all changes to the "cameras" edge.
func (m *TenantMutation) ResetCameras() {
	m.cameras = nil
	m.clearedcameras = false
	m.removedcameras = nil
}

// AddTicketIDs adds the "tickets" edge to the Ticket entity by ids.
func (m *TenantMutation) AddTicketIDs(ids ...int) {
	if m.tickets == nil {
		m.tickets = make(map[int]struct{})
	}
	for i := range ids {
		m.tickets[ids[i]] = struct{}{}
	}
}

// ClearTickets clears the "tickets" edge to the Ticket entity.
func (m *TenantMutation) ClearTickets() {
	m.clearedtickets = true
}

// TicketsCleared reports if the "tickets" edge to the Ticket entity was cleared.
func (m *TenantMutation) TicketsCleared() bool {
	return m.clearedtickets
}

// RemoveTicketIDs removes the "tickets" edge to the Ticket entity by IDs.
func (m *TenantMutation) RemoveTicketIDs(ids ...int) {
	if m.removedtickets == nil {
		m.removedtickets = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.tickets, ids[i])
		m.removedtickets[ids[i]] = struct{}{}
	}
}

// RemovedTickets returns the removed IDs of the "tickets" edge to the Ticket entity.
func (m *TenantMutation) RemovedTicketsIDs() (ids []int) {
	for id := range m.removedtickets {
		ids = append(ids, id)
	}
	return
}

// TicketsIDs returns the "tickets" edge IDs in the mutation.
func (m *TenantMutation) TicketsIDs() (ids []int) {
	for id := range m.tickets {
		ids = append(ids, id)
	}
	return
}

// ResetTickets resets all changes to the "tickets" edge.
func (m *TenantMutation) ResetTickets() {
	m.tickets = nil
	m.clearedtickets = false
	m.removedtickets = nil
}

// AddContractIDs adds the "contracts" edge to the Contract entity by ids.
func (m *TenantMutation) AddContractIDs(ids ...int) {
	if m.contracts == nil {
		m.contracts = make(map[int]struct{})
	}
	for i := range ids {
		m.contracts[ids[i]] = struct{}{}
	}
}

// ClearContracts clears the "contracts" edge to the Contract entity.
func (m *TenantMutation) ClearContracts() {
	m.clearedcontracts = true
}

// ContractsCleared reports if the "contracts" edge to the Contract entity was cleared.
func (m *TenantMutation) ContractsCleared() bool {
	return m.clearedcontracts
}

// RemoveContractIDs removes the "contracts" edge to the Contract entity by IDs.
func (m *TenantMutation) RemoveContractIDs(ids ...int) {
	if m.removedcontracts == nil {
		m.removedcontracts = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.contracts, ids[i])
		m.removedcontracts[ids[i]] = struct{}{}
	}
}

// RemovedContracts returns the removed IDs of the "contracts" edge to the Contract entity.
func (m *TenantMutation) RemovedContractsIDs() (ids []int) {
	for id := range m.removedcontracts {
		ids = append(ids, id)
	}
	return
}

// ContractsIDs returns the "contracts" edge IDs in the mutation.
func (m *TenantMutation) ContractsIDs() (ids []int) {
	for id := range m.contracts {
		ids = append(ids, id)
	}
	return
}

// ResetContracts resets all changes to the "contracts" edge.
func (m *TenantMutation) ResetContracts() {
	m.contracts = nil
	m.clearedcontracts = false
	m.removedcontracts = nil
}

// AddSaasAppIDs adds the "saas_apps" edge to the SaaSApp entity by ids.
func (m *TenantMutation) AddSaasAppIDs(ids ...int) {
	if m.saas_apps == nil {
		m.saas_apps = make(map[int]struct{})
	}
	for i := range ids {
		m.saas_apps[ids[i]] = struct{}{}
	}
}

// ClearSaasApps clears the "saas_apps" edge to the SaaSApp entity.
func (m *TenantMutation) ClearSaasApps() {
	m.clearedsaas_apps = true
}

// SaasAppsCleared reports if the "saas_apps" edge to the SaaSApp entity was cleared.
func (m *TenantMutation) SaasAppsCleared() bool {
	return m.clearedsaas_apps
}

// RemoveSaasAppIDs removes the "saas_apps" edge to the SaaSApp entity by IDs.
func (m *TenantMutation) RemoveSaasAppIDs(ids ...int) {
	if m.removedsaas_apps == nil {
		m.removedsaas_apps = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.saas_apps, ids[i])
		m.removedsaas_apps[ids[i]] = struct{}{}
	}
}

// RemovedSaasApps returns the removed IDs of the "saas_apps" edge to the SaaSApp entity.
func (m *TenantMutation) RemovedSaasAppsIDs() (ids []int) {
	for id := range m.removedsaas_apps {
		ids = append(ids, id)
	}
	return
}

// SaasAppsIDs returns the "saas_apps" edge IDs in the mutation.
func (m *TenantMutation) SaasAppsIDs() (ids []int) {
	for id := range m.saas_apps {
		ids = append(ids, id)
	}
	return
}

// ResetSaasApps resets all changes to the "saas_apps" edge.
func (m *TenantMutation) ResetSaasApps() {
	m.saas_apps = nil
	m.clearedsaas_apps = false
	m.removedsaas_apps = nil
}

// AddSaasFilterIDs adds the "saas_filters" edge to the SaaSFilter entity by ids.
func (m *TenantMutation) AddSaasFilterIDs(ids ...int) {
	if m.saas_filters == nil {
		m.saas_filters = make(map[int]struct{})
	}
	for i := range ids {
		m.saas_filters[ids[i]] = struct{}{}
	}
}

// ClearSaasFilters clears the "saas_filters" edge to the SaaSFilter entity.
func (m *TenantMutation) ClearSaasFilters() {
	m.clearedsaas_filters = true
}

// SaasFiltersCleared reports if the "saas_filters" edge to the SaaSFilter entity was cleared.
func (m *TenantMutation) SaasFiltersCleared() bool {
	return m.clearedsaas_filters
}

// RemoveSaasFilterIDs removes the "saas_filters" edge to the SaaSFilter entity by IDs.
func (m *TenantMutation) RemoveSaasFilterIDs(ids ...int) {
	if m.removedsaas_filters == nil {
		m.removedsaas_filters = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.saas_filters, ids[i])
		m.removedsaas_filters[ids[i]] = struct{}{}
	}
}

// RemovedSaasFilters returns the removed IDs of the "saas_filters" edge to the SaaSFilter entity.
func (m *TenantMutation) RemovedSaasFiltersIDs() (ids []int) {
	for id := range m.removedsaas_filters {
		ids = append(ids, id)
	}
	return
}

// SaasFiltersIDs returns the "saas_filters" edge IDs in the mutation.
func (m *TenantMutation) SaasFiltersIDs() (ids []int) {
	for id := range m.saas_filters {
		ids = append(ids, id)
	}
	return
}

// ResetSaasFilters resets all changes to the "saas_filters" edge.
func (m *TenantMutation) ResetSaasFilters() {
	m.saas_filters = nil
	m.clearedsaas_filters = false
	m.removedsaas_filters = nil
}

// AddCallLogIDs adds the "call_logs" edge to the CallLog entity by ids.
func (m *TenantMutation) AddCallLogIDs(ids ...int) {
	if m.call_logs == nil {
		m.call_logs = make(map[int]struct{})
	}
	for i := range ids {
		m.call_logs[ids[i]] = struct{}{}
	}
}

// ClearCallLogs clears the "call_logs" edge to the CallLog entity.
func (m *TenantMutation) ClearCallLogs() {
	m.clearedcall_logs = true
}

// CallLogsCleared reports if the "call_logs" edge to the CallLog entity was cleared.
func (m *TenantMutation) CallLogsCleared() bool {
	return m.clearedcall_logs
}

// RemoveCallLogIDs removes the "call_logs" edge to the CallLog entity by IDs.
func (m *TenantMutation) RemoveCallLogIDs(ids ...int) {
	if m.removedcall_logs == nil {
		m.removedcall_logs = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.call_logs, ids[i])
		m.removedcall_logs[ids[i]] = struct{}{}
	}
}

// RemovedCallLogs returns the removed IDs of the "call_logs" edge to the CallLog entity.
func (m *TenantMutation) RemovedCallLogsIDs() (ids []int) {
	for id := range m.removedcall_logs {
		ids = append(ids, id)
	}
	return
}

// CallLogsIDs returns the "call_logs" edge IDs in the mutation.
func (m *TenantMutation) CallLogsIDs() (ids []int) {
	for id := range m.call_logs {
		ids = append(ids, id)
	}
	return
}

// ResetCallLogs resets all changes to the "call_logs" edge.
func (m *TenantMutation) ResetCallLogs() {
	m.call_logs = nil
	m.clearedcall_logs = false
	m.removedcall_logs = nil
}

// AddIvrFlowIDs adds the "ivr_flows" edge to the IVRFlow entity by ids.
func (m *TenantMutation) AddIvrFlowIDs(ids ...int) {
	if m.ivr_flows == nil {
		m.ivr_flows = make(map[int]struct{})
	}
	for i := range ids {
		m.ivr_flows[ids[i]] = struct{}{}
	}
}

// ClearIvrFlows clears the "ivr_flows" edge to the IVRFlow entity.
func (m *TenantMutation) ClearIvrFlows() {
	m.clearedivr_flows = true
}

// IvrFlowsCleared reports if the "ivr_flows" edge to the IVRFlow entity was cleared.
func (m *TenantMutation) IvrFlowsCleared() bool {
	return m.clearedivr_flows
}

// RemoveIvrFlowIDs removes the "ivr_flows" edge to the IVRFlow entity by IDs.
func (m *TenantMutation) RemoveIvrFlowIDs(ids ...int) {
	if m.removedivr_flows == nil {
		m.removedivr_flows = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.ivr_flows, ids[i])
		m.removedivr_flows[ids[i]] = struct{}{}
	}
}

// RemovedIvrFlows returns the removed IDs of the "ivr_flows" edge to the IVRFlow entity.
func (m *TenantMutation) RemovedIvrFlowsIDs() (ids []int) {
	for id := range m.removedivr_flows {
		ids = append(ids, id)
	}
	return
}

// IvrFlowsIDs returns the "ivr_flows" edge IDs in the mutation.
func (m *TenantMutation) IvrFlowsIDs() (ids []int) {
	for id := range m.ivr_flows {
		ids = append(ids, id)
	}
	return
}

// ResetIvrFlows resets all changes to the "ivr_flows" edge.
func (m *TenantMutation) ResetIvrFlows() {
	m.ivr_flows = nil
	m.clearedivr_flows = false
	m.removedivr_flows = nil
}

// AddVoicemailIDs adds the "voicemails" edge to the Voicemail entity by ids.
func (m *TenantMutation) AddVoicemailIDs(ids ...int) {
	if m.voicemails == nil {
		m.voicemails = make(map[int]struct{})
	}
	for i := range ids {
		m.voicemails[ids[i]] = struct{}{}
	}
}

// ClearVoicemails clears the "voicemails" edge to the Voicemail entity.
func (m *TenantMutation) ClearVoicemails() {
	m.clearedvoicemails = true
}

// VoicemailsCleared reports if the "voicemails" edge to the Voicemail entity was cleared.
func (m *TenantMutation) VoicemailsCleared() bool {
	return m.clearedvoicemails
}

// RemoveVoicemailIDs removes the "voicemails" edge to the Voicemail entity by IDs.
func (m *TenantMutation) RemoveVoicemailIDs(ids ...int) {
	if m.removedvoicemails == nil {
		m.removedvoicemails = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.voicemails, ids[i])
		m.removedvoicemails[ids[i]] = struct{}{}
	}
}

// RemovedVoicemails returns the removed IDs of the "voicemails" edge to the Voicemail entity.
func (m *TenantMutation) RemovedVoicemailsIDs() (ids []int) {
	for id := range m.removedvoicemails {
		ids = append(ids, id)
	}
	return
}

// VoicemailsIDs returns the "voicemails" edge IDs in the mutation.
func (m *TenantMutation) VoicemailsIDs() (ids []int) {
	for id := range m.voicemails {
		ids = append(ids, id)
	}
	return
}

// ResetVoicemails resets all changes to the "voicemails" edge.
func (m *TenantMutation) ResetVoicemails() {
	m.voicemails = nil
	m.clearedvoicemails = false
	m.removedvoicemails = nil
}

// AddHealthSnapshotIDs adds the "health_snapshots" edge to the HealthScoreSnapshot entity by ids.
func (m *TenantMutation) AddHealthSnapshotIDs(ids ...int) {
	if m.health_snapshots == nil {
		m.health_snapshots = make(map[int]struct{})
	}
	for i := range ids {
		m.health_snapshots[ids[i]] = struct{}{}
	}
}

// ClearHealthSnapshots clears the "health_snapshots" edge to the HealthScoreSnapshot entity.
func (m *TenantMutation) ClearHealthSnapshots() {
	m.clearedhealth_snapshots = true
}

// HealthSnapshotsCleared reports if the "health_snapshots" edge to the HealthScoreSnapshot entity was cleared.
func (m *TenantMutation) HealthSnapshotsCleared() bool {
	return m.clearedhealth_snapshots
}

// RemoveHealthSnapshotIDs removes the "health_snapshots" edge to the HealthScoreSnapshot entity by IDs.
func (m *TenantMutation) RemoveHealthSnapshotIDs(ids ...int) {
	if m.removedhealth_snapshots == nil {
		m.removedhealth_snapshots = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.health_snapshots, ids[i])
		m.removedhealth_snapshots[ids[i]] = struct{}{}
	}
}

// RemovedHealthSnapshots returns the removed IDs of the "health_snapshots" edge to the HealthScoreSnapshot entity.
func (m *TenantMutation) RemovedHealthSnapshotsIDs() (ids []int) {
	for id := range m.removedhealth_snapshots {
		ids = append(ids, id)
	}
	return
}

// HealthSnapshotsIDs returns the "health_snapshots" edge IDs in the mutation.
func (m *TenantMutation) HealthSnapshotsIDs() (ids []int) {
	for id := range m.health_snapshots {
		ids = append(ids, id)
	}
	return
}

// ResetHealthSnapshots resets all changes to the "health_snapshots" edge.
func (m *TenantMutation) ResetHealthSnapshots() {
	m.health_snapshots = nil
	m.clearedhealth_snapshots = false
	m.removedhealth_snapshots = nil
}

// AddRoadmapIDs adds the "roadmaps" edge to the StrategicRoadmap entity by ids.
func (m *TenantMutation) AddRoadmapIDs(ids ...int) {
	if m.roadmaps == nil {
		m.roadmaps = make(map[int]struct{})
	}
	for i := range ids {
		m.roadmaps[ids[i]] = struct{}{}
	}
}

// ClearRoadmaps clears the "roadmaps" edge to the StrategicRoadmap entity.
func (m *TenantMutation) ClearRoadmaps() {
	m.clearedroadmaps = true
}

// RoadmapsCleared reports if the "roadmaps" edge to the StrategicRoadmap entity was cleared.
func (m *TenantMutation) RoadmapsCleared() bool {
	return m.clearedroadmaps
}

// RemoveRoadmapIDs removes the "roadmaps" edge to the StrategicRoadmap entity by IDs.
func (m *TenantMutation) RemoveRoadmapIDs(ids ...int) {
	if m.removedroadmaps == nil {
		m.removedroadmaps = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.roadmaps, ids[i])
		m.removedroadmaps[ids[i]] = struct{}{}
	}
}

// RemovedRoadmaps returns the removed IDs of the "roadmaps" edge to the StrategicRoadmap entity.
func (m *TenantMutation) RemovedRoadmapsIDs() (ids []int) {
	for id := range m.removedroadmaps {
		ids = append(ids, id)
	}
	return
}

// RoadmapsIDs returns the "roadmaps" edge IDs in the mutation.
func (m *TenantMutation) RoadmapsIDs() (ids []int) {
	for id := range m.roadmaps {
		ids = append(ids, id)
	}
	return
}

// ResetRoadmaps resets all changes to the "roadmaps" edge.
func (m *TenantMutation) ResetRoadmaps() {
	m.roadmaps = nil
	m.clearedroadmaps = false
	m.removedroadmaps = nil
}

// AddServiceRateIDs adds the "service_rates" edge to the ServiceRate entity by ids.
func (m *TenantMutation) AddServiceRateIDs(ids ...int) {
	if m.service_rates == nil {
		m.service_rates = make(map[int]struct{})
	}
	for i := range ids {
		m.service_rates[ids[i]] = struct{}{}
	}
}

// ClearServiceRates clears the "service_rates" edge to the ServiceRate entity.
func (m *TenantMutation) ClearServiceRates() {
	m.clearedservice_rates = true
}

// ServiceRatesCleared reports if the "service_rates" edge to the ServiceRate entity was cleared.
func (m *TenantMutation) ServiceRatesCleared() bool {
	return m.clearedservice_rates
}

// RemoveServiceRateIDs removes the "service_rates" edge to the ServiceRate entity by IDs.
func (m *TenantMutation) RemoveServiceRateIDs(ids ...int) {
	if m.removedservice_rates == nil {
		m.removedservice_rates = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.service_rates, ids[i])
		m.removedservice_rates[ids[i]] = struct{}{}
	}
}

// RemovedServiceRates returns the removed IDs of the "service_rates" edge to the ServiceRate entity.
func (m *TenantMutation) RemovedServiceRatesIDs() (ids []int) {
	for id := range m.removedservice_rates {
		ids = append(ids, id)
	}
	return
}

// ServiceRatesIDs returns the "service_rates" edge IDs in the mutation.
func (m *TenantMutation) ServiceRatesIDs() (ids []int) {
	for id := range m.service_rates {
		ids = append(ids, id)
	}
	return
}

// ResetServiceRates resets all changes to the "service_rates" edge.
func (m *TenantMutation) ResetServiceRates() {
	m.service_rates = nil
	m.clearedservice_rates = false
	m.removedservice_rates = nil
}

// AddBudgetForecastIDs adds the "budget_forecasts" edge to the BudgetForecast entity by ids.
func (m *TenantMutation) AddBudgetForecastIDs(ids ...int) {
	if m.budget_forecasts == nil {
		m.budget_forecasts = make(map[int]struct{})
	}
	for i := range ids {
		m.budget_forecasts[ids[i]] = struct{}{}
	}
}

// ClearBudgetForecasts clears the "budget_forecasts" edge to the BudgetForecast entity.
func (m *TenantMutation) ClearBudgetForecasts() {
	m.clearedbudget_forecasts = true
}

// BudgetForecastsCleared reports if the "budget_forecasts" edge to the BudgetForecast entity was cleared.
func (m *TenantMutation) BudgetForecastsCleared() bool {
	return m.clearedbudget_forecasts
}

// RemoveBudgetForecastIDs removes the "budget_forecasts" edge to the BudgetForecast entity by IDs.
func (m *TenantMutation) RemoveBudgetForecastIDs(ids ...int) {
	if m.removedbudget_forecasts == nil {
		m.removedbudget_forecasts = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.budget_forecasts, ids[i])
		m.removedbudget_forecasts[ids[i]] = struct{}{}
	}
}

// RemovedBudgetForecasts returns the removed IDs of the "budget_forecasts" edge to the BudgetForecast entity.
func (m *TenantMutation) RemovedBudgetForecastsIDs() (ids []int) {
	for id := range m.removedbudget_forecasts {
		ids = append(ids, id)
	}
	return
}

// BudgetForecastsIDs returns the "budget_forecasts" edge IDs in the mutation.
func (m *TenantMutation) BudgetForecastsIDs() (ids []int) {
	for id := range m.budget_forecasts {
		ids = append(ids, id)
	}
	return
}

// ResetBudgetForecasts resets all changes to the "budget_forecasts" edge.
func (m *TenantMutation) ResetBudgetForecasts() {
	m.budget_forecasts = nil
	m.clearedbudget_forecasts = false
	m.removedbudget_forecasts = nil
}

// AddEmployeeIDs adds the "employees" edge to the Employee entity by ids.
func (m *TenantMutation) AddEmployeeIDs(ids ...int) {
	if m.employees == nil {
		m.employees = make(map[int]struct{})
	}
	for i := range ids {
		m.employees[ids[i]] = struct{}{}
	}
}

// ClearEmployees clears the "employees" edge to the Employee entity.
func (m *TenantMutation) ClearEmployees() {
	m.clearedemployees = true
}

// EmployeesCleared reports if the "employees" edge to the Employee entity was cleared.
func (m *TenantMutation) EmployeesCleared() bool {
	return m.clearedemployees
}

// RemoveEmployeeIDs removes the "employees" edge to the Employee entity by IDs.
func (m *TenantMutation) RemoveEmployeeIDs(ids ...int) {
	if m.removedemployees == nil {
		m.removedemployees = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.employees, ids[i])
		m.removedemployees[ids[i]] = struct{}{}
	}
}

// RemovedEmployees returns the removed IDs of the "employees" edge to the Employee entity.
func (m *TenantMutation) RemovedEmployeesIDs() (ids []int) {
	for id := range m.removedemployees {
		ids = append(ids, id)
	}
	return
}

// EmployeesIDs returns the "employees" edge IDs in the mutation.
func (m *TenantMutation) EmployeesIDs() (ids []int) {
	for id := range m.employees {
		ids = append(ids, id)
	}
	return
}

// ResetEmployees resets all changes to the "employees" edge.
func (m *TenantMutation) ResetEmployees() {
	m.employees = nil
	m.clearedemployees = false
	m.removedemployees = nil
}

// AddCompensationAgreementIDs adds the "compensation_agreements" edge to the CompensationAgreement entity by ids.
func (m *TenantMutation) AddCompensationAgreementIDs(ids ...int) {
	if m.compensation_agreements == nil {
		m.compensation_agreements = make(map[int]struct{})
	}
	for i := range ids {
		m.compensation_agreements[ids[i]] = struct{}{}
	}
}

// ClearCompensationAgreements clears the "compensation_agreements" edge to the CompensationAgreement entity.
func (m *TenantMutation) ClearCompensationAgreements() {
	m.clearedcompensation_agreements = true
}

// CompensationAgreementsCleared reports if the "compensation_agreements" edge to the CompensationAgreement entity was cleared.
func (m *TenantMutation) CompensationAgreementsCleared() bool {
	return m.clearedcompensation_agreements
}

// RemoveCompensationAgreementIDs removes the "compensation_agreements" edge to the CompensationAgreement entity by IDs.
func (m *TenantMutation) RemoveCompensationAgreementIDs(ids ...int) {
	if m.removedcompensation_agreements == nil {
		m.removedcompensation_agreements = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.compensation_agreements, ids[i])
		m.removedcompensation_agreements[ids[i]] = struct{}{}
	}
}

// RemovedCompensationAgreements returns the removed IDs of the "compensation_agreements" edge to the CompensationAgreement entity.
func (m *TenantMutation) RemovedCompensationAgreementsIDs() (ids []int) {
	for id := range m.removedcompensation_agreements {
		ids = append(ids, id)
	}
	return
}

// CompensationAgreementsIDs returns the "compensation_agreements" edge IDs in the mutation.
func (m *TenantMutation) CompensationAgreementsIDs() (ids []int) {
	for id := range m.compensation_agreements {
		ids = append(ids, id)
	}
	return
}

// ResetCompensationAgreements resets all changes to the "compensation_agreements" edge.
func (m *TenantMutation) ResetCompensationAgreements() {
	m.compensation_agreements = nil
	m.clearedcompensation_agreements = false
	m.removedcompensation_agreements = nil
}

// AddVaultItemIDs adds the "vault_items" edge to the VaultItem entity by ids.
func (m *TenantMutation) AddVaultItemIDs(ids ...int) {
	if m.vault_items == nil {
		m.vault_items = make(map[int]struct{})
	}
	for i := range ids {
		m.vault_items[ids[i]] = struct{}{}
	}
}

// ClearVaultItems clears the "vault_items" edge to the VaultItem entity.
func (m *TenantMutation) ClearVaultItems() {
	m.clearedvault_items = true
}

// VaultItemsCleared reports if the "vault_items" edge to the VaultItem entity was cleared.
func (m *TenantMutation) VaultItemsCleared() bool {
	return m.clearedvault_items
}

// RemoveVaultItemIDs removes the "vault_items" edge to the VaultItem entity by IDs.
func (m *TenantMutation) RemoveVaultItemIDs(ids ...int) {
	if m.removedvault_items == nil {
		m.removedvault_items = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.vault_items, ids[i])
		m.removedvault_items[ids[i]] = struct{}{}
	}
}

// RemovedVaultItems returns the removed IDs of the "vault_items" edge to the VaultItem entity.
func (m *TenantMutation) RemovedVaultItemsIDs() (ids []int) {
	for id := range m.removedvault_items {
		ids = append(ids, id)
	}
	return
}

// VaultItemsIDs returns the "vault_items" edge IDs in the mutation.
func (m *TenantMutation) VaultItemsIDs() (ids []int) {
	for id := range m.vault_items {
		ids = append(ids, id)
	}
	return
}

// ResetVaultItems resets all changes to the "vault_items" edge.
func (m *TenantMutation) ResetVaultItems() {
	m.vault_items = nil
	m.clearedvault_items = false
	m.removedvault_items = nil
}

// AddJournalEntryIDs adds the "journal_entries" edge to the JournalEntry entity by ids.
func (m *TenantMutation) AddJournalEntryIDs(ids ...int) {
	if m.journal_entries == nil {
		m.journal_entries = make(map[int]struct{})
	}
	for i := range ids {
		m.journal_entries[ids[i]] = struct{}{}
	}
}

// ClearJournalEntries clears the "journal_entries" edge to the JournalEntry entity.
func (m *TenantMutation) ClearJournalEntries() {
	m.clearedjournal_entries = true
}

// JournalEntriesCleared reports if the "journal_entries" edge to the JournalEntry entity was cleared.
func (m *TenantMutation) JournalEntriesCleared() bool {
	return m.clearedjournal_entries
}

// RemoveJournalEntryIDs removes the "journal_entries" edge to the JournalEntry entity by IDs.
func (m *TenantMutation) RemoveJournalEntryIDs(ids ...int) {
	if m.removedjournal_entries == nil {
		m.removedjournal_entries = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.journal_entries, ids[i])
		m.removedjournal_entries[ids[i]] = struct{}{}
	}
}

// RemovedJournalEntries returns the removed IDs of the "journal_entries" edge to the JournalEntry entity.
func (m *TenantMutation) RemovedJournalEntriesIDs() (ids []int) {
	for id := range m.removedjournal_entries {
		ids = append(ids, id)
	}
	return
}

// JournalEntriesIDs returns the "journal_entries" edge IDs in the mutation.
func (m *TenantMutation) JournalEntriesIDs() (ids []int) {
	for id := range m.journal_entries {
		ids = append(ids, id)
	}
	return
}

// ResetJournalEntries resets all changes to the "journal_entries" edge.
func (m *TenantMutation) ResetJournalEntries() {
	m.journal_entries = nil
	m.clearedjournal_entries = false
	m.removedjournal_entries = nil
}

// AddRecurringInvoiceIDs adds the "recurring_invoices" edge to the RecurringInvoice entity by ids.
func (m *TenantMutation) AddRecurringInvoiceIDs(ids ...int) {
	if m.recurring_invoices == nil {
		m.recurring_invoices = make(map[int]struct{})
	}
	for i := range ids {
		m.recurring_invoices[ids[i]] = struct{}{}
	}
}

// ClearRecurringInvoices clears the "recurring_invoices" edge to the RecurringInvoice entity.
func (m *TenantMutation) ClearRecurringInvoices() {
	m.clearedrecurring_invoices = true
}

// RecurringInvoicesCleared reports if the "recurring_invoices" edge to the RecurringInvoice entity was cleared.
func (m *TenantMutation) RecurringInvoicesCleared() bool {
	return m.clearedrecurring_invoices
}

// RemoveRecurringInvoiceIDs removes the "recurring_invoices" edge to the RecurringInvoice entity by IDs.
func (m *TenantMutation) RemoveRecurringInvoiceIDs(ids ...int) {
	if m.removedrecurring_invoices == nil {
		m.removedrecurring_invoices = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.recurring_invoices, ids[i])
		m.removedrecurring_invoices[ids[i]] = struct{}{}
	}
}

// RemovedRecurringInvoices returns the removed IDs of the "recurring_invoices" edge to the RecurringInvoice entity.
func (m *TenantMutation) RemovedRecurringInvoicesIDs() (ids []int) {
	for id := range m.removedrecurring_invoices {
		ids = append(ids, id)
	}
	return
}

// RecurringInvoicesIDs returns the "recurring_invoices" edge IDs in the mutation.
func (m *TenantMutation) RecurringInvoicesIDs() (ids []int) {
	for id := range m.recurring_invoices {
		ids = append(ids, id)
	}
	return
}

// ResetRecurringInvoices resets all changes to the "recurring_invoices" edge.
func (m *TenantMutation) ResetRecurringInvoices() {
	m.recurring_invoices = nil
	m.clearedrecurring_invoices = false
	m.removedrecurring_invoices = nil
}

// AddInventoryReservationIDs adds the "inventory_reservations" edge to the InventoryReservation entity by ids.
func (m *TenantMutation) AddInventoryReservationIDs(ids ...int) {
	if m.inventory_reservations == nil {
		m.inventory_reservations = make(map[int]struct{})
	}
	for i := range ids {
		m.inventory_reservations[ids[i]] = struct{}{}
	}
}

// ClearInventoryReservations clears the "inventory_reservations" edge to the InventoryReservation entity.
func (m *TenantMutation) ClearInventoryReservations() {
	m.clearedinventory_reservations = true
}

// InventoryReservationsCleared reports if the "inventory_reservations" edge to the InventoryReservation entity was cleared.
func (m *TenantMutation) InventoryReservationsCleared() bool {
	return m.clearedinventory_reservations
}

// RemoveInventoryReservationIDs removes the "inventory_reservations" edge to the InventoryReservation entity by IDs.
func (m *TenantMutation) RemoveInventoryReservationIDs(ids ...int) {
	if m.removedinventory_reservations == nil {
		m.removedinventory_reservations = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.inventory_reservations, ids[i])
		m.removedinventory_reservations[ids[i]] = struct{}{}
	}
}

// RemovedInventoryReservations returns the removed IDs of the "inventory_reservations" edge to the InventoryReservation entity.
func (m *TenantMutation) RemovedInventoryReservationsIDs() (ids []int) {
	for id := range m.removedinventory_reservations {
		ids = append(ids, id)
	}
	return
}

// InventoryReservationsIDs returns the "inventory_reservations" edge IDs in the mutation.
func (m *TenantMutation) InventoryReservationsIDs() (ids []int) {
	for id := range m.inventory_reservations {
		ids = append(ids, id)
	}
	return
}

// ResetInventoryReservations resets all changes to the "inventory_reservations" edge.
func (m *TenantMutation) ResetInventoryReservations() {
	m.inventory_reservations = nil
	m.clearedinventory_reservations = false
	m.removedinventory_reservations = nil
}

// SetCustomerAccountID sets the "customer_account" edge to the Account entity by id.
func (m *TenantMutation) SetCustomerAccountID(id int) {
	m.customer_account = &id
}

// ClearCustomerAccount clears the "customer_account" edge to the Account entity.
func (m *TenantMutation) ClearCustomerAccount() {
	m.clearedcustomer_account = true
}

// CustomerAccountCleared reports if the "customer_account" edge to the Account entity was cleared.
func (m *TenantMutation) CustomerAccountCleared() bool {
	return m.clearedcustomer_account
}

// CustomerAccountID returns the "customer_account" edge ID in the mutation.
func (m *TenantMutation) CustomerAccountID() (id int, exists bool) {
	if m.customer_account != nil {
		return *m.customer_account, true
	}
	return
}

// CustomerAccountIDs returns the "customer_account" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CustomerAccountID instead. It exists only for internal usage by the builders.
func (m *TenantMutation) CustomerAccountIDs() (ids []int) {
	if id := m.customer_account; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCustomerAccount resets all changes to the "customer_account" edge.
func (m *TenantMutation) ResetCustomerAccount() {
	m.customer_account = nil
	m.clearedcustomer_account = false
}

// Where appends a list predicates to the TenantMutation builder.
func (m *TenantMutation) Where(ps ...predicate.Tenant) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TenantMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TenantMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Tenant, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TenantMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TenantMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Tenant).
func (m *TenantMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TenantMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.name != nil {
		fields = append(fields, tenant.FieldName)
	}
	if m.domain != nil {
		fields = append(fields, tenant.FieldDomain)
	}
	if m.created_at != nil {
		fields = append(fields, tenant.FieldCreatedAt)
	}
	if m.active != nil {
		fields = append(fields, tenant.FieldActive)
	}
	if m.transaction_limit != nil {
		fields = append(fields, tenant.FieldTransactionLimit)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TenantMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case tenant.FieldName:
		return m.Name()
	case tenant.FieldDomain:
		return m.Domain()
	case tenant.FieldCreatedAt:
		return m.CreatedAt()
	case tenant.FieldActive:
		return m.Active()
	case tenant.FieldTransactionLimit:
		return m.TransactionLimit()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TenantMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case tenant.FieldName:
		return m.OldName(ctx)
	case tenant.FieldDomain:
		return m.OldDomain(ctx)
	case tenant.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case tenant.FieldActive:
		return m.OldActive(ctx)
	case tenant.FieldTransactionLimit:
		return m.OldTransactionLimit(ctx)
	}
	return nil, fmt.Errorf("unknown Tenant field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TenantMutation) SetField(name string, value ent.Value) error {
	switch name {
	case tenant.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case tenant.FieldDomain:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDomain(v)
		return nil
	case tenant.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case tenant.FieldActive:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetActive(v)
		return nil
	case tenant.FieldTransactionLimit:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTransactionLimit(v)
		return nil
	}
	return fmt.Errorf("unknown Tenant field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TenantMutation) AddedFields() []string {
	var fields []string
	if m.addtransaction_limit != nil {
		fields = append(fields, tenant.FieldTransactionLimit)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TenantMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case tenant.FieldTransactionLimit:
		return m.AddedTransactionLimit()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TenantMutation) AddField(name string, value ent.Value) error {
	switch name {
	case tenant.FieldTransactionLimit:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTransactionLimit(v)
		return nil
	}
	return fmt.Errorf("unknown Tenant numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TenantMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TenantMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TenantMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Tenant nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TenantMutation) ResetField(name string) error {
	switch name {
	case tenant.FieldName:
		m.ResetName()
		return nil
	case tenant.FieldDomain:
		m.ResetDomain()
		return nil
	case tenant.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case tenant.FieldActive:
		m.ResetActive()
		return nil
	case tenant.FieldTransactionLimit:
		m.ResetTransactionLimit()
		return nil
	}
	return fmt.Errorf("unknown Tenant field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TenantMutation) AddedEdges() []string {
	edges := make([]string, 0, 34)
	if m.parent != nil {
		edges = append(edges, tenant.EdgeParent)
	}
	if m.children != nil {
		edges = append(edges, tenant.EdgeChildren)
	}
	if m.users != nil {
		edges = append(edges, tenant.EdgeUsers)
	}
	if m.accounts != nil {
		edges = append(edges, tenant.EdgeAccounts)
	}
	if m.transactions != nil {
		edges = append(edges, tenant.EdgeTransactions)
	}
	if m.ledger_entries != nil {
		edges = append(edges, tenant.EdgeLedgerEntries)
	}
	if m.products != nil {
		edges = append(edges, tenant.EdgeProducts)
	}
	if m.stock_movements != nil {
		edges = append(edges, tenant.EdgeStockMovements)
	}
	if m.audit_logs != nil {
		edges = append(edges, tenant.EdgeAuditLogs)
	}
	if m.agents != nil {
		edges = append(edges, tenant.EdgeAgents)
	}
	if m.discovery_entries != nil {
		edges = append(edges, tenant.EdgeDiscoveryEntries)
	}
	if m.assets != nil {
		edges = append(edges, tenant.EdgeAssets)
	}
	if m.credentials != nil {
		edges = append(edges, tenant.EdgeCredentials)
	}
	if m.one_time_links != nil {
		edges = append(edges, tenant.EdgeOneTimeLinks)
	}
	if m.sops != nil {
		edges = append(edges, tenant.EdgeSops)
	}
	if m.cameras != nil {
		edges = append(edges, tenant.EdgeCameras)
	}
	if m.tickets != nil {
		edges = append(edges, tenant.EdgeTickets)
	}
	if m.contracts != nil {
		edges = append(edges, tenant.EdgeContracts)
	}
	if m.saas_apps != nil {
		edges = append(edges, tenant.EdgeSaasApps)
	}
	if m.saas_filters != nil {
		edges = append(edges, tenant.EdgeSaasFilters)
	}
	if m.call_logs != nil {
		edges = append(edges, tenant.EdgeCallLogs)
	}
	if m.ivr_flows != nil {
		edges = append(edges, tenant.EdgeIvrFlows)
	}
	if m.voicemails != nil {
		edges = append(edges, tenant.EdgeVoicemails)
	}
	if m.health_snapshots != nil {
		edges = append(edges, tenant.EdgeHealthSnapshots)
	}
	if m.roadmaps != nil {
		edges = append(edges, tenant.EdgeRoadmaps)
	}
	if m.service_rates != nil {
		edges = append(edges, tenant.EdgeServiceRates)
	}
	if m.budget_forecasts != nil {
		edges = append(edges, tenant.EdgeBudgetForecasts)
	}
	if m.employees != nil {
		edges = append(edges, tenant.EdgeEmployees)
	}
	if m.compensation_agreements != nil {
		edges = append(edges, tenant.EdgeCompensationAgreements)
	}
	if m.vault_items != nil {
		edges = append(edges, tenant.EdgeVaultItems)
	}
	if m.journal_entries != nil {
		edges = append(edges, tenant.EdgeJournalEntries)
	}
	if m.recurring_invoices != nil {
		edges = append(edges, tenant.EdgeRecurringInvoices)
	}
	if m.inventory_reservations != nil {
		edges = append(edges, tenant.EdgeInventoryReservations)
	}
	if m.customer_account != nil {
		edges = append(edges, tenant.EdgeCustomerAccount)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TenantMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case tenant.EdgeParent:
		if id := m.parent; id != nil {
			return []ent.Value{*id}
		}
	case tenant.EdgeChildren:
		ids := make([]ent.Value, 0, len(m.children))
		for id := range m.children {
			ids = append(ids, id)
		}
		return ids
	case tenant.EdgeUsers:
		ids := make([]ent.Value, 0, len(m.users))
		for id := range m.users {
			ids = append(ids, id)
		}
		return ids
	case tenant.EdgeAccounts:
		ids := make([]ent.Value, 0, len(m.accounts))
		for id := range m.accounts {
			ids = append(ids, id)
		}
		return ids
	case tenant.EdgeTransactions:
		ids := make([]ent.Value, 0, len(m.transactions))
		for id := range m.transactions {
			ids = append(ids, id)
		}
		return ids
	case tenant.EdgeLedgerEntries:
		ids := make([]ent.Value, 0, len(m.ledger_entries))
		for id := range m.ledger_entries {
			ids = append(ids, id)
		}
		return ids
	case tenant.EdgeProducts:
		ids := make([]ent.Value, 0, len(m.products))
		for id := range m.products {
			ids = append(ids, id)
		}
		return ids
	case tenant.EdgeStockMovements:
		ids := make([]ent.Value, 0, len(m.stock_movements))
		for id := range m.stock_movements {
			ids = append(ids, id)
		}
		return ids
	case tenant.EdgeAuditLogs:
		ids := make([]ent.Value, 0, len(m.audit_logs))
		for id := range m.audit_logs {
			ids = append(ids, id)
		}
		return ids
	case tenant.EdgeAgents:
		ids := make([]ent.Value, 0, len(m.agents))
		for id := range m.agents {
			ids = append(ids, id)
		}
		return ids
	case tenant.EdgeDiscoveryEntries:
		ids := make([]ent.Value, 0, len(m.discovery_entries))
		for id := range m.discovery_entries {
			ids = append(ids, id)
		}
		return ids
	case tenant.EdgeAssets:
		ids := make([]ent.Value, 0, len(m.assets))
		for id := range m.assets {
			ids = append(ids, id)
		}
		return ids
	case tenant.EdgeCredentials:
		ids := make([]ent.Value, 0, len(m.credentials))
		for id := range m.credentials {
			ids = append(ids, id)
		}
		return ids
	case tenant.EdgeOneTimeLinks:
		ids := make([]ent.Value, 0, len(m.one_time_links))
		for id := range m.one_time_links {
			ids = append(ids, id)
		}
		return ids
	case tenant.EdgeSops:
		ids := make([]ent.Value, 0, len(m.sops))
		for id := range m.sops {
			ids = append(ids, id)
		}
		return ids
	case tenant.EdgeCameras:
		ids := make([]ent.Value, 0, len(m.cameras))
		for id := range m.cameras {
			ids = append(ids, id)
		}
		return ids
	case tenant.EdgeTickets:
		ids := make([]ent.Value, 0, len(m.tickets))
		for id := range m.tickets {
			ids = append(ids, id)
		}
		return ids
	case tenant.EdgeContracts:
		ids := make([]ent.Value, 0, len(m.contracts))
		for id := range m.contracts {
			ids = append(ids, id)
		}
		return ids
	case tenant.EdgeSaasApps:
		ids := make([]ent.Value, 0, len(m.saas_apps))
		for id := range m.saas_apps {
			ids = append(ids, id)
		}
		return ids
	case tenant.EdgeSaasFilters:
		ids := make([]ent.Value, 0, len(m.saas_filters))
		for id := range m.saas_filters {
			ids = append(ids, id)
		}
		return ids
	case tenant.EdgeCallLogs:
		ids := make([]ent.Value, 0, len(m.call_logs))
		for id := range m.call_logs {
			ids = append(ids, id)
		}
		return ids
	case tenant.EdgeIvrFlows:
		ids := make([]ent.Value, 0, len(m.ivr_flows))
		for id := range m.ivr_flows {
			ids = append(ids, id)
		}
		return ids
	case tenant.EdgeVoicemails:
		ids := make([]ent.Value, 0, len(m.voicemails))
		for id := range m.voicemails {
			ids = append(ids, id)
		}
		return ids
	case tenant.EdgeHealthSnapshots:
		ids := make([]ent.Value, 0, len(m.health_snapshots))
		for id := range m.health_snapshots {
			ids = append(ids, id)
		}
		return ids
	case tenant.EdgeRoadmaps:
		ids := make([]ent.Value, 0, len(m.roadmaps))
		for id := range m.roadmaps {
			ids = append(ids, id)
		}
		return ids
	case tenant.EdgeServiceRates:
		ids := make([]ent.Value, 0, len(m.service_rates))
		for id := range m.service_rates {
			ids = append(ids, id)
		}
		return ids
	case tenant.EdgeBudgetForecasts:
		ids := make([]ent.Value, 0, len(m.budget_forecasts))
		for id := range m.budget_forecasts {
			ids = append(ids, id)
		}
		return ids
	case tenant.EdgeEmployees:
		ids := make([]ent.Value, 0, len(m.employees))
		for id := range m.employees {
			ids = append(ids, id)
		}
		return ids
	case tenant.EdgeCompensationAgreements:
		ids := make([]ent.Value, 0, len(m.compensation_agreements))
		for id := range m.compensation_agreements {
			ids = append(ids, id)
		}
		return ids
	case tenant.EdgeVaultItems:
		ids := make([]ent.Value, 0, len(m.vault_items))
		for id := range m.vault_items {
			ids = append(ids, id)
		}
		return ids
	case tenant.EdgeJournalEntries:
		ids := make([]ent.Value, 0, len(m.journal_entries))
		for id := range m.journal_entries {
			ids = append(ids, id)
		}
		return ids
	case tenant.EdgeRecurringInvoices:
		ids := make([]ent.Value, 0, len(m.recurring_invoices))
		for id := range m.recurring_invoices {
			ids = append(ids, id)
		}
		return ids
	case tenant.EdgeInventoryReservations:
		ids := make([]ent.Value, 0, len(m.inventory_reservations))
		for id := range m.inventory_reservations {
			ids = append(ids, id)
		}
		return ids
	case tenant.EdgeCustomerAccount:
		if id := m.customer_account; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TenantMutation) RemovedEdges() []string {
	edges := make([]string, 0, 34)
	if m.removedchildren != nil {
		edges = append(edges, tenant.EdgeChildren)
	}
	if m.removedusers != nil {
		edges = append(edges, tenant.EdgeUsers)
	}
	if m.removedaccounts != nil {
		edges = append(edges, tenant.EdgeAccounts)
	}
	if m.removedtransactions != nil {
		edges = append(edges, tenant.EdgeTransactions)
	}
	if m.removedledger_entries != nil {
		edges = append(edges, tenant.EdgeLedgerEntries)
	}
	if m.removedproducts != nil {
		edges = append(edges, tenant.EdgeProducts)
	}
	if m.removedstock_movements != nil {
		edges = append(edges, tenant.EdgeStockMovements)
	}
	if m.removedaudit_logs != nil {
		edges = append(edges, tenant.EdgeAuditLogs)
	}
	if m.removedagents != nil {
		edges = append(edges, tenant.EdgeAgents)
	}
	if m.removeddiscovery_entries != nil {
		edges = append(edges, tenant.EdgeDiscoveryEntries)
	}
	if m.removedassets != nil {
		edges = append(edges, tenant.EdgeAssets)
	}
	if m.removedcredentials != nil {
		edges = append(edges, tenant.EdgeCredentials)
	}
	if m.removedone_time_links != nil {
		edges = append(edges, tenant.EdgeOneTimeLinks)
	}
	if m.removedsops != nil {
		edges = append(edges, tenant.EdgeSops)
	}
	if m.removedcameras != nil {
		edges = append(edges, tenant.EdgeCameras)
	}
	if m.removedtickets != nil {
		edges = append(edges, tenant.EdgeTickets)
	}
	if m.removedcontracts != nil {
		edges = append(edges, tenant.EdgeContracts)
	}
	if m.removedsaas_apps != nil {
		edges = append(edges, tenant.EdgeSaasApps)
	}
	if m.removedsaas_filters != nil {
		edges = append(edges, tenant.EdgeSaasFilters)
	}
	if m.removedcall_logs != nil {
		edges = append(edges, tenant.EdgeCallLogs)
	}
	if m.removedivr_flows != nil {
		edges = append(edges, tenant.EdgeIvrFlows)
	}
	if m.removedvoicemails != nil {
		edges = append(edges, tenant.EdgeVoicemails)
	}
	if m.removedhealth_snapshots != nil {
		edges = append(edges, tenant.EdgeHealthSnapshots)
	}
	if m.removedroadmaps != nil {
		edges = append(edges, tenant.EdgeRoadmaps)
	}
	if m.removedservice_rates != nil {
		edges = append(edges, tenant.EdgeServiceRates)
	}
	if m.removedbudget_forecasts != nil {
		edges = append(edges, tenant.EdgeBudgetForecasts)
	}
	if m.removedemployees != nil {
		edges = append(edges, tenant.EdgeEmployees)
	}
	if m.removedcompensation_agreements != nil {
		edges = append(edges, tenant.EdgeCompensationAgreements)
	}
	if m.removedvault_items != nil {
		edges = append(edges, tenant.EdgeVaultItems)
	}
	if m.removedjournal_entries != nil {
		edges = append(edges, tenant.EdgeJournalEntries)
	}
	if m.removedrecurring_invoices != nil {
		edges = append(edges, tenant.EdgeRecurringInvoices)
	}
	if m.removedinventory_reservations != nil {
		edges = append(edges, tenant.EdgeInventoryReservations)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TenantMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case tenant.EdgeChildren:
		ids := make([]ent.Value, 0, len(m.removedchildren))
		for id := range m.removedchildren {
			ids = append(ids, id)
		}
		return ids
	case tenant.EdgeUsers:
		ids := make([]ent.Value, 0, len(m.removedusers))
		for id := range m.removedusers {
			ids = append(ids, id)
		}
		return ids
	case tenant.EdgeAccounts:
		ids := make([]ent.Value, 0, len(m.removedaccounts))
		for id := range m.removedaccounts {
			ids = append(ids, id)
		}
		return ids
	case tenant.EdgeTransactions:
		ids := make([]ent.Value, 0, len(m.removedtransactions))
		for id := range m.removedtransactions {
			ids = append(ids, id)
		}
		return ids
	case tenant.EdgeLedgerEntries:
		ids := make([]ent.Value, 0, len(m.removedledger_entries))
		for id := range m.removedledger_entries {
			ids = append(ids, id)
		}
		return ids
	case tenant.EdgeProducts:
		ids := make([]ent.Value, 0, len(m.removedproducts))
		for id := range m.removedproducts {
			ids = append(ids, id)
		}
		return ids
	case tenant.EdgeStockMovements:
		ids := make([]ent.Value, 0, len(m.removedstock_movements))
		for id := range m.removedstock_movements {
			ids = append(ids, id)
		}
		return ids
	case tenant.EdgeAuditLogs:
		ids := make([]ent.Value, 0, len(m.removedaudit_logs))
		for id := range m.removedaudit_logs {
			ids = append(ids, id)
		}
		return ids
	case tenant.EdgeAgents:
		ids := make([]ent.Value, 0, len(m.removedagents))
		for id := range m.removedagents {
			ids = append(ids, id)
		}
		return ids
	case tenant.EdgeDiscoveryEntries:
		ids := make([]ent.Value, 0, len(m.removeddiscovery_entries))
		for id := range m.removeddiscovery_entries {
			ids = append(ids, id)
		}
		return ids
	case tenant.EdgeAssets:
		ids := make([]ent.Value, 0, len(m.removedassets))
		for id := range m.removedassets {
			ids = append(ids, id)
		}
		return ids
	case tenant.EdgeCredentials:
		ids := make([]ent.Value, 0, len(m.removedcredentials))
		for id := range m.removedcredentials {
			ids = append(ids, id)
		}
		return ids
	case tenant.EdgeOneTimeLinks:
		ids := make([]ent.Value, 0, len(m.removedone_time_links))
		for id := range m.removedone_time_links {
			ids = append(ids, id)
		}
		return ids
	case tenant.EdgeSops:
		ids := make([]ent.Value, 0, len(m.removedsops))
		for id := range m.removedsops {
			ids = append(ids, id)
		}
		return ids
	case tenant.EdgeCameras:
		ids := make([]ent.Value, 0, len(m.removedcameras))
		for id := range m.removedcameras {
			ids = append(ids, id)
		}
		return ids
	case tenant.EdgeTickets:
		ids := make([]ent.Value, 0, len(m.removedtickets))
		for id := range m.removedtickets {
			ids = append(ids, id)
		}
		return ids
	case tenant.EdgeContracts:
		ids := make([]ent.Value, 0, len(m.removedcontracts))
		for id := range m.removedcontracts {
			ids = append(ids, id)
		}
		return ids
	case tenant.EdgeSaasApps:
		ids := make([]ent.Value, 0, len(m.removedsaas_apps))
		for id := range m.removedsaas_apps {
			ids = append(ids, id)
		}
		return ids
	case tenant.EdgeSaasFilters:
		ids := make([]ent.Value, 0, len(m.removedsaas_filters))
		for id := range m.removedsaas_filters {
			ids = append(ids, id)
		}
		return ids
	case tenant.EdgeCallLogs:
		ids := make([]ent.Value, 0, len(m.removedcall_logs))
		for id := range m.removedcall_logs {
			ids = append(ids, id)
		}
		return ids
	case tenant.EdgeIvrFlows:
		ids := make([]ent.Value, 0, len(m.removedivr_flows))
		for id := range m.removedivr_flows {
			ids = append(ids, id)
		}
		return ids
	case tenant.EdgeVoicemails:
		ids := make([]ent.Value, 0, len(m.removedvoicemails))
		for id := range m.removedvoicemails {
			ids = append(ids, id)
		}
		return ids
	case tenant.EdgeHealthSnapshots:
		ids := make([]ent.Value, 0, len(m.removedhealth_snapshots))
		for id := range m.removedhealth_snapshots {
			ids = append(ids, id)
		}
		return ids
	case tenant.EdgeRoadmaps:
		ids := make([]ent.Value, 0, len(m.removedroadmaps))
		for id := range m.removedroadmaps {
			ids = append(ids, id)
		}
		return ids
	case tenant.EdgeServiceRates:
		ids := make([]ent.Value, 0, len(m.removedservice_rates))
		for id := range m.removedservice_rates {
			ids = append(ids, id)
		}
		return ids
	case tenant.EdgeBudgetForecasts:
		ids := make([]ent.Value, 0, len(m.removedbudget_forecasts))
		for id := range m.removedbudget_forecasts {
			ids = append(ids, id)
		}
		return ids
	case tenant.EdgeEmployees:
		ids := make([]ent.Value, 0, len(m.removedemployees))
		for id := range m.removedemployees {
			ids = append(ids, id)
		}
		return ids
	case tenant.EdgeCompensationAgreements:
		ids := make([]ent.Value, 0, len(m.removedcompensation_agreements))
		for id := range m.removedcompensation_agreements {
			ids = append(ids, id)
		}
		return ids
	case tenant.EdgeVaultItems:
		ids := make([]ent.Value, 0, len(m.removedvault_items))
		for id := range m.removedvault_items {
			ids = append(ids, id)
		}
		return ids
	case tenant.EdgeJournalEntries:
		ids := make([]ent.Value, 0, len(m.removedjournal_entries))
		for id := range m.removedjournal_entries {
			ids = append(ids, id)
		}
		return ids
	case tenant.EdgeRecurringInvoices:
		ids := make([]ent.Value, 0, len(m.removedrecurring_invoices))
		for id := range m.removedrecurring_invoices {
			ids = append(ids, id)
		}
		return ids
	case tenant.EdgeInventoryReservations:
		ids := make([]ent.Value, 0, len(m.removedinventory_reservations))
		for id := range m.removedinventory_reservations {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TenantMutation) ClearedEdges() []string {
	edges := make([]string, 0, 34)
	if m.clearedparent {
		edges = append(edges, tenant.EdgeParent)
	}
	if m.clearedchildren {
		edges = append(edges, tenant.EdgeChildren)
	}
	if m.clearedusers {
		edges = append(edges, tenant.EdgeUsers)
	}
	if m.clearedaccounts {
		edges = append(edges, tenant.EdgeAccounts)
	}
	if m.clearedtransactions {
		edges = append(edges, tenant.EdgeTransactions)
	}
	if m.clearedledger_entries {
		edges = append(edges, tenant.EdgeLedgerEntries)
	}
	if m.clearedproducts {
		edges = append(edges, tenant.EdgeProducts)
	}
	if m.clearedstock_movements {
		edges = append(edges, tenant.EdgeStockMovements)
	}
	if m.clearedaudit_logs {
		edges = append(edges, tenant.EdgeAuditLogs)
	}
	if m.clearedagents {
		edges = append(edges, tenant.EdgeAgents)
	}
	if m.cleareddiscovery_entries {
		edges = append(edges, tenant.EdgeDiscoveryEntries)
	}
	if m.clearedassets {
		edges = append(edges, tenant.EdgeAssets)
	}
	if m.clearedcredentials {
		edges = append(edges, tenant.EdgeCredentials)
	}
	if m.clearedone_time_links {
		edges = append(edges, tenant.EdgeOneTimeLinks)
	}
	if m.clearedsops {
		edges = append(edges, tenant.EdgeSops)
	}
	if m.clearedcameras {
		edges = append(edges, tenant.EdgeCameras)
	}
	if m.clearedtickets {
		edges = append(edges, tenant.EdgeTickets)
	}
	if m.clearedcontracts {
		edges = append(edges, tenant.EdgeContracts)
	}
	if m.clearedsaas_apps {
		edges = append(edges, tenant.EdgeSaasApps)
	}
	if m.clearedsaas_filters {
		edges = append(edges, tenant.EdgeSaasFilters)
	}
	if m.clearedcall_logs {
		edges = append(edges, tenant.EdgeCallLogs)
	}
	if m.clearedivr_flows {
		edges = append(edges, tenant.EdgeIvrFlows)
	}
	if m.clearedvoicemails {
		edges = append(edges, tenant.EdgeVoicemails)
	}
	if m.clearedhealth_snapshots {
		edges = append(edges, tenant.EdgeHealthSnapshots)
	}
	if m.clearedroadmaps {
		edges = append(edges, tenant.EdgeRoadmaps)
	}
	if m.clearedservice_rates {
		edges = append(edges, tenant.EdgeServiceRates)
	}
	if m.clearedbudget_forecasts {
		edges = append(edges, tenant.EdgeBudgetForecasts)
	}
	if m.clearedemployees {
		edges = append(edges, tenant.EdgeEmployees)
	}
	if m.clearedcompensation_agreements {
		edges = append(edges, tenant.EdgeCompensationAgreements)
	}
	if m.clearedvault_items {
		edges = append(edges, tenant.EdgeVaultItems)
	}
	if m.clearedjournal_entries {
		edges = append(edges, tenant.EdgeJournalEntries)
	}
	if m.clearedrecurring_invoices {
		edges = append(edges, tenant.EdgeRecurringInvoices)
	}
	if m.clearedinventory_reservations {
		edges = append(edges, tenant.EdgeInventoryReservations)
	}
	if m.clearedcustomer_account {
		edges = append(edges, tenant.EdgeCustomerAccount)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TenantMutation) EdgeCleared(name string) bool {
	switch name {
	case tenant.EdgeParent:
		return m.clearedparent
	case tenant.EdgeChildren:
		return m.clearedchildren
	case tenant.EdgeUsers:
		return m.clearedusers
	case tenant.EdgeAccounts:
		return m.clearedaccounts
	case tenant.EdgeTransactions:
		return m.clearedtransactions
	case tenant.EdgeLedgerEntries:
		return m.clearedledger_entries
	case tenant.EdgeProducts:
		return m.clearedproducts
	case tenant.EdgeStockMovements:
		return m.clearedstock_movements
	case tenant.EdgeAuditLogs:
		return m.clearedaudit_logs
	case tenant.EdgeAgents:
		return m.clearedagents
	case tenant.EdgeDiscoveryEntries:
		return m.cleareddiscovery_entries
	case tenant.EdgeAssets:
		return m.clearedassets
	case tenant.EdgeCredentials:
		return m.clearedcredentials
	case tenant.EdgeOneTimeLinks:
		return m.clearedone_time_links
	case tenant.EdgeSops:
		return m.clearedsops
	case tenant.EdgeCameras:
		return m.clearedcameras
	case tenant.EdgeTickets:
		return m.clearedtickets
	case tenant.EdgeContracts:
		return m.clearedcontracts
	case tenant.EdgeSaasApps:
		return m.clearedsaas_apps
	case tenant.EdgeSaasFilters:
		return m.clearedsaas_filters
	case tenant.EdgeCallLogs:
		return m.clearedcall_logs
	case tenant.EdgeIvrFlows:
		return m.clearedivr_flows
	case tenant.EdgeVoicemails:
		return m.clearedvoicemails
	case tenant.EdgeHealthSnapshots:
		return m.clearedhealth_snapshots
	case tenant.EdgeRoadmaps:
		return m.clearedroadmaps
	case tenant.EdgeServiceRates:
		return m.clearedservice_rates
	case tenant.EdgeBudgetForecasts:
		return m.clearedbudget_forecasts
	case tenant.EdgeEmployees:
		return m.clearedemployees
	case tenant.EdgeCompensationAgreements:
		return m.clearedcompensation_agreements
	case tenant.EdgeVaultItems:
		return m.clearedvault_items
	case tenant.EdgeJournalEntries:
		return m.clearedjournal_entries
	case tenant.EdgeRecurringInvoices:
		return m.clearedrecurring_invoices
	case tenant.EdgeInventoryReservations:
		return m.clearedinventory_reservations
	case tenant.EdgeCustomerAccount:
		return m.clearedcustomer_account
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TenantMutation) ClearEdge(name string) error {
	switch name {
	case tenant.EdgeParent:
		m.ClearParent()
		return nil
	case tenant.EdgeCustomerAccount:
		m.ClearCustomerAccount()
		return nil
	}
	return fmt.Errorf("unknown Tenant unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TenantMutation) ResetEdge(name string) error {
	switch name {
	case tenant.EdgeParent:
		m.ResetParent()
		return nil
	case tenant.EdgeChildren:
		m.ResetChildren()
		return nil
	case tenant.EdgeUsers:
		m.ResetUsers()
		return nil
	case tenant.EdgeAccounts:
		m.ResetAccounts()
		return nil
	case tenant.EdgeTransactions:
		m.ResetTransactions()
		return nil
	case tenant.EdgeLedgerEntries:
		m.ResetLedgerEntries()
		return nil
	case tenant.EdgeProducts:
		m.ResetProducts()
		return nil
	case tenant.EdgeStockMovements:
		m.ResetStockMovements()
		return nil
	case tenant.EdgeAuditLogs:
		m.ResetAuditLogs()
		return nil
	case tenant.EdgeAgents:
		m.ResetAgents()
		return nil
	case tenant.EdgeDiscoveryEntries:
		m.ResetDiscoveryEntries()
		return nil
	case tenant.EdgeAssets:
		m.ResetAssets()
		return nil
	case tenant.EdgeCredentials:
		m.ResetCredentials()
		return nil
	case tenant.EdgeOneTimeLinks:
		m.ResetOneTimeLinks()
		return nil
	case tenant.EdgeSops:
		m.ResetSops()
		return nil
	case tenant.EdgeCameras:
		m.ResetCameras()
		return nil
	case tenant.EdgeTickets:
		m.ResetTickets()
		return nil
	case tenant.EdgeContracts:
		m.ResetContracts()
		return nil
	case tenant.EdgeSaasApps:
		m.ResetSaasApps()
		return nil
	case tenant.EdgeSaasFilters:
		m.ResetSaasFilters()
		return nil
	case tenant.EdgeCallLogs:
		m.ResetCallLogs()
		return nil
	case tenant.EdgeIvrFlows:
		m.ResetIvrFlows()
		return nil
	case tenant.EdgeVoicemails:
		m.ResetVoicemails()
		return nil
	case tenant.EdgeHealthSnapshots:
		m.ResetHealthSnapshots()
		return nil
	case tenant.EdgeRoadmaps:
		m.ResetRoadmaps()
		return nil
	case tenant.EdgeServiceRates:
		m.ResetServiceRates()
		return nil
	case tenant.EdgeBudgetForecasts:
		m.ResetBudgetForecasts()
		return nil
	case tenant.EdgeEmployees:
		m.ResetEmployees()
		return nil
	case tenant.EdgeCompensationAgreements:
		m.ResetCompensationAgreements()
		return nil
	case tenant.EdgeVaultItems:
		m.ResetVaultItems()
		return nil
	case tenant.EdgeJournalEntries:
		m.ResetJournalEntries()
		return nil
	case tenant.EdgeRecurringInvoices:
		m.ResetRecurringInvoices()
		return nil
	case tenant.EdgeInventoryReservations:
		m.ResetInventoryReservations()
		return nil
	case tenant.EdgeCustomerAccount:
		m.ResetCustomerAccount()
		return nil
	}
	return fmt.Errorf("unknown Tenant edge %s", name)
}

// TicketMutation represents an operation that mutates the Ticket nodes in the graph.
type TicketMutation struct {
	config
	op                       Op
	typ                      string
	id                       *int
	subject                  *string
	description              *string
	status                   *ticket.Status
	priority                 *ticket.Priority
	metadata                 *string
	created_at               *time.Time
	updated_at               *time.Time
	resolved_at              *time.Time
	due_date                 *time.Time
	claim_lease_owner        *string
	claim_lease_expires_at   *time.Time
	clearedFields            map[string]struct{}
	tenant                   *int
	clearedtenant            bool
	requester                *int
	clearedrequester         bool
	assignee                 *int
	clearedassignee          bool
	asset                    *int
	clearedasset             bool
	time_entries             map[int]struct{}
	removedtime_entries      map[int]struct{}
	clearedtime_entries      bool
	remediation_steps        map[int]struct{}
	removedremediation_steps map[int]struct{}
	clearedremediation_steps bool
	done                     bool
	oldValue                 func(context.Context) (*Ticket, error)
	predicates               []predicate.Ticket
}

var _ ent.Mutation = (*TicketMutation)(nil)

// ticketOption allows management of the mutation configuration using functional options.
type ticketOption func(*TicketMutation)

// newTicketMutation creates new mutation for the Ticket entity.
func newTicketMutation(c config, op Op, opts ...ticketOption) *TicketMutation {
	m := &TicketMutation{
		config:        c,
		op:            op,
		typ:           TypeTicket,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTicketID sets the ID field of the mutation.
func withTicketID(id int) ticketOption {
	return func(m *TicketMutation) {
		var (
			err   error
			once  sync.Once
			value *Ticket
		)
		m.oldValue = func(ctx context.Context) (*Ticket, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Ticket.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTicket sets the old Ticket of the mutation.
func withTicket(node *Ticket) ticketOption {
	return func(m *TicketMutation) {
		m.oldValue = func(context.Context) (*Ticket, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TicketMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TicketMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TicketMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TicketMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Ticket.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetSubject sets the "subject" field.
func (m *TicketMutation) SetSubject(s string) {
	m.subject = &s
}

// Subject returns the value of the "subject" field in the mutation.
func (m *TicketMutation) Subject() (r string, exists bool) {
	v := m.subject
	if v == nil {
		return
	}
	return *v, true
}

// OldSubject returns the old "subject" field's value of the Ticket entity.
// If the Ticket object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TicketMutation) OldSubject(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSubject is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSubject requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSubject: %w", err)
	}
	return oldValue.Subject, nil
}

// ResetSubject resets all changes to the "subject" field.
func (m *TicketMutation) ResetSubject() {
	m.subject = nil
}

// SetDescription sets the "description" field.
func (m *TicketMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *TicketMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Ticket entity.
// If the Ticket object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TicketMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *TicketMutation) ResetDescription() {
	m.description = nil
}

// SetStatus sets the "status" field.
func (m *TicketMutation) SetStatus(t ticket.Status) {
	m.status = &t
}

// Status returns the value of the "status" field in the mutation.
func (m *TicketMutation) Status() (r ticket.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Ticket entity.
// If the Ticket object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TicketMutation) OldStatus(ctx context.Context) (v ticket.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *TicketMutation) ResetStatus() {
	m.status = nil
}

// SetPriority sets the "priority" field.
func (m *TicketMutation) SetPriority(t ticket.Priority) {
	m.priority = &t
}

// Priority returns the value of the "priority" field in the mutation.
func (m *TicketMutation) Priority() (r ticket.Priority, exists bool) {
	v := m.priority
	if v == nil {
		return
	}
	return *v, true
}

// OldPriority returns the old "priority" field's value of the Ticket entity.
// If the Ticket object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TicketMutation) OldPriority(ctx context.Context) (v ticket.Priority, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPriority is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPriority requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPriority: %w", err)
	}
	return oldValue.Priority, nil
}

// ResetPriority resets all changes to the "priority" field.
func (m *TicketMutation) ResetPriority() {
	m.priority = nil
}

// SetMetadata sets the "metadata" field.
func (m *TicketMutation) SetMetadata(s string) {
	m.metadata = &s
}

// Metadata returns the value of the "metadata" field in the mutation.
func (m *TicketMutation) Metadata() (r string, exists bool) {
	v := m.metadata
	if v == nil {
		return
	}
	return *v, true
}

// OldMetadata returns the old "metadata" field's value of the Ticket entity.
// If the Ticket object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TicketMutation) OldMetadata(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMetadata is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMetadata requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetadata: %w", err)
	}
	return oldValue.Metadata, nil
}

// ClearMetadata clears the value of the "metadata" field.
func (m *TicketMutation) ClearMetadata() {
	m.metadata = nil
	m.clearedFields[ticket.FieldMetadata] = struct{}{}
}

// MetadataCleared returns if the "metadata" field was cleared in this mutation.
func (m *TicketMutation) MetadataCleared() bool {
	_, ok := m.clearedFields[ticket.FieldMetadata]
	return ok
}

// ResetMetadata resets all changes to the "metadata" field.
func (m *TicketMutation) ResetMetadata() {
	m.metadata = nil
	delete(m.clearedFields, ticket.FieldMetadata)
}

// SetCreatedAt sets the "created_at" field.
func (m *TicketMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *TicketMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Ticket entity.
// If the Ticket object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TicketMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *TicketMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *TicketMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *TicketMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Ticket entity.
// If the Ticket object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TicketMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *TicketMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetResolvedAt sets the "resolved_at" field.
func (m *TicketMutation) SetResolvedAt(t time.Time) {
	m.resolved_at = &t
}

// ResolvedAt returns the value of the "resolved_at" field in the mutation.
func (m *TicketMutation) ResolvedAt() (r time.Time, exists bool) {
	v := m.resolved_at
	if v == nil {
		return
	}
	return *v, true
}

// OldResolvedAt returns the old "resolved_at" field's value of the Ticket entity.
// If the Ticket object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TicketMutation) OldResolvedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResolvedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResolvedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResolvedAt: %w", err)
	}
	return oldValue.ResolvedAt, nil
}

// ClearResolvedAt clears the value of the "resolved_at" field.
func (m *TicketMutation) ClearResolvedAt() {
	m.resolved_at = nil
	m.clearedFields[ticket.FieldResolvedAt] = struct{}{}
}

// ResolvedAtCleared returns if the "resolved_at" field was cleared in this mutation.
func (m *TicketMutation) ResolvedAtCleared() bool {
	_, ok := m.clearedFields[ticket.FieldResolvedAt]
	return ok
}

// ResetResolvedAt resets all changes to the "resolved_at" field.
func (m *TicketMutation) ResetResolvedAt() {
	m.resolved_at = nil
	delete(m.clearedFields, ticket.FieldResolvedAt)
}

// SetDueDate sets the "due_date" field.
func (m *TicketMutation) SetDueDate(t time.Time) {
	m.due_date = &t
}

// DueDate returns the value of the "due_date" field in the mutation.
func (m *TicketMutation) DueDate() (r time.Time, exists bool) {
	v := m.due_date
	if v == nil {
		return
	}
	return *v, true
}

// OldDueDate returns the old "due_date" field's value of the Ticket entity.
// If the Ticket object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TicketMutation) OldDueDate(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDueDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDueDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDueDate: %w", err)
	}
	return oldValue.DueDate, nil
}

// ClearDueDate clears the value of the "due_date" field.
func (m *TicketMutation) ClearDueDate() {
	m.due_date = nil
	m.clearedFields[ticket.FieldDueDate] = struct{}{}
}

// DueDateCleared returns if the "due_date" field was cleared in this mutation.
func (m *TicketMutation) DueDateCleared() bool {
	_, ok := m.clearedFields[ticket.FieldDueDate]
	return ok
}

// ResetDueDate resets all changes to the "due_date" field.
func (m *TicketMutation) ResetDueDate() {
	m.due_date = nil
	delete(m.clearedFields, ticket.FieldDueDate)
}

// SetClaimLeaseOwner sets the "claim_lease_owner" field.
func (m *TicketMutation) SetClaimLeaseOwner(s string) {
	m.claim_lease_owner = &s
}

// ClaimLeaseOwner returns the value of the "claim_lease_owner" field in the mutation.
func (m *TicketMutation) ClaimLeaseOwner() (r string, exists bool) {
	v := m.claim_lease_owner
	if v == nil {
		return
	}
	return *v, true
}

// OldClaimLeaseOwner returns the old "claim_lease_owner" field's value of the Ticket entity.
// If the Ticket object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TicketMutation) OldClaimLeaseOwner(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClaimLeaseOwner is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClaimLeaseOwner requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClaimLeaseOwner: %w", err)
	}
	return oldValue.ClaimLeaseOwner, nil
}

// ClearClaimLeaseOwner clears the value of the "claim_lease_owner" field.
func (m *TicketMutation) ClearClaimLeaseOwner() {
	m.claim_lease_owner = nil
	m.clearedFields[ticket.FieldClaimLeaseOwner] = struct{}{}
}

// ClaimLeaseOwnerCleared returns if the "claim_lease_owner" field was cleared in this mutation.
func (m *TicketMutation) ClaimLeaseOwnerCleared() bool {
	_, ok := m.clearedFields[ticket.FieldClaimLeaseOwner]
	return ok
}

// ResetClaimLeaseOwner resets all changes to the "claim_lease_owner" field.
func (m *TicketMutation) ResetClaimLeaseOwner() {
	m.claim_lease_owner = nil
	delete(m.clearedFields, ticket.FieldClaimLeaseOwner)
}

// SetClaimLeaseExpiresAt sets the "claim_lease_expires_at" field.
func (m *TicketMutation) SetClaimLeaseExpiresAt(t time.Time) {
	m.claim_lease_expires_at = &t
}

// ClaimLeaseExpiresAt returns the value of the "claim_lease_expires_at" field in the mutation.
func (m *TicketMutation) ClaimLeaseExpiresAt() (r time.Time, exists bool) {
	v := m.claim_lease_expires_at
	if v == nil {
		return
	}
	return *v, true
}

// OldClaimLeaseExpiresAt returns the old "claim_lease_expires_at" field's value of the Ticket entity.
// If the Ticket object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TicketMutation) OldClaimLeaseExpiresAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClaimLeaseExpiresAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClaimLeaseExpiresAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClaimLeaseExpiresAt: %w", err)
	}
	return oldValue.ClaimLeaseExpiresAt, nil
}

// ClearClaimLeaseExpiresAt clears the value of the "claim_lease_expires_at" field.
func (m *TicketMutation) ClearClaimLeaseExpiresAt() {
	m.claim_lease_expires_at = nil
	m.clearedFields[ticket.FieldClaimLeaseExpiresAt] = struct{}{}
}

// ClaimLeaseExpiresAtCleared returns if the "claim_lease_expires_at" field was cleared in this mutation.
func (m *TicketMutation) ClaimLeaseExpiresAtCleared() bool {
	_, ok := m.clearedFields[ticket.FieldClaimLeaseExpiresAt]
	return ok
}

// ResetClaimLeaseExpiresAt resets all changes to the "claim_lease_expires_at" field.
func (m *TicketMutation) ResetClaimLeaseExpiresAt() {
	m.claim_lease_expires_at = nil
	delete(m.clearedFields, ticket.FieldClaimLeaseExpiresAt)
}

// SetTenantID sets the "tenant" edge to the Tenant entity by id.
func (m *TicketMutation) SetTenantID(id int) {
	m.tenant = &id
}

// ClearTenant clears the "tenant" edge to the Tenant entity.
func (m *TicketMutation) ClearTenant() {
	m.clearedtenant = true
}

// TenantCleared reports if the "tenant" edge to the Tenant entity was cleared.
func (m *TicketMutation) TenantCleared() bool {
	return m.clearedtenant
}

// TenantID returns the "tenant" edge ID in the mutation.
func (m *TicketMutation) TenantID() (id int, exists bool) {
	if m.tenant != nil {
		return *m.tenant, true
	}
	return
}

// TenantIDs returns the "tenant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TenantID instead. It exists only for internal usage by the builders.
func (m *TicketMutation) TenantIDs() (ids []int) {
	if id := m.tenant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTenant resets all changes to the "tenant" edge.
func (m *TicketMutation) ResetTenant() {
	m.tenant = nil
	m.clearedtenant = false
}

// SetRequesterID sets the "requester" edge to the User entity by id.
func (m *TicketMutation) SetRequesterID(id int) {
	m.requester = &id
}

// ClearRequester clears the "requester" edge to the User entity.
func (m *TicketMutation) ClearRequester() {
	m.clearedrequester = true
}

// RequesterCleared reports if the "requester" edge to the User entity was cleared.
func (m *TicketMutation) RequesterCleared() bool {
	return m.clearedrequester
}

// RequesterID returns the "requester" edge ID in the mutation.
func (m *TicketMutation) RequesterID() (id int, exists bool) {
	if m.requester != nil {
		return *m.requester, true
	}
	return
}

// RequesterIDs returns the "requester" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RequesterID instead. It exists only for internal usage by the builders.
func (m *TicketMutation) RequesterIDs() (ids []int) {
	if id := m.requester; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRequester resets all changes to the "requester" edge.
func (m *TicketMutation) ResetRequester() {
	m.requester = nil
	m.clearedrequester = false
}

// SetAssigneeID sets the "assignee" edge to the User entity by id.
func (m *TicketMutation) SetAssigneeID(id int) {
	m.assignee = &id
}

// ClearAssignee clears the "assignee" edge to the User entity.
func (m *TicketMutation) ClearAssignee() {
	m.clearedassignee = true
}

// AssigneeCleared reports if the "assignee" edge to the User entity was cleared.
func (m *TicketMutation) AssigneeCleared() bool {
	return m.clearedassignee
}

// AssigneeID returns the "assignee" edge ID in the mutation.
func (m *TicketMutation) AssigneeID() (id int, exists bool) {
	if m.assignee != nil {
		return *m.assignee, true
	}
	return
}

// AssigneeIDs returns the "assignee" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AssigneeID instead. It exists only for internal usage by the builders.
func (m *TicketMutation) AssigneeIDs() (ids []int) {
	if id := m.assignee; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAssignee resets all changes to the "assignee" edge.
func (m *TicketMutation) ResetAssignee() {
	m.assignee = nil
	m.clearedassignee = false
}

// SetAssetID sets the "asset" edge to the Asset entity by id.
func (m *TicketMutation) SetAssetID(id int) {
	m.asset = &id
}

// ClearAsset clears the "asset" edge to the Asset entity.
func (m *TicketMutation) ClearAsset() {
	m.clearedasset = true
}

// AssetCleared reports if the "asset" edge to the Asset entity was cleared.
func (m *TicketMutation) AssetCleared() bool {
	return m.clearedasset
}

// AssetID returns the "asset" edge ID in the mutation.
func (m *TicketMutation) AssetID() (id int, exists bool) {
	if m.asset != nil {
		return *m.asset, true
	}
	return
}

// AssetIDs returns the "asset" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AssetID instead. It exists only for internal usage by the builders.
func (m *TicketMutation) AssetIDs() (ids []int) {
	if id := m.asset; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAsset resets all changes to the "asset" edge.
func (m *TicketMutation) ResetAsset() {
	m.asset = nil
	m.clearedasset = false
}

// AddTimeEntryIDs adds the "time_entries" edge to the TimeEntry entity by ids.
func (m *TicketMutation) AddTimeEntryIDs(ids ...int) {
	if m.time_entries == nil {
		m.time_entries = make(map[int]struct{})
	}
	for i := range ids {
		m.time_entries[ids[i]] = struct{}{}
	}
}

// ClearTimeEntries clears the "time_entries" edge to the TimeEntry entity.
func (m *TicketMutation) ClearTimeEntries() {
	m.clearedtime_entries = true
}

// TimeEntriesCleared reports if the "time_entries" edge to the TimeEntry entity was cleared.
func (m *TicketMutation) TimeEntriesCleared() bool {
	return m.clearedtime_entries
}

// RemoveTimeEntryIDs removes the "time_entries" edge to the TimeEntry entity by IDs.
func (m *TicketMutation) RemoveTimeEntryIDs(ids ...int) {
	if m.removedtime_entries == nil {
		m.removedtime_entries = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.time_entries, ids[i])
		m.removedtime_entries[ids[i]] = struct{}{}
	}
}

// RemovedTimeEntries returns the removed IDs of the "time_entries" edge to the TimeEntry entity.
func (m *TicketMutation) RemovedTimeEntriesIDs() (ids []int) {
	for id := range m.removedtime_entries {
		ids = append(ids, id)
	}
	return
}

// TimeEntriesIDs returns the "time_entries" edge IDs in the mutation.
func (m *TicketMutation) TimeEntriesIDs() (ids []int) {
	for id := range m.time_entries {
		ids = append(ids, id)
	}
	return
}

// ResetTimeEntries resets all changes to the "time_entries" edge.
func (m *TicketMutation) ResetTimeEntries() {
	m.time_entries = nil
	m.clearedtime_entries = false
	m.removedtime_entries = nil
}

// AddRemediationStepIDs adds the "remediation_steps" edge to the RemediationStep entity by ids.
func (m *TicketMutation) AddRemediationStepIDs(ids ...int) {
	if m.remediation_steps == nil {
		m.remediation_steps = make(map[int]struct{})
	}
	for i := range ids {
		m.remediation_steps[ids[i]] = struct{}{}
	}
}

// ClearRemediationSteps clears the "remediation_steps" edge to the RemediationStep entity.
func (m *TicketMutation) ClearRemediationSteps() {
	m.clearedremediation_steps = true
}

// RemediationStepsCleared reports if the "remediation_steps" edge to the RemediationStep entity was cleared.
func (m *TicketMutation) RemediationStepsCleared() bool {
	return m.clearedremediation_steps
}

// RemoveRemediationStepIDs removes the "remediation_steps" edge to the RemediationStep entity by IDs.
func (m *TicketMutation) RemoveRemediationStepIDs(ids ...int) {
	if m.removedremediation_steps == nil {
		m.removedremediation_steps = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.remediation_steps, ids[i])
		m.removedremediation_steps[ids[i]] = struct{}{}
	}
}

// RemovedRemediationSteps returns the removed IDs of the "remediation_steps" edge to the RemediationStep entity.
func (m *TicketMutation) RemovedRemediationStepsIDs() (ids []int) {
	for id := range m.removedremediation_steps {
		ids = append(ids, id)
	}
	return
}

// RemediationStepsIDs returns the "remediation_steps" edge IDs in the mutation.
func (m *TicketMutation) RemediationStepsIDs() (ids []int) {
	for id := range m.remediation_steps {
		ids = append(ids, id)
	}
	return
}

// ResetRemediationSteps resets all changes to the "remediation_steps" edge.
func (m *TicketMutation) ResetRemediationSteps() {
	m.remediation_steps = nil
	m.clearedremediation_steps = false
	m.removedremediation_steps = nil
}

// Where appends a list predicates to the TicketMutation builder.
func (m *TicketMutation) Where(ps ...predicate.Ticket) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TicketMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TicketMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Ticket, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TicketMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TicketMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Ticket).
func (m *TicketMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TicketMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.subject != nil {
		fields = append(fields, ticket.FieldSubject)
	}
	if m.description != nil {
		fields = append(fields, ticket.FieldDescription)
	}
	if m.status != nil {
		fields = append(fields, ticket.FieldStatus)
	}
	if m.priority != nil {
		fields = append(fields, ticket.FieldPriority)
	}
	if m.metadata != nil {
		fields = append(fields, ticket.FieldMetadata)
	}
	if m.created_at != nil {
		fields = append(fields, ticket.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, ticket.FieldUpdatedAt)
	}
	if m.resolved_at != nil {
		fields = append(fields, ticket.FieldResolvedAt)
	}
	if m.due_date != nil {
		fields = append(fields, ticket.FieldDueDate)
	}
	if m.claim_lease_owner != nil {
		fields = append(fields, ticket.FieldClaimLeaseOwner)
	}
	if m.claim_lease_expires_at != nil {
		fields = append(fields, ticket.FieldClaimLeaseExpiresAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TicketMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case ticket.FieldSubject:
		return m.Subject()
	case ticket.FieldDescription:
		return m.Description()
	case ticket.FieldStatus:
		return m.Status()
	case ticket.FieldPriority:
		return m.Priority()
	case ticket.FieldMetadata:
		return m.Metadata()
	case ticket.FieldCreatedAt:
		return m.CreatedAt()
	case ticket.FieldUpdatedAt:
		return m.UpdatedAt()
	case ticket.FieldResolvedAt:
		return m.ResolvedAt()
	case ticket.FieldDueDate:
		return m.DueDate()
	case ticket.FieldClaimLeaseOwner:
		return m.ClaimLeaseOwner()
	case ticket.FieldClaimLeaseExpiresAt:
		return m.ClaimLeaseExpiresAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TicketMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case ticket.FieldSubject:
		return m.OldSubject(ctx)
	case ticket.FieldDescription:
		return m.OldDescription(ctx)
	case ticket.FieldStatus:
		return m.OldStatus(ctx)
	case ticket.FieldPriority:
		return m.OldPriority(ctx)
	case ticket.FieldMetadata:
		return m.OldMetadata(ctx)
	case ticket.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case ticket.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case ticket.FieldResolvedAt:
		return m.OldResolvedAt(ctx)
	case ticket.FieldDueDate:
		return m.OldDueDate(ctx)
	case ticket.FieldClaimLeaseOwner:
		return m.OldClaimLeaseOwner(ctx)
	case ticket.FieldClaimLeaseExpiresAt:
		return m.OldClaimLeaseExpiresAt(ctx)
	}
	return nil, fmt.Errorf("unknown Ticket field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TicketMutation) SetField(name string, value ent.Value) error {
	switch name {
	case ticket.FieldSubject:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSubject(v)
		return nil
	case ticket.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case ticket.FieldStatus:
		v, ok := value.(ticket.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case ticket.FieldPriority:
		v, ok := value.(ticket.Priority)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPriority(v)
		return nil
	case ticket.FieldMetadata:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetadata(v)
		return nil
	case ticket.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case ticket.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case ticket.FieldResolvedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResolvedAt(v)
		return nil
	case ticket.FieldDueDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDueDate(v)
		return nil
	case ticket.FieldClaimLeaseOwner:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClaimLeaseOwner(v)
		return nil
	case ticket.FieldClaimLeaseExpiresAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClaimLeaseExpiresAt(v)
		return nil
	}
	return fmt.Errorf("unknown Ticket field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TicketMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TicketMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TicketMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Ticket numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TicketMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(ticket.FieldMetadata) {
		fields = append(fields, ticket.FieldMetadata)
	}
	if m.FieldCleared(ticket.FieldResolvedAt) {
		fields = append(fields, ticket.FieldResolvedAt)
	}
	if m.FieldCleared(ticket.FieldDueDate) {
		fields = append(fields, ticket.FieldDueDate)
	}
	if m.FieldCleared(ticket.FieldClaimLeaseOwner) {
		fields = append(fields, ticket.FieldClaimLeaseOwner)
	}
	if m.FieldCleared(ticket.FieldClaimLeaseExpiresAt) {
		fields = append(fields, ticket.FieldClaimLeaseExpiresAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TicketMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TicketMutation) ClearField(name string) error {
	switch name {
	case ticket.FieldMetadata:
		m.ClearMetadata()
		return nil
	case ticket.FieldResolvedAt:
		m.ClearResolvedAt()
		return nil
	case ticket.FieldDueDate:
		m.ClearDueDate()
		return nil
	case ticket.FieldClaimLeaseOwner:
		m.ClearClaimLeaseOwner()
		return nil
	case ticket.FieldClaimLeaseExpiresAt:
		m.ClearClaimLeaseExpiresAt()
		return nil
	}
	return fmt.Errorf("unknown Ticket nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TicketMutation) ResetField(name string) error {
	switch name {
	case ticket.FieldSubject:
		m.ResetSubject()
		return nil
	case ticket.FieldDescription:
		m.ResetDescription()
		return nil
	case ticket.FieldStatus:
		m.ResetStatus()
		return nil
	case ticket.FieldPriority:
		m.ResetPriority()
		return nil
	case ticket.FieldMetadata:
		m.ResetMetadata()
		return nil
	case ticket.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case ticket.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case ticket.FieldResolvedAt:
		m.ResetResolvedAt()
		return nil
	case ticket.FieldDueDate:
		m.ResetDueDate()
		return nil
	case ticket.FieldClaimLeaseOwner:
		m.ResetClaimLeaseOwner()
		return nil
	case ticket.FieldClaimLeaseExpiresAt:
		m.ResetClaimLeaseExpiresAt()
		return nil
	}
	return fmt.Errorf("unknown Ticket field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TicketMutation) AddedEdges() []string {
	edges := make([]string, 0, 6)
	if m.tenant != nil {
		edges = append(edges, ticket.EdgeTenant)
	}
	if m.requester != nil {
		edges = append(edges, ticket.EdgeRequester)
	}
	if m.assignee != nil {
		edges = append(edges, ticket.EdgeAssignee)
	}
	if m.asset != nil {
		edges = append(edges, ticket.EdgeAsset)
	}
	if m.time_entries != nil {
		edges = append(edges, ticket.EdgeTimeEntries)
	}
	if m.remediation_steps != nil {
		edges = append(edges, ticket.EdgeRemediationSteps)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TicketMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case ticket.EdgeTenant:
		if id := m.tenant; id != nil {
			return []ent.Value{*id}
		}
	case ticket.EdgeRequester:
		if id := m.requester; id != nil {
			return []ent.Value{*id}
		}
	case ticket.EdgeAssignee:
		if id := m.assignee; id != nil {
			return []ent.Value{*id}
		}
	case ticket.EdgeAsset:
		if id := m.asset; id != nil {
			return []ent.Value{*id}
		}
	case ticket.EdgeTimeEntries:
		ids := make([]ent.Value, 0, len(m.time_entries))
		for id := range m.time_entries {
			ids = append(ids, id)
		}
		return ids
	case ticket.EdgeRemediationSteps:
		ids := make([]ent.Value, 0, len(m.remediation_steps))
		for id := range m.remediation_steps {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TicketMutation) RemovedEdges() []string {
	edges := make([]string, 0, 6)
	if m.removedtime_entries != nil {
		edges = append(edges, ticket.EdgeTimeEntries)
	}
	if m.removedremediation_steps != nil {
		edges = append(edges, ticket.EdgeRemediationSteps)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TicketMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case ticket.EdgeTimeEntries:
		ids := make([]ent.Value, 0, len(m.removedtime_entries))
		for id := range m.removedtime_entries {
			ids = append(ids, id)
		}
		return ids
	case ticket.EdgeRemediationSteps:
		ids := make([]ent.Value, 0, len(m.removedremediation_steps))
		for id := range m.removedremediation_steps {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TicketMutation) ClearedEdges() []string {
	edges := make([]string, 0, 6)
	if m.clearedtenant {
		edges = append(edges, ticket.EdgeTenant)
	}
	if m.clearedrequester {
		edges = append(edges, ticket.EdgeRequester)
	}
	if m.clearedassignee {
		edges = append(edges, ticket.EdgeAssignee)
	}
	if m.clearedasset {
		edges = append(edges, ticket.EdgeAsset)
	}
	if m.clearedtime_entries {
		edges = append(edges, ticket.EdgeTimeEntries)
	}
	if m.clearedremediation_steps {
		edges = append(edges, ticket.EdgeRemediationSteps)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TicketMutation) EdgeCleared(name string) bool {
	switch name {
	case ticket.EdgeTenant:
		return m.clearedtenant
	case ticket.EdgeRequester:
		return m.clearedrequester
	case ticket.EdgeAssignee:
		return m.clearedassignee
	case ticket.EdgeAsset:
		return m.clearedasset
	case ticket.EdgeTimeEntries:
		return m.clearedtime_entries
	case ticket.EdgeRemediationSteps:
		return m.clearedremediation_steps
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TicketMutation) ClearEdge(name string) error {
	switch name {
	case ticket.EdgeTenant:
		m.ClearTenant()
		return nil
	case ticket.EdgeRequester:
		m.ClearRequester()
		return nil
	case ticket.EdgeAssignee:
		m.ClearAssignee()
		return nil
	case ticket.EdgeAsset:
		m.ClearAsset()
		return nil
	}
	return fmt.Errorf("unknown Ticket unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TicketMutation) ResetEdge(name string) error {
	switch name {
	case ticket.EdgeTenant:
		m.ResetTenant()
		return nil
	case ticket.EdgeRequester:
		m.ResetRequester()
		return nil
	case ticket.EdgeAssignee:
		m.ResetAssignee()
		return nil
	case ticket.EdgeAsset:
		m.ResetAsset()
		return nil
	case ticket.EdgeTimeEntries:
		m.ResetTimeEntries()
		return nil
	case ticket.EdgeRemediationSteps:
		m.ResetRemediationSteps()
		return nil
	}
	return fmt.Errorf("unknown Ticket edge %s", name)
}

// TimeEntryMutation represents an operation that mutates the TimeEntry nodes in the graph.
type TimeEntryMutation struct {
	config
	op                Op
	typ               string
	id                *int
	duration_hours    *float64
	addduration_hours *float64
	note              *string
	started_at        *time.Time
	is_billable       *bool
	status            *timeentry.Status
	work_type         *string
	invoice_id        *int
	addinvoice_id     *int
	clearedFields     map[string]struct{}
	ticket            *int
	clearedticket     bool
	technician        *int
	clearedtechnician bool
	done              bool
	oldValue          func(context.Context) (*TimeEntry, error)
	predicates        []predicate.TimeEntry
}

var _ ent.Mutation = (*TimeEntryMutation)(nil)

// timeentryOption allows management of the mutation configuration using functional options.
type timeentryOption func(*TimeEntryMutation)

// newTimeEntryMutation creates new mutation for the TimeEntry entity.
func newTimeEntryMutation(c config, op Op, opts ...timeentryOption) *TimeEntryMutation {
	m := &TimeEntryMutation{
		config:        c,
		op:            op,
		typ:           TypeTimeEntry,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTimeEntryID sets the ID field of the mutation.
func withTimeEntryID(id int) timeentryOption {
	return func(m *TimeEntryMutation) {
		var (
			err   error
			once  sync.Once
			value *TimeEntry
		)
		m.oldValue = func(ctx context.Context) (*TimeEntry, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().TimeEntry.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTimeEntry sets the old TimeEntry of the mutation.
func withTimeEntry(node *TimeEntry) timeentryOption {
	return func(m *TimeEntryMutation) {
		m.oldValue = func(context.Context) (*TimeEntry, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TimeEntryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TimeEntryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TimeEntryMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TimeEntryMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().TimeEntry.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetDurationHours sets the "duration_hours" field.
func (m *TimeEntryMutation) SetDurationHours(f float64) {
	m.duration_hours = &f
	m.addduration_hours = nil
}

// DurationHours returns the value of the "duration_hours" field in the mutation.
func (m *TimeEntryMutation) DurationHours() (r float64, exists bool) {
	v := m.duration_hours
	if v == nil {
		return
	}
	return *v, true
}

// OldDurationHours returns the old "duration_hours" field's value of the TimeEntry entity.
// If the TimeEntry object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TimeEntryMutation) OldDurationHours(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDurationHours is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDurationHours requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDurationHours: %w", err)
	}
	return oldValue.DurationHours, nil
}

// AddDurationHours adds f to the "duration_hours" field.
func (m *TimeEntryMutation) AddDurationHours(f float64) {
	if m.addduration_hours != nil {
		*m.addduration_hours += f
	} else {
		m.addduration_hours = &f
	}
}

// AddedDurationHours returns the value that was added to the "duration_hours" field in this mutation.
func (m *TimeEntryMutation) AddedDurationHours() (r float64, exists bool) {
	v := m.addduration_hours
	if v == nil {
		return
	}
	return *v, true
}

// ResetDurationHours resets all changes to the "duration_hours" field.
func (m *TimeEntryMutation) ResetDurationHours() {
	m.duration_hours = nil
	m.addduration_hours = nil
}

// SetNote sets the "note" field.
func (m *TimeEntryMutation) SetNote(s string) {
	m.note = &s
}

// Note returns the value of the "note" field in the mutation.
func (m *TimeEntryMutation) Note() (r string, exists bool) {
	v := m.note
	if v == nil {
		return
	}
	return *v, true
}

// OldNote returns the old "note" field's value of the TimeEntry entity.
// If the TimeEntry object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TimeEntryMutation) OldNote(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNote is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNote requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNote: %w", err)
	}
	return oldValue.Note, nil
}

// ResetNote resets all changes to the "note" field.
func (m *TimeEntryMutation) ResetNote() {
	m.note = nil
}

// SetStartedAt sets the "started_at" field.
func (m *TimeEntryMutation) SetStartedAt(t time.Time) {
	m.started_at = &t
}

// StartedAt returns the value of the "started_at" field in the mutation.
func (m *TimeEntryMutation) StartedAt() (r time.Time, exists bool) {
	v := m.started_at
	if v == nil {
		return
	}
	return *v, true
}

// OldStartedAt returns the old "started_at" field's value of the TimeEntry entity.
// If the TimeEntry object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TimeEntryMutation) OldStartedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartedAt: %w", err)
	}
	return oldValue.StartedAt, nil
}

// ResetStartedAt resets all changes to the "started_at" field.
func (m *TimeEntryMutation) ResetStartedAt() {
	m.started_at = nil
}

// SetIsBillable sets the "is_billable" field.
func (m *TimeEntryMutation) SetIsBillable(b bool) {
	m.is_billable = &b
}

// IsBillable returns the value of the "is_billable" field in the mutation.
func (m *TimeEntryMutation) IsBillable() (r bool, exists bool) {
	v := m.is_billable
	if v == nil {
		return
	}
	return *v, true
}

// OldIsBillable returns the old "is_billable" field's value of the TimeEntry entity.
// If the TimeEntry object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TimeEntryMutation) OldIsBillable(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsBillable is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsBillable requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsBillable: %w", err)
	}
	return oldValue.IsBillable, nil
}

// ResetIsBillable resets all changes to the "is_billable" field.
func (m *TimeEntryMutation) ResetIsBillable() {
	m.is_billable = nil
}

// SetStatus sets the "status" field.
func (m *TimeEntryMutation) SetStatus(t timeentry.Status) {
	m.status = &t
}

// Status returns the value of the "status" field in the mutation.
func (m *TimeEntryMutation) Status() (r timeentry.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the TimeEntry entity.
// If the TimeEntry object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TimeEntryMutation) OldStatus(ctx context.Context) (v timeentry.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *TimeEntryMutation) ResetStatus() {
	m.status = nil
}

// SetWorkType sets the "work_type" field.
func (m *TimeEntryMutation) SetWorkType(s string) {
	m.work_type = &s
}

// WorkType returns the value of the "work_type" field in the mutation.
func (m *TimeEntryMutation) WorkType() (r string, exists bool) {
	v := m.work_type
	if v == nil {
		return
	}
	return *v, true
}

// OldWorkType returns the old "work_type" field's value of the TimeEntry entity.
// If the TimeEntry object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TimeEntryMutation) OldWorkType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWorkType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWorkType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWorkType: %w", err)
	}
	return oldValue.WorkType, nil
}

// ResetWorkType resets all changes to the "work_type" field.
func (m *TimeEntryMutation) ResetWorkType() {
	m.work_type = nil
}

// SetInvoiceID sets the "invoice_id" field.
func (m *TimeEntryMutation) SetInvoiceID(i int) {
	m.invoice_id = &i
	m.addinvoice_id = nil
}

// InvoiceID returns the value of the "invoice_id" field in the mutation.
func (m *TimeEntryMutation) InvoiceID() (r int, exists bool) {
	v := m.invoice_id
	if v == nil {
		return
	}
	return *v, true
}

// OldInvoiceID returns the old "invoice_id" field's value of the TimeEntry entity.
// If the TimeEntry object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TimeEntryMutation) OldInvoiceID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInvoiceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInvoiceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInvoiceID: %w", err)
	}
	return oldValue.InvoiceID, nil
}

// AddInvoiceID adds i to the "invoice_id" field.
func (m *TimeEntryMutation) AddInvoiceID(i int) {
	if m.addinvoice_id != nil {
		*m.addinvoice_id += i
	} else {
		m.addinvoice_id = &i
	}
}

// AddedInvoiceID returns the value that was added to the "invoice_id" field in this mutation.
func (m *TimeEntryMutation) AddedInvoiceID() (r int, exists bool) {
	v := m.addinvoice_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearInvoiceID clears the value of the "invoice_id" field.
func (m *TimeEntryMutation) ClearInvoiceID() {
	m.invoice_id = nil
	m.addinvoice_id = nil
	m.clearedFields[timeentry.FieldInvoiceID] = struct{}{}
}

// InvoiceIDCleared returns if the "invoice_id" field was cleared in this mutation.
func (m *TimeEntryMutation) InvoiceIDCleared() bool {
	_, ok := m.clearedFields[timeentry.FieldInvoiceID]
	return ok
}

// ResetInvoiceID resets all changes to the "invoice_id" field.
func (m *TimeEntryMutation) ResetInvoiceID() {
	m.invoice_id = nil
	m.addinvoice_id = nil
	delete(m.clearedFields, timeentry.FieldInvoiceID)
}

// SetTicketID sets the "ticket" edge to the Ticket entity by id.
func (m *TimeEntryMutation) SetTicketID(id int) {
	m.ticket = &id
}

// ClearTicket clears the "ticket" edge to the Ticket entity.
func (m *TimeEntryMutation) ClearTicket() {
	m.clearedticket = true
}

// TicketCleared reports if the "ticket" edge to the Ticket entity was cleared.
func (m *TimeEntryMutation) TicketCleared() bool {
	return m.clearedticket
}

// TicketID returns the "ticket" edge ID in the mutation.
func (m *TimeEntryMutation) TicketID() (id int, exists bool) {
	if m.ticket != nil {
		return *m.ticket, true
	}
	return
}

// TicketIDs returns the "ticket" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TicketID instead. It exists only for internal usage by the builders.
func (m *TimeEntryMutation) TicketIDs() (ids []int) {
	if id := m.ticket; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTicket resets all changes to the "ticket" edge.
func (m *TimeEntryMutation) ResetTicket() {
	m.ticket = nil
	m.clearedticket = false
}

// SetTechnicianID sets the "technician" edge to the User entity by id.
func (m *TimeEntryMutation) SetTechnicianID(id int) {
	m.technician = &id
}

// ClearTechnician clears the "technician" edge to the User entity.
func (m *TimeEntryMutation) ClearTechnician() {
	m.clearedtechnician = true
}

// TechnicianCleared reports if the "technician" edge to the User entity was cleared.
func (m *TimeEntryMutation) TechnicianCleared() bool {
	return m.clearedtechnician
}

// TechnicianID returns the "technician" edge ID in the mutation.
func (m *TimeEntryMutation) TechnicianID() (id int, exists bool) {
	if m.technician != nil {
		return *m.technician, true
	}
	return
}

// TechnicianIDs returns the "technician" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TechnicianID instead. It exists only for internal usage by the builders.
func (m *TimeEntryMutation) TechnicianIDs() (ids []int) {
	if id := m.technician; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTechnician resets all changes to the "technician" edge.
func (m *TimeEntryMutation) ResetTechnician() {
	m.technician = nil
	m.clearedtechnician = false
}

// Where appends a list predicates to the TimeEntryMutation builder.
func (m *TimeEntryMutation) Where(ps ...predicate.TimeEntry) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TimeEntryMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TimeEntryMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.TimeEntry, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TimeEntryMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TimeEntryMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (TimeEntry).
func (m *TimeEntryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TimeEntryMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.duration_hours != nil {
		fields = append(fields, timeentry.FieldDurationHours)
	}
	if m.note != nil {
		fields = append(fields, timeentry.FieldNote)
	}
	if m.started_at != nil {
		fields = append(fields, timeentry.FieldStartedAt)
	}
	if m.is_billable != nil {
		fields = append(fields, timeentry.FieldIsBillable)
	}
	if m.status != nil {
		fields = append(fields, timeentry.FieldStatus)
	}
	if m.work_type != nil {
		fields = append(fields, timeentry.FieldWorkType)
	}
	if m.invoice_id != nil {
		fields = append(fields, timeentry.FieldInvoiceID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TimeEntryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case timeentry.FieldDurationHours:
		return m.DurationHours()
	case timeentry.FieldNote:
		return m.Note()
	case timeentry.FieldStartedAt:
		return m.StartedAt()
	case timeentry.FieldIsBillable:
		return m.IsBillable()
	case timeentry.FieldStatus:
		return m.Status()
	case timeentry.FieldWorkType:
		return m.WorkType()
	case timeentry.FieldInvoiceID:
		return m.InvoiceID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TimeEntryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case timeentry.FieldDurationHours:
		return m.OldDurationHours(ctx)
	case timeentry.FieldNote:
		return m.OldNote(ctx)
	case timeentry.FieldStartedAt:
		return m.OldStartedAt(ctx)
	case timeentry.FieldIsBillable:
		return m.OldIsBillable(ctx)
	case timeentry.FieldStatus:
		return m.OldStatus(ctx)
	case timeentry.FieldWorkType:
		return m.OldWorkType(ctx)
	case timeentry.FieldInvoiceID:
		return m.OldInvoiceID(ctx)
	}
	return nil, fmt.Errorf("unknown TimeEntry field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TimeEntryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case timeentry.FieldDurationHours:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDurationHours(v)
		return nil
	case timeentry.FieldNote:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNote(v)
		return nil
	case timeentry.FieldStartedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartedAt(v)
		return nil
	case timeentry.FieldIsBillable:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsBillable(v)
		return nil
	case timeentry.FieldStatus:
		v, ok := value.(timeentry.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case timeentry.FieldWorkType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWorkType(v)
		return nil
	case timeentry.FieldInvoiceID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInvoiceID(v)
		return nil
	}
	return fmt.Errorf("unknown TimeEntry field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TimeEntryMutation) AddedFields() []string {
	var fields []string
	if m.addduration_hours != nil {
		fields = append(fields, timeentry.FieldDurationHours)
	}
	if m.addinvoice_id != nil {
		fields = append(fields, timeentry.FieldInvoiceID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TimeEntryMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case timeentry.FieldDurationHours:
		return m.AddedDurationHours()
	case timeentry.FieldInvoiceID:
		return m.AddedInvoiceID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TimeEntryMutation) AddField(name string, value ent.Value) error {
	switch name {
	case timeentry.FieldDurationHours:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDurationHours(v)
		return nil
	case timeentry.FieldInvoiceID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddInvoiceID(v)
		return nil
	}
	return fmt.Errorf("unknown TimeEntry numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TimeEntryMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(timeentry.FieldInvoiceID) {
		fields = append(fields, timeentry.FieldInvoiceID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TimeEntryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TimeEntryMutation) ClearField(name string) error {
	switch name {
	case timeentry.FieldInvoiceID:
		m.ClearInvoiceID()
		return nil
	}
	return fmt.Errorf("unknown TimeEntry nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TimeEntryMutation) ResetField(name string) error {
	switch name {
	case timeentry.FieldDurationHours:
		m.ResetDurationHours()
		return nil
	case timeentry.FieldNote:
		m.ResetNote()
		return nil
	case timeentry.FieldStartedAt:
		m.ResetStartedAt()
		return nil
	case timeentry.FieldIsBillable:
		m.ResetIsBillable()
		return nil
	case timeentry.FieldStatus:
		m.ResetStatus()
		return nil
	case timeentry.FieldWorkType:
		m.ResetWorkType()
		return nil
	case timeentry.FieldInvoiceID:
		m.ResetInvoiceID()
		return nil
	}
	return fmt.Errorf("unknown TimeEntry field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TimeEntryMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.ticket != nil {
		edges = append(edges, timeentry.EdgeTicket)
	}
	if m.technician != nil {
		edges = append(edges, timeentry.EdgeTechnician)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TimeEntryMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case timeentry.EdgeTicket:
		if id := m.ticket; id != nil {
			return []ent.Value{*id}
		}
	case timeentry.EdgeTechnician:
		if id := m.technician; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TimeEntryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TimeEntryMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TimeEntryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedticket {
		edges = append(edges, timeentry.EdgeTicket)
	}
	if m.clearedtechnician {
		edges = append(edges, timeentry.EdgeTechnician)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TimeEntryMutation) EdgeCleared(name string) bool {
	switch name {
	case timeentry.EdgeTicket:
		return m.clearedticket
	case timeentry.EdgeTechnician:
		return m.clearedtechnician
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TimeEntryMutation) ClearEdge(name string) error {
	switch name {
	case timeentry.EdgeTicket:
		m.ClearTicket()
		return nil
	case timeentry.EdgeTechnician:
		m.ClearTechnician()
		return nil
	}
	return fmt.Errorf("unknown TimeEntry unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TimeEntryMutation) ResetEdge(name string) error {
	switch name {
	case timeentry.EdgeTicket:
		m.ResetTicket()
		return nil
	case timeentry.EdgeTechnician:
		m.ResetTechnician()
		return nil
	}
	return fmt.Errorf("unknown TimeEntry edge %s", name)
}

// TransactionMutation represents an operation that mutates the Transaction nodes in the graph.
type TransactionMutation struct {
	config
	op                     Op
	typ                    string
	id                     *int
	description            *string
	date                   *time.Time
	total_amount           *float64
	addtotal_amount        *float64
	_type                  *string
	reference              *string
	uuid                   *string
	approval_status        *transaction.ApprovalStatus
	is_intercompany        *bool
	clearedFields          map[string]struct{}
	tenant                 *int
	clearedtenant          bool
	ledger_entries         map[int]struct{}
	removedledger_entries  map[int]struct{}
	clearedledger_entries  bool
	journal_entries        map[int]struct{}
	removedjournal_entries map[int]struct{}
	clearedjournal_entries bool
	recording              *int
	clearedrecording       bool
	approved_by            *int
	clearedapproved_by     bool
	done                   bool
	oldValue               func(context.Context) (*Transaction, error)
	predicates             []predicate.Transaction
}

var _ ent.Mutation = (*TransactionMutation)(nil)

// transactionOption allows management of the mutation configuration using functional options.
type transactionOption func(*TransactionMutation)

// newTransactionMutation creates new mutation for the Transaction entity.
func newTransactionMutation(c config, op Op, opts ...transactionOption) *TransactionMutation {
	m := &TransactionMutation{
		config:        c,
		op:            op,
		typ:           TypeTransaction,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTransactionID sets the ID field of the mutation.
func withTransactionID(id int) transactionOption {
	return func(m *TransactionMutation) {
		var (
			err   error
			once  sync.Once
			value *Transaction
		)
		m.oldValue = func(ctx context.Context) (*Transaction, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Transaction.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTransaction sets the old Transaction of the mutation.
func withTransaction(node *Transaction) transactionOption {
	return func(m *TransactionMutation) {
		m.oldValue = func(context.Context) (*Transaction, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TransactionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TransactionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TransactionMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TransactionMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Transaction.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetDescription sets the "description" field.
func (m *TransactionMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *TransactionMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Transaction entity.
// If the Transaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransactionMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *TransactionMutation) ResetDescription() {
	m.description = nil
}

// SetDate sets the "date" field.
func (m *TransactionMutation) SetDate(t time.Time) {
	m.date = &t
}

// Date returns the value of the "date" field in the mutation.
func (m *TransactionMutation) Date() (r time.Time, exists bool) {
	v := m.date
	if v == nil {
		return
	}
	return *v, true
}

// OldDate returns the old "date" field's value of the Transaction entity.
// If the Transaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransactionMutation) OldDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDate: %w", err)
	}
	return oldValue.Date, nil
}

// ResetDate resets all changes to the "date" field.
func (m *TransactionMutation) ResetDate() {
	m.date = nil
}

// SetTotalAmount sets the "total_amount" field.
func (m *TransactionMutation) SetTotalAmount(f float64) {
	m.total_amount = &f
	m.addtotal_amount = nil
}

// TotalAmount returns the value of the "total_amount" field in the mutation.
func (m *TransactionMutation) TotalAmount() (r float64, exists bool) {
	v := m.total_amount
	if v == nil {
		return
	}
	return *v, true
}

// OldTotalAmount returns the old "total_amount" field's value of the Transaction entity.
// If the Transaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransactionMutation) OldTotalAmount(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTotalAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTotalAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTotalAmount: %w", err)
	}
	return oldValue.TotalAmount, nil
}

// AddTotalAmount adds f to the "total_amount" field.
func (m *TransactionMutation) AddTotalAmount(f float64) {
	if m.addtotal_amount != nil {
		*m.addtotal_amount += f
	} else {
		m.addtotal_amount = &f
	}
}

// AddedTotalAmount returns the value that was added to the "total_amount" field in this mutation.
func (m *TransactionMutation) AddedTotalAmount() (r float64, exists bool) {
	v := m.addtotal_amount
	if v == nil {
		return
	}
	return *v, true
}

// ResetTotalAmount resets all changes to the "total_amount" field.
func (m *TransactionMutation) ResetTotalAmount() {
	m.total_amount = nil
	m.addtotal_amount = nil
}

// SetType sets the "type" field.
func (m *TransactionMutation) SetType(s string) {
	m._type = &s
}

// GetType returns the value of the "type" field in the mutation.
func (m *TransactionMutation) GetType() (r string, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Transaction entity.
// If the Transaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransactionMutation) OldType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ClearType clears the value of the "type" field.
func (m *TransactionMutation) ClearType() {
	m._type = nil
	m.clearedFields[transaction.FieldType] = struct{}{}
}

// TypeCleared returns if the "type" field was cleared in this mutation.
func (m *TransactionMutation) TypeCleared() bool {
	_, ok := m.clearedFields[transaction.FieldType]
	return ok
}

// ResetType resets all changes to the "type" field.
func (m *TransactionMutation) ResetType() {
	m._type = nil
	delete(m.clearedFields, transaction.FieldType)
}

// SetReference sets the "reference" field.
func (m *TransactionMutation) SetReference(s string) {
	m.reference = &s
}

// Reference returns the value of the "reference" field in the mutation.
func (m *TransactionMutation) Reference() (r string, exists bool) {
	v := m.reference
	if v == nil {
		return
	}
	return *v, true
}

// OldReference returns the old "reference" field's value of the Transaction entity.
// If the Transaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransactionMutation) OldReference(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReference is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReference requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReference: %w", err)
	}
	return oldValue.Reference, nil
}

// ClearReference clears the value of the "reference" field.
func (m *TransactionMutation) ClearReference() {
	m.reference = nil
	m.clearedFields[transaction.FieldReference] = struct{}{}
}

// ReferenceCleared returns if the "reference" field was cleared in this mutation.
func (m *TransactionMutation) ReferenceCleared() bool {
	_, ok := m.clearedFields[transaction.FieldReference]
	return ok
}

// ResetReference resets all changes to the "reference" field.
func (m *TransactionMutation) ResetReference() {
	m.reference = nil
	delete(m.clearedFields, transaction.FieldReference)
}

// SetUUID sets the "uuid" field.
func (m *TransactionMutation) SetUUID(s string) {
	m.uuid = &s
}

// UUID returns the value of the "uuid" field in the mutation.
func (m *TransactionMutation) UUID() (r string, exists bool) {
	v := m.uuid
	if v == nil {
		return
	}
	return *v, true
}

// OldUUID returns the old "uuid" field's value of the Transaction entity.
// If the Transaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransactionMutation) OldUUID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUUID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUUID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUUID: %w", err)
	}
	return oldValue.UUID, nil
}

// ResetUUID resets all changes to the "uuid" field.
func (m *TransactionMutation) ResetUUID() {
	m.uuid = nil
}

// SetRecordingID sets the "recording_id" field.
func (m *TransactionMutation) SetRecordingID(i int) {
	m.recording = &i
}

// RecordingID returns the value of the "recording_id" field in the mutation.
func (m *TransactionMutation) RecordingID() (r int, exists bool) {
	v := m.recording
	if v == nil {
		return
	}
	return *v, true
}

// OldRecordingID returns the old "recording_id" field's value of the Transaction entity.
// If the Transaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransactionMutation) OldRecordingID(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRecordingID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRecordingID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRecordingID: %w", err)
	}
	return oldValue.RecordingID, nil
}

// ClearRecordingID clears the value of the "recording_id" field.
func (m *TransactionMutation) ClearRecordingID() {
	m.recording = nil
	m.clearedFields[transaction.FieldRecordingID] = struct{}{}
}

// RecordingIDCleared returns if the "recording_id" field was cleared in this mutation.
func (m *TransactionMutation) RecordingIDCleared() bool {
	_, ok := m.clearedFields[transaction.FieldRecordingID]
	return ok
}

// ResetRecordingID resets all changes to the "recording_id" field.
func (m *TransactionMutation) ResetRecordingID() {
	m.recording = nil
	delete(m.clearedFields, transaction.FieldRecordingID)
}

// SetApprovalStatus sets the "approval_status" field.
func (m *TransactionMutation) SetApprovalStatus(ts transaction.ApprovalStatus) {
	m.approval_status = &ts
}

// ApprovalStatus returns the value of the "approval_status" field in the mutation.
func (m *TransactionMutation) ApprovalStatus() (r transaction.ApprovalStatus, exists bool) {
	v := m.approval_status
	if v == nil {
		return
	}
	return *v, true
}

// OldApprovalStatus returns the old "approval_status" field's value of the Transaction entity.
// If the Transaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransactionMutation) OldApprovalStatus(ctx context.Context) (v transaction.ApprovalStatus, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldApprovalStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldApprovalStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldApprovalStatus: %w", err)
	}
	return oldValue.ApprovalStatus, nil
}

// ResetApprovalStatus resets all changes to the "approval_status" field.
func (m *TransactionMutation) ResetApprovalStatus() {
	m.approval_status = nil
}

// SetIsIntercompany sets the "is_intercompany" field.
func (m *TransactionMutation) SetIsIntercompany(b bool) {
	m.is_intercompany = &b
}

// IsIntercompany returns the value of the "is_intercompany" field in the mutation.
func (m *TransactionMutation) IsIntercompany() (r bool, exists bool) {
	v := m.is_intercompany
	if v == nil {
		return
	}
	return *v, true
}

// OldIsIntercompany returns the old "is_intercompany" field's value of the Transaction entity.
// If the Transaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransactionMutation) OldIsIntercompany(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsIntercompany is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsIntercompany requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsIntercompany: %w", err)
	}
	return oldValue.IsIntercompany, nil
}

// ResetIsIntercompany resets all changes to the "is_intercompany" field.
func (m *TransactionMutation) ResetIsIntercompany() {
	m.is_intercompany = nil
}

// SetTenantID sets the "tenant" edge to the Tenant entity by id.
func (m *TransactionMutation) SetTenantID(id int) {
	m.tenant = &id
}

// ClearTenant clears the "tenant" edge to the Tenant entity.
func (m *TransactionMutation) ClearTenant() {
	m.clearedtenant = true
}

// TenantCleared reports if the "tenant" edge to the Tenant entity was cleared.
func (m *TransactionMutation) TenantCleared() bool {
	return m.clearedtenant
}

// TenantID returns the "tenant" edge ID in the mutation.
func (m *TransactionMutation) TenantID() (id int, exists bool) {
	if m.tenant != nil {
		return *m.tenant, true
	}
	return
}

// TenantIDs returns the "tenant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TenantID instead. It exists only for internal usage by the builders.
func (m *TransactionMutation) TenantIDs() (ids []int) {
	if id := m.tenant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTenant resets all changes to the "tenant" edge.
func (m *TransactionMutation) ResetTenant() {
	m.tenant = nil
	m.clearedtenant = false
}

// AddLedgerEntryIDs adds the "ledger_entries" edge to the LedgerEntry entity by ids.
func (m *TransactionMutation) AddLedgerEntryIDs(ids ...int) {
	if m.ledger_entries == nil {
		m.ledger_entries = make(map[int]struct{})
	}
	for i := range ids {
		m.ledger_entries[ids[i]] = struct{}{}
	}
}

// ClearLedgerEntries clears the "ledger_entries" edge to the LedgerEntry entity.
func (m *TransactionMutation) ClearLedgerEntries() {
	m.clearedledger_entries = true
}

// LedgerEntriesCleared reports if the "ledger_entries" edge to the LedgerEntry entity was cleared.
func (m *TransactionMutation) LedgerEntriesCleared() bool {
	return m.clearedledger_entries
}

// RemoveLedgerEntryIDs removes the "ledger_entries" edge to the LedgerEntry entity by IDs.
func (m *TransactionMutation) RemoveLedgerEntryIDs(ids ...int) {
	if m.removedledger_entries == nil {
		m.removedledger_entries = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.ledger_entries, ids[i])
		m.removedledger_entries[ids[i]] = struct{}{}
	}
}

// RemovedLedgerEntries returns the removed IDs of the "ledger_entries" edge to the LedgerEntry entity.
func (m *TransactionMutation) RemovedLedgerEntriesIDs() (ids []int) {
	for id := range m.removedledger_entries {
		ids = append(ids, id)
	}
	return
}

// LedgerEntriesIDs returns the "ledger_entries" edge IDs in the mutation.
func (m *TransactionMutation) LedgerEntriesIDs() (ids []int) {
	for id := range m.ledger_entries {
		ids = append(ids, id)
	}
	return
}

// ResetLedgerEntries resets all changes to the "ledger_entries" edge.
func (m *TransactionMutation) ResetLedgerEntries() {
	m.ledger_entries = nil
	m.clearedledger_entries = false
	m.removedledger_entries = nil
}

// AddJournalEntryIDs adds the "journal_entries" edge to the JournalEntry entity by ids.
func (m *TransactionMutation) AddJournalEntryIDs(ids ...int) {
	if m.journal_entries == nil {
		m.journal_entries = make(map[int]struct{})
	}
	for i := range ids {
		m.journal_entries[ids[i]] = struct{}{}
	}
}

// ClearJournalEntries clears the "journal_entries" edge to the JournalEntry entity.
func (m *TransactionMutation) ClearJournalEntries() {
	m.clearedjournal_entries = true
}

// JournalEntriesCleared reports if the "journal_entries" edge to the JournalEntry entity was cleared.
func (m *TransactionMutation) JournalEntriesCleared() bool {
	return m.clearedjournal_entries
}

// RemoveJournalEntryIDs removes the "journal_entries" edge to the JournalEntry entity by IDs.
func (m *TransactionMutation) RemoveJournalEntryIDs(ids ...int) {
	if m.removedjournal_entries == nil {
		m.removedjournal_entries = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.journal_entries, ids[i])
		m.removedjournal_entries[ids[i]] = struct{}{}
	}
}

// RemovedJournalEntries returns the removed IDs of the "journal_entries" edge to the JournalEntry entity.
func (m *TransactionMutation) RemovedJournalEntriesIDs() (ids []int) {
	for id := range m.removedjournal_entries {
		ids = append(ids, id)
	}
	return
}

// JournalEntriesIDs returns the "journal_entries" edge IDs in the mutation.
func (m *TransactionMutation) JournalEntriesIDs() (ids []int) {
	for id := range m.journal_entries {
		ids = append(ids, id)
	}
	return
}

// ResetJournalEntries resets all changes to the "journal_entries" edge.
func (m *TransactionMutation) ResetJournalEntries() {
	m.journal_entries = nil
	m.clearedjournal_entries = false
	m.removedjournal_entries = nil
}

// ClearRecording clears the "recording" edge to the Recording entity.
func (m *TransactionMutation) ClearRecording() {
	m.clearedrecording = true
	m.clearedFields[transaction.FieldRecordingID] = struct{}{}
}

// RecordingCleared reports if the "recording" edge to the Recording entity was cleared.
func (m *TransactionMutation) RecordingCleared() bool {
	return m.RecordingIDCleared() || m.clearedrecording
}

// RecordingIDs returns the "recording" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RecordingID instead. It exists only for internal usage by the builders.
func (m *TransactionMutation) RecordingIDs() (ids []int) {
	if id := m.recording; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRecording resets all changes to the "recording" edge.
func (m *TransactionMutation) ResetRecording() {
	m.recording = nil
	m.clearedrecording = false
}

// SetApprovedByID sets the "approved_by" edge to the User entity by id.
func (m *TransactionMutation) SetApprovedByID(id int) {
	m.approved_by = &id
}

// ClearApprovedBy clears the "approved_by" edge to the User entity.
func (m *TransactionMutation) ClearApprovedBy() {
	m.clearedapproved_by = true
}

// ApprovedByCleared reports if the "approved_by" edge to the User entity was cleared.
func (m *TransactionMutation) ApprovedByCleared() bool {
	return m.clearedapproved_by
}

// ApprovedByID returns the "approved_by" edge ID in the mutation.
func (m *TransactionMutation) ApprovedByID() (id int, exists bool) {
	if m.approved_by != nil {
		return *m.approved_by, true
	}
	return
}

// ApprovedByIDs returns the "approved_by" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ApprovedByID instead. It exists only for internal usage by the builders.
func (m *TransactionMutation) ApprovedByIDs() (ids []int) {
	if id := m.approved_by; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetApprovedBy resets all changes to the "approved_by" edge.
func (m *TransactionMutation) ResetApprovedBy() {
	m.approved_by = nil
	m.clearedapproved_by = false
}

// Where appends a list predicates to the TransactionMutation builder.
func (m *TransactionMutation) Where(ps ...predicate.Transaction) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TransactionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TransactionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Transaction, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TransactionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TransactionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Transaction).
func (m *TransactionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TransactionMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.description != nil {
		fields = append(fields, transaction.FieldDescription)
	}
	if m.date != nil {
		fields = append(fields, transaction.FieldDate)
	}
	if m.total_amount != nil {
		fields = append(fields, transaction.FieldTotalAmount)
	}
	if m._type != nil {
		fields = append(fields, transaction.FieldType)
	}
	if m.reference != nil {
		fields = append(fields, transaction.FieldReference)
	}
	if m.uuid != nil {
		fields = append(fields, transaction.FieldUUID)
	}
	if m.recording != nil {
		fields = append(fields, transaction.FieldRecordingID)
	}
	if m.approval_status != nil {
		fields = append(fields, transaction.FieldApprovalStatus)
	}
	if m.is_intercompany != nil {
		fields = append(fields, transaction.FieldIsIntercompany)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TransactionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case transaction.FieldDescription:
		return m.Description()
	case transaction.FieldDate:
		return m.Date()
	case transaction.FieldTotalAmount:
		return m.TotalAmount()
	case transaction.FieldType:
		return m.GetType()
	case transaction.FieldReference:
		return m.Reference()
	case transaction.FieldUUID:
		return m.UUID()
	case transaction.FieldRecordingID:
		return m.RecordingID()
	case transaction.FieldApprovalStatus:
		return m.ApprovalStatus()
	case transaction.FieldIsIntercompany:
		return m.IsIntercompany()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TransactionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case transaction.FieldDescription:
		return m.OldDescription(ctx)
	case transaction.FieldDate:
		return m.OldDate(ctx)
	case transaction.FieldTotalAmount:
		return m.OldTotalAmount(ctx)
	case transaction.FieldType:
		return m.OldType(ctx)
	case transaction.FieldReference:
		return m.OldReference(ctx)
	case transaction.FieldUUID:
		return m.OldUUID(ctx)
	case transaction.FieldRecordingID:
		return m.OldRecordingID(ctx)
	case transaction.FieldApprovalStatus:
		return m.OldApprovalStatus(ctx)
	case transaction.FieldIsIntercompany:
		return m.OldIsIntercompany(ctx)
	}
	return nil, fmt.Errorf("unknown Transaction field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TransactionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case transaction.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case transaction.FieldDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDate(v)
		return nil
	case transaction.FieldTotalAmount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTotalAmount(v)
		return nil
	case transaction.FieldType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case transaction.FieldReference:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReference(v)
		return nil
	case transaction.FieldUUID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUUID(v)
		return nil
	case transaction.FieldRecordingID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRecordingID(v)
		return nil
	case transaction.FieldApprovalStatus:
		v, ok := value.(transaction.ApprovalStatus)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetApprovalStatus(v)
		return nil
	case transaction.FieldIsIntercompany:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsIntercompany(v)
		return nil
	}
	return fmt.Errorf("unknown Transaction field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TransactionMutation) AddedFields() []string {
	var fields []string
	if m.addtotal_amount != nil {
		fields = append(fields, transaction.FieldTotalAmount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TransactionMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case transaction.FieldTotalAmount:
		return m.AddedTotalAmount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TransactionMutation) AddField(name string, value ent.Value) error {
	switch name {
	case transaction.FieldTotalAmount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTotalAmount(v)
		return nil
	}
	return fmt.Errorf("unknown Transaction numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TransactionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(transaction.FieldType) {
		fields = append(fields, transaction.FieldType)
	}
	if m.FieldCleared(transaction.FieldReference) {
		fields = append(fields, transaction.FieldReference)
	}
	if m.FieldCleared(transaction.FieldRecordingID) {
		fields = append(fields, transaction.FieldRecordingID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TransactionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TransactionMutation) ClearField(name string) error {
	switch name {
	case transaction.FieldType:
		m.ClearType()
		return nil
	case transaction.FieldReference:
		m.ClearReference()
		return nil
	case transaction.FieldRecordingID:
		m.ClearRecordingID()
		return nil
	}
	return fmt.Errorf("unknown Transaction nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TransactionMutation) ResetField(name string) error {
	switch name {
	case transaction.FieldDescription:
		m.ResetDescription()
		return nil
	case transaction.FieldDate:
		m.ResetDate()
		return nil
	case transaction.FieldTotalAmount:
		m.ResetTotalAmount()
		return nil
	case transaction.FieldType:
		m.ResetType()
		return nil
	case transaction.FieldReference:
		m.ResetReference()
		return nil
	case transaction.FieldUUID:
		m.ResetUUID()
		return nil
	case transaction.FieldRecordingID:
		m.ResetRecordingID()
		return nil
	case transaction.FieldApprovalStatus:
		m.ResetApprovalStatus()
		return nil
	case transaction.FieldIsIntercompany:
		m.ResetIsIntercompany()
		return nil
	}
	return fmt.Errorf("unknown Transaction field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TransactionMutation) AddedEdges() []string {
	edges := make([]string, 0, 5)
	if m.tenant != nil {
		edges = append(edges, transaction.EdgeTenant)
	}
	if m.ledger_entries != nil {
		edges = append(edges, transaction.EdgeLedgerEntries)
	}
	if m.journal_entries != nil {
		edges = append(edges, transaction.EdgeJournalEntries)
	}
	if m.recording != nil {
		edges = append(edges, transaction.EdgeRecording)
	}
	if m.approved_by != nil {
		edges = append(edges, transaction.EdgeApprovedBy)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TransactionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case transaction.EdgeTenant:
		if id := m.tenant; id != nil {
			return []ent.Value{*id}
		}
	case transaction.EdgeLedgerEntries:
		ids := make([]ent.Value, 0, len(m.ledger_entries))
		for id := range m.ledger_entries {
			ids = append(ids, id)
		}
		return ids
	case transaction.EdgeJournalEntries:
		ids := make([]ent.Value, 0, len(m.journal_entries))
		for id := range m.journal_entries {
			ids = append(ids, id)
		}
		return ids
	case transaction.EdgeRecording:
		if id := m.recording; id != nil {
			return []ent.Value{*id}
		}
	case transaction.EdgeApprovedBy:
		if id := m.approved_by; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TransactionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 5)
	if m.removedledger_entries != nil {
		edges = append(edges, transaction.EdgeLedgerEntries)
	}
	if m.removedjournal_entries != nil {
		edges = append(edges, transaction.EdgeJournalEntries)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TransactionMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case transaction.EdgeLedgerEntries:
		ids := make([]ent.Value, 0, len(m.removedledger_entries))
		for id := range m.removedledger_entries {
			ids = append(ids, id)
		}
		return ids
	case transaction.EdgeJournalEntries:
		ids := make([]ent.Value, 0, len(m.removedjournal_entries))
		for id := range m.removedjournal_entries {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TransactionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 5)
	if m.clearedtenant {
		edges = append(edges, transaction.EdgeTenant)
	}
	if m.clearedledger_entries {
		edges = append(edges, transaction.EdgeLedgerEntries)
	}
	if m.clearedjournal_entries {
		edges = append(edges, transaction.EdgeJournalEntries)
	}
	if m.clearedrecording {
		edges = append(edges, transaction.EdgeRecording)
	}
	if m.clearedapproved_by {
		edges = append(edges, transaction.EdgeApprovedBy)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TransactionMutation) EdgeCleared(name string) bool {
	switch name {
	case transaction.EdgeTenant:
		return m.clearedtenant
	case transaction.EdgeLedgerEntries:
		return m.clearedledger_entries
	case transaction.EdgeJournalEntries:
		return m.clearedjournal_entries
	case transaction.EdgeRecording:
		return m.clearedrecording
	case transaction.EdgeApprovedBy:
		return m.clearedapproved_by
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TransactionMutation) ClearEdge(name string) error {
	switch name {
	case transaction.EdgeTenant:
		m.ClearTenant()
		return nil
	case transaction.EdgeRecording:
		m.ClearRecording()
		return nil
	case transaction.EdgeApprovedBy:
		m.ClearApprovedBy()
		return nil
	}
	return fmt.Errorf("unknown Transaction unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TransactionMutation) ResetEdge(name string) error {
	switch name {
	case transaction.EdgeTenant:
		m.ResetTenant()
		return nil
	case transaction.EdgeLedgerEntries:
		m.ResetLedgerEntries()
		return nil
	case transaction.EdgeJournalEntries:
		m.ResetJournalEntries()
		return nil
	case transaction.EdgeRecording:
		m.ResetRecording()
		return nil
	case transaction.EdgeApprovedBy:
		m.ResetApprovedBy()
		return nil
	}
	return fmt.Errorf("unknown Transaction edge %s", name)
}

// UserMutation represents an operation that mutates the User nodes in the graph.
type UserMutation struct {
	config
	op                       Op
	typ                      string
	id                       *int
	zitadel_id               *string
	email                    *string
	first_name               *string
	last_name                *string
	job_title                *string
	department               *string
	external_mappings        *map[string]interface{}
	created_at               *time.Time
	role                     *string
	seniority                *user.Seniority
	max_wip                  *int
	addmax_wip               *int
	clearedFields            map[string]struct{}
	tenant                   *int
	clearedtenant            bool
	permissions              map[int]struct{}
	removedpermissions       map[int]struct{}
	clearedpermissions       bool
	requested_tickets        map[int]struct{}
	removedrequested_tickets map[int]struct{}
	clearedrequested_tickets bool
	assigned_tickets         map[int]struct{}
	removedassigned_tickets  map[int]struct{}
	clearedassigned_tickets  bool
	time_entries             map[int]struct{}
	removedtime_entries      map[int]struct{}
	clearedtime_entries      bool
	owned_assets             map[int]struct{}
	removedowned_assets      map[int]struct{}
	clearedowned_assets      bool
	authored_sops            map[int]struct{}
	removedauthored_sops     map[int]struct{}
	clearedauthored_sops     bool
	call_logs                map[int]struct{}
	removedcall_logs         map[int]struct{}
	clearedcall_logs         bool
	voicemails               map[int]struct{}
	removedvoicemails        map[int]struct{}
	clearedvoicemails        bool
	saas_identities          map[int]struct{}
	removedsaas_identities   map[int]struct{}
	clearedsaas_identities   bool
	done                     bool
	oldValue                 func(context.Context) (*User, error)
	predicates               []predicate.User
}

var _ ent.Mutation = (*UserMutation)(nil)

// userOption allows management of the mutation configuration using functional options.
type userOption func(*UserMutation)

// newUserMutation creates new mutation for the User entity.
func newUserMutation(c config, op Op, opts ...userOption) *UserMutation {
	m := &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserID sets the ID field of the mutation.
func withUserID(id int) userOption {
	return func(m *UserMutation) {
		var (
			err   error
			once  sync.Once
			value *User
		)
		m.oldValue = func(ctx context.Context) (*User, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().User.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUser sets the old User of the mutation.
func withUser(node *User) userOption {
	return func(m *UserMutation) {
		m.oldValue = func(context.Context) (*User, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().User.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetZitadelID sets the "zitadel_id" field.
func (m *UserMutation) SetZitadelID(s string) {
	m.zitadel_id = &s
}

// ZitadelID returns the value of the "zitadel_id" field in the mutation.
func (m *UserMutation) ZitadelID() (r string, exists bool) {
	v := m.zitadel_id
	if v == nil {
		return
	}
	return *v, true
}

// OldZitadelID returns the old "zitadel_id" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldZitadelID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldZitadelID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldZitadelID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldZitadelID: %w", err)
	}
	return oldValue.ZitadelID, nil
}

// ResetZitadelID resets all changes to the "zitadel_id" field.
func (m *UserMutation) ResetZitadelID() {
	m.zitadel_id = nil
}

// SetEmail sets the "email" field.
func (m *UserMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *UserMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail resets all changes to the "email" field.
func (m *UserMutation) ResetEmail() {
	m.email = nil
}

// SetFirstName sets the "first_name" field.
func (m *UserMutation) SetFirstName(s string) {
	m.first_name = &s
}

// FirstName returns the value of the "first_name" field in the mutation.
func (m *UserMutation) FirstName() (r string, exists bool) {
	v := m.first_name
	if v == nil {
		return
	}
	return *v, true
}

// OldFirstName returns the old "first_name" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldFirstName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFirstName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFirstName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFirstName: %w", err)
	}
	return oldValue.FirstName, nil
}

// ClearFirstName clears the value of the "first_name" field.
func (m *UserMutation) ClearFirstName() {
	m.first_name = nil
	m.clearedFields[user.FieldFirstName] = struct{}{}
}

// FirstNameCleared returns if the "first_name" field was cleared in this mutation.
func (m *UserMutation) FirstNameCleared() bool {
	_, ok := m.clearedFields[user.FieldFirstName]
	return ok
}

// ResetFirstName resets all changes to the "first_name" field.
func (m *UserMutation) ResetFirstName() {
	m.first_name = nil
	delete(m.clearedFields, user.FieldFirstName)
}

// SetLastName sets the "last_name" field.
func (m *UserMutation) SetLastName(s string) {
	m.last_name = &s
}

// LastName returns the value of the "last_name" field in the mutation.
func (m *UserMutation) LastName() (r string, exists bool) {
	v := m.last_name
	if v == nil {
		return
	}
	return *v, true
}

// OldLastName returns the old "last_name" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldLastName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastName: %w", err)
	}
	return oldValue.LastName, nil
}

// ClearLastName clears the value of the "last_name" field.
func (m *UserMutation) ClearLastName() {
	m.last_name = nil
	m.clearedFields[user.FieldLastName] = struct{}{}
}

// LastNameCleared returns if the "last_name" field was cleared in this mutation.
func (m *UserMutation) LastNameCleared() bool {
	_, ok := m.clearedFields[user.FieldLastName]
	return ok
}

// ResetLastName resets all changes to the "last_name" field.
func (m *UserMutation) ResetLastName() {
	m.last_name = nil
	delete(m.clearedFields, user.FieldLastName)
}

// SetJobTitle sets the "job_title" field.
func (m *UserMutation) SetJobTitle(s string) {
	m.job_title = &s
}

// JobTitle returns the value of the "job_title" field in the mutation.
func (m *UserMutation) JobTitle() (r string, exists bool) {
	v := m.job_title
	if v == nil {
		return
	}
	return *v, true
}

// OldJobTitle returns the old "job_title" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldJobTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldJobTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldJobTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldJobTitle: %w", err)
	}
	return oldValue.JobTitle, nil
}

// ClearJobTitle clears the value of the "job_title" field.
func (m *UserMutation) ClearJobTitle() {
	m.job_title = nil
	m.clearedFields[user.FieldJobTitle] = struct{}{}
}

// JobTitleCleared returns if the "job_title" field was cleared in this mutation.
func (m *UserMutation) JobTitleCleared() bool {
	_, ok := m.clearedFields[user.FieldJobTitle]
	return ok
}

// ResetJobTitle resets all changes to the "job_title" field.
func (m *UserMutation) ResetJobTitle() {
	m.job_title = nil
	delete(m.clearedFields, user.FieldJobTitle)
}

// SetDepartment sets the "department" field.
func (m *UserMutation) SetDepartment(s string) {
	m.department = &s
}

// Department returns the value of the "department" field in the mutation.
func (m *UserMutation) Department() (r string, exists bool) {
	v := m.department
	if v == nil {
		return
	}
	return *v, true
}

// OldDepartment returns the old "department" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldDepartment(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDepartment is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDepartment requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDepartment: %w", err)
	}
	return oldValue.Department, nil
}

// ClearDepartment clears the value of the "department" field.
func (m *UserMutation) ClearDepartment() {
	m.department = nil
	m.clearedFields[user.FieldDepartment] = struct{}{}
}

// DepartmentCleared returns if the "department" field was cleared in this mutation.
func (m *UserMutation) DepartmentCleared() bool {
	_, ok := m.clearedFields[user.FieldDepartment]
	return ok
}

// ResetDepartment resets all changes to the "department" field.
func (m *UserMutation) ResetDepartment() {
	m.department = nil
	delete(m.clearedFields, user.FieldDepartment)
}

// SetExternalMappings sets the "external_mappings" field.
func (m *UserMutation) SetExternalMappings(value map[string]interface{}) {
	m.external_mappings = &value
}

// ExternalMappings returns the value of the "external_mappings" field in the mutation.
func (m *UserMutation) ExternalMappings() (r map[string]interface{}, exists bool) {
	v := m.external_mappings
	if v == nil {
		return
	}
	return *v, true
}

// OldExternalMappings returns the old "external_mappings" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldExternalMappings(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExternalMappings is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExternalMappings requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExternalMappings: %w", err)
	}
	return oldValue.ExternalMappings, nil
}

// ClearExternalMappings clears the value of the "external_mappings" field.
func (m *UserMutation) ClearExternalMappings() {
	m.external_mappings = nil
	m.clearedFields[user.FieldExternalMappings] = struct{}{}
}

// ExternalMappingsCleared returns if the "external_mappings" field was cleared in this mutation.
func (m *UserMutation) ExternalMappingsCleared() bool {
	_, ok := m.clearedFields[user.FieldExternalMappings]
	return ok
}

// ResetExternalMappings resets all changes to the "external_mappings" field.
func (m *UserMutation) ResetExternalMappings() {
	m.external_mappings = nil
	delete(m.clearedFields, user.FieldExternalMappings)
}

// SetCreatedAt sets the "created_at" field.
func (m *UserMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UserMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UserMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetRole sets the "role" field.
func (m *UserMutation) SetRole(s string) {
	m.role = &s
}

// Role returns the value of the "role" field in the mutation.
func (m *UserMutation) Role() (r string, exists bool) {
	v := m.role
	if v == nil {
		return
	}
	return *v, true
}

// OldRole returns the old "role" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldRole(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRole is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRole requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRole: %w", err)
	}
	return oldValue.Role, nil
}

// ResetRole resets all changes to the "role" field.
func (m *UserMutation) ResetRole() {
	m.role = nil
}

// SetSeniority sets the "seniority" field.
func (m *UserMutation) SetSeniority(u user.Seniority) {
	m.seniority = &u
}

// Seniority returns the value of the "seniority" field in the mutation.
func (m *UserMutation) Seniority() (r user.Seniority, exists bool) {
	v := m.seniority
	if v == nil {
		return
	}
	return *v, true
}

// OldSeniority returns the old "seniority" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldSeniority(ctx context.Context) (v user.Seniority, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSeniority is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSeniority requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSeniority: %w", err)
	}
	return oldValue.Seniority, nil
}

// ResetSeniority resets all changes to the "seniority" field.
func (m *UserMutation) ResetSeniority() {
	m.seniority = nil
}

// SetMaxWip sets the "max_wip" field.
func (m *UserMutation) SetMaxWip(i int) {
	m.max_wip = &i
	m.addmax_wip = nil
}

// MaxWip returns the value of the "max_wip" field in the mutation.
func (m *UserMutation) MaxWip() (r int, exists bool) {
	v := m.max_wip
	if v == nil {
		return
	}
	return *v, true
}

// OldMaxWip returns the old "max_wip" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldMaxWip(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMaxWip is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMaxWip requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMaxWip: %w", err)
	}
	return oldValue.MaxWip, nil
}

// AddMaxWip adds i to the "max_wip" field.
func (m *UserMutation) AddMaxWip(i int) {
	if m.addmax_wip != nil {
		*m.addmax_wip += i
	} else {
		m.addmax_wip = &i
	}
}

// AddedMaxWip returns the value that was added to the "max_wip" field in this mutation.
func (m *UserMutation) AddedMaxWip() (r int, exists bool) {
	v := m.addmax_wip
	if v == nil {
		return
	}
	return *v, true
}

// ResetMaxWip resets all changes to the "max_wip" field.
func (m *UserMutation) ResetMaxWip() {
	m.max_wip = nil
	m.addmax_wip = nil
}

// SetTenantID sets the "tenant" edge to the Tenant entity by id.
func (m *UserMutation) SetTenantID(id int) {
	m.tenant = &id
}

// ClearTenant clears the "tenant" edge to the Tenant entity.
func (m *UserMutation) ClearTenant() {
	m.clearedtenant = true
}

// TenantCleared reports if the "tenant" edge to the Tenant entity was cleared.
func (m *UserMutation) TenantCleared() bool {
	return m.clearedtenant
}

// TenantID returns the "tenant" edge ID in the mutation.
func (m *UserMutation) TenantID() (id int, exists bool) {
	if m.tenant != nil {
		return *m.tenant, true
	}
	return
}

// TenantIDs returns the "tenant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TenantID instead. It exists only for internal usage by the builders.
func (m *UserMutation) TenantIDs() (ids []int) {
	if id := m.tenant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTenant resets all changes to the "tenant" edge.
func (m *UserMutation) ResetTenant() {
	m.tenant = nil
	m.clearedtenant = false
}

// AddPermissionIDs adds the "permissions" edge to the Permission entity by ids.
func (m *UserMutation) AddPermissionIDs(ids ...int) {
	if m.permissions == nil {
		m.permissions = make(map[int]struct{})
	}
	for i := range ids {
		m.permissions[ids[i]] = struct{}{}
	}
}

// ClearPermissions clears the "permissions" edge to the Permission entity.
func (m *UserMutation) ClearPermissions() {
	m.clearedpermissions = true
}

// PermissionsCleared reports if the "permissions" edge to the Permission entity was cleared.
func (m *UserMutation) PermissionsCleared() bool {
	return m.clearedpermissions
}

// RemovePermissionIDs removes the "permissions" edge to the Permission entity by IDs.
func (m *UserMutation) RemovePermissionIDs(ids ...int) {
	if m.removedpermissions == nil {
		m.removedpermissions = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.permissions, ids[i])
		m.removedpermissions[ids[i]] = struct{}{}
	}
}

// RemovedPermissions returns the removed IDs of the "permissions" edge to the Permission entity.
func (m *UserMutation) RemovedPermissionsIDs() (ids []int) {
	for id := range m.removedpermissions {
		ids = append(ids, id)
	}
	return
}

// PermissionsIDs returns the "permissions" edge IDs in the mutation.
func (m *UserMutation) PermissionsIDs() (ids []int) {
	for id := range m.permissions {
		ids = append(ids, id)
	}
	return
}

// ResetPermissions resets all changes to the "permissions" edge.
func (m *UserMutation) ResetPermissions() {
	m.permissions = nil
	m.clearedpermissions = false
	m.removedpermissions = nil
}

// AddRequestedTicketIDs adds the "requested_tickets" edge to the Ticket entity by ids.
func (m *UserMutation) AddRequestedTicketIDs(ids ...int) {
	if m.requested_tickets == nil {
		m.requested_tickets = make(map[int]struct{})
	}
	for i := range ids {
		m.requested_tickets[ids[i]] = struct{}{}
	}
}

// ClearRequestedTickets clears the "requested_tickets" edge to the Ticket entity.
func (m *UserMutation) ClearRequestedTickets() {
	m.clearedrequested_tickets = true
}

// RequestedTicketsCleared reports if the "requested_tickets" edge to the Ticket entity was cleared.
func (m *UserMutation) RequestedTicketsCleared() bool {
	return m.clearedrequested_tickets
}

// RemoveRequestedTicketIDs removes the "requested_tickets" edge to the Ticket entity by IDs.
func (m *UserMutation) RemoveRequestedTicketIDs(ids ...int) {
	if m.removedrequested_tickets == nil {
		m.removedrequested_tickets = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.requested_tickets, ids[i])
		m.removedrequested_tickets[ids[i]] = struct{}{}
	}
}

// RemovedRequestedTickets returns the removed IDs of the "requested_tickets" edge to the Ticket entity.
func (m *UserMutation) RemovedRequestedTicketsIDs() (ids []int) {
	for id := range m.removedrequested_tickets {
		ids = append(ids, id)
	}
	return
}

// RequestedTicketsIDs returns the "requested_tickets" edge IDs in the mutation.
func (m *UserMutation) RequestedTicketsIDs() (ids []int) {
	for id := range m.requested_tickets {
		ids = append(ids, id)
	}
	return
}

// ResetRequestedTickets resets all changes to the "requested_tickets" edge.
func (m *UserMutation) ResetRequestedTickets() {
	m.requested_tickets = nil
	m.clearedrequested_tickets = false
	m.removedrequested_tickets = nil
}

// AddAssignedTicketIDs adds the "assigned_tickets" edge to the Ticket entity by ids.
func (m *UserMutation) AddAssignedTicketIDs(ids ...int) {
	if m.assigned_tickets == nil {
		m.assigned_tickets = make(map[int]struct{})
	}
	for i := range ids {
		m.assigned_tickets[ids[i]] = struct{}{}
	}
}

// ClearAssignedTickets clears the "assigned_tickets" edge to the Ticket entity.
func (m *UserMutation) ClearAssignedTickets() {
	m.clearedassigned_tickets = true
}

// AssignedTicketsCleared reports if the "assigned_tickets" edge to the Ticket entity was cleared.
func (m *UserMutation) AssignedTicketsCleared() bool {
	return m.clearedassigned_tickets
}

// RemoveAssignedTicketIDs removes the "assigned_tickets" edge to the Ticket entity by IDs.
func (m *UserMutation) RemoveAssignedTicketIDs(ids ...int) {
	if m.removedassigned_tickets == nil {
		m.removedassigned_tickets = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.assigned_tickets, ids[i])
		m.removedassigned_tickets[ids[i]] = struct{}{}
	}
}

// RemovedAssignedTickets returns the removed IDs of the "assigned_tickets" edge to the Ticket entity.
func (m *UserMutation) RemovedAssignedTicketsIDs() (ids []int) {
	for id := range m.removedassigned_tickets {
		ids = append(ids, id)
	}
	return
}

// AssignedTicketsIDs returns the "assigned_tickets" edge IDs in the mutation.
func (m *UserMutation) AssignedTicketsIDs() (ids []int) {
	for id := range m.assigned_tickets {
		ids = append(ids, id)
	}
	return
}

// ResetAssignedTickets resets all changes to the "assigned_tickets" edge.
func (m *UserMutation) ResetAssignedTickets() {
	m.assigned_tickets = nil
	m.clearedassigned_tickets = false
	m.removedassigned_tickets = nil
}

// AddTimeEntryIDs adds the "time_entries" edge to the TimeEntry entity by ids.
func (m *UserMutation) AddTimeEntryIDs(ids ...int) {
	if m.time_entries == nil {
		m.time_entries = make(map[int]struct{})
	}
	for i := range ids {
		m.time_entries[ids[i]] = struct{}{}
	}
}

// ClearTimeEntries clears the "time_entries" edge to the TimeEntry entity.
func (m *UserMutation) ClearTimeEntries() {
	m.clearedtime_entries = true
}

// TimeEntriesCleared reports if the "time_entries" edge to the TimeEntry entity was cleared.
func (m *UserMutation) TimeEntriesCleared() bool {
	return m.clearedtime_entries
}

// RemoveTimeEntryIDs removes the "time_entries" edge to the TimeEntry entity by IDs.
func (m *UserMutation) RemoveTimeEntryIDs(ids ...int) {
	if m.removedtime_entries == nil {
		m.removedtime_entries = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.time_entries, ids[i])
		m.removedtime_entries[ids[i]] = struct{}{}
	}
}

// RemovedTimeEntries returns the removed IDs of the "time_entries" edge to the TimeEntry entity.
func (m *UserMutation) RemovedTimeEntriesIDs() (ids []int) {
	for id := range m.removedtime_entries {
		ids = append(ids, id)
	}
	return
}

// TimeEntriesIDs returns the "time_entries" edge IDs in the mutation.
func (m *UserMutation) TimeEntriesIDs() (ids []int) {
	for id := range m.time_entries {
		ids = append(ids, id)
	}
	return
}

// ResetTimeEntries resets all changes to the "time_entries" edge.
func (m *UserMutation) ResetTimeEntries() {
	m.time_entries = nil
	m.clearedtime_entries = false
	m.removedtime_entries = nil
}

// AddOwnedAssetIDs adds the "owned_assets" edge to the Asset entity by ids.
func (m *UserMutation) AddOwnedAssetIDs(ids ...int) {
	if m.owned_assets == nil {
		m.owned_assets = make(map[int]struct{})
	}
	for i := range ids {
		m.owned_assets[ids[i]] = struct{}{}
	}
}

// ClearOwnedAssets clears the "owned_assets" edge to the Asset entity.
func (m *UserMutation) ClearOwnedAssets() {
	m.clearedowned_assets = true
}

// OwnedAssetsCleared reports if the "owned_assets" edge to the Asset entity was cleared.
func (m *UserMutation) OwnedAssetsCleared() bool {
	return m.clearedowned_assets
}

// RemoveOwnedAssetIDs removes the "owned_assets" edge to the Asset entity by IDs.
func (m *UserMutation) RemoveOwnedAssetIDs(ids ...int) {
	if m.removedowned_assets == nil {
		m.removedowned_assets = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.owned_assets, ids[i])
		m.removedowned_assets[ids[i]] = struct{}{}
	}
}

// RemovedOwnedAssets returns the removed IDs of the "owned_assets" edge to the Asset entity.
func (m *UserMutation) RemovedOwnedAssetsIDs() (ids []int) {
	for id := range m.removedowned_assets {
		ids = append(ids, id)
	}
	return
}

// OwnedAssetsIDs returns the "owned_assets" edge IDs in the mutation.
func (m *UserMutation) OwnedAssetsIDs() (ids []int) {
	for id := range m.owned_assets {
		ids = append(ids, id)
	}
	return
}

// ResetOwnedAssets resets all changes to the "owned_assets" edge.
func (m *UserMutation) ResetOwnedAssets() {
	m.owned_assets = nil
	m.clearedowned_assets = false
	m.removedowned_assets = nil
}

// AddAuthoredSopIDs adds the "authored_sops" edge to the SOP entity by ids.
func (m *UserMutation) AddAuthoredSopIDs(ids ...int) {
	if m.authored_sops == nil {
		m.authored_sops = make(map[int]struct{})
	}
	for i := range ids {
		m.authored_sops[ids[i]] = struct{}{}
	}
}

// ClearAuthoredSops clears the "authored_sops" edge to the SOP entity.
func (m *UserMutation) ClearAuthoredSops() {
	m.clearedauthored_sops = true
}

// AuthoredSopsCleared reports if the "authored_sops" edge to the SOP entity was cleared.
func (m *UserMutation) AuthoredSopsCleared() bool {
	return m.clearedauthored_sops
}

// RemoveAuthoredSopIDs removes the "authored_sops" edge to the SOP entity by IDs.
func (m *UserMutation) RemoveAuthoredSopIDs(ids ...int) {
	if m.removedauthored_sops == nil {
		m.removedauthored_sops = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.authored_sops, ids[i])
		m.removedauthored_sops[ids[i]] = struct{}{}
	}
}

// RemovedAuthoredSops returns the removed IDs of the "authored_sops" edge to the SOP entity.
func (m *UserMutation) RemovedAuthoredSopsIDs() (ids []int) {
	for id := range m.removedauthored_sops {
		ids = append(ids, id)
	}
	return
}

// AuthoredSopsIDs returns the "authored_sops" edge IDs in the mutation.
func (m *UserMutation) AuthoredSopsIDs() (ids []int) {
	for id := range m.authored_sops {
		ids = append(ids, id)
	}
	return
}

// ResetAuthoredSops resets all changes to the "authored_sops" edge.
func (m *UserMutation) ResetAuthoredSops() {
	m.authored_sops = nil
	m.clearedauthored_sops = false
	m.removedauthored_sops = nil
}

// AddCallLogIDs adds the "call_logs" edge to the CallLog entity by ids.
func (m *UserMutation) AddCallLogIDs(ids ...int) {
	if m.call_logs == nil {
		m.call_logs = make(map[int]struct{})
	}
	for i := range ids {
		m.call_logs[ids[i]] = struct{}{}
	}
}

// ClearCallLogs clears the "call_logs" edge to the CallLog entity.
func (m *UserMutation) ClearCallLogs() {
	m.clearedcall_logs = true
}

// CallLogsCleared reports if the "call_logs" edge to the CallLog entity was cleared.
func (m *UserMutation) CallLogsCleared() bool {
	return m.clearedcall_logs
}

// RemoveCallLogIDs removes the "call_logs" edge to the CallLog entity by IDs.
func (m *UserMutation) RemoveCallLogIDs(ids ...int) {
	if m.removedcall_logs == nil {
		m.removedcall_logs = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.call_logs, ids[i])
		m.removedcall_logs[ids[i]] = struct{}{}
	}
}

// RemovedCallLogs returns the removed IDs of the "call_logs" edge to the CallLog entity.
func (m *UserMutation) RemovedCallLogsIDs() (ids []int) {
	for id := range m.removedcall_logs {
		ids = append(ids, id)
	}
	return
}

// CallLogsIDs returns the "call_logs" edge IDs in the mutation.
func (m *UserMutation) CallLogsIDs() (ids []int) {
	for id := range m.call_logs {
		ids = append(ids, id)
	}
	return
}

// ResetCallLogs resets all changes to the "call_logs" edge.
func (m *UserMutation) ResetCallLogs() {
	m.call_logs = nil
	m.clearedcall_logs = false
	m.removedcall_logs = nil
}

// AddVoicemailIDs adds the "voicemails" edge to the Voicemail entity by ids.
func (m *UserMutation) AddVoicemailIDs(ids ...int) {
	if m.voicemails == nil {
		m.voicemails = make(map[int]struct{})
	}
	for i := range ids {
		m.voicemails[ids[i]] = struct{}{}
	}
}

// ClearVoicemails clears the "voicemails" edge to the Voicemail entity.
func (m *UserMutation) ClearVoicemails() {
	m.clearedvoicemails = true
}

// VoicemailsCleared reports if the "voicemails" edge to the Voicemail entity was cleared.
func (m *UserMutation) VoicemailsCleared() bool {
	return m.clearedvoicemails
}

// RemoveVoicemailIDs removes the "voicemails" edge to the Voicemail entity by IDs.
func (m *UserMutation) RemoveVoicemailIDs(ids ...int) {
	if m.removedvoicemails == nil {
		m.removedvoicemails = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.voicemails, ids[i])
		m.removedvoicemails[ids[i]] = struct{}{}
	}
}

// RemovedVoicemails returns the removed IDs of the "voicemails" edge to the Voicemail entity.
func (m *UserMutation) RemovedVoicemailsIDs() (ids []int) {
	for id := range m.removedvoicemails {
		ids = append(ids, id)
	}
	return
}

// VoicemailsIDs returns the "voicemails" edge IDs in the mutation.
func (m *UserMutation) VoicemailsIDs() (ids []int) {
	for id := range m.voicemails {
		ids = append(ids, id)
	}
	return
}

// ResetVoicemails resets all changes to the "voicemails" edge.
func (m *UserMutation) ResetVoicemails() {
	m.voicemails = nil
	m.clearedvoicemails = false
	m.removedvoicemails = nil
}

// AddSaasIdentityIDs adds the "saas_identities" edge to the SaaSIdentity entity by ids.
func (m *UserMutation) AddSaasIdentityIDs(ids ...int) {
	if m.saas_identities == nil {
		m.saas_identities = make(map[int]struct{})
	}
	for i := range ids {
		m.saas_identities[ids[i]] = struct{}{}
	}
}

// ClearSaasIdentities clears the "saas_identities" edge to the SaaSIdentity entity.
func (m *UserMutation) ClearSaasIdentities() {
	m.clearedsaas_identities = true
}

// SaasIdentitiesCleared reports if the "saas_identities" edge to the SaaSIdentity entity was cleared.
func (m *UserMutation) SaasIdentitiesCleared() bool {
	return m.clearedsaas_identities
}

// RemoveSaasIdentityIDs removes the "saas_identities" edge to the SaaSIdentity entity by IDs.
func (m *UserMutation) RemoveSaasIdentityIDs(ids ...int) {
	if m.removedsaas_identities == nil {
		m.removedsaas_identities = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.saas_identities, ids[i])
		m.removedsaas_identities[ids[i]] = struct{}{}
	}
}

// RemovedSaasIdentities returns the removed IDs of the "saas_identities" edge to the SaaSIdentity entity.
func (m *UserMutation) RemovedSaasIdentitiesIDs() (ids []int) {
	for id := range m.removedsaas_identities {
		ids = append(ids, id)
	}
	return
}

// SaasIdentitiesIDs returns the "saas_identities" edge IDs in the mutation.
func (m *UserMutation) SaasIdentitiesIDs() (ids []int) {
	for id := range m.saas_identities {
		ids = append(ids, id)
	}
	return
}

// ResetSaasIdentities resets all changes to the "saas_identities" edge.
func (m *UserMutation) ResetSaasIdentities() {
	m.saas_identities = nil
	m.clearedsaas_identities = false
	m.removedsaas_identities = nil
}

// Where appends a list predicates to the UserMutation builder.
func (m *UserMutation) Where(ps ...predicate.User) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.User, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.zitadel_id != nil {
		fields = append(fields, user.FieldZitadelID)
	}
	if m.email != nil {
		fields = append(fields, user.FieldEmail)
	}
	if m.first_name != nil {
		fields = append(fields, user.FieldFirstName)
	}
	if m.last_name != nil {
		fields = append(fields, user.FieldLastName)
	}
	if m.job_title != nil {
		fields = append(fields, user.FieldJobTitle)
	}
	if m.department != nil {
		fields = append(fields, user.FieldDepartment)
	}
	if m.external_mappings != nil {
		fields = append(fields, user.FieldExternalMappings)
	}
	if m.created_at != nil {
		fields = append(fields, user.FieldCreatedAt)
	}
	if m.role != nil {
		fields = append(fields, user.FieldRole)
	}
	if m.seniority != nil {
		fields = append(fields, user.FieldSeniority)
	}
	if m.max_wip != nil {
		fields = append(fields, user.FieldMaxWip)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user.FieldZitadelID:
		return m.ZitadelID()
	case user.FieldEmail:
		return m.Email()
	case user.FieldFirstName:
		return m.FirstName()
	case user.FieldLastName:
		return m.LastName()
	case user.FieldJobTitle:
		return m.JobTitle()
	case user.FieldDepartment:
		return m.Department()
	case user.FieldExternalMappings:
		return m.ExternalMappings()
	case user.FieldCreatedAt:
		return m.CreatedAt()
	case user.FieldRole:
		return m.Role()
	case user.FieldSeniority:
		return m.Seniority()
	case user.FieldMaxWip:
		return m.MaxWip()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case user.FieldZitadelID:
		return m.OldZitadelID(ctx)
	case user.FieldEmail:
		return m.OldEmail(ctx)
	case user.FieldFirstName:
		return m.OldFirstName(ctx)
	case user.FieldLastName:
		return m.OldLastName(ctx)
	case user.FieldJobTitle:
		return m.OldJobTitle(ctx)
	case user.FieldDepartment:
		return m.OldDepartment(ctx)
	case user.FieldExternalMappings:
		return m.OldExternalMappings(ctx)
	case user.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case user.FieldRole:
		return m.OldRole(ctx)
	case user.FieldSeniority:
		return m.OldSeniority(ctx)
	case user.FieldMaxWip:
		return m.OldMaxWip(ctx)
	}
	return nil, fmt.Errorf("unknown User field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user.FieldZitadelID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetZitadelID(v)
		return nil
	case user.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case user.FieldFirstName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFirstName(v)
		return nil
	case user.FieldLastName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastName(v)
		return nil
	case user.FieldJobTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetJobTitle(v)
		return nil
	case user.FieldDepartment:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDepartment(v)
		return nil
	case user.FieldExternalMappings:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExternalMappings(v)
		return nil
	case user.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case user.FieldRole:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRole(v)
		return nil
	case user.FieldSeniority:
		v, ok := value.(user.Seniority)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSeniority(v)
		return nil
	case user.FieldMaxWip:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMaxWip(v)
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserMutation) AddedFields() []string {
	var fields []string
	if m.addmax_wip != nil {
		fields = append(fields, user.FieldMaxWip)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case user.FieldMaxWip:
		return m.AddedMaxWip()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	switch name {
	case user.FieldMaxWip:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMaxWip(v)
		return nil
	}
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(user.FieldFirstName) {
		fields = append(fields, user.FieldFirstName)
	}
	if m.FieldCleared(user.FieldLastName) {
		fields = append(fields, user.FieldLastName)
	}
	if m.FieldCleared(user.FieldJobTitle) {
		fields = append(fields, user.FieldJobTitle)
	}
	if m.FieldCleared(user.FieldDepartment) {
		fields = append(fields, user.FieldDepartment)
	}
	if m.FieldCleared(user.FieldExternalMappings) {
		fields = append(fields, user.FieldExternalMappings)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	switch name {
	case user.FieldFirstName:
		m.ClearFirstName()
		return nil
	case user.FieldLastName:
		m.ClearLastName()
		return nil
	case user.FieldJobTitle:
		m.ClearJobTitle()
		return nil
	case user.FieldDepartment:
		m.ClearDepartment()
		return nil
	case user.FieldExternalMappings:
		m.ClearExternalMappings()
		return nil
	}
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	switch name {
	case user.FieldZitadelID:
		m.ResetZitadelID()
		return nil
	case user.FieldEmail:
		m.ResetEmail()
		return nil
	case user.FieldFirstName:
		m.ResetFirstName()
		return nil
	case user.FieldLastName:
		m.ResetLastName()
		return nil
	case user.FieldJobTitle:
		m.ResetJobTitle()
		return nil
	case user.FieldDepartment:
		m.ResetDepartment()
		return nil
	case user.FieldExternalMappings:
		m.ResetExternalMappings()
		return nil
	case user.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case user.FieldRole:
		m.ResetRole()
		return nil
	case user.FieldSeniority:
		m.ResetSeniority()
		return nil
	case user.FieldMaxWip:
		m.ResetMaxWip()
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 10)
	if m.tenant != nil {
		edges = append(edges, user.EdgeTenant)
	}
	if m.permissions != nil {
		edges = append(edges, user.EdgePermissions)
	}
	if m.requested_tickets != nil {
		edges = append(edges, user.EdgeRequestedTickets)
	}
	if m.assigned_tickets != nil {
		edges = append(edges, user.EdgeAssignedTickets)
	}
	if m.time_entries != nil {
		edges = append(edges, user.EdgeTimeEntries)
	}
	if m.owned_assets != nil {
		edges = append(edges, user.EdgeOwnedAssets)
	}
	if m.authored_sops != nil {
		edges = append(edges, user.EdgeAuthoredSops)
	}
	if m.call_logs != nil {
		edges = append(edges, user.EdgeCallLogs)
	}
	if m.voicemails != nil {
		edges = append(edges, user.EdgeVoicemails)
	}
	if m.saas_identities != nil {
		edges = append(edges, user.EdgeSaasIdentities)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeTenant:
		if id := m.tenant; id != nil {
			return []ent.Value{*id}
		}
	case user.EdgePermissions:
		ids := make([]ent.Value, 0, len(m.permissions))
		for id := range m.permissions {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeRequestedTickets:
		ids := make([]ent.Value, 0, len(m.requested_tickets))
		for id := range m.requested_tickets {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeAssignedTickets:
		ids := make([]ent.Value, 0, len(m.assigned_tickets))
		for id := range m.assigned_tickets {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeTimeEntries:
		ids := make([]ent.Value, 0, len(m.time_entries))
		for id := range m.time_entries {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeOwnedAssets:
		ids := make([]ent.Value, 0, len(m.owned_assets))
		for id := range m.owned_assets {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeAuthoredSops:
		ids := make([]ent.Value, 0, len(m.authored_sops))
		for id := range m.authored_sops {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeCallLogs:
		ids := make([]ent.Value, 0, len(m.call_logs))
		for id := range m.call_logs {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeVoicemails:
		ids := make([]ent.Value, 0, len(m.voicemails))
		for id := range m.voicemails {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeSaasIdentities:
		ids := make([]ent.Value, 0, len(m.saas_identities))
		for id := range m.saas_identities {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 10)
	if m.removedpermissions != nil {
		edges = append(edges, user.EdgePermissions)
	}
	if m.removedrequested_tickets != nil {
		edges = append(edges, user.EdgeRequestedTickets)
	}
	if m.removedassigned_tickets != nil {
		edges = append(edges, user.EdgeAssignedTickets)
	}
	if m.removedtime_entries != nil {
		edges = append(edges, user.EdgeTimeEntries)
	}
	if m.removedowned_assets != nil {
		edges = append(edges, user.EdgeOwnedAssets)
	}
	if m.removedauthored_sops != nil {
		edges = append(edges, user.EdgeAuthoredSops)
	}
	if m.removedcall_logs != nil {
		edges = append(edges, user.EdgeCallLogs)
	}
	if m.removedvoicemails != nil {
		edges = append(edges, user.EdgeVoicemails)
	}
	if m.removedsaas_identities != nil {
		edges = append(edges, user.EdgeSaasIdentities)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case user.EdgePermissions:
		ids := make([]ent.Value, 0, len(m.removedpermissions))
		for id := range m.removedpermissions {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeRequestedTickets:
		ids := make([]ent.Value, 0, len(m.removedrequested_tickets))
		for id := range m.removedrequested_tickets {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeAssignedTickets:
		ids := make([]ent.Value, 0, len(m.removedassigned_tickets))
		for id := range m.removedassigned_tickets {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeTimeEntries:
		ids := make([]ent.Value, 0, len(m.removedtime_entries))
		for id := range m.removedtime_entries {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeOwnedAssets:
		ids := make([]ent.Value, 0, len(m.removedowned_assets))
		for id := range m.removedowned_assets {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeAuthoredSops:
		ids := make([]ent.Value, 0, len(m.removedauthored_sops))
		for id := range m.removedauthored_sops {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeCallLogs:
		ids := make([]ent.Value, 0, len(m.removedcall_logs))
		for id := range m.removedcall_logs {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeVoicemails:
		ids := make([]ent.Value, 0, len(m.removedvoicemails))
		for id := range m.removedvoicemails {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeSaasIdentities:
		ids := make([]ent.Value, 0, len(m.removedsaas_identities))
		for id := range m.removedsaas_identities {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 10)
	if m.clearedtenant {
		edges = append(edges, user.EdgeTenant)
	}
	if m.clearedpermissions {
		edges = append(edges, user.EdgePermissions)
	}
	if m.clearedrequested_tickets {
		edges = append(edges, user.EdgeRequestedTickets)
	}
	if m.clearedassigned_tickets {
		edges = append(edges, user.EdgeAssignedTickets)
	}
	if m.clearedtime_entries {
		edges = append(edges, user.EdgeTimeEntries)
	}
	if m.clearedowned_assets {
		edges = append(edges, user.EdgeOwnedAssets)
	}
	if m.clearedauthored_sops {
		edges = append(edges, user.EdgeAuthoredSops)
	}
	if m.clearedcall_logs {
		edges = append(edges, user.EdgeCallLogs)
	}
	if m.clearedvoicemails {
		edges = append(edges, user.EdgeVoicemails)
	}
	if m.clearedsaas_identities {
		edges = append(edges, user.EdgeSaasIdentities)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	switch name {
	case user.EdgeTenant:
		return m.clearedtenant
	case user.EdgePermissions:
		return m.clearedpermissions
	case user.EdgeRequestedTickets:
		return m.clearedrequested_tickets
	case user.EdgeAssignedTickets:
		return m.clearedassigned_tickets
	case user.EdgeTimeEntries:
		return m.clearedtime_entries
	case user.EdgeOwnedAssets:
		return m.clearedowned_assets
	case user.EdgeAuthoredSops:
		return m.clearedauthored_sops
	case user.EdgeCallLogs:
		return m.clearedcall_logs
	case user.EdgeVoicemails:
		return m.clearedvoicemails
	case user.EdgeSaasIdentities:
		return m.clearedsaas_identities
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	switch name {
	case user.EdgeTenant:
		m.ClearTenant()
		return nil
	}
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	switch name {
	case user.EdgeTenant:
		m.ResetTenant()
		return nil
	case user.EdgePermissions:
		m.ResetPermissions()
		return nil
	case user.EdgeRequestedTickets:
		m.ResetRequestedTickets()
		return nil
	case user.EdgeAssignedTickets:
		m.ResetAssignedTickets()
		return nil
	case user.EdgeTimeEntries:
		m.ResetTimeEntries()
		return nil
	case user.EdgeOwnedAssets:
		m.ResetOwnedAssets()
		return nil
	case user.EdgeAuthoredSops:
		m.ResetAuthoredSops()
		return nil
	case user.EdgeCallLogs:
		m.ResetCallLogs()
		return nil
	case user.EdgeVoicemails:
		m.ResetVoicemails()
		return nil
	case user.EdgeSaasIdentities:
		m.ResetSaasIdentities()
		return nil
	}
	return fmt.Errorf("unknown User edge %s", name)
}

// VaultItemMutation represents an operation that mutates the VaultItem nodes in the graph.
type VaultItemMutation struct {
	config
	op            Op
	typ           string
	id            *int
	_path         *string
	name          *string
	size          *int64
	addsize       *int64
	hash          *string
	content       *string
	is_dir        *bool
	created_at    *time.Time
	updated_at    *time.Time
	clearedFields map[string]struct{}
	tenant        *int
	clearedtenant bool
	done          bool
	oldValue      func(context.Context) (*VaultItem, error)
	predicates    []predicate.VaultItem
}

var _ ent.Mutation = (*VaultItemMutation)(nil)

// vaultitemOption allows management of the mutation configuration using functional options.
type vaultitemOption func(*VaultItemMutation)

// newVaultItemMutation creates new mutation for the VaultItem entity.
func newVaultItemMutation(c config, op Op, opts ...vaultitemOption) *VaultItemMutation {
	m := &VaultItemMutation{
		config:        c,
		op:            op,
		typ:           TypeVaultItem,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withVaultItemID sets the ID field of the mutation.
func withVaultItemID(id int) vaultitemOption {
	return func(m *VaultItemMutation) {
		var (
			err   error
			once  sync.Once
			value *VaultItem
		)
		m.oldValue = func(ctx context.Context) (*VaultItem, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().VaultItem.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withVaultItem sets the old VaultItem of the mutation.
func withVaultItem(node *VaultItem) vaultitemOption {
	return func(m *VaultItemMutation) {
		m.oldValue = func(context.Context) (*VaultItem, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m VaultItemMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m VaultItemMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *VaultItemMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *VaultItemMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().VaultItem.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetPath sets the "path" field.
func (m *VaultItemMutation) SetPath(s string) {
	m._path = &s
}

// Path returns the value of the "path" field in the mutation.
func (m *VaultItemMutation) Path() (r string, exists bool) {
	v := m._path
	if v == nil {
		return
	}
	return *v, true
}

// OldPath returns the old "path" field's value of the VaultItem entity.
// If the VaultItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VaultItemMutation) OldPath(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPath is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPath requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPath: %w", err)
	}
	return oldValue.Path, nil
}

// ResetPath resets all changes to the "path" field.
func (m *VaultItemMutation) ResetPath() {
	m._path = nil
}

// SetName sets the "name" field.
func (m *VaultItemMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *VaultItemMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the VaultItem entity.
// If the VaultItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VaultItemMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *VaultItemMutation) ResetName() {
	m.name = nil
}

// SetSize sets the "size" field.
func (m *VaultItemMutation) SetSize(i int64) {
	m.size = &i
	m.addsize = nil
}

// Size returns the value of the "size" field in the mutation.
func (m *VaultItemMutation) Size() (r int64, exists bool) {
	v := m.size
	if v == nil {
		return
	}
	return *v, true
}

// OldSize returns the old "size" field's value of the VaultItem entity.
// If the VaultItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VaultItemMutation) OldSize(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSize is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSize requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSize: %w", err)
	}
	return oldValue.Size, nil
}

// AddSize adds i to the "size" field.
func (m *VaultItemMutation) AddSize(i int64) {
	if m.addsize != nil {
		*m.addsize += i
	} else {
		m.addsize = &i
	}
}

// AddedSize returns the value that was added to the "size" field in this mutation.
func (m *VaultItemMutation) AddedSize() (r int64, exists bool) {
	v := m.addsize
	if v == nil {
		return
	}
	return *v, true
}

// ResetSize resets all changes to the "size" field.
func (m *VaultItemMutation) ResetSize() {
	m.size = nil
	m.addsize = nil
}

// SetHash sets the "hash" field.
func (m *VaultItemMutation) SetHash(s string) {
	m.hash = &s
}

// Hash returns the value of the "hash" field in the mutation.
func (m *VaultItemMutation) Hash() (r string, exists bool) {
	v := m.hash
	if v == nil {
		return
	}
	return *v, true
}

// OldHash returns the old "hash" field's value of the VaultItem entity.
// If the VaultItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VaultItemMutation) OldHash(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHash is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHash requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHash: %w", err)
	}
	return oldValue.Hash, nil
}

// ResetHash resets all changes to the "hash" field.
func (m *VaultItemMutation) ResetHash() {
	m.hash = nil
}

// SetContent sets the "content" field.
func (m *VaultItemMutation) SetContent(s string) {
	m.content = &s
}

// Content returns the value of the "content" field in the mutation.
func (m *VaultItemMutation) Content() (r string, exists bool) {
	v := m.content
	if v == nil {
		return
	}
	return *v, true
}

// OldContent returns the old "content" field's value of the VaultItem entity.
// If the VaultItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VaultItemMutation) OldContent(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContent: %w", err)
	}
	return oldValue.Content, nil
}

// ClearContent clears the value of the "content" field.
func (m *VaultItemMutation) ClearContent() {
	m.content = nil
	m.clearedFields[vaultitem.FieldContent] = struct{}{}
}

// ContentCleared returns if the "content" field was cleared in this mutation.
func (m *VaultItemMutation) ContentCleared() bool {
	_, ok := m.clearedFields[vaultitem.FieldContent]
	return ok
}

// ResetContent resets all changes to the "content" field.
func (m *VaultItemMutation) ResetContent() {
	m.content = nil
	delete(m.clearedFields, vaultitem.FieldContent)
}

// SetIsDir sets the "is_dir" field.
func (m *VaultItemMutation) SetIsDir(b bool) {
	m.is_dir = &b
}

// IsDir returns the value of the "is_dir" field in the mutation.
func (m *VaultItemMutation) IsDir() (r bool, exists bool) {
	v := m.is_dir
	if v == nil {
		return
	}
	return *v, true
}

// OldIsDir returns the old "is_dir" field's value of the VaultItem entity.
// If the VaultItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VaultItemMutation) OldIsDir(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsDir is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsDir requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsDir: %w", err)
	}
	return oldValue.IsDir, nil
}

// ResetIsDir resets all changes to the "is_dir" field.
func (m *VaultItemMutation) ResetIsDir() {
	m.is_dir = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *VaultItemMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *VaultItemMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the VaultItem entity.
// If the VaultItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VaultItemMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *VaultItemMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *VaultItemMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *VaultItemMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the VaultItem entity.
// If the VaultItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VaultItemMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *VaultItemMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetTenantID sets the "tenant" edge to the Tenant entity by id.
func (m *VaultItemMutation) SetTenantID(id int) {
	m.tenant = &id
}

// ClearTenant clears the "tenant" edge to the Tenant entity.
func (m *VaultItemMutation) ClearTenant() {
	m.clearedtenant = true
}

// TenantCleared reports if the "tenant" edge to the Tenant entity was cleared.
func (m *VaultItemMutation) TenantCleared() bool {
	return m.clearedtenant
}

// TenantID returns the "tenant" edge ID in the mutation.
func (m *VaultItemMutation) TenantID() (id int, exists bool) {
	if m.tenant != nil {
		return *m.tenant, true
	}
	return
}

// TenantIDs returns the "tenant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TenantID instead. It exists only for internal usage by the builders.
func (m *VaultItemMutation) TenantIDs() (ids []int) {
	if id := m.tenant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTenant resets all changes to the "tenant" edge.
func (m *VaultItemMutation) ResetTenant() {
	m.tenant = nil
	m.clearedtenant = false
}

// Where appends a list predicates to the VaultItemMutation builder.
func (m *VaultItemMutation) Where(ps ...predicate.VaultItem) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the VaultItemMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *VaultItemMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.VaultItem, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *VaultItemMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *VaultItemMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (VaultItem).
func (m *VaultItemMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *VaultItemMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m._path != nil {
		fields = append(fields, vaultitem.FieldPath)
	}
	if m.name != nil {
		fields = append(fields, vaultitem.FieldName)
	}
	if m.size != nil {
		fields = append(fields, vaultitem.FieldSize)
	}
	if m.hash != nil {
		fields = append(fields, vaultitem.FieldHash)
	}
	if m.content != nil {
		fields = append(fields, vaultitem.FieldContent)
	}
	if m.is_dir != nil {
		fields = append(fields, vaultitem.FieldIsDir)
	}
	if m.created_at != nil {
		fields = append(fields, vaultitem.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, vaultitem.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *VaultItemMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case vaultitem.FieldPath:
		return m.Path()
	case vaultitem.FieldName:
		return m.Name()
	case vaultitem.FieldSize:
		return m.Size()
	case vaultitem.FieldHash:
		return m.Hash()
	case vaultitem.FieldContent:
		return m.Content()
	case vaultitem.FieldIsDir:
		return m.IsDir()
	case vaultitem.FieldCreatedAt:
		return m.CreatedAt()
	case vaultitem.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *VaultItemMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case vaultitem.FieldPath:
		return m.OldPath(ctx)
	case vaultitem.FieldName:
		return m.OldName(ctx)
	case vaultitem.FieldSize:
		return m.OldSize(ctx)
	case vaultitem.FieldHash:
		return m.OldHash(ctx)
	case vaultitem.FieldContent:
		return m.OldContent(ctx)
	case vaultitem.FieldIsDir:
		return m.OldIsDir(ctx)
	case vaultitem.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case vaultitem.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown VaultItem field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *VaultItemMutation) SetField(name string, value ent.Value) error {
	switch name {
	case vaultitem.FieldPath:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPath(v)
		return nil
	case vaultitem.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case vaultitem.FieldSize:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSize(v)
		return nil
	case vaultitem.FieldHash:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHash(v)
		return nil
	case vaultitem.FieldContent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContent(v)
		return nil
	case vaultitem.FieldIsDir:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsDir(v)
		return nil
	case vaultitem.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case vaultitem.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown VaultItem field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *VaultItemMutation) AddedFields() []string {
	var fields []string
	if m.addsize != nil {
		fields = append(fields, vaultitem.FieldSize)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *VaultItemMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case vaultitem.FieldSize:
		return m.AddedSize()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *VaultItemMutation) AddField(name string, value ent.Value) error {
	switch name {
	case vaultitem.FieldSize:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSize(v)
		return nil
	}
	return fmt.Errorf("unknown VaultItem numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *VaultItemMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(vaultitem.FieldContent) {
		fields = append(fields, vaultitem.FieldContent)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *VaultItemMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *VaultItemMutation) ClearField(name string) error {
	switch name {
	case vaultitem.FieldContent:
		m.ClearContent()
		return nil
	}
	return fmt.Errorf("unknown VaultItem nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *VaultItemMutation) ResetField(name string) error {
	switch name {
	case vaultitem.FieldPath:
		m.ResetPath()
		return nil
	case vaultitem.FieldName:
		m.ResetName()
		return nil
	case vaultitem.FieldSize:
		m.ResetSize()
		return nil
	case vaultitem.FieldHash:
		m.ResetHash()
		return nil
	case vaultitem.FieldContent:
		m.ResetContent()
		return nil
	case vaultitem.FieldIsDir:
		m.ResetIsDir()
		return nil
	case vaultitem.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case vaultitem.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown VaultItem field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *VaultItemMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.tenant != nil {
		edges = append(edges, vaultitem.EdgeTenant)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *VaultItemMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case vaultitem.EdgeTenant:
		if id := m.tenant; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *VaultItemMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *VaultItemMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *VaultItemMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedtenant {
		edges = append(edges, vaultitem.EdgeTenant)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *VaultItemMutation) EdgeCleared(name string) bool {
	switch name {
	case vaultitem.EdgeTenant:
		return m.clearedtenant
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *VaultItemMutation) ClearEdge(name string) error {
	switch name {
	case vaultitem.EdgeTenant:
		m.ClearTenant()
		return nil
	}
	return fmt.Errorf("unknown VaultItem unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *VaultItemMutation) ResetEdge(name string) error {
	switch name {
	case vaultitem.EdgeTenant:
		m.ResetTenant()
		return nil
	}
	return fmt.Errorf("unknown VaultItem edge %s", name)
}

// VoicemailMutation represents an operation that mutates the Voicemail nodes in the graph.
type VoicemailMutation struct {
	config
	op            Op
	typ           string
	id            *int
	caller        *string
	audio_path    *string
	transcription *string
	created_at    *time.Time
	read_at       *time.Time
	clearedFields map[string]struct{}
	tenant        *int
	clearedtenant bool
	user          *int
	cleareduser   bool
	done          bool
	oldValue      func(context.Context) (*Voicemail, error)
	predicates    []predicate.Voicemail
}

var _ ent.Mutation = (*VoicemailMutation)(nil)

// voicemailOption allows management of the mutation configuration using functional options.
type voicemailOption func(*VoicemailMutation)

// newVoicemailMutation creates new mutation for the Voicemail entity.
func newVoicemailMutation(c config, op Op, opts ...voicemailOption) *VoicemailMutation {
	m := &VoicemailMutation{
		config:        c,
		op:            op,
		typ:           TypeVoicemail,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withVoicemailID sets the ID field of the mutation.
func withVoicemailID(id int) voicemailOption {
	return func(m *VoicemailMutation) {
		var (
			err   error
			once  sync.Once
			value *Voicemail
		)
		m.oldValue = func(ctx context.Context) (*Voicemail, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Voicemail.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withVoicemail sets the old Voicemail of the mutation.
func withVoicemail(node *Voicemail) voicemailOption {
	return func(m *VoicemailMutation) {
		m.oldValue = func(context.Context) (*Voicemail, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m VoicemailMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m VoicemailMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *VoicemailMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *VoicemailMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Voicemail.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCaller sets the "caller" field.
func (m *VoicemailMutation) SetCaller(s string) {
	m.caller = &s
}

// Caller returns the value of the "caller" field in the mutation.
func (m *VoicemailMutation) Caller() (r string, exists bool) {
	v := m.caller
	if v == nil {
		return
	}
	return *v, true
}

// OldCaller returns the old "caller" field's value of the Voicemail entity.
// If the Voicemail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VoicemailMutation) OldCaller(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCaller is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCaller requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCaller: %w", err)
	}
	return oldValue.Caller, nil
}

// ResetCaller resets all changes to the "caller" field.
func (m *VoicemailMutation) ResetCaller() {
	m.caller = nil
}

// SetAudioPath sets the "audio_path" field.
func (m *VoicemailMutation) SetAudioPath(s string) {
	m.audio_path = &s
}

// AudioPath returns the value of the "audio_path" field in the mutation.
func (m *VoicemailMutation) AudioPath() (r string, exists bool) {
	v := m.audio_path
	if v == nil {
		return
	}
	return *v, true
}

// OldAudioPath returns the old "audio_path" field's value of the Voicemail entity.
// If the Voicemail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VoicemailMutation) OldAudioPath(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAudioPath is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAudioPath requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAudioPath: %w", err)
	}
	return oldValue.AudioPath, nil
}

// ResetAudioPath resets all changes to the "audio_path" field.
func (m *VoicemailMutation) ResetAudioPath() {
	m.audio_path = nil
}

// SetTranscription sets the "transcription" field.
func (m *VoicemailMutation) SetTranscription(s string) {
	m.transcription = &s
}

// Transcription returns the value of the "transcription" field in the mutation.
func (m *VoicemailMutation) Transcription() (r string, exists bool) {
	v := m.transcription
	if v == nil {
		return
	}
	return *v, true
}

// OldTranscription returns the old "transcription" field's value of the Voicemail entity.
// If the Voicemail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VoicemailMutation) OldTranscription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTranscription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTranscription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTranscription: %w", err)
	}
	return oldValue.Transcription, nil
}

// ClearTranscription clears the value of the "transcription" field.
func (m *VoicemailMutation) ClearTranscription() {
	m.transcription = nil
	m.clearedFields[voicemail.FieldTranscription] = struct{}{}
}

// TranscriptionCleared returns if the "transcription" field was cleared in this mutation.
func (m *VoicemailMutation) TranscriptionCleared() bool {
	_, ok := m.clearedFields[voicemail.FieldTranscription]
	return ok
}

// ResetTranscription resets all changes to the "transcription" field.
func (m *VoicemailMutation) ResetTranscription() {
	m.transcription = nil
	delete(m.clearedFields, voicemail.FieldTranscription)
}

// SetCreatedAt sets the "created_at" field.
func (m *VoicemailMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *VoicemailMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Voicemail entity.
// If the Voicemail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VoicemailMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *VoicemailMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetReadAt sets the "read_at" field.
func (m *VoicemailMutation) SetReadAt(t time.Time) {
	m.read_at = &t
}

// ReadAt returns the value of the "read_at" field in the mutation.
func (m *VoicemailMutation) ReadAt() (r time.Time, exists bool) {
	v := m.read_at
	if v == nil {
		return
	}
	return *v, true
}

// OldReadAt returns the old "read_at" field's value of the Voicemail entity.
// If the Voicemail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VoicemailMutation) OldReadAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReadAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReadAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReadAt: %w", err)
	}
	return oldValue.ReadAt, nil
}

// ClearReadAt clears the value of the "read_at" field.
func (m *VoicemailMutation) ClearReadAt() {
	m.read_at = nil
	m.clearedFields[voicemail.FieldReadAt] = struct{}{}
}

// ReadAtCleared returns if the "read_at" field was cleared in this mutation.
func (m *VoicemailMutation) ReadAtCleared() bool {
	_, ok := m.clearedFields[voicemail.FieldReadAt]
	return ok
}

// ResetReadAt resets all changes to the "read_at" field.
func (m *VoicemailMutation) ResetReadAt() {
	m.read_at = nil
	delete(m.clearedFields, voicemail.FieldReadAt)
}

// SetTenantID sets the "tenant" edge to the Tenant entity by id.
func (m *VoicemailMutation) SetTenantID(id int) {
	m.tenant = &id
}

// ClearTenant clears the "tenant" edge to the Tenant entity.
func (m *VoicemailMutation) ClearTenant() {
	m.clearedtenant = true
}

// TenantCleared reports if the "tenant" edge to the Tenant entity was cleared.
func (m *VoicemailMutation) TenantCleared() bool {
	return m.clearedtenant
}

// TenantID returns the "tenant" edge ID in the mutation.
func (m *VoicemailMutation) TenantID() (id int, exists bool) {
	if m.tenant != nil {
		return *m.tenant, true
	}
	return
}

// TenantIDs returns the "tenant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TenantID instead. It exists only for internal usage by the builders.
func (m *VoicemailMutation) TenantIDs() (ids []int) {
	if id := m.tenant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTenant resets all changes to the "tenant" edge.
func (m *VoicemailMutation) ResetTenant() {
	m.tenant = nil
	m.clearedtenant = false
}

// SetUserID sets the "user" edge to the User entity by id.
func (m *VoicemailMutation) SetUserID(id int) {
	m.user = &id
}

// ClearUser clears the "user" edge to the User entity.
func (m *VoicemailMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *VoicemailMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *VoicemailMutation) UserID() (id int, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *VoicemailMutation) UserIDs() (ids []int) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *VoicemailMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the VoicemailMutation builder.
func (m *VoicemailMutation) Where(ps ...predicate.Voicemail) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the VoicemailMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *VoicemailMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Voicemail, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *VoicemailMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *VoicemailMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Voicemail).
func (m *VoicemailMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *VoicemailMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.caller != nil {
		fields = append(fields, voicemail.FieldCaller)
	}
	if m.audio_path != nil {
		fields = append(fields, voicemail.FieldAudioPath)
	}
	if m.transcription != nil {
		fields = append(fields, voicemail.FieldTranscription)
	}
	if m.created_at != nil {
		fields = append(fields, voicemail.FieldCreatedAt)
	}
	if m.read_at != nil {
		fields = append(fields, voicemail.FieldReadAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *VoicemailMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case voicemail.FieldCaller:
		return m.Caller()
	case voicemail.FieldAudioPath:
		return m.AudioPath()
	case voicemail.FieldTranscription:
		return m.Transcription()
	case voicemail.FieldCreatedAt:
		return m.CreatedAt()
	case voicemail.FieldReadAt:
		return m.ReadAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *VoicemailMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case voicemail.FieldCaller:
		return m.OldCaller(ctx)
	case voicemail.FieldAudioPath:
		return m.OldAudioPath(ctx)
	case voicemail.FieldTranscription:
		return m.OldTranscription(ctx)
	case voicemail.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case voicemail.FieldReadAt:
		return m.OldReadAt(ctx)
	}
	return nil, fmt.Errorf("unknown Voicemail field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *VoicemailMutation) SetField(name string, value ent.Value) error {
	switch name {
	case voicemail.FieldCaller:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCaller(v)
		return nil
	case voicemail.FieldAudioPath:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAudioPath(v)
		return nil
	case voicemail.FieldTranscription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTranscription(v)
		return nil
	case voicemail.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case voicemail.FieldReadAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReadAt(v)
		return nil
	}
	return fmt.Errorf("unknown Voicemail field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *VoicemailMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *VoicemailMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *VoicemailMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Voicemail numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *VoicemailMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(voicemail.FieldTranscription) {
		fields = append(fields, voicemail.FieldTranscription)
	}
	if m.FieldCleared(voicemail.FieldReadAt) {
		fields = append(fields, voicemail.FieldReadAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *VoicemailMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *VoicemailMutation) ClearField(name string) error {
	switch name {
	case voicemail.FieldTranscription:
		m.ClearTranscription()
		return nil
	case voicemail.FieldReadAt:
		m.ClearReadAt()
		return nil
	}
	return fmt.Errorf("unknown Voicemail nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *VoicemailMutation) ResetField(name string) error {
	switch name {
	case voicemail.FieldCaller:
		m.ResetCaller()
		return nil
	case voicemail.FieldAudioPath:
		m.ResetAudioPath()
		return nil
	case voicemail.FieldTranscription:
		m.ResetTranscription()
		return nil
	case voicemail.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case voicemail.FieldReadAt:
		m.ResetReadAt()
		return nil
	}
	return fmt.Errorf("unknown Voicemail field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *VoicemailMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.tenant != nil {
		edges = append(edges, voicemail.EdgeTenant)
	}
	if m.user != nil {
		edges = append(edges, voicemail.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *VoicemailMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case voicemail.EdgeTenant:
		if id := m.tenant; id != nil {
			return []ent.Value{*id}
		}
	case voicemail.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *VoicemailMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *VoicemailMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *VoicemailMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedtenant {
		edges = append(edges, voicemail.EdgeTenant)
	}
	if m.cleareduser {
		edges = append(edges, voicemail.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *VoicemailMutation) EdgeCleared(name string) bool {
	switch name {
	case voicemail.EdgeTenant:
		return m.clearedtenant
	case voicemail.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *VoicemailMutation) ClearEdge(name string) error {
	switch name {
	case voicemail.EdgeTenant:
		m.ClearTenant()
		return nil
	case voicemail.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown Voicemail unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *VoicemailMutation) ResetEdge(name string) error {
	switch name {
	case voicemail.EdgeTenant:
		m.ResetTenant()
		return nil
	case voicemail.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown Voicemail edge %s", name)
}
