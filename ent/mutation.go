// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"sent/ent/account"
	"sent/ent/agent"
	"sent/ent/application"
	"sent/ent/asset"
	"sent/ent/assetassignment"
	"sent/ent/assettype"
	"sent/ent/auditlog"
	"sent/ent/benefitenrollment"
	"sent/ent/benefitplan"
	"sent/ent/budgetforecast"
	"sent/ent/calllog"
	"sent/ent/camera"
	"sent/ent/candidate"
	"sent/ent/category"
	"sent/ent/compensationagreement"
	"sent/ent/contact"
	"sent/ent/contract"
	"sent/ent/credential"
	"sent/ent/department"
	"sent/ent/detectionevent"
	"sent/ent/discoveryentry"
	"sent/ent/employee"
	"sent/ent/goal"
	"sent/ent/healthscoresnapshot"
	"sent/ent/interview"
	"sent/ent/inventorycount"
	"sent/ent/inventoryreservation"
	"sent/ent/ivrflow"
	"sent/ent/job"
	"sent/ent/jobexecution"
	"sent/ent/jobposting"
	"sent/ent/journalentry"
	"sent/ent/ledgerentry"
	"sent/ent/legalhold"
	"sent/ent/maintenanceschedule"
	"sent/ent/networkbackup"
	"sent/ent/networkdevice"
	"sent/ent/networklink"
	"sent/ent/networkport"
	"sent/ent/nexusaudit"
	"sent/ent/onetimelink"
	"sent/ent/performancereview"
	"sent/ent/permission"
	"sent/ent/predicate"
	"sent/ent/product"
	"sent/ent/productvariant"
	"sent/ent/purchaseorder"
	"sent/ent/purchaseorderline"
	"sent/ent/recording"
	"sent/ent/recurringinvoice"
	"sent/ent/remediationstep"
	"sent/ent/retentionpolicy"
	"sent/ent/reviewcycle"
	"sent/ent/saasapp"
	"sent/ent/saasfilter"
	"sent/ent/saasidentity"
	"sent/ent/saasusage"
	"sent/ent/script"
	"sent/ent/servicerate"
	"sent/ent/sop"
	"sent/ent/stockalert"
	"sent/ent/stockauditlog"
	"sent/ent/stockmovement"
	"sent/ent/strategicroadmap"
	"sent/ent/successionmap"
	"sent/ent/supplier"
	"sent/ent/tenant"
	"sent/ent/ticket"
	"sent/ent/timeentry"
	"sent/ent/timeoffbalance"
	"sent/ent/timeoffpolicy"
	"sent/ent/timeoffrequest"
	"sent/ent/transaction"
	"sent/ent/user"
	"sent/ent/vaultcomment"
	"sent/ent/vaultfavorite"
	"sent/ent/vaultitem"
	"sent/ent/vaultsharelink"
	"sent/ent/vaulttemplate"
	"sent/ent/vaultversion"
	"sent/ent/voicemail"
	"sent/ent/warehouse"
	"sent/ent/worklog"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/shopspring/decimal"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeAccount               = "Account"
	TypeAgent                 = "Agent"
	TypeApplication           = "Application"
	TypeAsset                 = "Asset"
	TypeAssetAssignment       = "AssetAssignment"
	TypeAssetType             = "AssetType"
	TypeAuditLog              = "AuditLog"
	TypeBenefitEnrollment     = "BenefitEnrollment"
	TypeBenefitPlan           = "BenefitPlan"
	TypeBudgetForecast        = "BudgetForecast"
	TypeCallLog               = "CallLog"
	TypeCamera                = "Camera"
	TypeCandidate             = "Candidate"
	TypeCategory              = "Category"
	TypeCompensationAgreement = "CompensationAgreement"
	TypeContact               = "Contact"
	TypeContract              = "Contract"
	TypeCredential            = "Credential"
	TypeDepartment            = "Department"
	TypeDetectionEvent        = "DetectionEvent"
	TypeDiscoveryEntry        = "DiscoveryEntry"
	TypeEmployee              = "Employee"
	TypeGoal                  = "Goal"
	TypeHealthScoreSnapshot   = "HealthScoreSnapshot"
	TypeIVRFlow               = "IVRFlow"
	TypeInterview             = "Interview"
	TypeInventoryCount        = "InventoryCount"
	TypeInventoryReservation  = "InventoryReservation"
	TypeJob                   = "Job"
	TypeJobExecution          = "JobExecution"
	TypeJobPosting            = "JobPosting"
	TypeJournalEntry          = "JournalEntry"
	TypeLedgerEntry           = "LedgerEntry"
	TypeLegalHold             = "LegalHold"
	TypeMaintenanceSchedule   = "MaintenanceSchedule"
	TypeNetworkBackup         = "NetworkBackup"
	TypeNetworkDevice         = "NetworkDevice"
	TypeNetworkLink           = "NetworkLink"
	TypeNetworkPort           = "NetworkPort"
	TypeNexusAudit            = "NexusAudit"
	TypeOneTimeLink           = "OneTimeLink"
	TypePerformanceReview     = "PerformanceReview"
	TypePermission            = "Permission"
	TypeProduct               = "Product"
	TypeProductVariant        = "ProductVariant"
	TypePurchaseOrder         = "PurchaseOrder"
	TypePurchaseOrderLine     = "PurchaseOrderLine"
	TypeRecording             = "Recording"
	TypeRecurringInvoice      = "RecurringInvoice"
	TypeRemediationStep       = "RemediationStep"
	TypeRetentionPolicy       = "RetentionPolicy"
	TypeReviewCycle           = "ReviewCycle"
	TypeSOP                   = "SOP"
	TypeSaaSApp               = "SaaSApp"
	TypeSaaSFilter            = "SaaSFilter"
	TypeSaaSIdentity          = "SaaSIdentity"
	TypeSaaSUsage             = "SaaSUsage"
	TypeScript                = "Script"
	TypeServiceRate           = "ServiceRate"
	TypeStockAlert            = "StockAlert"
	TypeStockAuditLog         = "StockAuditLog"
	TypeStockMovement         = "StockMovement"
	TypeStrategicRoadmap      = "StrategicRoadmap"
	TypeSuccessionMap         = "SuccessionMap"
	TypeSupplier              = "Supplier"
	TypeTenant                = "Tenant"
	TypeTicket                = "Ticket"
	TypeTimeEntry             = "TimeEntry"
	TypeTimeOffBalance        = "TimeOffBalance"
	TypeTimeOffPolicy         = "TimeOffPolicy"
	TypeTimeOffRequest        = "TimeOffRequest"
	TypeTransaction           = "Transaction"
	TypeUser                  = "User"
	TypeVaultComment          = "VaultComment"
	TypeVaultFavorite         = "VaultFavorite"
	TypeVaultItem             = "VaultItem"
	TypeVaultShareLink        = "VaultShareLink"
	TypeVaultTemplate         = "VaultTemplate"
	TypeVaultVersion          = "VaultVersion"
	TypeVoicemail             = "Voicemail"
	TypeWarehouse             = "Warehouse"
	TypeWorkLog               = "WorkLog"
)

// AccountMutation represents an operation that mutates the Account nodes in the graph.
type AccountMutation struct {
	config
	op                        Op
	typ                       string
	id                        *int
	name                      *string
	number                    *string
	_type                     *account.Type
	balance                   *decimal.Decimal
	is_intercompany           *bool
	created_at                *time.Time
	clearedFields             map[string]struct{}
	tenant                    *int
	clearedtenant             bool
	entries                   map[int]struct{}
	removedentries            map[int]struct{}
	clearedentries            bool
	journal_entries           map[int]struct{}
	removedjournal_entries    map[int]struct{}
	clearedjournal_entries    bool
	recurring_invoices        map[int]struct{}
	removedrecurring_invoices map[int]struct{}
	clearedrecurring_invoices bool
	done                      bool
	oldValue                  func(context.Context) (*Account, error)
	predicates                []predicate.Account
}

var _ ent.Mutation = (*AccountMutation)(nil)

// accountOption allows management of the mutation configuration using functional options.
type accountOption func(*AccountMutation)

// newAccountMutation creates new mutation for the Account entity.
func newAccountMutation(c config, op Op, opts ...accountOption) *AccountMutation {
	m := &AccountMutation{
		config:        c,
		op:            op,
		typ:           TypeAccount,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAccountID sets the ID field of the mutation.
func withAccountID(id int) accountOption {
	return func(m *AccountMutation) {
		var (
			err   error
			once  sync.Once
			value *Account
		)
		m.oldValue = func(ctx context.Context) (*Account, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Account.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAccount sets the old Account of the mutation.
func withAccount(node *Account) accountOption {
	return func(m *AccountMutation) {
		m.oldValue = func(context.Context) (*Account, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AccountMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AccountMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AccountMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AccountMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Account.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *AccountMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *AccountMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *AccountMutation) ResetName() {
	m.name = nil
}

// SetNumber sets the "number" field.
func (m *AccountMutation) SetNumber(s string) {
	m.number = &s
}

// Number returns the value of the "number" field in the mutation.
func (m *AccountMutation) Number() (r string, exists bool) {
	v := m.number
	if v == nil {
		return
	}
	return *v, true
}

// OldNumber returns the old "number" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNumber: %w", err)
	}
	return oldValue.Number, nil
}

// ResetNumber resets all changes to the "number" field.
func (m *AccountMutation) ResetNumber() {
	m.number = nil
}

// SetType sets the "type" field.
func (m *AccountMutation) SetType(a account.Type) {
	m._type = &a
}

// GetType returns the value of the "type" field in the mutation.
func (m *AccountMutation) GetType() (r account.Type, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldType(ctx context.Context) (v account.Type, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *AccountMutation) ResetType() {
	m._type = nil
}

// SetBalance sets the "balance" field.
func (m *AccountMutation) SetBalance(d decimal.Decimal) {
	m.balance = &d
}

// Balance returns the value of the "balance" field in the mutation.
func (m *AccountMutation) Balance() (r decimal.Decimal, exists bool) {
	v := m.balance
	if v == nil {
		return
	}
	return *v, true
}

// OldBalance returns the old "balance" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldBalance(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBalance is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBalance requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBalance: %w", err)
	}
	return oldValue.Balance, nil
}

// ResetBalance resets all changes to the "balance" field.
func (m *AccountMutation) ResetBalance() {
	m.balance = nil
}

// SetIsIntercompany sets the "is_intercompany" field.
func (m *AccountMutation) SetIsIntercompany(b bool) {
	m.is_intercompany = &b
}

// IsIntercompany returns the value of the "is_intercompany" field in the mutation.
func (m *AccountMutation) IsIntercompany() (r bool, exists bool) {
	v := m.is_intercompany
	if v == nil {
		return
	}
	return *v, true
}

// OldIsIntercompany returns the old "is_intercompany" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldIsIntercompany(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsIntercompany is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsIntercompany requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsIntercompany: %w", err)
	}
	return oldValue.IsIntercompany, nil
}

// ResetIsIntercompany resets all changes to the "is_intercompany" field.
func (m *AccountMutation) ResetIsIntercompany() {
	m.is_intercompany = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *AccountMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AccountMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AccountMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetTenantID sets the "tenant" edge to the Tenant entity by id.
func (m *AccountMutation) SetTenantID(id int) {
	m.tenant = &id
}

// ClearTenant clears the "tenant" edge to the Tenant entity.
func (m *AccountMutation) ClearTenant() {
	m.clearedtenant = true
}

// TenantCleared reports if the "tenant" edge to the Tenant entity was cleared.
func (m *AccountMutation) TenantCleared() bool {
	return m.clearedtenant
}

// TenantID returns the "tenant" edge ID in the mutation.
func (m *AccountMutation) TenantID() (id int, exists bool) {
	if m.tenant != nil {
		return *m.tenant, true
	}
	return
}

// TenantIDs returns the "tenant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TenantID instead. It exists only for internal usage by the builders.
func (m *AccountMutation) TenantIDs() (ids []int) {
	if id := m.tenant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTenant resets all changes to the "tenant" edge.
func (m *AccountMutation) ResetTenant() {
	m.tenant = nil
	m.clearedtenant = false
}

// AddEntryIDs adds the "entries" edge to the LedgerEntry entity by ids.
func (m *AccountMutation) AddEntryIDs(ids ...int) {
	if m.entries == nil {
		m.entries = make(map[int]struct{})
	}
	for i := range ids {
		m.entries[ids[i]] = struct{}{}
	}
}

// ClearEntries clears the "entries" edge to the LedgerEntry entity.
func (m *AccountMutation) ClearEntries() {
	m.clearedentries = true
}

// EntriesCleared reports if the "entries" edge to the LedgerEntry entity was cleared.
func (m *AccountMutation) EntriesCleared() bool {
	return m.clearedentries
}

// RemoveEntryIDs removes the "entries" edge to the LedgerEntry entity by IDs.
func (m *AccountMutation) RemoveEntryIDs(ids ...int) {
	if m.removedentries == nil {
		m.removedentries = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.entries, ids[i])
		m.removedentries[ids[i]] = struct{}{}
	}
}

// RemovedEntries returns the removed IDs of the "entries" edge to the LedgerEntry entity.
func (m *AccountMutation) RemovedEntriesIDs() (ids []int) {
	for id := range m.removedentries {
		ids = append(ids, id)
	}
	return
}

// EntriesIDs returns the "entries" edge IDs in the mutation.
func (m *AccountMutation) EntriesIDs() (ids []int) {
	for id := range m.entries {
		ids = append(ids, id)
	}
	return
}

// ResetEntries resets all changes to the "entries" edge.
func (m *AccountMutation) ResetEntries() {
	m.entries = nil
	m.clearedentries = false
	m.removedentries = nil
}

// AddJournalEntryIDs adds the "journal_entries" edge to the JournalEntry entity by ids.
func (m *AccountMutation) AddJournalEntryIDs(ids ...int) {
	if m.journal_entries == nil {
		m.journal_entries = make(map[int]struct{})
	}
	for i := range ids {
		m.journal_entries[ids[i]] = struct{}{}
	}
}

// ClearJournalEntries clears the "journal_entries" edge to the JournalEntry entity.
func (m *AccountMutation) ClearJournalEntries() {
	m.clearedjournal_entries = true
}

// JournalEntriesCleared reports if the "journal_entries" edge to the JournalEntry entity was cleared.
func (m *AccountMutation) JournalEntriesCleared() bool {
	return m.clearedjournal_entries
}

// RemoveJournalEntryIDs removes the "journal_entries" edge to the JournalEntry entity by IDs.
func (m *AccountMutation) RemoveJournalEntryIDs(ids ...int) {
	if m.removedjournal_entries == nil {
		m.removedjournal_entries = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.journal_entries, ids[i])
		m.removedjournal_entries[ids[i]] = struct{}{}
	}
}

// RemovedJournalEntries returns the removed IDs of the "journal_entries" edge to the JournalEntry entity.
func (m *AccountMutation) RemovedJournalEntriesIDs() (ids []int) {
	for id := range m.removedjournal_entries {
		ids = append(ids, id)
	}
	return
}

// JournalEntriesIDs returns the "journal_entries" edge IDs in the mutation.
func (m *AccountMutation) JournalEntriesIDs() (ids []int) {
	for id := range m.journal_entries {
		ids = append(ids, id)
	}
	return
}

// ResetJournalEntries resets all changes to the "journal_entries" edge.
func (m *AccountMutation) ResetJournalEntries() {
	m.journal_entries = nil
	m.clearedjournal_entries = false
	m.removedjournal_entries = nil
}

// AddRecurringInvoiceIDs adds the "recurring_invoices" edge to the RecurringInvoice entity by ids.
func (m *AccountMutation) AddRecurringInvoiceIDs(ids ...int) {
	if m.recurring_invoices == nil {
		m.recurring_invoices = make(map[int]struct{})
	}
	for i := range ids {
		m.recurring_invoices[ids[i]] = struct{}{}
	}
}

// ClearRecurringInvoices clears the "recurring_invoices" edge to the RecurringInvoice entity.
func (m *AccountMutation) ClearRecurringInvoices() {
	m.clearedrecurring_invoices = true
}

// RecurringInvoicesCleared reports if the "recurring_invoices" edge to the RecurringInvoice entity was cleared.
func (m *AccountMutation) RecurringInvoicesCleared() bool {
	return m.clearedrecurring_invoices
}

// RemoveRecurringInvoiceIDs removes the "recurring_invoices" edge to the RecurringInvoice entity by IDs.
func (m *AccountMutation) RemoveRecurringInvoiceIDs(ids ...int) {
	if m.removedrecurring_invoices == nil {
		m.removedrecurring_invoices = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.recurring_invoices, ids[i])
		m.removedrecurring_invoices[ids[i]] = struct{}{}
	}
}

// RemovedRecurringInvoices returns the removed IDs of the "recurring_invoices" edge to the RecurringInvoice entity.
func (m *AccountMutation) RemovedRecurringInvoicesIDs() (ids []int) {
	for id := range m.removedrecurring_invoices {
		ids = append(ids, id)
	}
	return
}

// RecurringInvoicesIDs returns the "recurring_invoices" edge IDs in the mutation.
func (m *AccountMutation) RecurringInvoicesIDs() (ids []int) {
	for id := range m.recurring_invoices {
		ids = append(ids, id)
	}
	return
}

// ResetRecurringInvoices resets all changes to the "recurring_invoices" edge.
func (m *AccountMutation) ResetRecurringInvoices() {
	m.recurring_invoices = nil
	m.clearedrecurring_invoices = false
	m.removedrecurring_invoices = nil
}

// Where appends a list predicates to the AccountMutation builder.
func (m *AccountMutation) Where(ps ...predicate.Account) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AccountMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AccountMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Account, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AccountMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AccountMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Account).
func (m *AccountMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AccountMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.name != nil {
		fields = append(fields, account.FieldName)
	}
	if m.number != nil {
		fields = append(fields, account.FieldNumber)
	}
	if m._type != nil {
		fields = append(fields, account.FieldType)
	}
	if m.balance != nil {
		fields = append(fields, account.FieldBalance)
	}
	if m.is_intercompany != nil {
		fields = append(fields, account.FieldIsIntercompany)
	}
	if m.created_at != nil {
		fields = append(fields, account.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AccountMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case account.FieldName:
		return m.Name()
	case account.FieldNumber:
		return m.Number()
	case account.FieldType:
		return m.GetType()
	case account.FieldBalance:
		return m.Balance()
	case account.FieldIsIntercompany:
		return m.IsIntercompany()
	case account.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AccountMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case account.FieldName:
		return m.OldName(ctx)
	case account.FieldNumber:
		return m.OldNumber(ctx)
	case account.FieldType:
		return m.OldType(ctx)
	case account.FieldBalance:
		return m.OldBalance(ctx)
	case account.FieldIsIntercompany:
		return m.OldIsIntercompany(ctx)
	case account.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Account field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AccountMutation) SetField(name string, value ent.Value) error {
	switch name {
	case account.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case account.FieldNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNumber(v)
		return nil
	case account.FieldType:
		v, ok := value.(account.Type)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case account.FieldBalance:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBalance(v)
		return nil
	case account.FieldIsIntercompany:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsIntercompany(v)
		return nil
	case account.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Account field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AccountMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AccountMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AccountMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Account numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AccountMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AccountMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AccountMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Account nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AccountMutation) ResetField(name string) error {
	switch name {
	case account.FieldName:
		m.ResetName()
		return nil
	case account.FieldNumber:
		m.ResetNumber()
		return nil
	case account.FieldType:
		m.ResetType()
		return nil
	case account.FieldBalance:
		m.ResetBalance()
		return nil
	case account.FieldIsIntercompany:
		m.ResetIsIntercompany()
		return nil
	case account.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown Account field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AccountMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.tenant != nil {
		edges = append(edges, account.EdgeTenant)
	}
	if m.entries != nil {
		edges = append(edges, account.EdgeEntries)
	}
	if m.journal_entries != nil {
		edges = append(edges, account.EdgeJournalEntries)
	}
	if m.recurring_invoices != nil {
		edges = append(edges, account.EdgeRecurringInvoices)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AccountMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case account.EdgeTenant:
		if id := m.tenant; id != nil {
			return []ent.Value{*id}
		}
	case account.EdgeEntries:
		ids := make([]ent.Value, 0, len(m.entries))
		for id := range m.entries {
			ids = append(ids, id)
		}
		return ids
	case account.EdgeJournalEntries:
		ids := make([]ent.Value, 0, len(m.journal_entries))
		for id := range m.journal_entries {
			ids = append(ids, id)
		}
		return ids
	case account.EdgeRecurringInvoices:
		ids := make([]ent.Value, 0, len(m.recurring_invoices))
		for id := range m.recurring_invoices {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AccountMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedentries != nil {
		edges = append(edges, account.EdgeEntries)
	}
	if m.removedjournal_entries != nil {
		edges = append(edges, account.EdgeJournalEntries)
	}
	if m.removedrecurring_invoices != nil {
		edges = append(edges, account.EdgeRecurringInvoices)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AccountMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case account.EdgeEntries:
		ids := make([]ent.Value, 0, len(m.removedentries))
		for id := range m.removedentries {
			ids = append(ids, id)
		}
		return ids
	case account.EdgeJournalEntries:
		ids := make([]ent.Value, 0, len(m.removedjournal_entries))
		for id := range m.removedjournal_entries {
			ids = append(ids, id)
		}
		return ids
	case account.EdgeRecurringInvoices:
		ids := make([]ent.Value, 0, len(m.removedrecurring_invoices))
		for id := range m.removedrecurring_invoices {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AccountMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedtenant {
		edges = append(edges, account.EdgeTenant)
	}
	if m.clearedentries {
		edges = append(edges, account.EdgeEntries)
	}
	if m.clearedjournal_entries {
		edges = append(edges, account.EdgeJournalEntries)
	}
	if m.clearedrecurring_invoices {
		edges = append(edges, account.EdgeRecurringInvoices)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AccountMutation) EdgeCleared(name string) bool {
	switch name {
	case account.EdgeTenant:
		return m.clearedtenant
	case account.EdgeEntries:
		return m.clearedentries
	case account.EdgeJournalEntries:
		return m.clearedjournal_entries
	case account.EdgeRecurringInvoices:
		return m.clearedrecurring_invoices
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AccountMutation) ClearEdge(name string) error {
	switch name {
	case account.EdgeTenant:
		m.ClearTenant()
		return nil
	}
	return fmt.Errorf("unknown Account unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AccountMutation) ResetEdge(name string) error {
	switch name {
	case account.EdgeTenant:
		m.ResetTenant()
		return nil
	case account.EdgeEntries:
		m.ResetEntries()
		return nil
	case account.EdgeJournalEntries:
		m.ResetJournalEntries()
		return nil
	case account.EdgeRecurringInvoices:
		m.ResetRecurringInvoices()
		return nil
	}
	return fmt.Errorf("unknown Account edge %s", name)
}

// AgentMutation represents an operation that mutates the Agent nodes in the graph.
type AgentMutation struct {
	config
	op                    Op
	typ                   string
	id                    *int
	hostname              *string
	os                    *string
	arch                  *string
	ip                    *string
	mac                   *string
	version               *string
	status                *agent.Status
	last_seen             *time.Time
	created_at            *time.Time
	updated_at            *time.Time
	clearedFields         map[string]struct{}
	tenant                *int
	clearedtenant         bool
	job_executions        map[int]struct{}
	removedjob_executions map[int]struct{}
	clearedjob_executions bool
	done                  bool
	oldValue              func(context.Context) (*Agent, error)
	predicates            []predicate.Agent
}

var _ ent.Mutation = (*AgentMutation)(nil)

// agentOption allows management of the mutation configuration using functional options.
type agentOption func(*AgentMutation)

// newAgentMutation creates new mutation for the Agent entity.
func newAgentMutation(c config, op Op, opts ...agentOption) *AgentMutation {
	m := &AgentMutation{
		config:        c,
		op:            op,
		typ:           TypeAgent,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAgentID sets the ID field of the mutation.
func withAgentID(id int) agentOption {
	return func(m *AgentMutation) {
		var (
			err   error
			once  sync.Once
			value *Agent
		)
		m.oldValue = func(ctx context.Context) (*Agent, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Agent.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAgent sets the old Agent of the mutation.
func withAgent(node *Agent) agentOption {
	return func(m *AgentMutation) {
		m.oldValue = func(context.Context) (*Agent, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AgentMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AgentMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AgentMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AgentMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Agent.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetHostname sets the "hostname" field.
func (m *AgentMutation) SetHostname(s string) {
	m.hostname = &s
}

// Hostname returns the value of the "hostname" field in the mutation.
func (m *AgentMutation) Hostname() (r string, exists bool) {
	v := m.hostname
	if v == nil {
		return
	}
	return *v, true
}

// OldHostname returns the old "hostname" field's value of the Agent entity.
// If the Agent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentMutation) OldHostname(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHostname is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHostname requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHostname: %w", err)
	}
	return oldValue.Hostname, nil
}

// ResetHostname resets all changes to the "hostname" field.
func (m *AgentMutation) ResetHostname() {
	m.hostname = nil
}

// SetOs sets the "os" field.
func (m *AgentMutation) SetOs(s string) {
	m.os = &s
}

// Os returns the value of the "os" field in the mutation.
func (m *AgentMutation) Os() (r string, exists bool) {
	v := m.os
	if v == nil {
		return
	}
	return *v, true
}

// OldOs returns the old "os" field's value of the Agent entity.
// If the Agent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentMutation) OldOs(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOs is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOs requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOs: %w", err)
	}
	return oldValue.Os, nil
}

// ResetOs resets all changes to the "os" field.
func (m *AgentMutation) ResetOs() {
	m.os = nil
}

// SetArch sets the "arch" field.
func (m *AgentMutation) SetArch(s string) {
	m.arch = &s
}

// Arch returns the value of the "arch" field in the mutation.
func (m *AgentMutation) Arch() (r string, exists bool) {
	v := m.arch
	if v == nil {
		return
	}
	return *v, true
}

// OldArch returns the old "arch" field's value of the Agent entity.
// If the Agent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentMutation) OldArch(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldArch is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldArch requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldArch: %w", err)
	}
	return oldValue.Arch, nil
}

// ResetArch resets all changes to the "arch" field.
func (m *AgentMutation) ResetArch() {
	m.arch = nil
}

// SetIP sets the "ip" field.
func (m *AgentMutation) SetIP(s string) {
	m.ip = &s
}

// IP returns the value of the "ip" field in the mutation.
func (m *AgentMutation) IP() (r string, exists bool) {
	v := m.ip
	if v == nil {
		return
	}
	return *v, true
}

// OldIP returns the old "ip" field's value of the Agent entity.
// If the Agent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentMutation) OldIP(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIP is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIP requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIP: %w", err)
	}
	return oldValue.IP, nil
}

// ResetIP resets all changes to the "ip" field.
func (m *AgentMutation) ResetIP() {
	m.ip = nil
}

// SetMAC sets the "mac" field.
func (m *AgentMutation) SetMAC(s string) {
	m.mac = &s
}

// MAC returns the value of the "mac" field in the mutation.
func (m *AgentMutation) MAC() (r string, exists bool) {
	v := m.mac
	if v == nil {
		return
	}
	return *v, true
}

// OldMAC returns the old "mac" field's value of the Agent entity.
// If the Agent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentMutation) OldMAC(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMAC is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMAC requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMAC: %w", err)
	}
	return oldValue.MAC, nil
}

// ResetMAC resets all changes to the "mac" field.
func (m *AgentMutation) ResetMAC() {
	m.mac = nil
}

// SetVersion sets the "version" field.
func (m *AgentMutation) SetVersion(s string) {
	m.version = &s
}

// Version returns the value of the "version" field in the mutation.
func (m *AgentMutation) Version() (r string, exists bool) {
	v := m.version
	if v == nil {
		return
	}
	return *v, true
}

// OldVersion returns the old "version" field's value of the Agent entity.
// If the Agent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentMutation) OldVersion(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVersion: %w", err)
	}
	return oldValue.Version, nil
}

// ResetVersion resets all changes to the "version" field.
func (m *AgentMutation) ResetVersion() {
	m.version = nil
}

// SetStatus sets the "status" field.
func (m *AgentMutation) SetStatus(a agent.Status) {
	m.status = &a
}

// Status returns the value of the "status" field in the mutation.
func (m *AgentMutation) Status() (r agent.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Agent entity.
// If the Agent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentMutation) OldStatus(ctx context.Context) (v agent.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *AgentMutation) ResetStatus() {
	m.status = nil
}

// SetLastSeen sets the "last_seen" field.
func (m *AgentMutation) SetLastSeen(t time.Time) {
	m.last_seen = &t
}

// LastSeen returns the value of the "last_seen" field in the mutation.
func (m *AgentMutation) LastSeen() (r time.Time, exists bool) {
	v := m.last_seen
	if v == nil {
		return
	}
	return *v, true
}

// OldLastSeen returns the old "last_seen" field's value of the Agent entity.
// If the Agent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentMutation) OldLastSeen(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastSeen is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastSeen requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastSeen: %w", err)
	}
	return oldValue.LastSeen, nil
}

// ResetLastSeen resets all changes to the "last_seen" field.
func (m *AgentMutation) ResetLastSeen() {
	m.last_seen = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *AgentMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AgentMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Agent entity.
// If the Agent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AgentMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AgentMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AgentMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Agent entity.
// If the Agent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AgentMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetTenantID sets the "tenant" edge to the Tenant entity by id.
func (m *AgentMutation) SetTenantID(id int) {
	m.tenant = &id
}

// ClearTenant clears the "tenant" edge to the Tenant entity.
func (m *AgentMutation) ClearTenant() {
	m.clearedtenant = true
}

// TenantCleared reports if the "tenant" edge to the Tenant entity was cleared.
func (m *AgentMutation) TenantCleared() bool {
	return m.clearedtenant
}

// TenantID returns the "tenant" edge ID in the mutation.
func (m *AgentMutation) TenantID() (id int, exists bool) {
	if m.tenant != nil {
		return *m.tenant, true
	}
	return
}

// TenantIDs returns the "tenant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TenantID instead. It exists only for internal usage by the builders.
func (m *AgentMutation) TenantIDs() (ids []int) {
	if id := m.tenant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTenant resets all changes to the "tenant" edge.
func (m *AgentMutation) ResetTenant() {
	m.tenant = nil
	m.clearedtenant = false
}

// AddJobExecutionIDs adds the "job_executions" edge to the JobExecution entity by ids.
func (m *AgentMutation) AddJobExecutionIDs(ids ...int) {
	if m.job_executions == nil {
		m.job_executions = make(map[int]struct{})
	}
	for i := range ids {
		m.job_executions[ids[i]] = struct{}{}
	}
}

// ClearJobExecutions clears the "job_executions" edge to the JobExecution entity.
func (m *AgentMutation) ClearJobExecutions() {
	m.clearedjob_executions = true
}

// JobExecutionsCleared reports if the "job_executions" edge to the JobExecution entity was cleared.
func (m *AgentMutation) JobExecutionsCleared() bool {
	return m.clearedjob_executions
}

// RemoveJobExecutionIDs removes the "job_executions" edge to the JobExecution entity by IDs.
func (m *AgentMutation) RemoveJobExecutionIDs(ids ...int) {
	if m.removedjob_executions == nil {
		m.removedjob_executions = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.job_executions, ids[i])
		m.removedjob_executions[ids[i]] = struct{}{}
	}
}

// RemovedJobExecutions returns the removed IDs of the "job_executions" edge to the JobExecution entity.
func (m *AgentMutation) RemovedJobExecutionsIDs() (ids []int) {
	for id := range m.removedjob_executions {
		ids = append(ids, id)
	}
	return
}

// JobExecutionsIDs returns the "job_executions" edge IDs in the mutation.
func (m *AgentMutation) JobExecutionsIDs() (ids []int) {
	for id := range m.job_executions {
		ids = append(ids, id)
	}
	return
}

// ResetJobExecutions resets all changes to the "job_executions" edge.
func (m *AgentMutation) ResetJobExecutions() {
	m.job_executions = nil
	m.clearedjob_executions = false
	m.removedjob_executions = nil
}

// Where appends a list predicates to the AgentMutation builder.
func (m *AgentMutation) Where(ps ...predicate.Agent) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AgentMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AgentMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Agent, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AgentMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AgentMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Agent).
func (m *AgentMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AgentMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.hostname != nil {
		fields = append(fields, agent.FieldHostname)
	}
	if m.os != nil {
		fields = append(fields, agent.FieldOs)
	}
	if m.arch != nil {
		fields = append(fields, agent.FieldArch)
	}
	if m.ip != nil {
		fields = append(fields, agent.FieldIP)
	}
	if m.mac != nil {
		fields = append(fields, agent.FieldMAC)
	}
	if m.version != nil {
		fields = append(fields, agent.FieldVersion)
	}
	if m.status != nil {
		fields = append(fields, agent.FieldStatus)
	}
	if m.last_seen != nil {
		fields = append(fields, agent.FieldLastSeen)
	}
	if m.created_at != nil {
		fields = append(fields, agent.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, agent.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AgentMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case agent.FieldHostname:
		return m.Hostname()
	case agent.FieldOs:
		return m.Os()
	case agent.FieldArch:
		return m.Arch()
	case agent.FieldIP:
		return m.IP()
	case agent.FieldMAC:
		return m.MAC()
	case agent.FieldVersion:
		return m.Version()
	case agent.FieldStatus:
		return m.Status()
	case agent.FieldLastSeen:
		return m.LastSeen()
	case agent.FieldCreatedAt:
		return m.CreatedAt()
	case agent.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AgentMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case agent.FieldHostname:
		return m.OldHostname(ctx)
	case agent.FieldOs:
		return m.OldOs(ctx)
	case agent.FieldArch:
		return m.OldArch(ctx)
	case agent.FieldIP:
		return m.OldIP(ctx)
	case agent.FieldMAC:
		return m.OldMAC(ctx)
	case agent.FieldVersion:
		return m.OldVersion(ctx)
	case agent.FieldStatus:
		return m.OldStatus(ctx)
	case agent.FieldLastSeen:
		return m.OldLastSeen(ctx)
	case agent.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case agent.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Agent field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AgentMutation) SetField(name string, value ent.Value) error {
	switch name {
	case agent.FieldHostname:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHostname(v)
		return nil
	case agent.FieldOs:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOs(v)
		return nil
	case agent.FieldArch:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetArch(v)
		return nil
	case agent.FieldIP:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIP(v)
		return nil
	case agent.FieldMAC:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMAC(v)
		return nil
	case agent.FieldVersion:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVersion(v)
		return nil
	case agent.FieldStatus:
		v, ok := value.(agent.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case agent.FieldLastSeen:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastSeen(v)
		return nil
	case agent.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case agent.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Agent field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AgentMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AgentMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AgentMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Agent numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AgentMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AgentMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AgentMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Agent nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AgentMutation) ResetField(name string) error {
	switch name {
	case agent.FieldHostname:
		m.ResetHostname()
		return nil
	case agent.FieldOs:
		m.ResetOs()
		return nil
	case agent.FieldArch:
		m.ResetArch()
		return nil
	case agent.FieldIP:
		m.ResetIP()
		return nil
	case agent.FieldMAC:
		m.ResetMAC()
		return nil
	case agent.FieldVersion:
		m.ResetVersion()
		return nil
	case agent.FieldStatus:
		m.ResetStatus()
		return nil
	case agent.FieldLastSeen:
		m.ResetLastSeen()
		return nil
	case agent.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case agent.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Agent field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AgentMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.tenant != nil {
		edges = append(edges, agent.EdgeTenant)
	}
	if m.job_executions != nil {
		edges = append(edges, agent.EdgeJobExecutions)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AgentMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case agent.EdgeTenant:
		if id := m.tenant; id != nil {
			return []ent.Value{*id}
		}
	case agent.EdgeJobExecutions:
		ids := make([]ent.Value, 0, len(m.job_executions))
		for id := range m.job_executions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AgentMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedjob_executions != nil {
		edges = append(edges, agent.EdgeJobExecutions)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AgentMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case agent.EdgeJobExecutions:
		ids := make([]ent.Value, 0, len(m.removedjob_executions))
		for id := range m.removedjob_executions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AgentMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedtenant {
		edges = append(edges, agent.EdgeTenant)
	}
	if m.clearedjob_executions {
		edges = append(edges, agent.EdgeJobExecutions)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AgentMutation) EdgeCleared(name string) bool {
	switch name {
	case agent.EdgeTenant:
		return m.clearedtenant
	case agent.EdgeJobExecutions:
		return m.clearedjob_executions
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AgentMutation) ClearEdge(name string) error {
	switch name {
	case agent.EdgeTenant:
		m.ClearTenant()
		return nil
	}
	return fmt.Errorf("unknown Agent unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AgentMutation) ResetEdge(name string) error {
	switch name {
	case agent.EdgeTenant:
		m.ResetTenant()
		return nil
	case agent.EdgeJobExecutions:
		m.ResetJobExecutions()
		return nil
	}
	return fmt.Errorf("unknown Agent edge %s", name)
}

// ApplicationMutation represents an operation that mutates the Application nodes in the graph.
type ApplicationMutation struct {
	config
	op                 Op
	typ                string
	id                 *int
	status             *application.Status
	applied_at         *time.Time
	updated_at         *time.Time
	clearedFields      map[string]struct{}
	tenant             *int
	clearedtenant      bool
	job_posting        *int
	clearedjob_posting bool
	candidate          *int
	clearedcandidate   bool
	interviews         map[int]struct{}
	removedinterviews  map[int]struct{}
	clearedinterviews  bool
	done               bool
	oldValue           func(context.Context) (*Application, error)
	predicates         []predicate.Application
}

var _ ent.Mutation = (*ApplicationMutation)(nil)

// applicationOption allows management of the mutation configuration using functional options.
type applicationOption func(*ApplicationMutation)

// newApplicationMutation creates new mutation for the Application entity.
func newApplicationMutation(c config, op Op, opts ...applicationOption) *ApplicationMutation {
	m := &ApplicationMutation{
		config:        c,
		op:            op,
		typ:           TypeApplication,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withApplicationID sets the ID field of the mutation.
func withApplicationID(id int) applicationOption {
	return func(m *ApplicationMutation) {
		var (
			err   error
			once  sync.Once
			value *Application
		)
		m.oldValue = func(ctx context.Context) (*Application, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Application.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withApplication sets the old Application of the mutation.
func withApplication(node *Application) applicationOption {
	return func(m *ApplicationMutation) {
		m.oldValue = func(context.Context) (*Application, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ApplicationMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ApplicationMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ApplicationMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ApplicationMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Application.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetStatus sets the "status" field.
func (m *ApplicationMutation) SetStatus(a application.Status) {
	m.status = &a
}

// Status returns the value of the "status" field in the mutation.
func (m *ApplicationMutation) Status() (r application.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Application entity.
// If the Application object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApplicationMutation) OldStatus(ctx context.Context) (v application.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *ApplicationMutation) ResetStatus() {
	m.status = nil
}

// SetAppliedAt sets the "applied_at" field.
func (m *ApplicationMutation) SetAppliedAt(t time.Time) {
	m.applied_at = &t
}

// AppliedAt returns the value of the "applied_at" field in the mutation.
func (m *ApplicationMutation) AppliedAt() (r time.Time, exists bool) {
	v := m.applied_at
	if v == nil {
		return
	}
	return *v, true
}

// OldAppliedAt returns the old "applied_at" field's value of the Application entity.
// If the Application object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApplicationMutation) OldAppliedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppliedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppliedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppliedAt: %w", err)
	}
	return oldValue.AppliedAt, nil
}

// ResetAppliedAt resets all changes to the "applied_at" field.
func (m *ApplicationMutation) ResetAppliedAt() {
	m.applied_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ApplicationMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ApplicationMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Application entity.
// If the Application object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApplicationMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ApplicationMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetTenantID sets the "tenant" edge to the Tenant entity by id.
func (m *ApplicationMutation) SetTenantID(id int) {
	m.tenant = &id
}

// ClearTenant clears the "tenant" edge to the Tenant entity.
func (m *ApplicationMutation) ClearTenant() {
	m.clearedtenant = true
}

// TenantCleared reports if the "tenant" edge to the Tenant entity was cleared.
func (m *ApplicationMutation) TenantCleared() bool {
	return m.clearedtenant
}

// TenantID returns the "tenant" edge ID in the mutation.
func (m *ApplicationMutation) TenantID() (id int, exists bool) {
	if m.tenant != nil {
		return *m.tenant, true
	}
	return
}

// TenantIDs returns the "tenant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TenantID instead. It exists only for internal usage by the builders.
func (m *ApplicationMutation) TenantIDs() (ids []int) {
	if id := m.tenant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTenant resets all changes to the "tenant" edge.
func (m *ApplicationMutation) ResetTenant() {
	m.tenant = nil
	m.clearedtenant = false
}

// SetJobPostingID sets the "job_posting" edge to the JobPosting entity by id.
func (m *ApplicationMutation) SetJobPostingID(id int) {
	m.job_posting = &id
}

// ClearJobPosting clears the "job_posting" edge to the JobPosting entity.
func (m *ApplicationMutation) ClearJobPosting() {
	m.clearedjob_posting = true
}

// JobPostingCleared reports if the "job_posting" edge to the JobPosting entity was cleared.
func (m *ApplicationMutation) JobPostingCleared() bool {
	return m.clearedjob_posting
}

// JobPostingID returns the "job_posting" edge ID in the mutation.
func (m *ApplicationMutation) JobPostingID() (id int, exists bool) {
	if m.job_posting != nil {
		return *m.job_posting, true
	}
	return
}

// JobPostingIDs returns the "job_posting" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// JobPostingID instead. It exists only for internal usage by the builders.
func (m *ApplicationMutation) JobPostingIDs() (ids []int) {
	if id := m.job_posting; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetJobPosting resets all changes to the "job_posting" edge.
func (m *ApplicationMutation) ResetJobPosting() {
	m.job_posting = nil
	m.clearedjob_posting = false
}

// SetCandidateID sets the "candidate" edge to the Candidate entity by id.
func (m *ApplicationMutation) SetCandidateID(id int) {
	m.candidate = &id
}

// ClearCandidate clears the "candidate" edge to the Candidate entity.
func (m *ApplicationMutation) ClearCandidate() {
	m.clearedcandidate = true
}

// CandidateCleared reports if the "candidate" edge to the Candidate entity was cleared.
func (m *ApplicationMutation) CandidateCleared() bool {
	return m.clearedcandidate
}

// CandidateID returns the "candidate" edge ID in the mutation.
func (m *ApplicationMutation) CandidateID() (id int, exists bool) {
	if m.candidate != nil {
		return *m.candidate, true
	}
	return
}

// CandidateIDs returns the "candidate" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CandidateID instead. It exists only for internal usage by the builders.
func (m *ApplicationMutation) CandidateIDs() (ids []int) {
	if id := m.candidate; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCandidate resets all changes to the "candidate" edge.
func (m *ApplicationMutation) ResetCandidate() {
	m.candidate = nil
	m.clearedcandidate = false
}

// AddInterviewIDs adds the "interviews" edge to the Interview entity by ids.
func (m *ApplicationMutation) AddInterviewIDs(ids ...int) {
	if m.interviews == nil {
		m.interviews = make(map[int]struct{})
	}
	for i := range ids {
		m.interviews[ids[i]] = struct{}{}
	}
}

// ClearInterviews clears the "interviews" edge to the Interview entity.
func (m *ApplicationMutation) ClearInterviews() {
	m.clearedinterviews = true
}

// InterviewsCleared reports if the "interviews" edge to the Interview entity was cleared.
func (m *ApplicationMutation) InterviewsCleared() bool {
	return m.clearedinterviews
}

// RemoveInterviewIDs removes the "interviews" edge to the Interview entity by IDs.
func (m *ApplicationMutation) RemoveInterviewIDs(ids ...int) {
	if m.removedinterviews == nil {
		m.removedinterviews = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.interviews, ids[i])
		m.removedinterviews[ids[i]] = struct{}{}
	}
}

// RemovedInterviews returns the removed IDs of the "interviews" edge to the Interview entity.
func (m *ApplicationMutation) RemovedInterviewsIDs() (ids []int) {
	for id := range m.removedinterviews {
		ids = append(ids, id)
	}
	return
}

// InterviewsIDs returns the "interviews" edge IDs in the mutation.
func (m *ApplicationMutation) InterviewsIDs() (ids []int) {
	for id := range m.interviews {
		ids = append(ids, id)
	}
	return
}

// ResetInterviews resets all changes to the "interviews" edge.
func (m *ApplicationMutation) ResetInterviews() {
	m.interviews = nil
	m.clearedinterviews = false
	m.removedinterviews = nil
}

// Where appends a list predicates to the ApplicationMutation builder.
func (m *ApplicationMutation) Where(ps ...predicate.Application) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ApplicationMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ApplicationMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Application, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ApplicationMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ApplicationMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Application).
func (m *ApplicationMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ApplicationMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.status != nil {
		fields = append(fields, application.FieldStatus)
	}
	if m.applied_at != nil {
		fields = append(fields, application.FieldAppliedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, application.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ApplicationMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case application.FieldStatus:
		return m.Status()
	case application.FieldAppliedAt:
		return m.AppliedAt()
	case application.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ApplicationMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case application.FieldStatus:
		return m.OldStatus(ctx)
	case application.FieldAppliedAt:
		return m.OldAppliedAt(ctx)
	case application.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Application field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ApplicationMutation) SetField(name string, value ent.Value) error {
	switch name {
	case application.FieldStatus:
		v, ok := value.(application.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case application.FieldAppliedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppliedAt(v)
		return nil
	case application.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Application field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ApplicationMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ApplicationMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ApplicationMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Application numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ApplicationMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ApplicationMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ApplicationMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Application nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ApplicationMutation) ResetField(name string) error {
	switch name {
	case application.FieldStatus:
		m.ResetStatus()
		return nil
	case application.FieldAppliedAt:
		m.ResetAppliedAt()
		return nil
	case application.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Application field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ApplicationMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.tenant != nil {
		edges = append(edges, application.EdgeTenant)
	}
	if m.job_posting != nil {
		edges = append(edges, application.EdgeJobPosting)
	}
	if m.candidate != nil {
		edges = append(edges, application.EdgeCandidate)
	}
	if m.interviews != nil {
		edges = append(edges, application.EdgeInterviews)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ApplicationMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case application.EdgeTenant:
		if id := m.tenant; id != nil {
			return []ent.Value{*id}
		}
	case application.EdgeJobPosting:
		if id := m.job_posting; id != nil {
			return []ent.Value{*id}
		}
	case application.EdgeCandidate:
		if id := m.candidate; id != nil {
			return []ent.Value{*id}
		}
	case application.EdgeInterviews:
		ids := make([]ent.Value, 0, len(m.interviews))
		for id := range m.interviews {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ApplicationMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedinterviews != nil {
		edges = append(edges, application.EdgeInterviews)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ApplicationMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case application.EdgeInterviews:
		ids := make([]ent.Value, 0, len(m.removedinterviews))
		for id := range m.removedinterviews {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ApplicationMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedtenant {
		edges = append(edges, application.EdgeTenant)
	}
	if m.clearedjob_posting {
		edges = append(edges, application.EdgeJobPosting)
	}
	if m.clearedcandidate {
		edges = append(edges, application.EdgeCandidate)
	}
	if m.clearedinterviews {
		edges = append(edges, application.EdgeInterviews)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ApplicationMutation) EdgeCleared(name string) bool {
	switch name {
	case application.EdgeTenant:
		return m.clearedtenant
	case application.EdgeJobPosting:
		return m.clearedjob_posting
	case application.EdgeCandidate:
		return m.clearedcandidate
	case application.EdgeInterviews:
		return m.clearedinterviews
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ApplicationMutation) ClearEdge(name string) error {
	switch name {
	case application.EdgeTenant:
		m.ClearTenant()
		return nil
	case application.EdgeJobPosting:
		m.ClearJobPosting()
		return nil
	case application.EdgeCandidate:
		m.ClearCandidate()
		return nil
	}
	return fmt.Errorf("unknown Application unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ApplicationMutation) ResetEdge(name string) error {
	switch name {
	case application.EdgeTenant:
		m.ResetTenant()
		return nil
	case application.EdgeJobPosting:
		m.ResetJobPosting()
		return nil
	case application.EdgeCandidate:
		m.ResetCandidate()
		return nil
	case application.EdgeInterviews:
		m.ResetInterviews()
		return nil
	}
	return fmt.Errorf("unknown Application edge %s", name)
}

// AssetMutation represents an operation that mutates the Asset nodes in the graph.
type AssetMutation struct {
	config
	op                   Op
	typ                  string
	id                   *int
	name                 *string
	hardware_id          *string
	serial_number        *string
	manufacturer         *string
	vendor_support_phone *string
	status               *asset.Status
	metadata             *map[string]interface{}
	last_certified_at    *time.Time
	purchase_date        *time.Time
	warranty_expiry      *time.Time
	created_at           *time.Time
	updated_at           *time.Time
	clearedFields        map[string]struct{}
	tenant               *int
	clearedtenant        bool
	_type                *int
	cleared_type         bool
	hosted_at            *int
	clearedhosted_at     bool
	hosted_assets        map[int]struct{}
	removedhosted_assets map[int]struct{}
	clearedhosted_assets bool
	dependency_of        map[int]struct{}
	removeddependency_of map[int]struct{}
	cleareddependency_of bool
	depends_on           map[int]struct{}
	removeddepends_on    map[int]struct{}
	cleareddepends_on    bool
	owner                *int
	clearedowner         bool
	credentials          map[int]struct{}
	removedcredentials   map[int]struct{}
	clearedcredentials   bool
	sops                 map[int]struct{}
	removedsops          map[int]struct{}
	clearedsops          bool
	tickets              map[int]struct{}
	removedtickets       map[int]struct{}
	clearedtickets       bool
	product              *int
	clearedproduct       bool
	done                 bool
	oldValue             func(context.Context) (*Asset, error)
	predicates           []predicate.Asset
}

var _ ent.Mutation = (*AssetMutation)(nil)

// assetOption allows management of the mutation configuration using functional options.
type assetOption func(*AssetMutation)

// newAssetMutation creates new mutation for the Asset entity.
func newAssetMutation(c config, op Op, opts ...assetOption) *AssetMutation {
	m := &AssetMutation{
		config:        c,
		op:            op,
		typ:           TypeAsset,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAssetID sets the ID field of the mutation.
func withAssetID(id int) assetOption {
	return func(m *AssetMutation) {
		var (
			err   error
			once  sync.Once
			value *Asset
		)
		m.oldValue = func(ctx context.Context) (*Asset, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Asset.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAsset sets the old Asset of the mutation.
func withAsset(node *Asset) assetOption {
	return func(m *AssetMutation) {
		m.oldValue = func(context.Context) (*Asset, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AssetMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AssetMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AssetMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AssetMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Asset.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *AssetMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *AssetMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Asset entity.
// If the Asset object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AssetMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *AssetMutation) ResetName() {
	m.name = nil
}

// SetHardwareID sets the "hardware_id" field.
func (m *AssetMutation) SetHardwareID(s string) {
	m.hardware_id = &s
}

// HardwareID returns the value of the "hardware_id" field in the mutation.
func (m *AssetMutation) HardwareID() (r string, exists bool) {
	v := m.hardware_id
	if v == nil {
		return
	}
	return *v, true
}

// OldHardwareID returns the old "hardware_id" field's value of the Asset entity.
// If the Asset object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AssetMutation) OldHardwareID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHardwareID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHardwareID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHardwareID: %w", err)
	}
	return oldValue.HardwareID, nil
}

// ClearHardwareID clears the value of the "hardware_id" field.
func (m *AssetMutation) ClearHardwareID() {
	m.hardware_id = nil
	m.clearedFields[asset.FieldHardwareID] = struct{}{}
}

// HardwareIDCleared returns if the "hardware_id" field was cleared in this mutation.
func (m *AssetMutation) HardwareIDCleared() bool {
	_, ok := m.clearedFields[asset.FieldHardwareID]
	return ok
}

// ResetHardwareID resets all changes to the "hardware_id" field.
func (m *AssetMutation) ResetHardwareID() {
	m.hardware_id = nil
	delete(m.clearedFields, asset.FieldHardwareID)
}

// SetSerialNumber sets the "serial_number" field.
func (m *AssetMutation) SetSerialNumber(s string) {
	m.serial_number = &s
}

// SerialNumber returns the value of the "serial_number" field in the mutation.
func (m *AssetMutation) SerialNumber() (r string, exists bool) {
	v := m.serial_number
	if v == nil {
		return
	}
	return *v, true
}

// OldSerialNumber returns the old "serial_number" field's value of the Asset entity.
// If the Asset object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AssetMutation) OldSerialNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSerialNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSerialNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSerialNumber: %w", err)
	}
	return oldValue.SerialNumber, nil
}

// ClearSerialNumber clears the value of the "serial_number" field.
func (m *AssetMutation) ClearSerialNumber() {
	m.serial_number = nil
	m.clearedFields[asset.FieldSerialNumber] = struct{}{}
}

// SerialNumberCleared returns if the "serial_number" field was cleared in this mutation.
func (m *AssetMutation) SerialNumberCleared() bool {
	_, ok := m.clearedFields[asset.FieldSerialNumber]
	return ok
}

// ResetSerialNumber resets all changes to the "serial_number" field.
func (m *AssetMutation) ResetSerialNumber() {
	m.serial_number = nil
	delete(m.clearedFields, asset.FieldSerialNumber)
}

// SetManufacturer sets the "manufacturer" field.
func (m *AssetMutation) SetManufacturer(s string) {
	m.manufacturer = &s
}

// Manufacturer returns the value of the "manufacturer" field in the mutation.
func (m *AssetMutation) Manufacturer() (r string, exists bool) {
	v := m.manufacturer
	if v == nil {
		return
	}
	return *v, true
}

// OldManufacturer returns the old "manufacturer" field's value of the Asset entity.
// If the Asset object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AssetMutation) OldManufacturer(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldManufacturer is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldManufacturer requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldManufacturer: %w", err)
	}
	return oldValue.Manufacturer, nil
}

// ClearManufacturer clears the value of the "manufacturer" field.
func (m *AssetMutation) ClearManufacturer() {
	m.manufacturer = nil
	m.clearedFields[asset.FieldManufacturer] = struct{}{}
}

// ManufacturerCleared returns if the "manufacturer" field was cleared in this mutation.
func (m *AssetMutation) ManufacturerCleared() bool {
	_, ok := m.clearedFields[asset.FieldManufacturer]
	return ok
}

// ResetManufacturer resets all changes to the "manufacturer" field.
func (m *AssetMutation) ResetManufacturer() {
	m.manufacturer = nil
	delete(m.clearedFields, asset.FieldManufacturer)
}

// SetVendorSupportPhone sets the "vendor_support_phone" field.
func (m *AssetMutation) SetVendorSupportPhone(s string) {
	m.vendor_support_phone = &s
}

// VendorSupportPhone returns the value of the "vendor_support_phone" field in the mutation.
func (m *AssetMutation) VendorSupportPhone() (r string, exists bool) {
	v := m.vendor_support_phone
	if v == nil {
		return
	}
	return *v, true
}

// OldVendorSupportPhone returns the old "vendor_support_phone" field's value of the Asset entity.
// If the Asset object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AssetMutation) OldVendorSupportPhone(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVendorSupportPhone is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVendorSupportPhone requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVendorSupportPhone: %w", err)
	}
	return oldValue.VendorSupportPhone, nil
}

// ClearVendorSupportPhone clears the value of the "vendor_support_phone" field.
func (m *AssetMutation) ClearVendorSupportPhone() {
	m.vendor_support_phone = nil
	m.clearedFields[asset.FieldVendorSupportPhone] = struct{}{}
}

// VendorSupportPhoneCleared returns if the "vendor_support_phone" field was cleared in this mutation.
func (m *AssetMutation) VendorSupportPhoneCleared() bool {
	_, ok := m.clearedFields[asset.FieldVendorSupportPhone]
	return ok
}

// ResetVendorSupportPhone resets all changes to the "vendor_support_phone" field.
func (m *AssetMutation) ResetVendorSupportPhone() {
	m.vendor_support_phone = nil
	delete(m.clearedFields, asset.FieldVendorSupportPhone)
}

// SetStatus sets the "status" field.
func (m *AssetMutation) SetStatus(a asset.Status) {
	m.status = &a
}

// Status returns the value of the "status" field in the mutation.
func (m *AssetMutation) Status() (r asset.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Asset entity.
// If the Asset object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AssetMutation) OldStatus(ctx context.Context) (v asset.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *AssetMutation) ResetStatus() {
	m.status = nil
}

// SetMetadata sets the "metadata" field.
func (m *AssetMutation) SetMetadata(value map[string]interface{}) {
	m.metadata = &value
}

// Metadata returns the value of the "metadata" field in the mutation.
func (m *AssetMutation) Metadata() (r map[string]interface{}, exists bool) {
	v := m.metadata
	if v == nil {
		return
	}
	return *v, true
}

// OldMetadata returns the old "metadata" field's value of the Asset entity.
// If the Asset object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AssetMutation) OldMetadata(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMetadata is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMetadata requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetadata: %w", err)
	}
	return oldValue.Metadata, nil
}

// ClearMetadata clears the value of the "metadata" field.
func (m *AssetMutation) ClearMetadata() {
	m.metadata = nil
	m.clearedFields[asset.FieldMetadata] = struct{}{}
}

// MetadataCleared returns if the "metadata" field was cleared in this mutation.
func (m *AssetMutation) MetadataCleared() bool {
	_, ok := m.clearedFields[asset.FieldMetadata]
	return ok
}

// ResetMetadata resets all changes to the "metadata" field.
func (m *AssetMutation) ResetMetadata() {
	m.metadata = nil
	delete(m.clearedFields, asset.FieldMetadata)
}

// SetLastCertifiedAt sets the "last_certified_at" field.
func (m *AssetMutation) SetLastCertifiedAt(t time.Time) {
	m.last_certified_at = &t
}

// LastCertifiedAt returns the value of the "last_certified_at" field in the mutation.
func (m *AssetMutation) LastCertifiedAt() (r time.Time, exists bool) {
	v := m.last_certified_at
	if v == nil {
		return
	}
	return *v, true
}

// OldLastCertifiedAt returns the old "last_certified_at" field's value of the Asset entity.
// If the Asset object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AssetMutation) OldLastCertifiedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastCertifiedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastCertifiedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastCertifiedAt: %w", err)
	}
	return oldValue.LastCertifiedAt, nil
}

// ClearLastCertifiedAt clears the value of the "last_certified_at" field.
func (m *AssetMutation) ClearLastCertifiedAt() {
	m.last_certified_at = nil
	m.clearedFields[asset.FieldLastCertifiedAt] = struct{}{}
}

// LastCertifiedAtCleared returns if the "last_certified_at" field was cleared in this mutation.
func (m *AssetMutation) LastCertifiedAtCleared() bool {
	_, ok := m.clearedFields[asset.FieldLastCertifiedAt]
	return ok
}

// ResetLastCertifiedAt resets all changes to the "last_certified_at" field.
func (m *AssetMutation) ResetLastCertifiedAt() {
	m.last_certified_at = nil
	delete(m.clearedFields, asset.FieldLastCertifiedAt)
}

// SetPurchaseDate sets the "purchase_date" field.
func (m *AssetMutation) SetPurchaseDate(t time.Time) {
	m.purchase_date = &t
}

// PurchaseDate returns the value of the "purchase_date" field in the mutation.
func (m *AssetMutation) PurchaseDate() (r time.Time, exists bool) {
	v := m.purchase_date
	if v == nil {
		return
	}
	return *v, true
}

// OldPurchaseDate returns the old "purchase_date" field's value of the Asset entity.
// If the Asset object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AssetMutation) OldPurchaseDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPurchaseDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPurchaseDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPurchaseDate: %w", err)
	}
	return oldValue.PurchaseDate, nil
}

// ClearPurchaseDate clears the value of the "purchase_date" field.
func (m *AssetMutation) ClearPurchaseDate() {
	m.purchase_date = nil
	m.clearedFields[asset.FieldPurchaseDate] = struct{}{}
}

// PurchaseDateCleared returns if the "purchase_date" field was cleared in this mutation.
func (m *AssetMutation) PurchaseDateCleared() bool {
	_, ok := m.clearedFields[asset.FieldPurchaseDate]
	return ok
}

// ResetPurchaseDate resets all changes to the "purchase_date" field.
func (m *AssetMutation) ResetPurchaseDate() {
	m.purchase_date = nil
	delete(m.clearedFields, asset.FieldPurchaseDate)
}

// SetWarrantyExpiry sets the "warranty_expiry" field.
func (m *AssetMutation) SetWarrantyExpiry(t time.Time) {
	m.warranty_expiry = &t
}

// WarrantyExpiry returns the value of the "warranty_expiry" field in the mutation.
func (m *AssetMutation) WarrantyExpiry() (r time.Time, exists bool) {
	v := m.warranty_expiry
	if v == nil {
		return
	}
	return *v, true
}

// OldWarrantyExpiry returns the old "warranty_expiry" field's value of the Asset entity.
// If the Asset object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AssetMutation) OldWarrantyExpiry(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWarrantyExpiry is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWarrantyExpiry requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWarrantyExpiry: %w", err)
	}
	return oldValue.WarrantyExpiry, nil
}

// ClearWarrantyExpiry clears the value of the "warranty_expiry" field.
func (m *AssetMutation) ClearWarrantyExpiry() {
	m.warranty_expiry = nil
	m.clearedFields[asset.FieldWarrantyExpiry] = struct{}{}
}

// WarrantyExpiryCleared returns if the "warranty_expiry" field was cleared in this mutation.
func (m *AssetMutation) WarrantyExpiryCleared() bool {
	_, ok := m.clearedFields[asset.FieldWarrantyExpiry]
	return ok
}

// ResetWarrantyExpiry resets all changes to the "warranty_expiry" field.
func (m *AssetMutation) ResetWarrantyExpiry() {
	m.warranty_expiry = nil
	delete(m.clearedFields, asset.FieldWarrantyExpiry)
}

// SetCreatedAt sets the "created_at" field.
func (m *AssetMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AssetMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Asset entity.
// If the Asset object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AssetMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AssetMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AssetMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AssetMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Asset entity.
// If the Asset object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AssetMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AssetMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetTenantID sets the "tenant" edge to the Tenant entity by id.
func (m *AssetMutation) SetTenantID(id int) {
	m.tenant = &id
}

// ClearTenant clears the "tenant" edge to the Tenant entity.
func (m *AssetMutation) ClearTenant() {
	m.clearedtenant = true
}

// TenantCleared reports if the "tenant" edge to the Tenant entity was cleared.
func (m *AssetMutation) TenantCleared() bool {
	return m.clearedtenant
}

// TenantID returns the "tenant" edge ID in the mutation.
func (m *AssetMutation) TenantID() (id int, exists bool) {
	if m.tenant != nil {
		return *m.tenant, true
	}
	return
}

// TenantIDs returns the "tenant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TenantID instead. It exists only for internal usage by the builders.
func (m *AssetMutation) TenantIDs() (ids []int) {
	if id := m.tenant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTenant resets all changes to the "tenant" edge.
func (m *AssetMutation) ResetTenant() {
	m.tenant = nil
	m.clearedtenant = false
}

// SetTypeID sets the "type" edge to the AssetType entity by id.
func (m *AssetMutation) SetTypeID(id int) {
	m._type = &id
}

// ClearType clears the "type" edge to the AssetType entity.
func (m *AssetMutation) ClearType() {
	m.cleared_type = true
}

// TypeCleared reports if the "type" edge to the AssetType entity was cleared.
func (m *AssetMutation) TypeCleared() bool {
	return m.cleared_type
}

// TypeID returns the "type" edge ID in the mutation.
func (m *AssetMutation) TypeID() (id int, exists bool) {
	if m._type != nil {
		return *m._type, true
	}
	return
}

// TypeIDs returns the "type" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TypeID instead. It exists only for internal usage by the builders.
func (m *AssetMutation) TypeIDs() (ids []int) {
	if id := m._type; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetType resets all changes to the "type" edge.
func (m *AssetMutation) ResetType() {
	m._type = nil
	m.cleared_type = false
}

// SetHostedAtID sets the "hosted_at" edge to the Asset entity by id.
func (m *AssetMutation) SetHostedAtID(id int) {
	m.hosted_at = &id
}

// ClearHostedAt clears the "hosted_at" edge to the Asset entity.
func (m *AssetMutation) ClearHostedAt() {
	m.clearedhosted_at = true
}

// HostedAtCleared reports if the "hosted_at" edge to the Asset entity was cleared.
func (m *AssetMutation) HostedAtCleared() bool {
	return m.clearedhosted_at
}

// HostedAtID returns the "hosted_at" edge ID in the mutation.
func (m *AssetMutation) HostedAtID() (id int, exists bool) {
	if m.hosted_at != nil {
		return *m.hosted_at, true
	}
	return
}

// HostedAtIDs returns the "hosted_at" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// HostedAtID instead. It exists only for internal usage by the builders.
func (m *AssetMutation) HostedAtIDs() (ids []int) {
	if id := m.hosted_at; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetHostedAt resets all changes to the "hosted_at" edge.
func (m *AssetMutation) ResetHostedAt() {
	m.hosted_at = nil
	m.clearedhosted_at = false
}

// AddHostedAssetIDs adds the "hosted_assets" edge to the Asset entity by ids.
func (m *AssetMutation) AddHostedAssetIDs(ids ...int) {
	if m.hosted_assets == nil {
		m.hosted_assets = make(map[int]struct{})
	}
	for i := range ids {
		m.hosted_assets[ids[i]] = struct{}{}
	}
}

// ClearHostedAssets clears the "hosted_assets" edge to the Asset entity.
func (m *AssetMutation) ClearHostedAssets() {
	m.clearedhosted_assets = true
}

// HostedAssetsCleared reports if the "hosted_assets" edge to the Asset entity was cleared.
func (m *AssetMutation) HostedAssetsCleared() bool {
	return m.clearedhosted_assets
}

// RemoveHostedAssetIDs removes the "hosted_assets" edge to the Asset entity by IDs.
func (m *AssetMutation) RemoveHostedAssetIDs(ids ...int) {
	if m.removedhosted_assets == nil {
		m.removedhosted_assets = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.hosted_assets, ids[i])
		m.removedhosted_assets[ids[i]] = struct{}{}
	}
}

// RemovedHostedAssets returns the removed IDs of the "hosted_assets" edge to the Asset entity.
func (m *AssetMutation) RemovedHostedAssetsIDs() (ids []int) {
	for id := range m.removedhosted_assets {
		ids = append(ids, id)
	}
	return
}

// HostedAssetsIDs returns the "hosted_assets" edge IDs in the mutation.
func (m *AssetMutation) HostedAssetsIDs() (ids []int) {
	for id := range m.hosted_assets {
		ids = append(ids, id)
	}
	return
}

// ResetHostedAssets resets all changes to the "hosted_assets" edge.
func (m *AssetMutation) ResetHostedAssets() {
	m.hosted_assets = nil
	m.clearedhosted_assets = false
	m.removedhosted_assets = nil
}

// AddDependencyOfIDs adds the "dependency_of" edge to the Asset entity by ids.
func (m *AssetMutation) AddDependencyOfIDs(ids ...int) {
	if m.dependency_of == nil {
		m.dependency_of = make(map[int]struct{})
	}
	for i := range ids {
		m.dependency_of[ids[i]] = struct{}{}
	}
}

// ClearDependencyOf clears the "dependency_of" edge to the Asset entity.
func (m *AssetMutation) ClearDependencyOf() {
	m.cleareddependency_of = true
}

// DependencyOfCleared reports if the "dependency_of" edge to the Asset entity was cleared.
func (m *AssetMutation) DependencyOfCleared() bool {
	return m.cleareddependency_of
}

// RemoveDependencyOfIDs removes the "dependency_of" edge to the Asset entity by IDs.
func (m *AssetMutation) RemoveDependencyOfIDs(ids ...int) {
	if m.removeddependency_of == nil {
		m.removeddependency_of = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.dependency_of, ids[i])
		m.removeddependency_of[ids[i]] = struct{}{}
	}
}

// RemovedDependencyOf returns the removed IDs of the "dependency_of" edge to the Asset entity.
func (m *AssetMutation) RemovedDependencyOfIDs() (ids []int) {
	for id := range m.removeddependency_of {
		ids = append(ids, id)
	}
	return
}

// DependencyOfIDs returns the "dependency_of" edge IDs in the mutation.
func (m *AssetMutation) DependencyOfIDs() (ids []int) {
	for id := range m.dependency_of {
		ids = append(ids, id)
	}
	return
}

// ResetDependencyOf resets all changes to the "dependency_of" edge.
func (m *AssetMutation) ResetDependencyOf() {
	m.dependency_of = nil
	m.cleareddependency_of = false
	m.removeddependency_of = nil
}

// AddDependsOnIDs adds the "depends_on" edge to the Asset entity by ids.
func (m *AssetMutation) AddDependsOnIDs(ids ...int) {
	if m.depends_on == nil {
		m.depends_on = make(map[int]struct{})
	}
	for i := range ids {
		m.depends_on[ids[i]] = struct{}{}
	}
}

// ClearDependsOn clears the "depends_on" edge to the Asset entity.
func (m *AssetMutation) ClearDependsOn() {
	m.cleareddepends_on = true
}

// DependsOnCleared reports if the "depends_on" edge to the Asset entity was cleared.
func (m *AssetMutation) DependsOnCleared() bool {
	return m.cleareddepends_on
}

// RemoveDependsOnIDs removes the "depends_on" edge to the Asset entity by IDs.
func (m *AssetMutation) RemoveDependsOnIDs(ids ...int) {
	if m.removeddepends_on == nil {
		m.removeddepends_on = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.depends_on, ids[i])
		m.removeddepends_on[ids[i]] = struct{}{}
	}
}

// RemovedDependsOn returns the removed IDs of the "depends_on" edge to the Asset entity.
func (m *AssetMutation) RemovedDependsOnIDs() (ids []int) {
	for id := range m.removeddepends_on {
		ids = append(ids, id)
	}
	return
}

// DependsOnIDs returns the "depends_on" edge IDs in the mutation.
func (m *AssetMutation) DependsOnIDs() (ids []int) {
	for id := range m.depends_on {
		ids = append(ids, id)
	}
	return
}

// ResetDependsOn resets all changes to the "depends_on" edge.
func (m *AssetMutation) ResetDependsOn() {
	m.depends_on = nil
	m.cleareddepends_on = false
	m.removeddepends_on = nil
}

// SetOwnerID sets the "owner" edge to the User entity by id.
func (m *AssetMutation) SetOwnerID(id int) {
	m.owner = &id
}

// ClearOwner clears the "owner" edge to the User entity.
func (m *AssetMutation) ClearOwner() {
	m.clearedowner = true
}

// OwnerCleared reports if the "owner" edge to the User entity was cleared.
func (m *AssetMutation) OwnerCleared() bool {
	return m.clearedowner
}

// OwnerID returns the "owner" edge ID in the mutation.
func (m *AssetMutation) OwnerID() (id int, exists bool) {
	if m.owner != nil {
		return *m.owner, true
	}
	return
}

// OwnerIDs returns the "owner" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OwnerID instead. It exists only for internal usage by the builders.
func (m *AssetMutation) OwnerIDs() (ids []int) {
	if id := m.owner; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOwner resets all changes to the "owner" edge.
func (m *AssetMutation) ResetOwner() {
	m.owner = nil
	m.clearedowner = false
}

// AddCredentialIDs adds the "credentials" edge to the Credential entity by ids.
func (m *AssetMutation) AddCredentialIDs(ids ...int) {
	if m.credentials == nil {
		m.credentials = make(map[int]struct{})
	}
	for i := range ids {
		m.credentials[ids[i]] = struct{}{}
	}
}

// ClearCredentials clears the "credentials" edge to the Credential entity.
func (m *AssetMutation) ClearCredentials() {
	m.clearedcredentials = true
}

// CredentialsCleared reports if the "credentials" edge to the Credential entity was cleared.
func (m *AssetMutation) CredentialsCleared() bool {
	return m.clearedcredentials
}

// RemoveCredentialIDs removes the "credentials" edge to the Credential entity by IDs.
func (m *AssetMutation) RemoveCredentialIDs(ids ...int) {
	if m.removedcredentials == nil {
		m.removedcredentials = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.credentials, ids[i])
		m.removedcredentials[ids[i]] = struct{}{}
	}
}

// RemovedCredentials returns the removed IDs of the "credentials" edge to the Credential entity.
func (m *AssetMutation) RemovedCredentialsIDs() (ids []int) {
	for id := range m.removedcredentials {
		ids = append(ids, id)
	}
	return
}

// CredentialsIDs returns the "credentials" edge IDs in the mutation.
func (m *AssetMutation) CredentialsIDs() (ids []int) {
	for id := range m.credentials {
		ids = append(ids, id)
	}
	return
}

// ResetCredentials resets all changes to the "credentials" edge.
func (m *AssetMutation) ResetCredentials() {
	m.credentials = nil
	m.clearedcredentials = false
	m.removedcredentials = nil
}

// AddSopIDs adds the "sops" edge to the SOP entity by ids.
func (m *AssetMutation) AddSopIDs(ids ...int) {
	if m.sops == nil {
		m.sops = make(map[int]struct{})
	}
	for i := range ids {
		m.sops[ids[i]] = struct{}{}
	}
}

// ClearSops clears the "sops" edge to the SOP entity.
func (m *AssetMutation) ClearSops() {
	m.clearedsops = true
}

// SopsCleared reports if the "sops" edge to the SOP entity was cleared.
func (m *AssetMutation) SopsCleared() bool {
	return m.clearedsops
}

// RemoveSopIDs removes the "sops" edge to the SOP entity by IDs.
func (m *AssetMutation) RemoveSopIDs(ids ...int) {
	if m.removedsops == nil {
		m.removedsops = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.sops, ids[i])
		m.removedsops[ids[i]] = struct{}{}
	}
}

// RemovedSops returns the removed IDs of the "sops" edge to the SOP entity.
func (m *AssetMutation) RemovedSopsIDs() (ids []int) {
	for id := range m.removedsops {
		ids = append(ids, id)
	}
	return
}

// SopsIDs returns the "sops" edge IDs in the mutation.
func (m *AssetMutation) SopsIDs() (ids []int) {
	for id := range m.sops {
		ids = append(ids, id)
	}
	return
}

// ResetSops resets all changes to the "sops" edge.
func (m *AssetMutation) ResetSops() {
	m.sops = nil
	m.clearedsops = false
	m.removedsops = nil
}

// AddTicketIDs adds the "tickets" edge to the Ticket entity by ids.
func (m *AssetMutation) AddTicketIDs(ids ...int) {
	if m.tickets == nil {
		m.tickets = make(map[int]struct{})
	}
	for i := range ids {
		m.tickets[ids[i]] = struct{}{}
	}
}

// ClearTickets clears the "tickets" edge to the Ticket entity.
func (m *AssetMutation) ClearTickets() {
	m.clearedtickets = true
}

// TicketsCleared reports if the "tickets" edge to the Ticket entity was cleared.
func (m *AssetMutation) TicketsCleared() bool {
	return m.clearedtickets
}

// RemoveTicketIDs removes the "tickets" edge to the Ticket entity by IDs.
func (m *AssetMutation) RemoveTicketIDs(ids ...int) {
	if m.removedtickets == nil {
		m.removedtickets = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.tickets, ids[i])
		m.removedtickets[ids[i]] = struct{}{}
	}
}

// RemovedTickets returns the removed IDs of the "tickets" edge to the Ticket entity.
func (m *AssetMutation) RemovedTicketsIDs() (ids []int) {
	for id := range m.removedtickets {
		ids = append(ids, id)
	}
	return
}

// TicketsIDs returns the "tickets" edge IDs in the mutation.
func (m *AssetMutation) TicketsIDs() (ids []int) {
	for id := range m.tickets {
		ids = append(ids, id)
	}
	return
}

// ResetTickets resets all changes to the "tickets" edge.
func (m *AssetMutation) ResetTickets() {
	m.tickets = nil
	m.clearedtickets = false
	m.removedtickets = nil
}

// SetProductID sets the "product" edge to the Product entity by id.
func (m *AssetMutation) SetProductID(id int) {
	m.product = &id
}

// ClearProduct clears the "product" edge to the Product entity.
func (m *AssetMutation) ClearProduct() {
	m.clearedproduct = true
}

// ProductCleared reports if the "product" edge to the Product entity was cleared.
func (m *AssetMutation) ProductCleared() bool {
	return m.clearedproduct
}

// ProductID returns the "product" edge ID in the mutation.
func (m *AssetMutation) ProductID() (id int, exists bool) {
	if m.product != nil {
		return *m.product, true
	}
	return
}

// ProductIDs returns the "product" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProductID instead. It exists only for internal usage by the builders.
func (m *AssetMutation) ProductIDs() (ids []int) {
	if id := m.product; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProduct resets all changes to the "product" edge.
func (m *AssetMutation) ResetProduct() {
	m.product = nil
	m.clearedproduct = false
}

// Where appends a list predicates to the AssetMutation builder.
func (m *AssetMutation) Where(ps ...predicate.Asset) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AssetMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AssetMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Asset, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AssetMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AssetMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Asset).
func (m *AssetMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AssetMutation) Fields() []string {
	fields := make([]string, 0, 12)
	if m.name != nil {
		fields = append(fields, asset.FieldName)
	}
	if m.hardware_id != nil {
		fields = append(fields, asset.FieldHardwareID)
	}
	if m.serial_number != nil {
		fields = append(fields, asset.FieldSerialNumber)
	}
	if m.manufacturer != nil {
		fields = append(fields, asset.FieldManufacturer)
	}
	if m.vendor_support_phone != nil {
		fields = append(fields, asset.FieldVendorSupportPhone)
	}
	if m.status != nil {
		fields = append(fields, asset.FieldStatus)
	}
	if m.metadata != nil {
		fields = append(fields, asset.FieldMetadata)
	}
	if m.last_certified_at != nil {
		fields = append(fields, asset.FieldLastCertifiedAt)
	}
	if m.purchase_date != nil {
		fields = append(fields, asset.FieldPurchaseDate)
	}
	if m.warranty_expiry != nil {
		fields = append(fields, asset.FieldWarrantyExpiry)
	}
	if m.created_at != nil {
		fields = append(fields, asset.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, asset.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AssetMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case asset.FieldName:
		return m.Name()
	case asset.FieldHardwareID:
		return m.HardwareID()
	case asset.FieldSerialNumber:
		return m.SerialNumber()
	case asset.FieldManufacturer:
		return m.Manufacturer()
	case asset.FieldVendorSupportPhone:
		return m.VendorSupportPhone()
	case asset.FieldStatus:
		return m.Status()
	case asset.FieldMetadata:
		return m.Metadata()
	case asset.FieldLastCertifiedAt:
		return m.LastCertifiedAt()
	case asset.FieldPurchaseDate:
		return m.PurchaseDate()
	case asset.FieldWarrantyExpiry:
		return m.WarrantyExpiry()
	case asset.FieldCreatedAt:
		return m.CreatedAt()
	case asset.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AssetMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case asset.FieldName:
		return m.OldName(ctx)
	case asset.FieldHardwareID:
		return m.OldHardwareID(ctx)
	case asset.FieldSerialNumber:
		return m.OldSerialNumber(ctx)
	case asset.FieldManufacturer:
		return m.OldManufacturer(ctx)
	case asset.FieldVendorSupportPhone:
		return m.OldVendorSupportPhone(ctx)
	case asset.FieldStatus:
		return m.OldStatus(ctx)
	case asset.FieldMetadata:
		return m.OldMetadata(ctx)
	case asset.FieldLastCertifiedAt:
		return m.OldLastCertifiedAt(ctx)
	case asset.FieldPurchaseDate:
		return m.OldPurchaseDate(ctx)
	case asset.FieldWarrantyExpiry:
		return m.OldWarrantyExpiry(ctx)
	case asset.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case asset.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Asset field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AssetMutation) SetField(name string, value ent.Value) error {
	switch name {
	case asset.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case asset.FieldHardwareID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHardwareID(v)
		return nil
	case asset.FieldSerialNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSerialNumber(v)
		return nil
	case asset.FieldManufacturer:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetManufacturer(v)
		return nil
	case asset.FieldVendorSupportPhone:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVendorSupportPhone(v)
		return nil
	case asset.FieldStatus:
		v, ok := value.(asset.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case asset.FieldMetadata:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetadata(v)
		return nil
	case asset.FieldLastCertifiedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastCertifiedAt(v)
		return nil
	case asset.FieldPurchaseDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPurchaseDate(v)
		return nil
	case asset.FieldWarrantyExpiry:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWarrantyExpiry(v)
		return nil
	case asset.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case asset.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Asset field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AssetMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AssetMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AssetMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Asset numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AssetMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(asset.FieldHardwareID) {
		fields = append(fields, asset.FieldHardwareID)
	}
	if m.FieldCleared(asset.FieldSerialNumber) {
		fields = append(fields, asset.FieldSerialNumber)
	}
	if m.FieldCleared(asset.FieldManufacturer) {
		fields = append(fields, asset.FieldManufacturer)
	}
	if m.FieldCleared(asset.FieldVendorSupportPhone) {
		fields = append(fields, asset.FieldVendorSupportPhone)
	}
	if m.FieldCleared(asset.FieldMetadata) {
		fields = append(fields, asset.FieldMetadata)
	}
	if m.FieldCleared(asset.FieldLastCertifiedAt) {
		fields = append(fields, asset.FieldLastCertifiedAt)
	}
	if m.FieldCleared(asset.FieldPurchaseDate) {
		fields = append(fields, asset.FieldPurchaseDate)
	}
	if m.FieldCleared(asset.FieldWarrantyExpiry) {
		fields = append(fields, asset.FieldWarrantyExpiry)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AssetMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AssetMutation) ClearField(name string) error {
	switch name {
	case asset.FieldHardwareID:
		m.ClearHardwareID()
		return nil
	case asset.FieldSerialNumber:
		m.ClearSerialNumber()
		return nil
	case asset.FieldManufacturer:
		m.ClearManufacturer()
		return nil
	case asset.FieldVendorSupportPhone:
		m.ClearVendorSupportPhone()
		return nil
	case asset.FieldMetadata:
		m.ClearMetadata()
		return nil
	case asset.FieldLastCertifiedAt:
		m.ClearLastCertifiedAt()
		return nil
	case asset.FieldPurchaseDate:
		m.ClearPurchaseDate()
		return nil
	case asset.FieldWarrantyExpiry:
		m.ClearWarrantyExpiry()
		return nil
	}
	return fmt.Errorf("unknown Asset nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AssetMutation) ResetField(name string) error {
	switch name {
	case asset.FieldName:
		m.ResetName()
		return nil
	case asset.FieldHardwareID:
		m.ResetHardwareID()
		return nil
	case asset.FieldSerialNumber:
		m.ResetSerialNumber()
		return nil
	case asset.FieldManufacturer:
		m.ResetManufacturer()
		return nil
	case asset.FieldVendorSupportPhone:
		m.ResetVendorSupportPhone()
		return nil
	case asset.FieldStatus:
		m.ResetStatus()
		return nil
	case asset.FieldMetadata:
		m.ResetMetadata()
		return nil
	case asset.FieldLastCertifiedAt:
		m.ResetLastCertifiedAt()
		return nil
	case asset.FieldPurchaseDate:
		m.ResetPurchaseDate()
		return nil
	case asset.FieldWarrantyExpiry:
		m.ResetWarrantyExpiry()
		return nil
	case asset.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case asset.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Asset field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AssetMutation) AddedEdges() []string {
	edges := make([]string, 0, 11)
	if m.tenant != nil {
		edges = append(edges, asset.EdgeTenant)
	}
	if m._type != nil {
		edges = append(edges, asset.EdgeType)
	}
	if m.hosted_at != nil {
		edges = append(edges, asset.EdgeHostedAt)
	}
	if m.hosted_assets != nil {
		edges = append(edges, asset.EdgeHostedAssets)
	}
	if m.dependency_of != nil {
		edges = append(edges, asset.EdgeDependencyOf)
	}
	if m.depends_on != nil {
		edges = append(edges, asset.EdgeDependsOn)
	}
	if m.owner != nil {
		edges = append(edges, asset.EdgeOwner)
	}
	if m.credentials != nil {
		edges = append(edges, asset.EdgeCredentials)
	}
	if m.sops != nil {
		edges = append(edges, asset.EdgeSops)
	}
	if m.tickets != nil {
		edges = append(edges, asset.EdgeTickets)
	}
	if m.product != nil {
		edges = append(edges, asset.EdgeProduct)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AssetMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case asset.EdgeTenant:
		if id := m.tenant; id != nil {
			return []ent.Value{*id}
		}
	case asset.EdgeType:
		if id := m._type; id != nil {
			return []ent.Value{*id}
		}
	case asset.EdgeHostedAt:
		if id := m.hosted_at; id != nil {
			return []ent.Value{*id}
		}
	case asset.EdgeHostedAssets:
		ids := make([]ent.Value, 0, len(m.hosted_assets))
		for id := range m.hosted_assets {
			ids = append(ids, id)
		}
		return ids
	case asset.EdgeDependencyOf:
		ids := make([]ent.Value, 0, len(m.dependency_of))
		for id := range m.dependency_of {
			ids = append(ids, id)
		}
		return ids
	case asset.EdgeDependsOn:
		ids := make([]ent.Value, 0, len(m.depends_on))
		for id := range m.depends_on {
			ids = append(ids, id)
		}
		return ids
	case asset.EdgeOwner:
		if id := m.owner; id != nil {
			return []ent.Value{*id}
		}
	case asset.EdgeCredentials:
		ids := make([]ent.Value, 0, len(m.credentials))
		for id := range m.credentials {
			ids = append(ids, id)
		}
		return ids
	case asset.EdgeSops:
		ids := make([]ent.Value, 0, len(m.sops))
		for id := range m.sops {
			ids = append(ids, id)
		}
		return ids
	case asset.EdgeTickets:
		ids := make([]ent.Value, 0, len(m.tickets))
		for id := range m.tickets {
			ids = append(ids, id)
		}
		return ids
	case asset.EdgeProduct:
		if id := m.product; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AssetMutation) RemovedEdges() []string {
	edges := make([]string, 0, 11)
	if m.removedhosted_assets != nil {
		edges = append(edges, asset.EdgeHostedAssets)
	}
	if m.removeddependency_of != nil {
		edges = append(edges, asset.EdgeDependencyOf)
	}
	if m.removeddepends_on != nil {
		edges = append(edges, asset.EdgeDependsOn)
	}
	if m.removedcredentials != nil {
		edges = append(edges, asset.EdgeCredentials)
	}
	if m.removedsops != nil {
		edges = append(edges, asset.EdgeSops)
	}
	if m.removedtickets != nil {
		edges = append(edges, asset.EdgeTickets)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AssetMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case asset.EdgeHostedAssets:
		ids := make([]ent.Value, 0, len(m.removedhosted_assets))
		for id := range m.removedhosted_assets {
			ids = append(ids, id)
		}
		return ids
	case asset.EdgeDependencyOf:
		ids := make([]ent.Value, 0, len(m.removeddependency_of))
		for id := range m.removeddependency_of {
			ids = append(ids, id)
		}
		return ids
	case asset.EdgeDependsOn:
		ids := make([]ent.Value, 0, len(m.removeddepends_on))
		for id := range m.removeddepends_on {
			ids = append(ids, id)
		}
		return ids
	case asset.EdgeCredentials:
		ids := make([]ent.Value, 0, len(m.removedcredentials))
		for id := range m.removedcredentials {
			ids = append(ids, id)
		}
		return ids
	case asset.EdgeSops:
		ids := make([]ent.Value, 0, len(m.removedsops))
		for id := range m.removedsops {
			ids = append(ids, id)
		}
		return ids
	case asset.EdgeTickets:
		ids := make([]ent.Value, 0, len(m.removedtickets))
		for id := range m.removedtickets {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AssetMutation) ClearedEdges() []string {
	edges := make([]string, 0, 11)
	if m.clearedtenant {
		edges = append(edges, asset.EdgeTenant)
	}
	if m.cleared_type {
		edges = append(edges, asset.EdgeType)
	}
	if m.clearedhosted_at {
		edges = append(edges, asset.EdgeHostedAt)
	}
	if m.clearedhosted_assets {
		edges = append(edges, asset.EdgeHostedAssets)
	}
	if m.cleareddependency_of {
		edges = append(edges, asset.EdgeDependencyOf)
	}
	if m.cleareddepends_on {
		edges = append(edges, asset.EdgeDependsOn)
	}
	if m.clearedowner {
		edges = append(edges, asset.EdgeOwner)
	}
	if m.clearedcredentials {
		edges = append(edges, asset.EdgeCredentials)
	}
	if m.clearedsops {
		edges = append(edges, asset.EdgeSops)
	}
	if m.clearedtickets {
		edges = append(edges, asset.EdgeTickets)
	}
	if m.clearedproduct {
		edges = append(edges, asset.EdgeProduct)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AssetMutation) EdgeCleared(name string) bool {
	switch name {
	case asset.EdgeTenant:
		return m.clearedtenant
	case asset.EdgeType:
		return m.cleared_type
	case asset.EdgeHostedAt:
		return m.clearedhosted_at
	case asset.EdgeHostedAssets:
		return m.clearedhosted_assets
	case asset.EdgeDependencyOf:
		return m.cleareddependency_of
	case asset.EdgeDependsOn:
		return m.cleareddepends_on
	case asset.EdgeOwner:
		return m.clearedowner
	case asset.EdgeCredentials:
		return m.clearedcredentials
	case asset.EdgeSops:
		return m.clearedsops
	case asset.EdgeTickets:
		return m.clearedtickets
	case asset.EdgeProduct:
		return m.clearedproduct
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AssetMutation) ClearEdge(name string) error {
	switch name {
	case asset.EdgeTenant:
		m.ClearTenant()
		return nil
	case asset.EdgeType:
		m.ClearType()
		return nil
	case asset.EdgeHostedAt:
		m.ClearHostedAt()
		return nil
	case asset.EdgeOwner:
		m.ClearOwner()
		return nil
	case asset.EdgeProduct:
		m.ClearProduct()
		return nil
	}
	return fmt.Errorf("unknown Asset unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AssetMutation) ResetEdge(name string) error {
	switch name {
	case asset.EdgeTenant:
		m.ResetTenant()
		return nil
	case asset.EdgeType:
		m.ResetType()
		return nil
	case asset.EdgeHostedAt:
		m.ResetHostedAt()
		return nil
	case asset.EdgeHostedAssets:
		m.ResetHostedAssets()
		return nil
	case asset.EdgeDependencyOf:
		m.ResetDependencyOf()
		return nil
	case asset.EdgeDependsOn:
		m.ResetDependsOn()
		return nil
	case asset.EdgeOwner:
		m.ResetOwner()
		return nil
	case asset.EdgeCredentials:
		m.ResetCredentials()
		return nil
	case asset.EdgeSops:
		m.ResetSops()
		return nil
	case asset.EdgeTickets:
		m.ResetTickets()
		return nil
	case asset.EdgeProduct:
		m.ResetProduct()
		return nil
	}
	return fmt.Errorf("unknown Asset edge %s", name)
}

// AssetAssignmentMutation represents an operation that mutates the AssetAssignment nodes in the graph.
type AssetAssignmentMutation struct {
	config
	op              Op
	typ             string
	id              *int
	assigned_at     *time.Time
	returned_at     *time.Time
	status          *assetassignment.Status
	quantity        *int
	addquantity     *int
	clearedFields   map[string]struct{}
	tenant          *int
	clearedtenant   bool
	product         *int
	clearedproduct  bool
	employee        *int
	clearedemployee bool
	done            bool
	oldValue        func(context.Context) (*AssetAssignment, error)
	predicates      []predicate.AssetAssignment
}

var _ ent.Mutation = (*AssetAssignmentMutation)(nil)

// assetassignmentOption allows management of the mutation configuration using functional options.
type assetassignmentOption func(*AssetAssignmentMutation)

// newAssetAssignmentMutation creates new mutation for the AssetAssignment entity.
func newAssetAssignmentMutation(c config, op Op, opts ...assetassignmentOption) *AssetAssignmentMutation {
	m := &AssetAssignmentMutation{
		config:        c,
		op:            op,
		typ:           TypeAssetAssignment,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAssetAssignmentID sets the ID field of the mutation.
func withAssetAssignmentID(id int) assetassignmentOption {
	return func(m *AssetAssignmentMutation) {
		var (
			err   error
			once  sync.Once
			value *AssetAssignment
		)
		m.oldValue = func(ctx context.Context) (*AssetAssignment, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AssetAssignment.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAssetAssignment sets the old AssetAssignment of the mutation.
func withAssetAssignment(node *AssetAssignment) assetassignmentOption {
	return func(m *AssetAssignmentMutation) {
		m.oldValue = func(context.Context) (*AssetAssignment, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AssetAssignmentMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AssetAssignmentMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AssetAssignmentMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AssetAssignmentMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AssetAssignment.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetAssignedAt sets the "assigned_at" field.
func (m *AssetAssignmentMutation) SetAssignedAt(t time.Time) {
	m.assigned_at = &t
}

// AssignedAt returns the value of the "assigned_at" field in the mutation.
func (m *AssetAssignmentMutation) AssignedAt() (r time.Time, exists bool) {
	v := m.assigned_at
	if v == nil {
		return
	}
	return *v, true
}

// OldAssignedAt returns the old "assigned_at" field's value of the AssetAssignment entity.
// If the AssetAssignment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AssetAssignmentMutation) OldAssignedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAssignedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAssignedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAssignedAt: %w", err)
	}
	return oldValue.AssignedAt, nil
}

// ResetAssignedAt resets all changes to the "assigned_at" field.
func (m *AssetAssignmentMutation) ResetAssignedAt() {
	m.assigned_at = nil
}

// SetReturnedAt sets the "returned_at" field.
func (m *AssetAssignmentMutation) SetReturnedAt(t time.Time) {
	m.returned_at = &t
}

// ReturnedAt returns the value of the "returned_at" field in the mutation.
func (m *AssetAssignmentMutation) ReturnedAt() (r time.Time, exists bool) {
	v := m.returned_at
	if v == nil {
		return
	}
	return *v, true
}

// OldReturnedAt returns the old "returned_at" field's value of the AssetAssignment entity.
// If the AssetAssignment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AssetAssignmentMutation) OldReturnedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReturnedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReturnedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReturnedAt: %w", err)
	}
	return oldValue.ReturnedAt, nil
}

// ClearReturnedAt clears the value of the "returned_at" field.
func (m *AssetAssignmentMutation) ClearReturnedAt() {
	m.returned_at = nil
	m.clearedFields[assetassignment.FieldReturnedAt] = struct{}{}
}

// ReturnedAtCleared returns if the "returned_at" field was cleared in this mutation.
func (m *AssetAssignmentMutation) ReturnedAtCleared() bool {
	_, ok := m.clearedFields[assetassignment.FieldReturnedAt]
	return ok
}

// ResetReturnedAt resets all changes to the "returned_at" field.
func (m *AssetAssignmentMutation) ResetReturnedAt() {
	m.returned_at = nil
	delete(m.clearedFields, assetassignment.FieldReturnedAt)
}

// SetStatus sets the "status" field.
func (m *AssetAssignmentMutation) SetStatus(a assetassignment.Status) {
	m.status = &a
}

// Status returns the value of the "status" field in the mutation.
func (m *AssetAssignmentMutation) Status() (r assetassignment.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the AssetAssignment entity.
// If the AssetAssignment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AssetAssignmentMutation) OldStatus(ctx context.Context) (v assetassignment.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *AssetAssignmentMutation) ResetStatus() {
	m.status = nil
}

// SetQuantity sets the "quantity" field.
func (m *AssetAssignmentMutation) SetQuantity(i int) {
	m.quantity = &i
	m.addquantity = nil
}

// Quantity returns the value of the "quantity" field in the mutation.
func (m *AssetAssignmentMutation) Quantity() (r int, exists bool) {
	v := m.quantity
	if v == nil {
		return
	}
	return *v, true
}

// OldQuantity returns the old "quantity" field's value of the AssetAssignment entity.
// If the AssetAssignment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AssetAssignmentMutation) OldQuantity(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldQuantity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldQuantity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldQuantity: %w", err)
	}
	return oldValue.Quantity, nil
}

// AddQuantity adds i to the "quantity" field.
func (m *AssetAssignmentMutation) AddQuantity(i int) {
	if m.addquantity != nil {
		*m.addquantity += i
	} else {
		m.addquantity = &i
	}
}

// AddedQuantity returns the value that was added to the "quantity" field in this mutation.
func (m *AssetAssignmentMutation) AddedQuantity() (r int, exists bool) {
	v := m.addquantity
	if v == nil {
		return
	}
	return *v, true
}

// ResetQuantity resets all changes to the "quantity" field.
func (m *AssetAssignmentMutation) ResetQuantity() {
	m.quantity = nil
	m.addquantity = nil
}

// SetTenantID sets the "tenant" edge to the Tenant entity by id.
func (m *AssetAssignmentMutation) SetTenantID(id int) {
	m.tenant = &id
}

// ClearTenant clears the "tenant" edge to the Tenant entity.
func (m *AssetAssignmentMutation) ClearTenant() {
	m.clearedtenant = true
}

// TenantCleared reports if the "tenant" edge to the Tenant entity was cleared.
func (m *AssetAssignmentMutation) TenantCleared() bool {
	return m.clearedtenant
}

// TenantID returns the "tenant" edge ID in the mutation.
func (m *AssetAssignmentMutation) TenantID() (id int, exists bool) {
	if m.tenant != nil {
		return *m.tenant, true
	}
	return
}

// TenantIDs returns the "tenant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TenantID instead. It exists only for internal usage by the builders.
func (m *AssetAssignmentMutation) TenantIDs() (ids []int) {
	if id := m.tenant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTenant resets all changes to the "tenant" edge.
func (m *AssetAssignmentMutation) ResetTenant() {
	m.tenant = nil
	m.clearedtenant = false
}

// SetProductID sets the "product" edge to the Product entity by id.
func (m *AssetAssignmentMutation) SetProductID(id int) {
	m.product = &id
}

// ClearProduct clears the "product" edge to the Product entity.
func (m *AssetAssignmentMutation) ClearProduct() {
	m.clearedproduct = true
}

// ProductCleared reports if the "product" edge to the Product entity was cleared.
func (m *AssetAssignmentMutation) ProductCleared() bool {
	return m.clearedproduct
}

// ProductID returns the "product" edge ID in the mutation.
func (m *AssetAssignmentMutation) ProductID() (id int, exists bool) {
	if m.product != nil {
		return *m.product, true
	}
	return
}

// ProductIDs returns the "product" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProductID instead. It exists only for internal usage by the builders.
func (m *AssetAssignmentMutation) ProductIDs() (ids []int) {
	if id := m.product; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProduct resets all changes to the "product" edge.
func (m *AssetAssignmentMutation) ResetProduct() {
	m.product = nil
	m.clearedproduct = false
}

// SetEmployeeID sets the "employee" edge to the Employee entity by id.
func (m *AssetAssignmentMutation) SetEmployeeID(id int) {
	m.employee = &id
}

// ClearEmployee clears the "employee" edge to the Employee entity.
func (m *AssetAssignmentMutation) ClearEmployee() {
	m.clearedemployee = true
}

// EmployeeCleared reports if the "employee" edge to the Employee entity was cleared.
func (m *AssetAssignmentMutation) EmployeeCleared() bool {
	return m.clearedemployee
}

// EmployeeID returns the "employee" edge ID in the mutation.
func (m *AssetAssignmentMutation) EmployeeID() (id int, exists bool) {
	if m.employee != nil {
		return *m.employee, true
	}
	return
}

// EmployeeIDs returns the "employee" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// EmployeeID instead. It exists only for internal usage by the builders.
func (m *AssetAssignmentMutation) EmployeeIDs() (ids []int) {
	if id := m.employee; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEmployee resets all changes to the "employee" edge.
func (m *AssetAssignmentMutation) ResetEmployee() {
	m.employee = nil
	m.clearedemployee = false
}

// Where appends a list predicates to the AssetAssignmentMutation builder.
func (m *AssetAssignmentMutation) Where(ps ...predicate.AssetAssignment) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AssetAssignmentMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AssetAssignmentMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.AssetAssignment, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AssetAssignmentMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AssetAssignmentMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (AssetAssignment).
func (m *AssetAssignmentMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AssetAssignmentMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.assigned_at != nil {
		fields = append(fields, assetassignment.FieldAssignedAt)
	}
	if m.returned_at != nil {
		fields = append(fields, assetassignment.FieldReturnedAt)
	}
	if m.status != nil {
		fields = append(fields, assetassignment.FieldStatus)
	}
	if m.quantity != nil {
		fields = append(fields, assetassignment.FieldQuantity)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AssetAssignmentMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case assetassignment.FieldAssignedAt:
		return m.AssignedAt()
	case assetassignment.FieldReturnedAt:
		return m.ReturnedAt()
	case assetassignment.FieldStatus:
		return m.Status()
	case assetassignment.FieldQuantity:
		return m.Quantity()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AssetAssignmentMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case assetassignment.FieldAssignedAt:
		return m.OldAssignedAt(ctx)
	case assetassignment.FieldReturnedAt:
		return m.OldReturnedAt(ctx)
	case assetassignment.FieldStatus:
		return m.OldStatus(ctx)
	case assetassignment.FieldQuantity:
		return m.OldQuantity(ctx)
	}
	return nil, fmt.Errorf("unknown AssetAssignment field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AssetAssignmentMutation) SetField(name string, value ent.Value) error {
	switch name {
	case assetassignment.FieldAssignedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAssignedAt(v)
		return nil
	case assetassignment.FieldReturnedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReturnedAt(v)
		return nil
	case assetassignment.FieldStatus:
		v, ok := value.(assetassignment.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case assetassignment.FieldQuantity:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetQuantity(v)
		return nil
	}
	return fmt.Errorf("unknown AssetAssignment field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AssetAssignmentMutation) AddedFields() []string {
	var fields []string
	if m.addquantity != nil {
		fields = append(fields, assetassignment.FieldQuantity)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AssetAssignmentMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case assetassignment.FieldQuantity:
		return m.AddedQuantity()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AssetAssignmentMutation) AddField(name string, value ent.Value) error {
	switch name {
	case assetassignment.FieldQuantity:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddQuantity(v)
		return nil
	}
	return fmt.Errorf("unknown AssetAssignment numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AssetAssignmentMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(assetassignment.FieldReturnedAt) {
		fields = append(fields, assetassignment.FieldReturnedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AssetAssignmentMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AssetAssignmentMutation) ClearField(name string) error {
	switch name {
	case assetassignment.FieldReturnedAt:
		m.ClearReturnedAt()
		return nil
	}
	return fmt.Errorf("unknown AssetAssignment nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AssetAssignmentMutation) ResetField(name string) error {
	switch name {
	case assetassignment.FieldAssignedAt:
		m.ResetAssignedAt()
		return nil
	case assetassignment.FieldReturnedAt:
		m.ResetReturnedAt()
		return nil
	case assetassignment.FieldStatus:
		m.ResetStatus()
		return nil
	case assetassignment.FieldQuantity:
		m.ResetQuantity()
		return nil
	}
	return fmt.Errorf("unknown AssetAssignment field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AssetAssignmentMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.tenant != nil {
		edges = append(edges, assetassignment.EdgeTenant)
	}
	if m.product != nil {
		edges = append(edges, assetassignment.EdgeProduct)
	}
	if m.employee != nil {
		edges = append(edges, assetassignment.EdgeEmployee)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AssetAssignmentMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case assetassignment.EdgeTenant:
		if id := m.tenant; id != nil {
			return []ent.Value{*id}
		}
	case assetassignment.EdgeProduct:
		if id := m.product; id != nil {
			return []ent.Value{*id}
		}
	case assetassignment.EdgeEmployee:
		if id := m.employee; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AssetAssignmentMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AssetAssignmentMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AssetAssignmentMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedtenant {
		edges = append(edges, assetassignment.EdgeTenant)
	}
	if m.clearedproduct {
		edges = append(edges, assetassignment.EdgeProduct)
	}
	if m.clearedemployee {
		edges = append(edges, assetassignment.EdgeEmployee)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AssetAssignmentMutation) EdgeCleared(name string) bool {
	switch name {
	case assetassignment.EdgeTenant:
		return m.clearedtenant
	case assetassignment.EdgeProduct:
		return m.clearedproduct
	case assetassignment.EdgeEmployee:
		return m.clearedemployee
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AssetAssignmentMutation) ClearEdge(name string) error {
	switch name {
	case assetassignment.EdgeTenant:
		m.ClearTenant()
		return nil
	case assetassignment.EdgeProduct:
		m.ClearProduct()
		return nil
	case assetassignment.EdgeEmployee:
		m.ClearEmployee()
		return nil
	}
	return fmt.Errorf("unknown AssetAssignment unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AssetAssignmentMutation) ResetEdge(name string) error {
	switch name {
	case assetassignment.EdgeTenant:
		m.ResetTenant()
		return nil
	case assetassignment.EdgeProduct:
		m.ResetProduct()
		return nil
	case assetassignment.EdgeEmployee:
		m.ResetEmployee()
		return nil
	}
	return fmt.Errorf("unknown AssetAssignment edge %s", name)
}

// AssetTypeMutation represents an operation that mutates the AssetType nodes in the graph.
type AssetTypeMutation struct {
	config
	op            Op
	typ           string
	id            *int
	name          *string
	description   *string
	clearedFields map[string]struct{}
	assets        map[int]struct{}
	removedassets map[int]struct{}
	clearedassets bool
	tenant        *int
	clearedtenant bool
	done          bool
	oldValue      func(context.Context) (*AssetType, error)
	predicates    []predicate.AssetType
}

var _ ent.Mutation = (*AssetTypeMutation)(nil)

// assettypeOption allows management of the mutation configuration using functional options.
type assettypeOption func(*AssetTypeMutation)

// newAssetTypeMutation creates new mutation for the AssetType entity.
func newAssetTypeMutation(c config, op Op, opts ...assettypeOption) *AssetTypeMutation {
	m := &AssetTypeMutation{
		config:        c,
		op:            op,
		typ:           TypeAssetType,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAssetTypeID sets the ID field of the mutation.
func withAssetTypeID(id int) assettypeOption {
	return func(m *AssetTypeMutation) {
		var (
			err   error
			once  sync.Once
			value *AssetType
		)
		m.oldValue = func(ctx context.Context) (*AssetType, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AssetType.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAssetType sets the old AssetType of the mutation.
func withAssetType(node *AssetType) assettypeOption {
	return func(m *AssetTypeMutation) {
		m.oldValue = func(context.Context) (*AssetType, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AssetTypeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AssetTypeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AssetTypeMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AssetTypeMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AssetType.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *AssetTypeMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *AssetTypeMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the AssetType entity.
// If the AssetType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AssetTypeMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *AssetTypeMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *AssetTypeMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *AssetTypeMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the AssetType entity.
// If the AssetType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AssetTypeMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *AssetTypeMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[assettype.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *AssetTypeMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[assettype.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *AssetTypeMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, assettype.FieldDescription)
}

// AddAssetIDs adds the "assets" edge to the Asset entity by ids.
func (m *AssetTypeMutation) AddAssetIDs(ids ...int) {
	if m.assets == nil {
		m.assets = make(map[int]struct{})
	}
	for i := range ids {
		m.assets[ids[i]] = struct{}{}
	}
}

// ClearAssets clears the "assets" edge to the Asset entity.
func (m *AssetTypeMutation) ClearAssets() {
	m.clearedassets = true
}

// AssetsCleared reports if the "assets" edge to the Asset entity was cleared.
func (m *AssetTypeMutation) AssetsCleared() bool {
	return m.clearedassets
}

// RemoveAssetIDs removes the "assets" edge to the Asset entity by IDs.
func (m *AssetTypeMutation) RemoveAssetIDs(ids ...int) {
	if m.removedassets == nil {
		m.removedassets = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.assets, ids[i])
		m.removedassets[ids[i]] = struct{}{}
	}
}

// RemovedAssets returns the removed IDs of the "assets" edge to the Asset entity.
func (m *AssetTypeMutation) RemovedAssetsIDs() (ids []int) {
	for id := range m.removedassets {
		ids = append(ids, id)
	}
	return
}

// AssetsIDs returns the "assets" edge IDs in the mutation.
func (m *AssetTypeMutation) AssetsIDs() (ids []int) {
	for id := range m.assets {
		ids = append(ids, id)
	}
	return
}

// ResetAssets resets all changes to the "assets" edge.
func (m *AssetTypeMutation) ResetAssets() {
	m.assets = nil
	m.clearedassets = false
	m.removedassets = nil
}

// SetTenantID sets the "tenant" edge to the Tenant entity by id.
func (m *AssetTypeMutation) SetTenantID(id int) {
	m.tenant = &id
}

// ClearTenant clears the "tenant" edge to the Tenant entity.
func (m *AssetTypeMutation) ClearTenant() {
	m.clearedtenant = true
}

// TenantCleared reports if the "tenant" edge to the Tenant entity was cleared.
func (m *AssetTypeMutation) TenantCleared() bool {
	return m.clearedtenant
}

// TenantID returns the "tenant" edge ID in the mutation.
func (m *AssetTypeMutation) TenantID() (id int, exists bool) {
	if m.tenant != nil {
		return *m.tenant, true
	}
	return
}

// TenantIDs returns the "tenant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TenantID instead. It exists only for internal usage by the builders.
func (m *AssetTypeMutation) TenantIDs() (ids []int) {
	if id := m.tenant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTenant resets all changes to the "tenant" edge.
func (m *AssetTypeMutation) ResetTenant() {
	m.tenant = nil
	m.clearedtenant = false
}

// Where appends a list predicates to the AssetTypeMutation builder.
func (m *AssetTypeMutation) Where(ps ...predicate.AssetType) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AssetTypeMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AssetTypeMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.AssetType, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AssetTypeMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AssetTypeMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (AssetType).
func (m *AssetTypeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AssetTypeMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.name != nil {
		fields = append(fields, assettype.FieldName)
	}
	if m.description != nil {
		fields = append(fields, assettype.FieldDescription)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AssetTypeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case assettype.FieldName:
		return m.Name()
	case assettype.FieldDescription:
		return m.Description()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AssetTypeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case assettype.FieldName:
		return m.OldName(ctx)
	case assettype.FieldDescription:
		return m.OldDescription(ctx)
	}
	return nil, fmt.Errorf("unknown AssetType field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AssetTypeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case assettype.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case assettype.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	}
	return fmt.Errorf("unknown AssetType field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AssetTypeMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AssetTypeMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AssetTypeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown AssetType numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AssetTypeMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(assettype.FieldDescription) {
		fields = append(fields, assettype.FieldDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AssetTypeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AssetTypeMutation) ClearField(name string) error {
	switch name {
	case assettype.FieldDescription:
		m.ClearDescription()
		return nil
	}
	return fmt.Errorf("unknown AssetType nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AssetTypeMutation) ResetField(name string) error {
	switch name {
	case assettype.FieldName:
		m.ResetName()
		return nil
	case assettype.FieldDescription:
		m.ResetDescription()
		return nil
	}
	return fmt.Errorf("unknown AssetType field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AssetTypeMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.assets != nil {
		edges = append(edges, assettype.EdgeAssets)
	}
	if m.tenant != nil {
		edges = append(edges, assettype.EdgeTenant)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AssetTypeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case assettype.EdgeAssets:
		ids := make([]ent.Value, 0, len(m.assets))
		for id := range m.assets {
			ids = append(ids, id)
		}
		return ids
	case assettype.EdgeTenant:
		if id := m.tenant; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AssetTypeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedassets != nil {
		edges = append(edges, assettype.EdgeAssets)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AssetTypeMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case assettype.EdgeAssets:
		ids := make([]ent.Value, 0, len(m.removedassets))
		for id := range m.removedassets {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AssetTypeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedassets {
		edges = append(edges, assettype.EdgeAssets)
	}
	if m.clearedtenant {
		edges = append(edges, assettype.EdgeTenant)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AssetTypeMutation) EdgeCleared(name string) bool {
	switch name {
	case assettype.EdgeAssets:
		return m.clearedassets
	case assettype.EdgeTenant:
		return m.clearedtenant
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AssetTypeMutation) ClearEdge(name string) error {
	switch name {
	case assettype.EdgeTenant:
		m.ClearTenant()
		return nil
	}
	return fmt.Errorf("unknown AssetType unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AssetTypeMutation) ResetEdge(name string) error {
	switch name {
	case assettype.EdgeAssets:
		m.ResetAssets()
		return nil
	case assettype.EdgeTenant:
		m.ResetTenant()
		return nil
	}
	return fmt.Errorf("unknown AssetType edge %s", name)
}

// AuditLogMutation represents an operation that mutates the AuditLog nodes in the graph.
type AuditLogMutation struct {
	config
	op            Op
	typ           string
	id            *int
	app_name      *string
	action        *string
	actor_id      *string
	remote_ip     *string
	payload       *map[string]interface{}
	timestamp     *time.Time
	clearedFields map[string]struct{}
	tenant        *int
	clearedtenant bool
	done          bool
	oldValue      func(context.Context) (*AuditLog, error)
	predicates    []predicate.AuditLog
}

var _ ent.Mutation = (*AuditLogMutation)(nil)

// auditlogOption allows management of the mutation configuration using functional options.
type auditlogOption func(*AuditLogMutation)

// newAuditLogMutation creates new mutation for the AuditLog entity.
func newAuditLogMutation(c config, op Op, opts ...auditlogOption) *AuditLogMutation {
	m := &AuditLogMutation{
		config:        c,
		op:            op,
		typ:           TypeAuditLog,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAuditLogID sets the ID field of the mutation.
func withAuditLogID(id int) auditlogOption {
	return func(m *AuditLogMutation) {
		var (
			err   error
			once  sync.Once
			value *AuditLog
		)
		m.oldValue = func(ctx context.Context) (*AuditLog, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AuditLog.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAuditLog sets the old AuditLog of the mutation.
func withAuditLog(node *AuditLog) auditlogOption {
	return func(m *AuditLogMutation) {
		m.oldValue = func(context.Context) (*AuditLog, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AuditLogMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AuditLogMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AuditLogMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AuditLogMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AuditLog.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetAppName sets the "app_name" field.
func (m *AuditLogMutation) SetAppName(s string) {
	m.app_name = &s
}

// AppName returns the value of the "app_name" field in the mutation.
func (m *AuditLogMutation) AppName() (r string, exists bool) {
	v := m.app_name
	if v == nil {
		return
	}
	return *v, true
}

// OldAppName returns the old "app_name" field's value of the AuditLog entity.
// If the AuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditLogMutation) OldAppName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppName: %w", err)
	}
	return oldValue.AppName, nil
}

// ResetAppName resets all changes to the "app_name" field.
func (m *AuditLogMutation) ResetAppName() {
	m.app_name = nil
}

// SetAction sets the "action" field.
func (m *AuditLogMutation) SetAction(s string) {
	m.action = &s
}

// Action returns the value of the "action" field in the mutation.
func (m *AuditLogMutation) Action() (r string, exists bool) {
	v := m.action
	if v == nil {
		return
	}
	return *v, true
}

// OldAction returns the old "action" field's value of the AuditLog entity.
// If the AuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditLogMutation) OldAction(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAction is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAction requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAction: %w", err)
	}
	return oldValue.Action, nil
}

// ResetAction resets all changes to the "action" field.
func (m *AuditLogMutation) ResetAction() {
	m.action = nil
}

// SetActorID sets the "actor_id" field.
func (m *AuditLogMutation) SetActorID(s string) {
	m.actor_id = &s
}

// ActorID returns the value of the "actor_id" field in the mutation.
func (m *AuditLogMutation) ActorID() (r string, exists bool) {
	v := m.actor_id
	if v == nil {
		return
	}
	return *v, true
}

// OldActorID returns the old "actor_id" field's value of the AuditLog entity.
// If the AuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditLogMutation) OldActorID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldActorID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldActorID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldActorID: %w", err)
	}
	return oldValue.ActorID, nil
}

// ResetActorID resets all changes to the "actor_id" field.
func (m *AuditLogMutation) ResetActorID() {
	m.actor_id = nil
}

// SetRemoteIP sets the "remote_ip" field.
func (m *AuditLogMutation) SetRemoteIP(s string) {
	m.remote_ip = &s
}

// RemoteIP returns the value of the "remote_ip" field in the mutation.
func (m *AuditLogMutation) RemoteIP() (r string, exists bool) {
	v := m.remote_ip
	if v == nil {
		return
	}
	return *v, true
}

// OldRemoteIP returns the old "remote_ip" field's value of the AuditLog entity.
// If the AuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditLogMutation) OldRemoteIP(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRemoteIP is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRemoteIP requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemoteIP: %w", err)
	}
	return oldValue.RemoteIP, nil
}

// ClearRemoteIP clears the value of the "remote_ip" field.
func (m *AuditLogMutation) ClearRemoteIP() {
	m.remote_ip = nil
	m.clearedFields[auditlog.FieldRemoteIP] = struct{}{}
}

// RemoteIPCleared returns if the "remote_ip" field was cleared in this mutation.
func (m *AuditLogMutation) RemoteIPCleared() bool {
	_, ok := m.clearedFields[auditlog.FieldRemoteIP]
	return ok
}

// ResetRemoteIP resets all changes to the "remote_ip" field.
func (m *AuditLogMutation) ResetRemoteIP() {
	m.remote_ip = nil
	delete(m.clearedFields, auditlog.FieldRemoteIP)
}

// SetPayload sets the "payload" field.
func (m *AuditLogMutation) SetPayload(value map[string]interface{}) {
	m.payload = &value
}

// Payload returns the value of the "payload" field in the mutation.
func (m *AuditLogMutation) Payload() (r map[string]interface{}, exists bool) {
	v := m.payload
	if v == nil {
		return
	}
	return *v, true
}

// OldPayload returns the old "payload" field's value of the AuditLog entity.
// If the AuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditLogMutation) OldPayload(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPayload is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPayload requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPayload: %w", err)
	}
	return oldValue.Payload, nil
}

// ClearPayload clears the value of the "payload" field.
func (m *AuditLogMutation) ClearPayload() {
	m.payload = nil
	m.clearedFields[auditlog.FieldPayload] = struct{}{}
}

// PayloadCleared returns if the "payload" field was cleared in this mutation.
func (m *AuditLogMutation) PayloadCleared() bool {
	_, ok := m.clearedFields[auditlog.FieldPayload]
	return ok
}

// ResetPayload resets all changes to the "payload" field.
func (m *AuditLogMutation) ResetPayload() {
	m.payload = nil
	delete(m.clearedFields, auditlog.FieldPayload)
}

// SetTimestamp sets the "timestamp" field.
func (m *AuditLogMutation) SetTimestamp(t time.Time) {
	m.timestamp = &t
}

// Timestamp returns the value of the "timestamp" field in the mutation.
func (m *AuditLogMutation) Timestamp() (r time.Time, exists bool) {
	v := m.timestamp
	if v == nil {
		return
	}
	return *v, true
}

// OldTimestamp returns the old "timestamp" field's value of the AuditLog entity.
// If the AuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditLogMutation) OldTimestamp(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTimestamp is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTimestamp requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTimestamp: %w", err)
	}
	return oldValue.Timestamp, nil
}

// ResetTimestamp resets all changes to the "timestamp" field.
func (m *AuditLogMutation) ResetTimestamp() {
	m.timestamp = nil
}

// SetTenantID sets the "tenant" edge to the Tenant entity by id.
func (m *AuditLogMutation) SetTenantID(id int) {
	m.tenant = &id
}

// ClearTenant clears the "tenant" edge to the Tenant entity.
func (m *AuditLogMutation) ClearTenant() {
	m.clearedtenant = true
}

// TenantCleared reports if the "tenant" edge to the Tenant entity was cleared.
func (m *AuditLogMutation) TenantCleared() bool {
	return m.clearedtenant
}

// TenantID returns the "tenant" edge ID in the mutation.
func (m *AuditLogMutation) TenantID() (id int, exists bool) {
	if m.tenant != nil {
		return *m.tenant, true
	}
	return
}

// TenantIDs returns the "tenant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TenantID instead. It exists only for internal usage by the builders.
func (m *AuditLogMutation) TenantIDs() (ids []int) {
	if id := m.tenant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTenant resets all changes to the "tenant" edge.
func (m *AuditLogMutation) ResetTenant() {
	m.tenant = nil
	m.clearedtenant = false
}

// Where appends a list predicates to the AuditLogMutation builder.
func (m *AuditLogMutation) Where(ps ...predicate.AuditLog) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AuditLogMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AuditLogMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.AuditLog, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AuditLogMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AuditLogMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (AuditLog).
func (m *AuditLogMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AuditLogMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.app_name != nil {
		fields = append(fields, auditlog.FieldAppName)
	}
	if m.action != nil {
		fields = append(fields, auditlog.FieldAction)
	}
	if m.actor_id != nil {
		fields = append(fields, auditlog.FieldActorID)
	}
	if m.remote_ip != nil {
		fields = append(fields, auditlog.FieldRemoteIP)
	}
	if m.payload != nil {
		fields = append(fields, auditlog.FieldPayload)
	}
	if m.timestamp != nil {
		fields = append(fields, auditlog.FieldTimestamp)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AuditLogMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case auditlog.FieldAppName:
		return m.AppName()
	case auditlog.FieldAction:
		return m.Action()
	case auditlog.FieldActorID:
		return m.ActorID()
	case auditlog.FieldRemoteIP:
		return m.RemoteIP()
	case auditlog.FieldPayload:
		return m.Payload()
	case auditlog.FieldTimestamp:
		return m.Timestamp()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AuditLogMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case auditlog.FieldAppName:
		return m.OldAppName(ctx)
	case auditlog.FieldAction:
		return m.OldAction(ctx)
	case auditlog.FieldActorID:
		return m.OldActorID(ctx)
	case auditlog.FieldRemoteIP:
		return m.OldRemoteIP(ctx)
	case auditlog.FieldPayload:
		return m.OldPayload(ctx)
	case auditlog.FieldTimestamp:
		return m.OldTimestamp(ctx)
	}
	return nil, fmt.Errorf("unknown AuditLog field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AuditLogMutation) SetField(name string, value ent.Value) error {
	switch name {
	case auditlog.FieldAppName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppName(v)
		return nil
	case auditlog.FieldAction:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAction(v)
		return nil
	case auditlog.FieldActorID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetActorID(v)
		return nil
	case auditlog.FieldRemoteIP:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemoteIP(v)
		return nil
	case auditlog.FieldPayload:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPayload(v)
		return nil
	case auditlog.FieldTimestamp:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTimestamp(v)
		return nil
	}
	return fmt.Errorf("unknown AuditLog field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AuditLogMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AuditLogMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AuditLogMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown AuditLog numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AuditLogMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(auditlog.FieldRemoteIP) {
		fields = append(fields, auditlog.FieldRemoteIP)
	}
	if m.FieldCleared(auditlog.FieldPayload) {
		fields = append(fields, auditlog.FieldPayload)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AuditLogMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AuditLogMutation) ClearField(name string) error {
	switch name {
	case auditlog.FieldRemoteIP:
		m.ClearRemoteIP()
		return nil
	case auditlog.FieldPayload:
		m.ClearPayload()
		return nil
	}
	return fmt.Errorf("unknown AuditLog nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AuditLogMutation) ResetField(name string) error {
	switch name {
	case auditlog.FieldAppName:
		m.ResetAppName()
		return nil
	case auditlog.FieldAction:
		m.ResetAction()
		return nil
	case auditlog.FieldActorID:
		m.ResetActorID()
		return nil
	case auditlog.FieldRemoteIP:
		m.ResetRemoteIP()
		return nil
	case auditlog.FieldPayload:
		m.ResetPayload()
		return nil
	case auditlog.FieldTimestamp:
		m.ResetTimestamp()
		return nil
	}
	return fmt.Errorf("unknown AuditLog field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AuditLogMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.tenant != nil {
		edges = append(edges, auditlog.EdgeTenant)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AuditLogMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case auditlog.EdgeTenant:
		if id := m.tenant; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AuditLogMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AuditLogMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AuditLogMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedtenant {
		edges = append(edges, auditlog.EdgeTenant)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AuditLogMutation) EdgeCleared(name string) bool {
	switch name {
	case auditlog.EdgeTenant:
		return m.clearedtenant
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AuditLogMutation) ClearEdge(name string) error {
	switch name {
	case auditlog.EdgeTenant:
		m.ClearTenant()
		return nil
	}
	return fmt.Errorf("unknown AuditLog unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AuditLogMutation) ResetEdge(name string) error {
	switch name {
	case auditlog.EdgeTenant:
		m.ResetTenant()
		return nil
	}
	return fmt.Errorf("unknown AuditLog edge %s", name)
}

// BenefitEnrollmentMutation represents an operation that mutates the BenefitEnrollment nodes in the graph.
type BenefitEnrollmentMutation struct {
	config
	op               Op
	typ              string
	id               *int
	tier             *benefitenrollment.Tier
	employee_cost    *float64
	addemployee_cost *float64
	employer_cost    *float64
	addemployer_cost *float64
	status           *benefitenrollment.Status
	effective_from   *time.Time
	effective_to     *time.Time
	created_at       *time.Time
	updated_at       *time.Time
	clearedFields    map[string]struct{}
	tenant           *int
	clearedtenant    bool
	plan             *int
	clearedplan      bool
	employee         *int
	clearedemployee  bool
	done             bool
	oldValue         func(context.Context) (*BenefitEnrollment, error)
	predicates       []predicate.BenefitEnrollment
}

var _ ent.Mutation = (*BenefitEnrollmentMutation)(nil)

// benefitenrollmentOption allows management of the mutation configuration using functional options.
type benefitenrollmentOption func(*BenefitEnrollmentMutation)

// newBenefitEnrollmentMutation creates new mutation for the BenefitEnrollment entity.
func newBenefitEnrollmentMutation(c config, op Op, opts ...benefitenrollmentOption) *BenefitEnrollmentMutation {
	m := &BenefitEnrollmentMutation{
		config:        c,
		op:            op,
		typ:           TypeBenefitEnrollment,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBenefitEnrollmentID sets the ID field of the mutation.
func withBenefitEnrollmentID(id int) benefitenrollmentOption {
	return func(m *BenefitEnrollmentMutation) {
		var (
			err   error
			once  sync.Once
			value *BenefitEnrollment
		)
		m.oldValue = func(ctx context.Context) (*BenefitEnrollment, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().BenefitEnrollment.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBenefitEnrollment sets the old BenefitEnrollment of the mutation.
func withBenefitEnrollment(node *BenefitEnrollment) benefitenrollmentOption {
	return func(m *BenefitEnrollmentMutation) {
		m.oldValue = func(context.Context) (*BenefitEnrollment, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BenefitEnrollmentMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BenefitEnrollmentMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *BenefitEnrollmentMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *BenefitEnrollmentMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().BenefitEnrollment.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTier sets the "tier" field.
func (m *BenefitEnrollmentMutation) SetTier(b benefitenrollment.Tier) {
	m.tier = &b
}

// Tier returns the value of the "tier" field in the mutation.
func (m *BenefitEnrollmentMutation) Tier() (r benefitenrollment.Tier, exists bool) {
	v := m.tier
	if v == nil {
		return
	}
	return *v, true
}

// OldTier returns the old "tier" field's value of the BenefitEnrollment entity.
// If the BenefitEnrollment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BenefitEnrollmentMutation) OldTier(ctx context.Context) (v benefitenrollment.Tier, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTier is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTier requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTier: %w", err)
	}
	return oldValue.Tier, nil
}

// ResetTier resets all changes to the "tier" field.
func (m *BenefitEnrollmentMutation) ResetTier() {
	m.tier = nil
}

// SetEmployeeCost sets the "employee_cost" field.
func (m *BenefitEnrollmentMutation) SetEmployeeCost(f float64) {
	m.employee_cost = &f
	m.addemployee_cost = nil
}

// EmployeeCost returns the value of the "employee_cost" field in the mutation.
func (m *BenefitEnrollmentMutation) EmployeeCost() (r float64, exists bool) {
	v := m.employee_cost
	if v == nil {
		return
	}
	return *v, true
}

// OldEmployeeCost returns the old "employee_cost" field's value of the BenefitEnrollment entity.
// If the BenefitEnrollment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BenefitEnrollmentMutation) OldEmployeeCost(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmployeeCost is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmployeeCost requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmployeeCost: %w", err)
	}
	return oldValue.EmployeeCost, nil
}

// AddEmployeeCost adds f to the "employee_cost" field.
func (m *BenefitEnrollmentMutation) AddEmployeeCost(f float64) {
	if m.addemployee_cost != nil {
		*m.addemployee_cost += f
	} else {
		m.addemployee_cost = &f
	}
}

// AddedEmployeeCost returns the value that was added to the "employee_cost" field in this mutation.
func (m *BenefitEnrollmentMutation) AddedEmployeeCost() (r float64, exists bool) {
	v := m.addemployee_cost
	if v == nil {
		return
	}
	return *v, true
}

// ResetEmployeeCost resets all changes to the "employee_cost" field.
func (m *BenefitEnrollmentMutation) ResetEmployeeCost() {
	m.employee_cost = nil
	m.addemployee_cost = nil
}

// SetEmployerCost sets the "employer_cost" field.
func (m *BenefitEnrollmentMutation) SetEmployerCost(f float64) {
	m.employer_cost = &f
	m.addemployer_cost = nil
}

// EmployerCost returns the value of the "employer_cost" field in the mutation.
func (m *BenefitEnrollmentMutation) EmployerCost() (r float64, exists bool) {
	v := m.employer_cost
	if v == nil {
		return
	}
	return *v, true
}

// OldEmployerCost returns the old "employer_cost" field's value of the BenefitEnrollment entity.
// If the BenefitEnrollment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BenefitEnrollmentMutation) OldEmployerCost(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmployerCost is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmployerCost requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmployerCost: %w", err)
	}
	return oldValue.EmployerCost, nil
}

// AddEmployerCost adds f to the "employer_cost" field.
func (m *BenefitEnrollmentMutation) AddEmployerCost(f float64) {
	if m.addemployer_cost != nil {
		*m.addemployer_cost += f
	} else {
		m.addemployer_cost = &f
	}
}

// AddedEmployerCost returns the value that was added to the "employer_cost" field in this mutation.
func (m *BenefitEnrollmentMutation) AddedEmployerCost() (r float64, exists bool) {
	v := m.addemployer_cost
	if v == nil {
		return
	}
	return *v, true
}

// ResetEmployerCost resets all changes to the "employer_cost" field.
func (m *BenefitEnrollmentMutation) ResetEmployerCost() {
	m.employer_cost = nil
	m.addemployer_cost = nil
}

// SetStatus sets the "status" field.
func (m *BenefitEnrollmentMutation) SetStatus(b benefitenrollment.Status) {
	m.status = &b
}

// Status returns the value of the "status" field in the mutation.
func (m *BenefitEnrollmentMutation) Status() (r benefitenrollment.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the BenefitEnrollment entity.
// If the BenefitEnrollment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BenefitEnrollmentMutation) OldStatus(ctx context.Context) (v benefitenrollment.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *BenefitEnrollmentMutation) ResetStatus() {
	m.status = nil
}

// SetEffectiveFrom sets the "effective_from" field.
func (m *BenefitEnrollmentMutation) SetEffectiveFrom(t time.Time) {
	m.effective_from = &t
}

// EffectiveFrom returns the value of the "effective_from" field in the mutation.
func (m *BenefitEnrollmentMutation) EffectiveFrom() (r time.Time, exists bool) {
	v := m.effective_from
	if v == nil {
		return
	}
	return *v, true
}

// OldEffectiveFrom returns the old "effective_from" field's value of the BenefitEnrollment entity.
// If the BenefitEnrollment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BenefitEnrollmentMutation) OldEffectiveFrom(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEffectiveFrom is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEffectiveFrom requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEffectiveFrom: %w", err)
	}
	return oldValue.EffectiveFrom, nil
}

// ResetEffectiveFrom resets all changes to the "effective_from" field.
func (m *BenefitEnrollmentMutation) ResetEffectiveFrom() {
	m.effective_from = nil
}

// SetEffectiveTo sets the "effective_to" field.
func (m *BenefitEnrollmentMutation) SetEffectiveTo(t time.Time) {
	m.effective_to = &t
}

// EffectiveTo returns the value of the "effective_to" field in the mutation.
func (m *BenefitEnrollmentMutation) EffectiveTo() (r time.Time, exists bool) {
	v := m.effective_to
	if v == nil {
		return
	}
	return *v, true
}

// OldEffectiveTo returns the old "effective_to" field's value of the BenefitEnrollment entity.
// If the BenefitEnrollment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BenefitEnrollmentMutation) OldEffectiveTo(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEffectiveTo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEffectiveTo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEffectiveTo: %w", err)
	}
	return oldValue.EffectiveTo, nil
}

// ClearEffectiveTo clears the value of the "effective_to" field.
func (m *BenefitEnrollmentMutation) ClearEffectiveTo() {
	m.effective_to = nil
	m.clearedFields[benefitenrollment.FieldEffectiveTo] = struct{}{}
}

// EffectiveToCleared returns if the "effective_to" field was cleared in this mutation.
func (m *BenefitEnrollmentMutation) EffectiveToCleared() bool {
	_, ok := m.clearedFields[benefitenrollment.FieldEffectiveTo]
	return ok
}

// ResetEffectiveTo resets all changes to the "effective_to" field.
func (m *BenefitEnrollmentMutation) ResetEffectiveTo() {
	m.effective_to = nil
	delete(m.clearedFields, benefitenrollment.FieldEffectiveTo)
}

// SetCreatedAt sets the "created_at" field.
func (m *BenefitEnrollmentMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *BenefitEnrollmentMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the BenefitEnrollment entity.
// If the BenefitEnrollment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BenefitEnrollmentMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *BenefitEnrollmentMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *BenefitEnrollmentMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *BenefitEnrollmentMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the BenefitEnrollment entity.
// If the BenefitEnrollment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BenefitEnrollmentMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *BenefitEnrollmentMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetTenantID sets the "tenant" edge to the Tenant entity by id.
func (m *BenefitEnrollmentMutation) SetTenantID(id int) {
	m.tenant = &id
}

// ClearTenant clears the "tenant" edge to the Tenant entity.
func (m *BenefitEnrollmentMutation) ClearTenant() {
	m.clearedtenant = true
}

// TenantCleared reports if the "tenant" edge to the Tenant entity was cleared.
func (m *BenefitEnrollmentMutation) TenantCleared() bool {
	return m.clearedtenant
}

// TenantID returns the "tenant" edge ID in the mutation.
func (m *BenefitEnrollmentMutation) TenantID() (id int, exists bool) {
	if m.tenant != nil {
		return *m.tenant, true
	}
	return
}

// TenantIDs returns the "tenant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TenantID instead. It exists only for internal usage by the builders.
func (m *BenefitEnrollmentMutation) TenantIDs() (ids []int) {
	if id := m.tenant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTenant resets all changes to the "tenant" edge.
func (m *BenefitEnrollmentMutation) ResetTenant() {
	m.tenant = nil
	m.clearedtenant = false
}

// SetPlanID sets the "plan" edge to the BenefitPlan entity by id.
func (m *BenefitEnrollmentMutation) SetPlanID(id int) {
	m.plan = &id
}

// ClearPlan clears the "plan" edge to the BenefitPlan entity.
func (m *BenefitEnrollmentMutation) ClearPlan() {
	m.clearedplan = true
}

// PlanCleared reports if the "plan" edge to the BenefitPlan entity was cleared.
func (m *BenefitEnrollmentMutation) PlanCleared() bool {
	return m.clearedplan
}

// PlanID returns the "plan" edge ID in the mutation.
func (m *BenefitEnrollmentMutation) PlanID() (id int, exists bool) {
	if m.plan != nil {
		return *m.plan, true
	}
	return
}

// PlanIDs returns the "plan" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PlanID instead. It exists only for internal usage by the builders.
func (m *BenefitEnrollmentMutation) PlanIDs() (ids []int) {
	if id := m.plan; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPlan resets all changes to the "plan" edge.
func (m *BenefitEnrollmentMutation) ResetPlan() {
	m.plan = nil
	m.clearedplan = false
}

// SetEmployeeID sets the "employee" edge to the Employee entity by id.
func (m *BenefitEnrollmentMutation) SetEmployeeID(id int) {
	m.employee = &id
}

// ClearEmployee clears the "employee" edge to the Employee entity.
func (m *BenefitEnrollmentMutation) ClearEmployee() {
	m.clearedemployee = true
}

// EmployeeCleared reports if the "employee" edge to the Employee entity was cleared.
func (m *BenefitEnrollmentMutation) EmployeeCleared() bool {
	return m.clearedemployee
}

// EmployeeID returns the "employee" edge ID in the mutation.
func (m *BenefitEnrollmentMutation) EmployeeID() (id int, exists bool) {
	if m.employee != nil {
		return *m.employee, true
	}
	return
}

// EmployeeIDs returns the "employee" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// EmployeeID instead. It exists only for internal usage by the builders.
func (m *BenefitEnrollmentMutation) EmployeeIDs() (ids []int) {
	if id := m.employee; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEmployee resets all changes to the "employee" edge.
func (m *BenefitEnrollmentMutation) ResetEmployee() {
	m.employee = nil
	m.clearedemployee = false
}

// Where appends a list predicates to the BenefitEnrollmentMutation builder.
func (m *BenefitEnrollmentMutation) Where(ps ...predicate.BenefitEnrollment) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the BenefitEnrollmentMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *BenefitEnrollmentMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.BenefitEnrollment, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *BenefitEnrollmentMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *BenefitEnrollmentMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (BenefitEnrollment).
func (m *BenefitEnrollmentMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *BenefitEnrollmentMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.tier != nil {
		fields = append(fields, benefitenrollment.FieldTier)
	}
	if m.employee_cost != nil {
		fields = append(fields, benefitenrollment.FieldEmployeeCost)
	}
	if m.employer_cost != nil {
		fields = append(fields, benefitenrollment.FieldEmployerCost)
	}
	if m.status != nil {
		fields = append(fields, benefitenrollment.FieldStatus)
	}
	if m.effective_from != nil {
		fields = append(fields, benefitenrollment.FieldEffectiveFrom)
	}
	if m.effective_to != nil {
		fields = append(fields, benefitenrollment.FieldEffectiveTo)
	}
	if m.created_at != nil {
		fields = append(fields, benefitenrollment.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, benefitenrollment.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *BenefitEnrollmentMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case benefitenrollment.FieldTier:
		return m.Tier()
	case benefitenrollment.FieldEmployeeCost:
		return m.EmployeeCost()
	case benefitenrollment.FieldEmployerCost:
		return m.EmployerCost()
	case benefitenrollment.FieldStatus:
		return m.Status()
	case benefitenrollment.FieldEffectiveFrom:
		return m.EffectiveFrom()
	case benefitenrollment.FieldEffectiveTo:
		return m.EffectiveTo()
	case benefitenrollment.FieldCreatedAt:
		return m.CreatedAt()
	case benefitenrollment.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *BenefitEnrollmentMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case benefitenrollment.FieldTier:
		return m.OldTier(ctx)
	case benefitenrollment.FieldEmployeeCost:
		return m.OldEmployeeCost(ctx)
	case benefitenrollment.FieldEmployerCost:
		return m.OldEmployerCost(ctx)
	case benefitenrollment.FieldStatus:
		return m.OldStatus(ctx)
	case benefitenrollment.FieldEffectiveFrom:
		return m.OldEffectiveFrom(ctx)
	case benefitenrollment.FieldEffectiveTo:
		return m.OldEffectiveTo(ctx)
	case benefitenrollment.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case benefitenrollment.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown BenefitEnrollment field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BenefitEnrollmentMutation) SetField(name string, value ent.Value) error {
	switch name {
	case benefitenrollment.FieldTier:
		v, ok := value.(benefitenrollment.Tier)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTier(v)
		return nil
	case benefitenrollment.FieldEmployeeCost:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmployeeCost(v)
		return nil
	case benefitenrollment.FieldEmployerCost:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmployerCost(v)
		return nil
	case benefitenrollment.FieldStatus:
		v, ok := value.(benefitenrollment.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case benefitenrollment.FieldEffectiveFrom:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEffectiveFrom(v)
		return nil
	case benefitenrollment.FieldEffectiveTo:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEffectiveTo(v)
		return nil
	case benefitenrollment.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case benefitenrollment.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown BenefitEnrollment field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *BenefitEnrollmentMutation) AddedFields() []string {
	var fields []string
	if m.addemployee_cost != nil {
		fields = append(fields, benefitenrollment.FieldEmployeeCost)
	}
	if m.addemployer_cost != nil {
		fields = append(fields, benefitenrollment.FieldEmployerCost)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *BenefitEnrollmentMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case benefitenrollment.FieldEmployeeCost:
		return m.AddedEmployeeCost()
	case benefitenrollment.FieldEmployerCost:
		return m.AddedEmployerCost()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BenefitEnrollmentMutation) AddField(name string, value ent.Value) error {
	switch name {
	case benefitenrollment.FieldEmployeeCost:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddEmployeeCost(v)
		return nil
	case benefitenrollment.FieldEmployerCost:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddEmployerCost(v)
		return nil
	}
	return fmt.Errorf("unknown BenefitEnrollment numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *BenefitEnrollmentMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(benefitenrollment.FieldEffectiveTo) {
		fields = append(fields, benefitenrollment.FieldEffectiveTo)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *BenefitEnrollmentMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *BenefitEnrollmentMutation) ClearField(name string) error {
	switch name {
	case benefitenrollment.FieldEffectiveTo:
		m.ClearEffectiveTo()
		return nil
	}
	return fmt.Errorf("unknown BenefitEnrollment nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *BenefitEnrollmentMutation) ResetField(name string) error {
	switch name {
	case benefitenrollment.FieldTier:
		m.ResetTier()
		return nil
	case benefitenrollment.FieldEmployeeCost:
		m.ResetEmployeeCost()
		return nil
	case benefitenrollment.FieldEmployerCost:
		m.ResetEmployerCost()
		return nil
	case benefitenrollment.FieldStatus:
		m.ResetStatus()
		return nil
	case benefitenrollment.FieldEffectiveFrom:
		m.ResetEffectiveFrom()
		return nil
	case benefitenrollment.FieldEffectiveTo:
		m.ResetEffectiveTo()
		return nil
	case benefitenrollment.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case benefitenrollment.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown BenefitEnrollment field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *BenefitEnrollmentMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.tenant != nil {
		edges = append(edges, benefitenrollment.EdgeTenant)
	}
	if m.plan != nil {
		edges = append(edges, benefitenrollment.EdgePlan)
	}
	if m.employee != nil {
		edges = append(edges, benefitenrollment.EdgeEmployee)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *BenefitEnrollmentMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case benefitenrollment.EdgeTenant:
		if id := m.tenant; id != nil {
			return []ent.Value{*id}
		}
	case benefitenrollment.EdgePlan:
		if id := m.plan; id != nil {
			return []ent.Value{*id}
		}
	case benefitenrollment.EdgeEmployee:
		if id := m.employee; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *BenefitEnrollmentMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *BenefitEnrollmentMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *BenefitEnrollmentMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedtenant {
		edges = append(edges, benefitenrollment.EdgeTenant)
	}
	if m.clearedplan {
		edges = append(edges, benefitenrollment.EdgePlan)
	}
	if m.clearedemployee {
		edges = append(edges, benefitenrollment.EdgeEmployee)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *BenefitEnrollmentMutation) EdgeCleared(name string) bool {
	switch name {
	case benefitenrollment.EdgeTenant:
		return m.clearedtenant
	case benefitenrollment.EdgePlan:
		return m.clearedplan
	case benefitenrollment.EdgeEmployee:
		return m.clearedemployee
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *BenefitEnrollmentMutation) ClearEdge(name string) error {
	switch name {
	case benefitenrollment.EdgeTenant:
		m.ClearTenant()
		return nil
	case benefitenrollment.EdgePlan:
		m.ClearPlan()
		return nil
	case benefitenrollment.EdgeEmployee:
		m.ClearEmployee()
		return nil
	}
	return fmt.Errorf("unknown BenefitEnrollment unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *BenefitEnrollmentMutation) ResetEdge(name string) error {
	switch name {
	case benefitenrollment.EdgeTenant:
		m.ResetTenant()
		return nil
	case benefitenrollment.EdgePlan:
		m.ResetPlan()
		return nil
	case benefitenrollment.EdgeEmployee:
		m.ResetEmployee()
		return nil
	}
	return fmt.Errorf("unknown BenefitEnrollment edge %s", name)
}

// BenefitPlanMutation represents an operation that mutates the BenefitPlan nodes in the graph.
type BenefitPlanMutation struct {
	config
	op                       Op
	typ                      string
	id                       *int
	name                     *string
	description              *string
	_type                    *benefitplan.Type
	status                   *benefitplan.Status
	employer_contribution    *float64
	addemployer_contribution *float64
	employee_deduction       *float64
	addemployee_deduction    *float64
	created_at               *time.Time
	updated_at               *time.Time
	clearedFields            map[string]struct{}
	tenant                   *int
	clearedtenant            bool
	enrollments              map[int]struct{}
	removedenrollments       map[int]struct{}
	clearedenrollments       bool
	done                     bool
	oldValue                 func(context.Context) (*BenefitPlan, error)
	predicates               []predicate.BenefitPlan
}

var _ ent.Mutation = (*BenefitPlanMutation)(nil)

// benefitplanOption allows management of the mutation configuration using functional options.
type benefitplanOption func(*BenefitPlanMutation)

// newBenefitPlanMutation creates new mutation for the BenefitPlan entity.
func newBenefitPlanMutation(c config, op Op, opts ...benefitplanOption) *BenefitPlanMutation {
	m := &BenefitPlanMutation{
		config:        c,
		op:            op,
		typ:           TypeBenefitPlan,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBenefitPlanID sets the ID field of the mutation.
func withBenefitPlanID(id int) benefitplanOption {
	return func(m *BenefitPlanMutation) {
		var (
			err   error
			once  sync.Once
			value *BenefitPlan
		)
		m.oldValue = func(ctx context.Context) (*BenefitPlan, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().BenefitPlan.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBenefitPlan sets the old BenefitPlan of the mutation.
func withBenefitPlan(node *BenefitPlan) benefitplanOption {
	return func(m *BenefitPlanMutation) {
		m.oldValue = func(context.Context) (*BenefitPlan, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BenefitPlanMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BenefitPlanMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *BenefitPlanMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *BenefitPlanMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().BenefitPlan.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *BenefitPlanMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *BenefitPlanMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the BenefitPlan entity.
// If the BenefitPlan object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BenefitPlanMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *BenefitPlanMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *BenefitPlanMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *BenefitPlanMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the BenefitPlan entity.
// If the BenefitPlan object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BenefitPlanMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *BenefitPlanMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[benefitplan.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *BenefitPlanMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[benefitplan.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *BenefitPlanMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, benefitplan.FieldDescription)
}

// SetType sets the "type" field.
func (m *BenefitPlanMutation) SetType(b benefitplan.Type) {
	m._type = &b
}

// GetType returns the value of the "type" field in the mutation.
func (m *BenefitPlanMutation) GetType() (r benefitplan.Type, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the BenefitPlan entity.
// If the BenefitPlan object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BenefitPlanMutation) OldType(ctx context.Context) (v benefitplan.Type, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *BenefitPlanMutation) ResetType() {
	m._type = nil
}

// SetStatus sets the "status" field.
func (m *BenefitPlanMutation) SetStatus(b benefitplan.Status) {
	m.status = &b
}

// Status returns the value of the "status" field in the mutation.
func (m *BenefitPlanMutation) Status() (r benefitplan.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the BenefitPlan entity.
// If the BenefitPlan object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BenefitPlanMutation) OldStatus(ctx context.Context) (v benefitplan.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *BenefitPlanMutation) ResetStatus() {
	m.status = nil
}

// SetEmployerContribution sets the "employer_contribution" field.
func (m *BenefitPlanMutation) SetEmployerContribution(f float64) {
	m.employer_contribution = &f
	m.addemployer_contribution = nil
}

// EmployerContribution returns the value of the "employer_contribution" field in the mutation.
func (m *BenefitPlanMutation) EmployerContribution() (r float64, exists bool) {
	v := m.employer_contribution
	if v == nil {
		return
	}
	return *v, true
}

// OldEmployerContribution returns the old "employer_contribution" field's value of the BenefitPlan entity.
// If the BenefitPlan object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BenefitPlanMutation) OldEmployerContribution(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmployerContribution is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmployerContribution requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmployerContribution: %w", err)
	}
	return oldValue.EmployerContribution, nil
}

// AddEmployerContribution adds f to the "employer_contribution" field.
func (m *BenefitPlanMutation) AddEmployerContribution(f float64) {
	if m.addemployer_contribution != nil {
		*m.addemployer_contribution += f
	} else {
		m.addemployer_contribution = &f
	}
}

// AddedEmployerContribution returns the value that was added to the "employer_contribution" field in this mutation.
func (m *BenefitPlanMutation) AddedEmployerContribution() (r float64, exists bool) {
	v := m.addemployer_contribution
	if v == nil {
		return
	}
	return *v, true
}

// ResetEmployerContribution resets all changes to the "employer_contribution" field.
func (m *BenefitPlanMutation) ResetEmployerContribution() {
	m.employer_contribution = nil
	m.addemployer_contribution = nil
}

// SetEmployeeDeduction sets the "employee_deduction" field.
func (m *BenefitPlanMutation) SetEmployeeDeduction(f float64) {
	m.employee_deduction = &f
	m.addemployee_deduction = nil
}

// EmployeeDeduction returns the value of the "employee_deduction" field in the mutation.
func (m *BenefitPlanMutation) EmployeeDeduction() (r float64, exists bool) {
	v := m.employee_deduction
	if v == nil {
		return
	}
	return *v, true
}

// OldEmployeeDeduction returns the old "employee_deduction" field's value of the BenefitPlan entity.
// If the BenefitPlan object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BenefitPlanMutation) OldEmployeeDeduction(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmployeeDeduction is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmployeeDeduction requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmployeeDeduction: %w", err)
	}
	return oldValue.EmployeeDeduction, nil
}

// AddEmployeeDeduction adds f to the "employee_deduction" field.
func (m *BenefitPlanMutation) AddEmployeeDeduction(f float64) {
	if m.addemployee_deduction != nil {
		*m.addemployee_deduction += f
	} else {
		m.addemployee_deduction = &f
	}
}

// AddedEmployeeDeduction returns the value that was added to the "employee_deduction" field in this mutation.
func (m *BenefitPlanMutation) AddedEmployeeDeduction() (r float64, exists bool) {
	v := m.addemployee_deduction
	if v == nil {
		return
	}
	return *v, true
}

// ResetEmployeeDeduction resets all changes to the "employee_deduction" field.
func (m *BenefitPlanMutation) ResetEmployeeDeduction() {
	m.employee_deduction = nil
	m.addemployee_deduction = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *BenefitPlanMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *BenefitPlanMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the BenefitPlan entity.
// If the BenefitPlan object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BenefitPlanMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *BenefitPlanMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *BenefitPlanMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *BenefitPlanMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the BenefitPlan entity.
// If the BenefitPlan object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BenefitPlanMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *BenefitPlanMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetTenantID sets the "tenant" edge to the Tenant entity by id.
func (m *BenefitPlanMutation) SetTenantID(id int) {
	m.tenant = &id
}

// ClearTenant clears the "tenant" edge to the Tenant entity.
func (m *BenefitPlanMutation) ClearTenant() {
	m.clearedtenant = true
}

// TenantCleared reports if the "tenant" edge to the Tenant entity was cleared.
func (m *BenefitPlanMutation) TenantCleared() bool {
	return m.clearedtenant
}

// TenantID returns the "tenant" edge ID in the mutation.
func (m *BenefitPlanMutation) TenantID() (id int, exists bool) {
	if m.tenant != nil {
		return *m.tenant, true
	}
	return
}

// TenantIDs returns the "tenant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TenantID instead. It exists only for internal usage by the builders.
func (m *BenefitPlanMutation) TenantIDs() (ids []int) {
	if id := m.tenant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTenant resets all changes to the "tenant" edge.
func (m *BenefitPlanMutation) ResetTenant() {
	m.tenant = nil
	m.clearedtenant = false
}

// AddEnrollmentIDs adds the "enrollments" edge to the BenefitEnrollment entity by ids.
func (m *BenefitPlanMutation) AddEnrollmentIDs(ids ...int) {
	if m.enrollments == nil {
		m.enrollments = make(map[int]struct{})
	}
	for i := range ids {
		m.enrollments[ids[i]] = struct{}{}
	}
}

// ClearEnrollments clears the "enrollments" edge to the BenefitEnrollment entity.
func (m *BenefitPlanMutation) ClearEnrollments() {
	m.clearedenrollments = true
}

// EnrollmentsCleared reports if the "enrollments" edge to the BenefitEnrollment entity was cleared.
func (m *BenefitPlanMutation) EnrollmentsCleared() bool {
	return m.clearedenrollments
}

// RemoveEnrollmentIDs removes the "enrollments" edge to the BenefitEnrollment entity by IDs.
func (m *BenefitPlanMutation) RemoveEnrollmentIDs(ids ...int) {
	if m.removedenrollments == nil {
		m.removedenrollments = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.enrollments, ids[i])
		m.removedenrollments[ids[i]] = struct{}{}
	}
}

// RemovedEnrollments returns the removed IDs of the "enrollments" edge to the BenefitEnrollment entity.
func (m *BenefitPlanMutation) RemovedEnrollmentsIDs() (ids []int) {
	for id := range m.removedenrollments {
		ids = append(ids, id)
	}
	return
}

// EnrollmentsIDs returns the "enrollments" edge IDs in the mutation.
func (m *BenefitPlanMutation) EnrollmentsIDs() (ids []int) {
	for id := range m.enrollments {
		ids = append(ids, id)
	}
	return
}

// ResetEnrollments resets all changes to the "enrollments" edge.
func (m *BenefitPlanMutation) ResetEnrollments() {
	m.enrollments = nil
	m.clearedenrollments = false
	m.removedenrollments = nil
}

// Where appends a list predicates to the BenefitPlanMutation builder.
func (m *BenefitPlanMutation) Where(ps ...predicate.BenefitPlan) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the BenefitPlanMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *BenefitPlanMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.BenefitPlan, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *BenefitPlanMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *BenefitPlanMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (BenefitPlan).
func (m *BenefitPlanMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *BenefitPlanMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.name != nil {
		fields = append(fields, benefitplan.FieldName)
	}
	if m.description != nil {
		fields = append(fields, benefitplan.FieldDescription)
	}
	if m._type != nil {
		fields = append(fields, benefitplan.FieldType)
	}
	if m.status != nil {
		fields = append(fields, benefitplan.FieldStatus)
	}
	if m.employer_contribution != nil {
		fields = append(fields, benefitplan.FieldEmployerContribution)
	}
	if m.employee_deduction != nil {
		fields = append(fields, benefitplan.FieldEmployeeDeduction)
	}
	if m.created_at != nil {
		fields = append(fields, benefitplan.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, benefitplan.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *BenefitPlanMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case benefitplan.FieldName:
		return m.Name()
	case benefitplan.FieldDescription:
		return m.Description()
	case benefitplan.FieldType:
		return m.GetType()
	case benefitplan.FieldStatus:
		return m.Status()
	case benefitplan.FieldEmployerContribution:
		return m.EmployerContribution()
	case benefitplan.FieldEmployeeDeduction:
		return m.EmployeeDeduction()
	case benefitplan.FieldCreatedAt:
		return m.CreatedAt()
	case benefitplan.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *BenefitPlanMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case benefitplan.FieldName:
		return m.OldName(ctx)
	case benefitplan.FieldDescription:
		return m.OldDescription(ctx)
	case benefitplan.FieldType:
		return m.OldType(ctx)
	case benefitplan.FieldStatus:
		return m.OldStatus(ctx)
	case benefitplan.FieldEmployerContribution:
		return m.OldEmployerContribution(ctx)
	case benefitplan.FieldEmployeeDeduction:
		return m.OldEmployeeDeduction(ctx)
	case benefitplan.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case benefitplan.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown BenefitPlan field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BenefitPlanMutation) SetField(name string, value ent.Value) error {
	switch name {
	case benefitplan.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case benefitplan.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case benefitplan.FieldType:
		v, ok := value.(benefitplan.Type)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case benefitplan.FieldStatus:
		v, ok := value.(benefitplan.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case benefitplan.FieldEmployerContribution:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmployerContribution(v)
		return nil
	case benefitplan.FieldEmployeeDeduction:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmployeeDeduction(v)
		return nil
	case benefitplan.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case benefitplan.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown BenefitPlan field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *BenefitPlanMutation) AddedFields() []string {
	var fields []string
	if m.addemployer_contribution != nil {
		fields = append(fields, benefitplan.FieldEmployerContribution)
	}
	if m.addemployee_deduction != nil {
		fields = append(fields, benefitplan.FieldEmployeeDeduction)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *BenefitPlanMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case benefitplan.FieldEmployerContribution:
		return m.AddedEmployerContribution()
	case benefitplan.FieldEmployeeDeduction:
		return m.AddedEmployeeDeduction()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BenefitPlanMutation) AddField(name string, value ent.Value) error {
	switch name {
	case benefitplan.FieldEmployerContribution:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddEmployerContribution(v)
		return nil
	case benefitplan.FieldEmployeeDeduction:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddEmployeeDeduction(v)
		return nil
	}
	return fmt.Errorf("unknown BenefitPlan numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *BenefitPlanMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(benefitplan.FieldDescription) {
		fields = append(fields, benefitplan.FieldDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *BenefitPlanMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *BenefitPlanMutation) ClearField(name string) error {
	switch name {
	case benefitplan.FieldDescription:
		m.ClearDescription()
		return nil
	}
	return fmt.Errorf("unknown BenefitPlan nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *BenefitPlanMutation) ResetField(name string) error {
	switch name {
	case benefitplan.FieldName:
		m.ResetName()
		return nil
	case benefitplan.FieldDescription:
		m.ResetDescription()
		return nil
	case benefitplan.FieldType:
		m.ResetType()
		return nil
	case benefitplan.FieldStatus:
		m.ResetStatus()
		return nil
	case benefitplan.FieldEmployerContribution:
		m.ResetEmployerContribution()
		return nil
	case benefitplan.FieldEmployeeDeduction:
		m.ResetEmployeeDeduction()
		return nil
	case benefitplan.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case benefitplan.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown BenefitPlan field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *BenefitPlanMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.tenant != nil {
		edges = append(edges, benefitplan.EdgeTenant)
	}
	if m.enrollments != nil {
		edges = append(edges, benefitplan.EdgeEnrollments)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *BenefitPlanMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case benefitplan.EdgeTenant:
		if id := m.tenant; id != nil {
			return []ent.Value{*id}
		}
	case benefitplan.EdgeEnrollments:
		ids := make([]ent.Value, 0, len(m.enrollments))
		for id := range m.enrollments {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *BenefitPlanMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedenrollments != nil {
		edges = append(edges, benefitplan.EdgeEnrollments)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *BenefitPlanMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case benefitplan.EdgeEnrollments:
		ids := make([]ent.Value, 0, len(m.removedenrollments))
		for id := range m.removedenrollments {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *BenefitPlanMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedtenant {
		edges = append(edges, benefitplan.EdgeTenant)
	}
	if m.clearedenrollments {
		edges = append(edges, benefitplan.EdgeEnrollments)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *BenefitPlanMutation) EdgeCleared(name string) bool {
	switch name {
	case benefitplan.EdgeTenant:
		return m.clearedtenant
	case benefitplan.EdgeEnrollments:
		return m.clearedenrollments
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *BenefitPlanMutation) ClearEdge(name string) error {
	switch name {
	case benefitplan.EdgeTenant:
		m.ClearTenant()
		return nil
	}
	return fmt.Errorf("unknown BenefitPlan unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *BenefitPlanMutation) ResetEdge(name string) error {
	switch name {
	case benefitplan.EdgeTenant:
		m.ResetTenant()
		return nil
	case benefitplan.EdgeEnrollments:
		m.ResetEnrollments()
		return nil
	}
	return fmt.Errorf("unknown BenefitPlan edge %s", name)
}

// BudgetForecastMutation represents an operation that mutates the BudgetForecast nodes in the graph.
type BudgetForecastMutation struct {
	config
	op               Op
	typ              string
	id               *int
	year             *int
	addyear          *int
	month            *int
	addmonth         *int
	projected_amount *decimal.Decimal
	actual_spent     *decimal.Decimal
	forecast_data    *map[string]interface{}
	created_at       *time.Time
	clearedFields    map[string]struct{}
	tenant           *int
	clearedtenant    bool
	done             bool
	oldValue         func(context.Context) (*BudgetForecast, error)
	predicates       []predicate.BudgetForecast
}

var _ ent.Mutation = (*BudgetForecastMutation)(nil)

// budgetforecastOption allows management of the mutation configuration using functional options.
type budgetforecastOption func(*BudgetForecastMutation)

// newBudgetForecastMutation creates new mutation for the BudgetForecast entity.
func newBudgetForecastMutation(c config, op Op, opts ...budgetforecastOption) *BudgetForecastMutation {
	m := &BudgetForecastMutation{
		config:        c,
		op:            op,
		typ:           TypeBudgetForecast,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBudgetForecastID sets the ID field of the mutation.
func withBudgetForecastID(id int) budgetforecastOption {
	return func(m *BudgetForecastMutation) {
		var (
			err   error
			once  sync.Once
			value *BudgetForecast
		)
		m.oldValue = func(ctx context.Context) (*BudgetForecast, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().BudgetForecast.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBudgetForecast sets the old BudgetForecast of the mutation.
func withBudgetForecast(node *BudgetForecast) budgetforecastOption {
	return func(m *BudgetForecastMutation) {
		m.oldValue = func(context.Context) (*BudgetForecast, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BudgetForecastMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BudgetForecastMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *BudgetForecastMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *BudgetForecastMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().BudgetForecast.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetYear sets the "year" field.
func (m *BudgetForecastMutation) SetYear(i int) {
	m.year = &i
	m.addyear = nil
}

// Year returns the value of the "year" field in the mutation.
func (m *BudgetForecastMutation) Year() (r int, exists bool) {
	v := m.year
	if v == nil {
		return
	}
	return *v, true
}

// OldYear returns the old "year" field's value of the BudgetForecast entity.
// If the BudgetForecast object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BudgetForecastMutation) OldYear(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldYear is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldYear requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldYear: %w", err)
	}
	return oldValue.Year, nil
}

// AddYear adds i to the "year" field.
func (m *BudgetForecastMutation) AddYear(i int) {
	if m.addyear != nil {
		*m.addyear += i
	} else {
		m.addyear = &i
	}
}

// AddedYear returns the value that was added to the "year" field in this mutation.
func (m *BudgetForecastMutation) AddedYear() (r int, exists bool) {
	v := m.addyear
	if v == nil {
		return
	}
	return *v, true
}

// ResetYear resets all changes to the "year" field.
func (m *BudgetForecastMutation) ResetYear() {
	m.year = nil
	m.addyear = nil
}

// SetMonth sets the "month" field.
func (m *BudgetForecastMutation) SetMonth(i int) {
	m.month = &i
	m.addmonth = nil
}

// Month returns the value of the "month" field in the mutation.
func (m *BudgetForecastMutation) Month() (r int, exists bool) {
	v := m.month
	if v == nil {
		return
	}
	return *v, true
}

// OldMonth returns the old "month" field's value of the BudgetForecast entity.
// If the BudgetForecast object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BudgetForecastMutation) OldMonth(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMonth is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMonth requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMonth: %w", err)
	}
	return oldValue.Month, nil
}

// AddMonth adds i to the "month" field.
func (m *BudgetForecastMutation) AddMonth(i int) {
	if m.addmonth != nil {
		*m.addmonth += i
	} else {
		m.addmonth = &i
	}
}

// AddedMonth returns the value that was added to the "month" field in this mutation.
func (m *BudgetForecastMutation) AddedMonth() (r int, exists bool) {
	v := m.addmonth
	if v == nil {
		return
	}
	return *v, true
}

// ResetMonth resets all changes to the "month" field.
func (m *BudgetForecastMutation) ResetMonth() {
	m.month = nil
	m.addmonth = nil
}

// SetProjectedAmount sets the "projected_amount" field.
func (m *BudgetForecastMutation) SetProjectedAmount(d decimal.Decimal) {
	m.projected_amount = &d
}

// ProjectedAmount returns the value of the "projected_amount" field in the mutation.
func (m *BudgetForecastMutation) ProjectedAmount() (r decimal.Decimal, exists bool) {
	v := m.projected_amount
	if v == nil {
		return
	}
	return *v, true
}

// OldProjectedAmount returns the old "projected_amount" field's value of the BudgetForecast entity.
// If the BudgetForecast object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BudgetForecastMutation) OldProjectedAmount(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProjectedAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProjectedAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProjectedAmount: %w", err)
	}
	return oldValue.ProjectedAmount, nil
}

// ResetProjectedAmount resets all changes to the "projected_amount" field.
func (m *BudgetForecastMutation) ResetProjectedAmount() {
	m.projected_amount = nil
}

// SetActualSpent sets the "actual_spent" field.
func (m *BudgetForecastMutation) SetActualSpent(d decimal.Decimal) {
	m.actual_spent = &d
}

// ActualSpent returns the value of the "actual_spent" field in the mutation.
func (m *BudgetForecastMutation) ActualSpent() (r decimal.Decimal, exists bool) {
	v := m.actual_spent
	if v == nil {
		return
	}
	return *v, true
}

// OldActualSpent returns the old "actual_spent" field's value of the BudgetForecast entity.
// If the BudgetForecast object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BudgetForecastMutation) OldActualSpent(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldActualSpent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldActualSpent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldActualSpent: %w", err)
	}
	return oldValue.ActualSpent, nil
}

// ResetActualSpent resets all changes to the "actual_spent" field.
func (m *BudgetForecastMutation) ResetActualSpent() {
	m.actual_spent = nil
}

// SetForecastData sets the "forecast_data" field.
func (m *BudgetForecastMutation) SetForecastData(value map[string]interface{}) {
	m.forecast_data = &value
}

// ForecastData returns the value of the "forecast_data" field in the mutation.
func (m *BudgetForecastMutation) ForecastData() (r map[string]interface{}, exists bool) {
	v := m.forecast_data
	if v == nil {
		return
	}
	return *v, true
}

// OldForecastData returns the old "forecast_data" field's value of the BudgetForecast entity.
// If the BudgetForecast object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BudgetForecastMutation) OldForecastData(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldForecastData is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldForecastData requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldForecastData: %w", err)
	}
	return oldValue.ForecastData, nil
}

// ClearForecastData clears the value of the "forecast_data" field.
func (m *BudgetForecastMutation) ClearForecastData() {
	m.forecast_data = nil
	m.clearedFields[budgetforecast.FieldForecastData] = struct{}{}
}

// ForecastDataCleared returns if the "forecast_data" field was cleared in this mutation.
func (m *BudgetForecastMutation) ForecastDataCleared() bool {
	_, ok := m.clearedFields[budgetforecast.FieldForecastData]
	return ok
}

// ResetForecastData resets all changes to the "forecast_data" field.
func (m *BudgetForecastMutation) ResetForecastData() {
	m.forecast_data = nil
	delete(m.clearedFields, budgetforecast.FieldForecastData)
}

// SetCreatedAt sets the "created_at" field.
func (m *BudgetForecastMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *BudgetForecastMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the BudgetForecast entity.
// If the BudgetForecast object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BudgetForecastMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *BudgetForecastMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetTenantID sets the "tenant" edge to the Tenant entity by id.
func (m *BudgetForecastMutation) SetTenantID(id int) {
	m.tenant = &id
}

// ClearTenant clears the "tenant" edge to the Tenant entity.
func (m *BudgetForecastMutation) ClearTenant() {
	m.clearedtenant = true
}

// TenantCleared reports if the "tenant" edge to the Tenant entity was cleared.
func (m *BudgetForecastMutation) TenantCleared() bool {
	return m.clearedtenant
}

// TenantID returns the "tenant" edge ID in the mutation.
func (m *BudgetForecastMutation) TenantID() (id int, exists bool) {
	if m.tenant != nil {
		return *m.tenant, true
	}
	return
}

// TenantIDs returns the "tenant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TenantID instead. It exists only for internal usage by the builders.
func (m *BudgetForecastMutation) TenantIDs() (ids []int) {
	if id := m.tenant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTenant resets all changes to the "tenant" edge.
func (m *BudgetForecastMutation) ResetTenant() {
	m.tenant = nil
	m.clearedtenant = false
}

// Where appends a list predicates to the BudgetForecastMutation builder.
func (m *BudgetForecastMutation) Where(ps ...predicate.BudgetForecast) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the BudgetForecastMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *BudgetForecastMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.BudgetForecast, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *BudgetForecastMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *BudgetForecastMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (BudgetForecast).
func (m *BudgetForecastMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *BudgetForecastMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.year != nil {
		fields = append(fields, budgetforecast.FieldYear)
	}
	if m.month != nil {
		fields = append(fields, budgetforecast.FieldMonth)
	}
	if m.projected_amount != nil {
		fields = append(fields, budgetforecast.FieldProjectedAmount)
	}
	if m.actual_spent != nil {
		fields = append(fields, budgetforecast.FieldActualSpent)
	}
	if m.forecast_data != nil {
		fields = append(fields, budgetforecast.FieldForecastData)
	}
	if m.created_at != nil {
		fields = append(fields, budgetforecast.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *BudgetForecastMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case budgetforecast.FieldYear:
		return m.Year()
	case budgetforecast.FieldMonth:
		return m.Month()
	case budgetforecast.FieldProjectedAmount:
		return m.ProjectedAmount()
	case budgetforecast.FieldActualSpent:
		return m.ActualSpent()
	case budgetforecast.FieldForecastData:
		return m.ForecastData()
	case budgetforecast.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *BudgetForecastMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case budgetforecast.FieldYear:
		return m.OldYear(ctx)
	case budgetforecast.FieldMonth:
		return m.OldMonth(ctx)
	case budgetforecast.FieldProjectedAmount:
		return m.OldProjectedAmount(ctx)
	case budgetforecast.FieldActualSpent:
		return m.OldActualSpent(ctx)
	case budgetforecast.FieldForecastData:
		return m.OldForecastData(ctx)
	case budgetforecast.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown BudgetForecast field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BudgetForecastMutation) SetField(name string, value ent.Value) error {
	switch name {
	case budgetforecast.FieldYear:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetYear(v)
		return nil
	case budgetforecast.FieldMonth:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMonth(v)
		return nil
	case budgetforecast.FieldProjectedAmount:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProjectedAmount(v)
		return nil
	case budgetforecast.FieldActualSpent:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetActualSpent(v)
		return nil
	case budgetforecast.FieldForecastData:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetForecastData(v)
		return nil
	case budgetforecast.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown BudgetForecast field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *BudgetForecastMutation) AddedFields() []string {
	var fields []string
	if m.addyear != nil {
		fields = append(fields, budgetforecast.FieldYear)
	}
	if m.addmonth != nil {
		fields = append(fields, budgetforecast.FieldMonth)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *BudgetForecastMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case budgetforecast.FieldYear:
		return m.AddedYear()
	case budgetforecast.FieldMonth:
		return m.AddedMonth()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BudgetForecastMutation) AddField(name string, value ent.Value) error {
	switch name {
	case budgetforecast.FieldYear:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddYear(v)
		return nil
	case budgetforecast.FieldMonth:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMonth(v)
		return nil
	}
	return fmt.Errorf("unknown BudgetForecast numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *BudgetForecastMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(budgetforecast.FieldForecastData) {
		fields = append(fields, budgetforecast.FieldForecastData)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *BudgetForecastMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *BudgetForecastMutation) ClearField(name string) error {
	switch name {
	case budgetforecast.FieldForecastData:
		m.ClearForecastData()
		return nil
	}
	return fmt.Errorf("unknown BudgetForecast nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *BudgetForecastMutation) ResetField(name string) error {
	switch name {
	case budgetforecast.FieldYear:
		m.ResetYear()
		return nil
	case budgetforecast.FieldMonth:
		m.ResetMonth()
		return nil
	case budgetforecast.FieldProjectedAmount:
		m.ResetProjectedAmount()
		return nil
	case budgetforecast.FieldActualSpent:
		m.ResetActualSpent()
		return nil
	case budgetforecast.FieldForecastData:
		m.ResetForecastData()
		return nil
	case budgetforecast.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown BudgetForecast field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *BudgetForecastMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.tenant != nil {
		edges = append(edges, budgetforecast.EdgeTenant)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *BudgetForecastMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case budgetforecast.EdgeTenant:
		if id := m.tenant; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *BudgetForecastMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *BudgetForecastMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *BudgetForecastMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedtenant {
		edges = append(edges, budgetforecast.EdgeTenant)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *BudgetForecastMutation) EdgeCleared(name string) bool {
	switch name {
	case budgetforecast.EdgeTenant:
		return m.clearedtenant
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *BudgetForecastMutation) ClearEdge(name string) error {
	switch name {
	case budgetforecast.EdgeTenant:
		m.ClearTenant()
		return nil
	}
	return fmt.Errorf("unknown BudgetForecast unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *BudgetForecastMutation) ResetEdge(name string) error {
	switch name {
	case budgetforecast.EdgeTenant:
		m.ResetTenant()
		return nil
	}
	return fmt.Errorf("unknown BudgetForecast edge %s", name)
}

// CallLogMutation represents an operation that mutates the CallLog nodes in the graph.
type CallLogMutation struct {
	config
	op             Op
	typ            string
	id             *int
	caller         *string
	callee         *string
	direction      *calllog.Direction
	start_time     *time.Time
	end_time       *time.Time
	duration       *int
	addduration    *int
	status         *string
	recording_path *string
	transcript     *string
	clearedFields  map[string]struct{}
	tenant         *int
	clearedtenant  bool
	user           *int
	cleareduser    bool
	done           bool
	oldValue       func(context.Context) (*CallLog, error)
	predicates     []predicate.CallLog
}

var _ ent.Mutation = (*CallLogMutation)(nil)

// calllogOption allows management of the mutation configuration using functional options.
type calllogOption func(*CallLogMutation)

// newCallLogMutation creates new mutation for the CallLog entity.
func newCallLogMutation(c config, op Op, opts ...calllogOption) *CallLogMutation {
	m := &CallLogMutation{
		config:        c,
		op:            op,
		typ:           TypeCallLog,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCallLogID sets the ID field of the mutation.
func withCallLogID(id int) calllogOption {
	return func(m *CallLogMutation) {
		var (
			err   error
			once  sync.Once
			value *CallLog
		)
		m.oldValue = func(ctx context.Context) (*CallLog, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CallLog.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCallLog sets the old CallLog of the mutation.
func withCallLog(node *CallLog) calllogOption {
	return func(m *CallLogMutation) {
		m.oldValue = func(context.Context) (*CallLog, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CallLogMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CallLogMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CallLogMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CallLogMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().CallLog.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCaller sets the "caller" field.
func (m *CallLogMutation) SetCaller(s string) {
	m.caller = &s
}

// Caller returns the value of the "caller" field in the mutation.
func (m *CallLogMutation) Caller() (r string, exists bool) {
	v := m.caller
	if v == nil {
		return
	}
	return *v, true
}

// OldCaller returns the old "caller" field's value of the CallLog entity.
// If the CallLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CallLogMutation) OldCaller(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCaller is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCaller requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCaller: %w", err)
	}
	return oldValue.Caller, nil
}

// ResetCaller resets all changes to the "caller" field.
func (m *CallLogMutation) ResetCaller() {
	m.caller = nil
}

// SetCallee sets the "callee" field.
func (m *CallLogMutation) SetCallee(s string) {
	m.callee = &s
}

// Callee returns the value of the "callee" field in the mutation.
func (m *CallLogMutation) Callee() (r string, exists bool) {
	v := m.callee
	if v == nil {
		return
	}
	return *v, true
}

// OldCallee returns the old "callee" field's value of the CallLog entity.
// If the CallLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CallLogMutation) OldCallee(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCallee is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCallee requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCallee: %w", err)
	}
	return oldValue.Callee, nil
}

// ResetCallee resets all changes to the "callee" field.
func (m *CallLogMutation) ResetCallee() {
	m.callee = nil
}

// SetDirection sets the "direction" field.
func (m *CallLogMutation) SetDirection(c calllog.Direction) {
	m.direction = &c
}

// Direction returns the value of the "direction" field in the mutation.
func (m *CallLogMutation) Direction() (r calllog.Direction, exists bool) {
	v := m.direction
	if v == nil {
		return
	}
	return *v, true
}

// OldDirection returns the old "direction" field's value of the CallLog entity.
// If the CallLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CallLogMutation) OldDirection(ctx context.Context) (v calllog.Direction, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDirection is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDirection requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDirection: %w", err)
	}
	return oldValue.Direction, nil
}

// ResetDirection resets all changes to the "direction" field.
func (m *CallLogMutation) ResetDirection() {
	m.direction = nil
}

// SetStartTime sets the "start_time" field.
func (m *CallLogMutation) SetStartTime(t time.Time) {
	m.start_time = &t
}

// StartTime returns the value of the "start_time" field in the mutation.
func (m *CallLogMutation) StartTime() (r time.Time, exists bool) {
	v := m.start_time
	if v == nil {
		return
	}
	return *v, true
}

// OldStartTime returns the old "start_time" field's value of the CallLog entity.
// If the CallLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CallLogMutation) OldStartTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartTime: %w", err)
	}
	return oldValue.StartTime, nil
}

// ResetStartTime resets all changes to the "start_time" field.
func (m *CallLogMutation) ResetStartTime() {
	m.start_time = nil
}

// SetEndTime sets the "end_time" field.
func (m *CallLogMutation) SetEndTime(t time.Time) {
	m.end_time = &t
}

// EndTime returns the value of the "end_time" field in the mutation.
func (m *CallLogMutation) EndTime() (r time.Time, exists bool) {
	v := m.end_time
	if v == nil {
		return
	}
	return *v, true
}

// OldEndTime returns the old "end_time" field's value of the CallLog entity.
// If the CallLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CallLogMutation) OldEndTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEndTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEndTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndTime: %w", err)
	}
	return oldValue.EndTime, nil
}

// ClearEndTime clears the value of the "end_time" field.
func (m *CallLogMutation) ClearEndTime() {
	m.end_time = nil
	m.clearedFields[calllog.FieldEndTime] = struct{}{}
}

// EndTimeCleared returns if the "end_time" field was cleared in this mutation.
func (m *CallLogMutation) EndTimeCleared() bool {
	_, ok := m.clearedFields[calllog.FieldEndTime]
	return ok
}

// ResetEndTime resets all changes to the "end_time" field.
func (m *CallLogMutation) ResetEndTime() {
	m.end_time = nil
	delete(m.clearedFields, calllog.FieldEndTime)
}

// SetDuration sets the "duration" field.
func (m *CallLogMutation) SetDuration(i int) {
	m.duration = &i
	m.addduration = nil
}

// Duration returns the value of the "duration" field in the mutation.
func (m *CallLogMutation) Duration() (r int, exists bool) {
	v := m.duration
	if v == nil {
		return
	}
	return *v, true
}

// OldDuration returns the old "duration" field's value of the CallLog entity.
// If the CallLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CallLogMutation) OldDuration(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDuration is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDuration requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDuration: %w", err)
	}
	return oldValue.Duration, nil
}

// AddDuration adds i to the "duration" field.
func (m *CallLogMutation) AddDuration(i int) {
	if m.addduration != nil {
		*m.addduration += i
	} else {
		m.addduration = &i
	}
}

// AddedDuration returns the value that was added to the "duration" field in this mutation.
func (m *CallLogMutation) AddedDuration() (r int, exists bool) {
	v := m.addduration
	if v == nil {
		return
	}
	return *v, true
}

// ResetDuration resets all changes to the "duration" field.
func (m *CallLogMutation) ResetDuration() {
	m.duration = nil
	m.addduration = nil
}

// SetStatus sets the "status" field.
func (m *CallLogMutation) SetStatus(s string) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *CallLogMutation) Status() (r string, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the CallLog entity.
// If the CallLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CallLogMutation) OldStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *CallLogMutation) ResetStatus() {
	m.status = nil
}

// SetRecordingPath sets the "recording_path" field.
func (m *CallLogMutation) SetRecordingPath(s string) {
	m.recording_path = &s
}

// RecordingPath returns the value of the "recording_path" field in the mutation.
func (m *CallLogMutation) RecordingPath() (r string, exists bool) {
	v := m.recording_path
	if v == nil {
		return
	}
	return *v, true
}

// OldRecordingPath returns the old "recording_path" field's value of the CallLog entity.
// If the CallLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CallLogMutation) OldRecordingPath(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRecordingPath is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRecordingPath requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRecordingPath: %w", err)
	}
	return oldValue.RecordingPath, nil
}

// ClearRecordingPath clears the value of the "recording_path" field.
func (m *CallLogMutation) ClearRecordingPath() {
	m.recording_path = nil
	m.clearedFields[calllog.FieldRecordingPath] = struct{}{}
}

// RecordingPathCleared returns if the "recording_path" field was cleared in this mutation.
func (m *CallLogMutation) RecordingPathCleared() bool {
	_, ok := m.clearedFields[calllog.FieldRecordingPath]
	return ok
}

// ResetRecordingPath resets all changes to the "recording_path" field.
func (m *CallLogMutation) ResetRecordingPath() {
	m.recording_path = nil
	delete(m.clearedFields, calllog.FieldRecordingPath)
}

// SetTranscript sets the "transcript" field.
func (m *CallLogMutation) SetTranscript(s string) {
	m.transcript = &s
}

// Transcript returns the value of the "transcript" field in the mutation.
func (m *CallLogMutation) Transcript() (r string, exists bool) {
	v := m.transcript
	if v == nil {
		return
	}
	return *v, true
}

// OldTranscript returns the old "transcript" field's value of the CallLog entity.
// If the CallLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CallLogMutation) OldTranscript(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTranscript is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTranscript requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTranscript: %w", err)
	}
	return oldValue.Transcript, nil
}

// ClearTranscript clears the value of the "transcript" field.
func (m *CallLogMutation) ClearTranscript() {
	m.transcript = nil
	m.clearedFields[calllog.FieldTranscript] = struct{}{}
}

// TranscriptCleared returns if the "transcript" field was cleared in this mutation.
func (m *CallLogMutation) TranscriptCleared() bool {
	_, ok := m.clearedFields[calllog.FieldTranscript]
	return ok
}

// ResetTranscript resets all changes to the "transcript" field.
func (m *CallLogMutation) ResetTranscript() {
	m.transcript = nil
	delete(m.clearedFields, calllog.FieldTranscript)
}

// SetTenantID sets the "tenant" edge to the Tenant entity by id.
func (m *CallLogMutation) SetTenantID(id int) {
	m.tenant = &id
}

// ClearTenant clears the "tenant" edge to the Tenant entity.
func (m *CallLogMutation) ClearTenant() {
	m.clearedtenant = true
}

// TenantCleared reports if the "tenant" edge to the Tenant entity was cleared.
func (m *CallLogMutation) TenantCleared() bool {
	return m.clearedtenant
}

// TenantID returns the "tenant" edge ID in the mutation.
func (m *CallLogMutation) TenantID() (id int, exists bool) {
	if m.tenant != nil {
		return *m.tenant, true
	}
	return
}

// TenantIDs returns the "tenant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TenantID instead. It exists only for internal usage by the builders.
func (m *CallLogMutation) TenantIDs() (ids []int) {
	if id := m.tenant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTenant resets all changes to the "tenant" edge.
func (m *CallLogMutation) ResetTenant() {
	m.tenant = nil
	m.clearedtenant = false
}

// SetUserID sets the "user" edge to the User entity by id.
func (m *CallLogMutation) SetUserID(id int) {
	m.user = &id
}

// ClearUser clears the "user" edge to the User entity.
func (m *CallLogMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *CallLogMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *CallLogMutation) UserID() (id int, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *CallLogMutation) UserIDs() (ids []int) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *CallLogMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the CallLogMutation builder.
func (m *CallLogMutation) Where(ps ...predicate.CallLog) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CallLogMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CallLogMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.CallLog, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CallLogMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CallLogMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (CallLog).
func (m *CallLogMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CallLogMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.caller != nil {
		fields = append(fields, calllog.FieldCaller)
	}
	if m.callee != nil {
		fields = append(fields, calllog.FieldCallee)
	}
	if m.direction != nil {
		fields = append(fields, calllog.FieldDirection)
	}
	if m.start_time != nil {
		fields = append(fields, calllog.FieldStartTime)
	}
	if m.end_time != nil {
		fields = append(fields, calllog.FieldEndTime)
	}
	if m.duration != nil {
		fields = append(fields, calllog.FieldDuration)
	}
	if m.status != nil {
		fields = append(fields, calllog.FieldStatus)
	}
	if m.recording_path != nil {
		fields = append(fields, calllog.FieldRecordingPath)
	}
	if m.transcript != nil {
		fields = append(fields, calllog.FieldTranscript)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CallLogMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case calllog.FieldCaller:
		return m.Caller()
	case calllog.FieldCallee:
		return m.Callee()
	case calllog.FieldDirection:
		return m.Direction()
	case calllog.FieldStartTime:
		return m.StartTime()
	case calllog.FieldEndTime:
		return m.EndTime()
	case calllog.FieldDuration:
		return m.Duration()
	case calllog.FieldStatus:
		return m.Status()
	case calllog.FieldRecordingPath:
		return m.RecordingPath()
	case calllog.FieldTranscript:
		return m.Transcript()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CallLogMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case calllog.FieldCaller:
		return m.OldCaller(ctx)
	case calllog.FieldCallee:
		return m.OldCallee(ctx)
	case calllog.FieldDirection:
		return m.OldDirection(ctx)
	case calllog.FieldStartTime:
		return m.OldStartTime(ctx)
	case calllog.FieldEndTime:
		return m.OldEndTime(ctx)
	case calllog.FieldDuration:
		return m.OldDuration(ctx)
	case calllog.FieldStatus:
		return m.OldStatus(ctx)
	case calllog.FieldRecordingPath:
		return m.OldRecordingPath(ctx)
	case calllog.FieldTranscript:
		return m.OldTranscript(ctx)
	}
	return nil, fmt.Errorf("unknown CallLog field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CallLogMutation) SetField(name string, value ent.Value) error {
	switch name {
	case calllog.FieldCaller:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCaller(v)
		return nil
	case calllog.FieldCallee:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCallee(v)
		return nil
	case calllog.FieldDirection:
		v, ok := value.(calllog.Direction)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDirection(v)
		return nil
	case calllog.FieldStartTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartTime(v)
		return nil
	case calllog.FieldEndTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndTime(v)
		return nil
	case calllog.FieldDuration:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDuration(v)
		return nil
	case calllog.FieldStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case calllog.FieldRecordingPath:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRecordingPath(v)
		return nil
	case calllog.FieldTranscript:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTranscript(v)
		return nil
	}
	return fmt.Errorf("unknown CallLog field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CallLogMutation) AddedFields() []string {
	var fields []string
	if m.addduration != nil {
		fields = append(fields, calllog.FieldDuration)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CallLogMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case calllog.FieldDuration:
		return m.AddedDuration()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CallLogMutation) AddField(name string, value ent.Value) error {
	switch name {
	case calllog.FieldDuration:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDuration(v)
		return nil
	}
	return fmt.Errorf("unknown CallLog numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CallLogMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(calllog.FieldEndTime) {
		fields = append(fields, calllog.FieldEndTime)
	}
	if m.FieldCleared(calllog.FieldRecordingPath) {
		fields = append(fields, calllog.FieldRecordingPath)
	}
	if m.FieldCleared(calllog.FieldTranscript) {
		fields = append(fields, calllog.FieldTranscript)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CallLogMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CallLogMutation) ClearField(name string) error {
	switch name {
	case calllog.FieldEndTime:
		m.ClearEndTime()
		return nil
	case calllog.FieldRecordingPath:
		m.ClearRecordingPath()
		return nil
	case calllog.FieldTranscript:
		m.ClearTranscript()
		return nil
	}
	return fmt.Errorf("unknown CallLog nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CallLogMutation) ResetField(name string) error {
	switch name {
	case calllog.FieldCaller:
		m.ResetCaller()
		return nil
	case calllog.FieldCallee:
		m.ResetCallee()
		return nil
	case calllog.FieldDirection:
		m.ResetDirection()
		return nil
	case calllog.FieldStartTime:
		m.ResetStartTime()
		return nil
	case calllog.FieldEndTime:
		m.ResetEndTime()
		return nil
	case calllog.FieldDuration:
		m.ResetDuration()
		return nil
	case calllog.FieldStatus:
		m.ResetStatus()
		return nil
	case calllog.FieldRecordingPath:
		m.ResetRecordingPath()
		return nil
	case calllog.FieldTranscript:
		m.ResetTranscript()
		return nil
	}
	return fmt.Errorf("unknown CallLog field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CallLogMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.tenant != nil {
		edges = append(edges, calllog.EdgeTenant)
	}
	if m.user != nil {
		edges = append(edges, calllog.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CallLogMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case calllog.EdgeTenant:
		if id := m.tenant; id != nil {
			return []ent.Value{*id}
		}
	case calllog.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CallLogMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CallLogMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CallLogMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedtenant {
		edges = append(edges, calllog.EdgeTenant)
	}
	if m.cleareduser {
		edges = append(edges, calllog.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CallLogMutation) EdgeCleared(name string) bool {
	switch name {
	case calllog.EdgeTenant:
		return m.clearedtenant
	case calllog.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CallLogMutation) ClearEdge(name string) error {
	switch name {
	case calllog.EdgeTenant:
		m.ClearTenant()
		return nil
	case calllog.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown CallLog unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CallLogMutation) ResetEdge(name string) error {
	switch name {
	case calllog.EdgeTenant:
		m.ResetTenant()
		return nil
	case calllog.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown CallLog edge %s", name)
}

// CameraMutation represents an operation that mutates the Camera nodes in the graph.
type CameraMutation struct {
	config
	op                Op
	typ               string
	id                *int
	name              *string
	rtsp_url          *string
	ip_address        *string
	onvif_port        *int
	addonvif_port     *int
	username          *string
	password          *string
	created_at        *time.Time
	updated_at        *time.Time
	clearedFields     map[string]struct{}
	tenant            *int
	clearedtenant     bool
	recordings        map[int]struct{}
	removedrecordings map[int]struct{}
	clearedrecordings bool
	detections        map[int]struct{}
	removeddetections map[int]struct{}
	cleareddetections bool
	done              bool
	oldValue          func(context.Context) (*Camera, error)
	predicates        []predicate.Camera
}

var _ ent.Mutation = (*CameraMutation)(nil)

// cameraOption allows management of the mutation configuration using functional options.
type cameraOption func(*CameraMutation)

// newCameraMutation creates new mutation for the Camera entity.
func newCameraMutation(c config, op Op, opts ...cameraOption) *CameraMutation {
	m := &CameraMutation{
		config:        c,
		op:            op,
		typ:           TypeCamera,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCameraID sets the ID field of the mutation.
func withCameraID(id int) cameraOption {
	return func(m *CameraMutation) {
		var (
			err   error
			once  sync.Once
			value *Camera
		)
		m.oldValue = func(ctx context.Context) (*Camera, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Camera.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCamera sets the old Camera of the mutation.
func withCamera(node *Camera) cameraOption {
	return func(m *CameraMutation) {
		m.oldValue = func(context.Context) (*Camera, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CameraMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CameraMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CameraMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CameraMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Camera.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *CameraMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *CameraMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Camera entity.
// If the Camera object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CameraMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *CameraMutation) ResetName() {
	m.name = nil
}

// SetRtspURL sets the "rtsp_url" field.
func (m *CameraMutation) SetRtspURL(s string) {
	m.rtsp_url = &s
}

// RtspURL returns the value of the "rtsp_url" field in the mutation.
func (m *CameraMutation) RtspURL() (r string, exists bool) {
	v := m.rtsp_url
	if v == nil {
		return
	}
	return *v, true
}

// OldRtspURL returns the old "rtsp_url" field's value of the Camera entity.
// If the Camera object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CameraMutation) OldRtspURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRtspURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRtspURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRtspURL: %w", err)
	}
	return oldValue.RtspURL, nil
}

// ResetRtspURL resets all changes to the "rtsp_url" field.
func (m *CameraMutation) ResetRtspURL() {
	m.rtsp_url = nil
}

// SetIPAddress sets the "ip_address" field.
func (m *CameraMutation) SetIPAddress(s string) {
	m.ip_address = &s
}

// IPAddress returns the value of the "ip_address" field in the mutation.
func (m *CameraMutation) IPAddress() (r string, exists bool) {
	v := m.ip_address
	if v == nil {
		return
	}
	return *v, true
}

// OldIPAddress returns the old "ip_address" field's value of the Camera entity.
// If the Camera object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CameraMutation) OldIPAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIPAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIPAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIPAddress: %w", err)
	}
	return oldValue.IPAddress, nil
}

// ClearIPAddress clears the value of the "ip_address" field.
func (m *CameraMutation) ClearIPAddress() {
	m.ip_address = nil
	m.clearedFields[camera.FieldIPAddress] = struct{}{}
}

// IPAddressCleared returns if the "ip_address" field was cleared in this mutation.
func (m *CameraMutation) IPAddressCleared() bool {
	_, ok := m.clearedFields[camera.FieldIPAddress]
	return ok
}

// ResetIPAddress resets all changes to the "ip_address" field.
func (m *CameraMutation) ResetIPAddress() {
	m.ip_address = nil
	delete(m.clearedFields, camera.FieldIPAddress)
}

// SetOnvifPort sets the "onvif_port" field.
func (m *CameraMutation) SetOnvifPort(i int) {
	m.onvif_port = &i
	m.addonvif_port = nil
}

// OnvifPort returns the value of the "onvif_port" field in the mutation.
func (m *CameraMutation) OnvifPort() (r int, exists bool) {
	v := m.onvif_port
	if v == nil {
		return
	}
	return *v, true
}

// OldOnvifPort returns the old "onvif_port" field's value of the Camera entity.
// If the Camera object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CameraMutation) OldOnvifPort(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOnvifPort is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOnvifPort requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOnvifPort: %w", err)
	}
	return oldValue.OnvifPort, nil
}

// AddOnvifPort adds i to the "onvif_port" field.
func (m *CameraMutation) AddOnvifPort(i int) {
	if m.addonvif_port != nil {
		*m.addonvif_port += i
	} else {
		m.addonvif_port = &i
	}
}

// AddedOnvifPort returns the value that was added to the "onvif_port" field in this mutation.
func (m *CameraMutation) AddedOnvifPort() (r int, exists bool) {
	v := m.addonvif_port
	if v == nil {
		return
	}
	return *v, true
}

// ResetOnvifPort resets all changes to the "onvif_port" field.
func (m *CameraMutation) ResetOnvifPort() {
	m.onvif_port = nil
	m.addonvif_port = nil
}

// SetUsername sets the "username" field.
func (m *CameraMutation) SetUsername(s string) {
	m.username = &s
}

// Username returns the value of the "username" field in the mutation.
func (m *CameraMutation) Username() (r string, exists bool) {
	v := m.username
	if v == nil {
		return
	}
	return *v, true
}

// OldUsername returns the old "username" field's value of the Camera entity.
// If the Camera object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CameraMutation) OldUsername(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsername is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsername requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsername: %w", err)
	}
	return oldValue.Username, nil
}

// ClearUsername clears the value of the "username" field.
func (m *CameraMutation) ClearUsername() {
	m.username = nil
	m.clearedFields[camera.FieldUsername] = struct{}{}
}

// UsernameCleared returns if the "username" field was cleared in this mutation.
func (m *CameraMutation) UsernameCleared() bool {
	_, ok := m.clearedFields[camera.FieldUsername]
	return ok
}

// ResetUsername resets all changes to the "username" field.
func (m *CameraMutation) ResetUsername() {
	m.username = nil
	delete(m.clearedFields, camera.FieldUsername)
}

// SetPassword sets the "password" field.
func (m *CameraMutation) SetPassword(s string) {
	m.password = &s
}

// Password returns the value of the "password" field in the mutation.
func (m *CameraMutation) Password() (r string, exists bool) {
	v := m.password
	if v == nil {
		return
	}
	return *v, true
}

// OldPassword returns the old "password" field's value of the Camera entity.
// If the Camera object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CameraMutation) OldPassword(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPassword is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPassword: %w", err)
	}
	return oldValue.Password, nil
}

// ClearPassword clears the value of the "password" field.
func (m *CameraMutation) ClearPassword() {
	m.password = nil
	m.clearedFields[camera.FieldPassword] = struct{}{}
}

// PasswordCleared returns if the "password" field was cleared in this mutation.
func (m *CameraMutation) PasswordCleared() bool {
	_, ok := m.clearedFields[camera.FieldPassword]
	return ok
}

// ResetPassword resets all changes to the "password" field.
func (m *CameraMutation) ResetPassword() {
	m.password = nil
	delete(m.clearedFields, camera.FieldPassword)
}

// SetCreatedAt sets the "created_at" field.
func (m *CameraMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *CameraMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Camera entity.
// If the Camera object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CameraMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *CameraMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *CameraMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *CameraMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Camera entity.
// If the Camera object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CameraMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *CameraMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetTenantID sets the "tenant" edge to the Tenant entity by id.
func (m *CameraMutation) SetTenantID(id int) {
	m.tenant = &id
}

// ClearTenant clears the "tenant" edge to the Tenant entity.
func (m *CameraMutation) ClearTenant() {
	m.clearedtenant = true
}

// TenantCleared reports if the "tenant" edge to the Tenant entity was cleared.
func (m *CameraMutation) TenantCleared() bool {
	return m.clearedtenant
}

// TenantID returns the "tenant" edge ID in the mutation.
func (m *CameraMutation) TenantID() (id int, exists bool) {
	if m.tenant != nil {
		return *m.tenant, true
	}
	return
}

// TenantIDs returns the "tenant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TenantID instead. It exists only for internal usage by the builders.
func (m *CameraMutation) TenantIDs() (ids []int) {
	if id := m.tenant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTenant resets all changes to the "tenant" edge.
func (m *CameraMutation) ResetTenant() {
	m.tenant = nil
	m.clearedtenant = false
}

// AddRecordingIDs adds the "recordings" edge to the Recording entity by ids.
func (m *CameraMutation) AddRecordingIDs(ids ...int) {
	if m.recordings == nil {
		m.recordings = make(map[int]struct{})
	}
	for i := range ids {
		m.recordings[ids[i]] = struct{}{}
	}
}

// ClearRecordings clears the "recordings" edge to the Recording entity.
func (m *CameraMutation) ClearRecordings() {
	m.clearedrecordings = true
}

// RecordingsCleared reports if the "recordings" edge to the Recording entity was cleared.
func (m *CameraMutation) RecordingsCleared() bool {
	return m.clearedrecordings
}

// RemoveRecordingIDs removes the "recordings" edge to the Recording entity by IDs.
func (m *CameraMutation) RemoveRecordingIDs(ids ...int) {
	if m.removedrecordings == nil {
		m.removedrecordings = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.recordings, ids[i])
		m.removedrecordings[ids[i]] = struct{}{}
	}
}

// RemovedRecordings returns the removed IDs of the "recordings" edge to the Recording entity.
func (m *CameraMutation) RemovedRecordingsIDs() (ids []int) {
	for id := range m.removedrecordings {
		ids = append(ids, id)
	}
	return
}

// RecordingsIDs returns the "recordings" edge IDs in the mutation.
func (m *CameraMutation) RecordingsIDs() (ids []int) {
	for id := range m.recordings {
		ids = append(ids, id)
	}
	return
}

// ResetRecordings resets all changes to the "recordings" edge.
func (m *CameraMutation) ResetRecordings() {
	m.recordings = nil
	m.clearedrecordings = false
	m.removedrecordings = nil
}

// AddDetectionIDs adds the "detections" edge to the DetectionEvent entity by ids.
func (m *CameraMutation) AddDetectionIDs(ids ...int) {
	if m.detections == nil {
		m.detections = make(map[int]struct{})
	}
	for i := range ids {
		m.detections[ids[i]] = struct{}{}
	}
}

// ClearDetections clears the "detections" edge to the DetectionEvent entity.
func (m *CameraMutation) ClearDetections() {
	m.cleareddetections = true
}

// DetectionsCleared reports if the "detections" edge to the DetectionEvent entity was cleared.
func (m *CameraMutation) DetectionsCleared() bool {
	return m.cleareddetections
}

// RemoveDetectionIDs removes the "detections" edge to the DetectionEvent entity by IDs.
func (m *CameraMutation) RemoveDetectionIDs(ids ...int) {
	if m.removeddetections == nil {
		m.removeddetections = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.detections, ids[i])
		m.removeddetections[ids[i]] = struct{}{}
	}
}

// RemovedDetections returns the removed IDs of the "detections" edge to the DetectionEvent entity.
func (m *CameraMutation) RemovedDetectionsIDs() (ids []int) {
	for id := range m.removeddetections {
		ids = append(ids, id)
	}
	return
}

// DetectionsIDs returns the "detections" edge IDs in the mutation.
func (m *CameraMutation) DetectionsIDs() (ids []int) {
	for id := range m.detections {
		ids = append(ids, id)
	}
	return
}

// ResetDetections resets all changes to the "detections" edge.
func (m *CameraMutation) ResetDetections() {
	m.detections = nil
	m.cleareddetections = false
	m.removeddetections = nil
}

// Where appends a list predicates to the CameraMutation builder.
func (m *CameraMutation) Where(ps ...predicate.Camera) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CameraMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CameraMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Camera, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CameraMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CameraMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Camera).
func (m *CameraMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CameraMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.name != nil {
		fields = append(fields, camera.FieldName)
	}
	if m.rtsp_url != nil {
		fields = append(fields, camera.FieldRtspURL)
	}
	if m.ip_address != nil {
		fields = append(fields, camera.FieldIPAddress)
	}
	if m.onvif_port != nil {
		fields = append(fields, camera.FieldOnvifPort)
	}
	if m.username != nil {
		fields = append(fields, camera.FieldUsername)
	}
	if m.password != nil {
		fields = append(fields, camera.FieldPassword)
	}
	if m.created_at != nil {
		fields = append(fields, camera.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, camera.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CameraMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case camera.FieldName:
		return m.Name()
	case camera.FieldRtspURL:
		return m.RtspURL()
	case camera.FieldIPAddress:
		return m.IPAddress()
	case camera.FieldOnvifPort:
		return m.OnvifPort()
	case camera.FieldUsername:
		return m.Username()
	case camera.FieldPassword:
		return m.Password()
	case camera.FieldCreatedAt:
		return m.CreatedAt()
	case camera.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CameraMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case camera.FieldName:
		return m.OldName(ctx)
	case camera.FieldRtspURL:
		return m.OldRtspURL(ctx)
	case camera.FieldIPAddress:
		return m.OldIPAddress(ctx)
	case camera.FieldOnvifPort:
		return m.OldOnvifPort(ctx)
	case camera.FieldUsername:
		return m.OldUsername(ctx)
	case camera.FieldPassword:
		return m.OldPassword(ctx)
	case camera.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case camera.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Camera field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CameraMutation) SetField(name string, value ent.Value) error {
	switch name {
	case camera.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case camera.FieldRtspURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRtspURL(v)
		return nil
	case camera.FieldIPAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIPAddress(v)
		return nil
	case camera.FieldOnvifPort:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOnvifPort(v)
		return nil
	case camera.FieldUsername:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsername(v)
		return nil
	case camera.FieldPassword:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPassword(v)
		return nil
	case camera.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case camera.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Camera field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CameraMutation) AddedFields() []string {
	var fields []string
	if m.addonvif_port != nil {
		fields = append(fields, camera.FieldOnvifPort)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CameraMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case camera.FieldOnvifPort:
		return m.AddedOnvifPort()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CameraMutation) AddField(name string, value ent.Value) error {
	switch name {
	case camera.FieldOnvifPort:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOnvifPort(v)
		return nil
	}
	return fmt.Errorf("unknown Camera numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CameraMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(camera.FieldIPAddress) {
		fields = append(fields, camera.FieldIPAddress)
	}
	if m.FieldCleared(camera.FieldUsername) {
		fields = append(fields, camera.FieldUsername)
	}
	if m.FieldCleared(camera.FieldPassword) {
		fields = append(fields, camera.FieldPassword)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CameraMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CameraMutation) ClearField(name string) error {
	switch name {
	case camera.FieldIPAddress:
		m.ClearIPAddress()
		return nil
	case camera.FieldUsername:
		m.ClearUsername()
		return nil
	case camera.FieldPassword:
		m.ClearPassword()
		return nil
	}
	return fmt.Errorf("unknown Camera nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CameraMutation) ResetField(name string) error {
	switch name {
	case camera.FieldName:
		m.ResetName()
		return nil
	case camera.FieldRtspURL:
		m.ResetRtspURL()
		return nil
	case camera.FieldIPAddress:
		m.ResetIPAddress()
		return nil
	case camera.FieldOnvifPort:
		m.ResetOnvifPort()
		return nil
	case camera.FieldUsername:
		m.ResetUsername()
		return nil
	case camera.FieldPassword:
		m.ResetPassword()
		return nil
	case camera.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case camera.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Camera field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CameraMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.tenant != nil {
		edges = append(edges, camera.EdgeTenant)
	}
	if m.recordings != nil {
		edges = append(edges, camera.EdgeRecordings)
	}
	if m.detections != nil {
		edges = append(edges, camera.EdgeDetections)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CameraMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case camera.EdgeTenant:
		if id := m.tenant; id != nil {
			return []ent.Value{*id}
		}
	case camera.EdgeRecordings:
		ids := make([]ent.Value, 0, len(m.recordings))
		for id := range m.recordings {
			ids = append(ids, id)
		}
		return ids
	case camera.EdgeDetections:
		ids := make([]ent.Value, 0, len(m.detections))
		for id := range m.detections {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CameraMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedrecordings != nil {
		edges = append(edges, camera.EdgeRecordings)
	}
	if m.removeddetections != nil {
		edges = append(edges, camera.EdgeDetections)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CameraMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case camera.EdgeRecordings:
		ids := make([]ent.Value, 0, len(m.removedrecordings))
		for id := range m.removedrecordings {
			ids = append(ids, id)
		}
		return ids
	case camera.EdgeDetections:
		ids := make([]ent.Value, 0, len(m.removeddetections))
		for id := range m.removeddetections {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CameraMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedtenant {
		edges = append(edges, camera.EdgeTenant)
	}
	if m.clearedrecordings {
		edges = append(edges, camera.EdgeRecordings)
	}
	if m.cleareddetections {
		edges = append(edges, camera.EdgeDetections)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CameraMutation) EdgeCleared(name string) bool {
	switch name {
	case camera.EdgeTenant:
		return m.clearedtenant
	case camera.EdgeRecordings:
		return m.clearedrecordings
	case camera.EdgeDetections:
		return m.cleareddetections
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CameraMutation) ClearEdge(name string) error {
	switch name {
	case camera.EdgeTenant:
		m.ClearTenant()
		return nil
	}
	return fmt.Errorf("unknown Camera unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CameraMutation) ResetEdge(name string) error {
	switch name {
	case camera.EdgeTenant:
		m.ResetTenant()
		return nil
	case camera.EdgeRecordings:
		m.ResetRecordings()
		return nil
	case camera.EdgeDetections:
		m.ResetDetections()
		return nil
	}
	return fmt.Errorf("unknown Camera edge %s", name)
}

// CandidateMutation represents an operation that mutates the Candidate nodes in the graph.
type CandidateMutation struct {
	config
	op                  Op
	typ                 string
	id                  *int
	first_name          *string
	last_name           *string
	email               *string
	phone               *string
	resume_url          *string
	linkedin_url        *string
	created_at          *time.Time
	updated_at          *time.Time
	clearedFields       map[string]struct{}
	tenant              *int
	clearedtenant       bool
	applications        map[int]struct{}
	removedapplications map[int]struct{}
	clearedapplications bool
	done                bool
	oldValue            func(context.Context) (*Candidate, error)
	predicates          []predicate.Candidate
}

var _ ent.Mutation = (*CandidateMutation)(nil)

// candidateOption allows management of the mutation configuration using functional options.
type candidateOption func(*CandidateMutation)

// newCandidateMutation creates new mutation for the Candidate entity.
func newCandidateMutation(c config, op Op, opts ...candidateOption) *CandidateMutation {
	m := &CandidateMutation{
		config:        c,
		op:            op,
		typ:           TypeCandidate,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCandidateID sets the ID field of the mutation.
func withCandidateID(id int) candidateOption {
	return func(m *CandidateMutation) {
		var (
			err   error
			once  sync.Once
			value *Candidate
		)
		m.oldValue = func(ctx context.Context) (*Candidate, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Candidate.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCandidate sets the old Candidate of the mutation.
func withCandidate(node *Candidate) candidateOption {
	return func(m *CandidateMutation) {
		m.oldValue = func(context.Context) (*Candidate, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CandidateMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CandidateMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CandidateMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CandidateMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Candidate.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetFirstName sets the "first_name" field.
func (m *CandidateMutation) SetFirstName(s string) {
	m.first_name = &s
}

// FirstName returns the value of the "first_name" field in the mutation.
func (m *CandidateMutation) FirstName() (r string, exists bool) {
	v := m.first_name
	if v == nil {
		return
	}
	return *v, true
}

// OldFirstName returns the old "first_name" field's value of the Candidate entity.
// If the Candidate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CandidateMutation) OldFirstName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFirstName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFirstName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFirstName: %w", err)
	}
	return oldValue.FirstName, nil
}

// ResetFirstName resets all changes to the "first_name" field.
func (m *CandidateMutation) ResetFirstName() {
	m.first_name = nil
}

// SetLastName sets the "last_name" field.
func (m *CandidateMutation) SetLastName(s string) {
	m.last_name = &s
}

// LastName returns the value of the "last_name" field in the mutation.
func (m *CandidateMutation) LastName() (r string, exists bool) {
	v := m.last_name
	if v == nil {
		return
	}
	return *v, true
}

// OldLastName returns the old "last_name" field's value of the Candidate entity.
// If the Candidate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CandidateMutation) OldLastName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastName: %w", err)
	}
	return oldValue.LastName, nil
}

// ResetLastName resets all changes to the "last_name" field.
func (m *CandidateMutation) ResetLastName() {
	m.last_name = nil
}

// SetEmail sets the "email" field.
func (m *CandidateMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *CandidateMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the Candidate entity.
// If the Candidate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CandidateMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail resets all changes to the "email" field.
func (m *CandidateMutation) ResetEmail() {
	m.email = nil
}

// SetPhone sets the "phone" field.
func (m *CandidateMutation) SetPhone(s string) {
	m.phone = &s
}

// Phone returns the value of the "phone" field in the mutation.
func (m *CandidateMutation) Phone() (r string, exists bool) {
	v := m.phone
	if v == nil {
		return
	}
	return *v, true
}

// OldPhone returns the old "phone" field's value of the Candidate entity.
// If the Candidate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CandidateMutation) OldPhone(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPhone is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPhone requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhone: %w", err)
	}
	return oldValue.Phone, nil
}

// ClearPhone clears the value of the "phone" field.
func (m *CandidateMutation) ClearPhone() {
	m.phone = nil
	m.clearedFields[candidate.FieldPhone] = struct{}{}
}

// PhoneCleared returns if the "phone" field was cleared in this mutation.
func (m *CandidateMutation) PhoneCleared() bool {
	_, ok := m.clearedFields[candidate.FieldPhone]
	return ok
}

// ResetPhone resets all changes to the "phone" field.
func (m *CandidateMutation) ResetPhone() {
	m.phone = nil
	delete(m.clearedFields, candidate.FieldPhone)
}

// SetResumeURL sets the "resume_url" field.
func (m *CandidateMutation) SetResumeURL(s string) {
	m.resume_url = &s
}

// ResumeURL returns the value of the "resume_url" field in the mutation.
func (m *CandidateMutation) ResumeURL() (r string, exists bool) {
	v := m.resume_url
	if v == nil {
		return
	}
	return *v, true
}

// OldResumeURL returns the old "resume_url" field's value of the Candidate entity.
// If the Candidate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CandidateMutation) OldResumeURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResumeURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResumeURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResumeURL: %w", err)
	}
	return oldValue.ResumeURL, nil
}

// ClearResumeURL clears the value of the "resume_url" field.
func (m *CandidateMutation) ClearResumeURL() {
	m.resume_url = nil
	m.clearedFields[candidate.FieldResumeURL] = struct{}{}
}

// ResumeURLCleared returns if the "resume_url" field was cleared in this mutation.
func (m *CandidateMutation) ResumeURLCleared() bool {
	_, ok := m.clearedFields[candidate.FieldResumeURL]
	return ok
}

// ResetResumeURL resets all changes to the "resume_url" field.
func (m *CandidateMutation) ResetResumeURL() {
	m.resume_url = nil
	delete(m.clearedFields, candidate.FieldResumeURL)
}

// SetLinkedinURL sets the "linkedin_url" field.
func (m *CandidateMutation) SetLinkedinURL(s string) {
	m.linkedin_url = &s
}

// LinkedinURL returns the value of the "linkedin_url" field in the mutation.
func (m *CandidateMutation) LinkedinURL() (r string, exists bool) {
	v := m.linkedin_url
	if v == nil {
		return
	}
	return *v, true
}

// OldLinkedinURL returns the old "linkedin_url" field's value of the Candidate entity.
// If the Candidate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CandidateMutation) OldLinkedinURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLinkedinURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLinkedinURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLinkedinURL: %w", err)
	}
	return oldValue.LinkedinURL, nil
}

// ClearLinkedinURL clears the value of the "linkedin_url" field.
func (m *CandidateMutation) ClearLinkedinURL() {
	m.linkedin_url = nil
	m.clearedFields[candidate.FieldLinkedinURL] = struct{}{}
}

// LinkedinURLCleared returns if the "linkedin_url" field was cleared in this mutation.
func (m *CandidateMutation) LinkedinURLCleared() bool {
	_, ok := m.clearedFields[candidate.FieldLinkedinURL]
	return ok
}

// ResetLinkedinURL resets all changes to the "linkedin_url" field.
func (m *CandidateMutation) ResetLinkedinURL() {
	m.linkedin_url = nil
	delete(m.clearedFields, candidate.FieldLinkedinURL)
}

// SetCreatedAt sets the "created_at" field.
func (m *CandidateMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *CandidateMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Candidate entity.
// If the Candidate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CandidateMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *CandidateMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *CandidateMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *CandidateMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Candidate entity.
// If the Candidate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CandidateMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *CandidateMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetTenantID sets the "tenant" edge to the Tenant entity by id.
func (m *CandidateMutation) SetTenantID(id int) {
	m.tenant = &id
}

// ClearTenant clears the "tenant" edge to the Tenant entity.
func (m *CandidateMutation) ClearTenant() {
	m.clearedtenant = true
}

// TenantCleared reports if the "tenant" edge to the Tenant entity was cleared.
func (m *CandidateMutation) TenantCleared() bool {
	return m.clearedtenant
}

// TenantID returns the "tenant" edge ID in the mutation.
func (m *CandidateMutation) TenantID() (id int, exists bool) {
	if m.tenant != nil {
		return *m.tenant, true
	}
	return
}

// TenantIDs returns the "tenant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TenantID instead. It exists only for internal usage by the builders.
func (m *CandidateMutation) TenantIDs() (ids []int) {
	if id := m.tenant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTenant resets all changes to the "tenant" edge.
func (m *CandidateMutation) ResetTenant() {
	m.tenant = nil
	m.clearedtenant = false
}

// AddApplicationIDs adds the "applications" edge to the Application entity by ids.
func (m *CandidateMutation) AddApplicationIDs(ids ...int) {
	if m.applications == nil {
		m.applications = make(map[int]struct{})
	}
	for i := range ids {
		m.applications[ids[i]] = struct{}{}
	}
}

// ClearApplications clears the "applications" edge to the Application entity.
func (m *CandidateMutation) ClearApplications() {
	m.clearedapplications = true
}

// ApplicationsCleared reports if the "applications" edge to the Application entity was cleared.
func (m *CandidateMutation) ApplicationsCleared() bool {
	return m.clearedapplications
}

// RemoveApplicationIDs removes the "applications" edge to the Application entity by IDs.
func (m *CandidateMutation) RemoveApplicationIDs(ids ...int) {
	if m.removedapplications == nil {
		m.removedapplications = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.applications, ids[i])
		m.removedapplications[ids[i]] = struct{}{}
	}
}

// RemovedApplications returns the removed IDs of the "applications" edge to the Application entity.
func (m *CandidateMutation) RemovedApplicationsIDs() (ids []int) {
	for id := range m.removedapplications {
		ids = append(ids, id)
	}
	return
}

// ApplicationsIDs returns the "applications" edge IDs in the mutation.
func (m *CandidateMutation) ApplicationsIDs() (ids []int) {
	for id := range m.applications {
		ids = append(ids, id)
	}
	return
}

// ResetApplications resets all changes to the "applications" edge.
func (m *CandidateMutation) ResetApplications() {
	m.applications = nil
	m.clearedapplications = false
	m.removedapplications = nil
}

// Where appends a list predicates to the CandidateMutation builder.
func (m *CandidateMutation) Where(ps ...predicate.Candidate) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CandidateMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CandidateMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Candidate, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CandidateMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CandidateMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Candidate).
func (m *CandidateMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CandidateMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.first_name != nil {
		fields = append(fields, candidate.FieldFirstName)
	}
	if m.last_name != nil {
		fields = append(fields, candidate.FieldLastName)
	}
	if m.email != nil {
		fields = append(fields, candidate.FieldEmail)
	}
	if m.phone != nil {
		fields = append(fields, candidate.FieldPhone)
	}
	if m.resume_url != nil {
		fields = append(fields, candidate.FieldResumeURL)
	}
	if m.linkedin_url != nil {
		fields = append(fields, candidate.FieldLinkedinURL)
	}
	if m.created_at != nil {
		fields = append(fields, candidate.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, candidate.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CandidateMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case candidate.FieldFirstName:
		return m.FirstName()
	case candidate.FieldLastName:
		return m.LastName()
	case candidate.FieldEmail:
		return m.Email()
	case candidate.FieldPhone:
		return m.Phone()
	case candidate.FieldResumeURL:
		return m.ResumeURL()
	case candidate.FieldLinkedinURL:
		return m.LinkedinURL()
	case candidate.FieldCreatedAt:
		return m.CreatedAt()
	case candidate.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CandidateMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case candidate.FieldFirstName:
		return m.OldFirstName(ctx)
	case candidate.FieldLastName:
		return m.OldLastName(ctx)
	case candidate.FieldEmail:
		return m.OldEmail(ctx)
	case candidate.FieldPhone:
		return m.OldPhone(ctx)
	case candidate.FieldResumeURL:
		return m.OldResumeURL(ctx)
	case candidate.FieldLinkedinURL:
		return m.OldLinkedinURL(ctx)
	case candidate.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case candidate.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Candidate field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CandidateMutation) SetField(name string, value ent.Value) error {
	switch name {
	case candidate.FieldFirstName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFirstName(v)
		return nil
	case candidate.FieldLastName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastName(v)
		return nil
	case candidate.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case candidate.FieldPhone:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhone(v)
		return nil
	case candidate.FieldResumeURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResumeURL(v)
		return nil
	case candidate.FieldLinkedinURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLinkedinURL(v)
		return nil
	case candidate.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case candidate.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Candidate field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CandidateMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CandidateMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CandidateMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Candidate numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CandidateMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(candidate.FieldPhone) {
		fields = append(fields, candidate.FieldPhone)
	}
	if m.FieldCleared(candidate.FieldResumeURL) {
		fields = append(fields, candidate.FieldResumeURL)
	}
	if m.FieldCleared(candidate.FieldLinkedinURL) {
		fields = append(fields, candidate.FieldLinkedinURL)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CandidateMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CandidateMutation) ClearField(name string) error {
	switch name {
	case candidate.FieldPhone:
		m.ClearPhone()
		return nil
	case candidate.FieldResumeURL:
		m.ClearResumeURL()
		return nil
	case candidate.FieldLinkedinURL:
		m.ClearLinkedinURL()
		return nil
	}
	return fmt.Errorf("unknown Candidate nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CandidateMutation) ResetField(name string) error {
	switch name {
	case candidate.FieldFirstName:
		m.ResetFirstName()
		return nil
	case candidate.FieldLastName:
		m.ResetLastName()
		return nil
	case candidate.FieldEmail:
		m.ResetEmail()
		return nil
	case candidate.FieldPhone:
		m.ResetPhone()
		return nil
	case candidate.FieldResumeURL:
		m.ResetResumeURL()
		return nil
	case candidate.FieldLinkedinURL:
		m.ResetLinkedinURL()
		return nil
	case candidate.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case candidate.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Candidate field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CandidateMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.tenant != nil {
		edges = append(edges, candidate.EdgeTenant)
	}
	if m.applications != nil {
		edges = append(edges, candidate.EdgeApplications)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CandidateMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case candidate.EdgeTenant:
		if id := m.tenant; id != nil {
			return []ent.Value{*id}
		}
	case candidate.EdgeApplications:
		ids := make([]ent.Value, 0, len(m.applications))
		for id := range m.applications {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CandidateMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedapplications != nil {
		edges = append(edges, candidate.EdgeApplications)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CandidateMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case candidate.EdgeApplications:
		ids := make([]ent.Value, 0, len(m.removedapplications))
		for id := range m.removedapplications {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CandidateMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedtenant {
		edges = append(edges, candidate.EdgeTenant)
	}
	if m.clearedapplications {
		edges = append(edges, candidate.EdgeApplications)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CandidateMutation) EdgeCleared(name string) bool {
	switch name {
	case candidate.EdgeTenant:
		return m.clearedtenant
	case candidate.EdgeApplications:
		return m.clearedapplications
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CandidateMutation) ClearEdge(name string) error {
	switch name {
	case candidate.EdgeTenant:
		m.ClearTenant()
		return nil
	}
	return fmt.Errorf("unknown Candidate unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CandidateMutation) ResetEdge(name string) error {
	switch name {
	case candidate.EdgeTenant:
		m.ResetTenant()
		return nil
	case candidate.EdgeApplications:
		m.ResetApplications()
		return nil
	}
	return fmt.Errorf("unknown Candidate edge %s", name)
}

// CategoryMutation represents an operation that mutates the Category nodes in the graph.
type CategoryMutation struct {
	config
	op              Op
	typ             string
	id              *int
	name            *string
	description     *string
	_type           *category.Type
	clearedFields   map[string]struct{}
	tenant          *int
	clearedtenant   bool
	products        map[int]struct{}
	removedproducts map[int]struct{}
	clearedproducts bool
	done            bool
	oldValue        func(context.Context) (*Category, error)
	predicates      []predicate.Category
}

var _ ent.Mutation = (*CategoryMutation)(nil)

// categoryOption allows management of the mutation configuration using functional options.
type categoryOption func(*CategoryMutation)

// newCategoryMutation creates new mutation for the Category entity.
func newCategoryMutation(c config, op Op, opts ...categoryOption) *CategoryMutation {
	m := &CategoryMutation{
		config:        c,
		op:            op,
		typ:           TypeCategory,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCategoryID sets the ID field of the mutation.
func withCategoryID(id int) categoryOption {
	return func(m *CategoryMutation) {
		var (
			err   error
			once  sync.Once
			value *Category
		)
		m.oldValue = func(ctx context.Context) (*Category, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Category.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCategory sets the old Category of the mutation.
func withCategory(node *Category) categoryOption {
	return func(m *CategoryMutation) {
		m.oldValue = func(context.Context) (*Category, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CategoryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CategoryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CategoryMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CategoryMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Category.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *CategoryMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *CategoryMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Category entity.
// If the Category object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CategoryMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *CategoryMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *CategoryMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *CategoryMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Category entity.
// If the Category object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CategoryMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *CategoryMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[category.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *CategoryMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[category.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *CategoryMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, category.FieldDescription)
}

// SetType sets the "type" field.
func (m *CategoryMutation) SetType(c category.Type) {
	m._type = &c
}

// GetType returns the value of the "type" field in the mutation.
func (m *CategoryMutation) GetType() (r category.Type, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Category entity.
// If the Category object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CategoryMutation) OldType(ctx context.Context) (v category.Type, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *CategoryMutation) ResetType() {
	m._type = nil
}

// SetTenantID sets the "tenant" edge to the Tenant entity by id.
func (m *CategoryMutation) SetTenantID(id int) {
	m.tenant = &id
}

// ClearTenant clears the "tenant" edge to the Tenant entity.
func (m *CategoryMutation) ClearTenant() {
	m.clearedtenant = true
}

// TenantCleared reports if the "tenant" edge to the Tenant entity was cleared.
func (m *CategoryMutation) TenantCleared() bool {
	return m.clearedtenant
}

// TenantID returns the "tenant" edge ID in the mutation.
func (m *CategoryMutation) TenantID() (id int, exists bool) {
	if m.tenant != nil {
		return *m.tenant, true
	}
	return
}

// TenantIDs returns the "tenant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TenantID instead. It exists only for internal usage by the builders.
func (m *CategoryMutation) TenantIDs() (ids []int) {
	if id := m.tenant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTenant resets all changes to the "tenant" edge.
func (m *CategoryMutation) ResetTenant() {
	m.tenant = nil
	m.clearedtenant = false
}

// AddProductIDs adds the "products" edge to the Product entity by ids.
func (m *CategoryMutation) AddProductIDs(ids ...int) {
	if m.products == nil {
		m.products = make(map[int]struct{})
	}
	for i := range ids {
		m.products[ids[i]] = struct{}{}
	}
}

// ClearProducts clears the "products" edge to the Product entity.
func (m *CategoryMutation) ClearProducts() {
	m.clearedproducts = true
}

// ProductsCleared reports if the "products" edge to the Product entity was cleared.
func (m *CategoryMutation) ProductsCleared() bool {
	return m.clearedproducts
}

// RemoveProductIDs removes the "products" edge to the Product entity by IDs.
func (m *CategoryMutation) RemoveProductIDs(ids ...int) {
	if m.removedproducts == nil {
		m.removedproducts = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.products, ids[i])
		m.removedproducts[ids[i]] = struct{}{}
	}
}

// RemovedProducts returns the removed IDs of the "products" edge to the Product entity.
func (m *CategoryMutation) RemovedProductsIDs() (ids []int) {
	for id := range m.removedproducts {
		ids = append(ids, id)
	}
	return
}

// ProductsIDs returns the "products" edge IDs in the mutation.
func (m *CategoryMutation) ProductsIDs() (ids []int) {
	for id := range m.products {
		ids = append(ids, id)
	}
	return
}

// ResetProducts resets all changes to the "products" edge.
func (m *CategoryMutation) ResetProducts() {
	m.products = nil
	m.clearedproducts = false
	m.removedproducts = nil
}

// Where appends a list predicates to the CategoryMutation builder.
func (m *CategoryMutation) Where(ps ...predicate.Category) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CategoryMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CategoryMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Category, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CategoryMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CategoryMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Category).
func (m *CategoryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CategoryMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.name != nil {
		fields = append(fields, category.FieldName)
	}
	if m.description != nil {
		fields = append(fields, category.FieldDescription)
	}
	if m._type != nil {
		fields = append(fields, category.FieldType)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CategoryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case category.FieldName:
		return m.Name()
	case category.FieldDescription:
		return m.Description()
	case category.FieldType:
		return m.GetType()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CategoryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case category.FieldName:
		return m.OldName(ctx)
	case category.FieldDescription:
		return m.OldDescription(ctx)
	case category.FieldType:
		return m.OldType(ctx)
	}
	return nil, fmt.Errorf("unknown Category field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CategoryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case category.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case category.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case category.FieldType:
		v, ok := value.(category.Type)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	}
	return fmt.Errorf("unknown Category field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CategoryMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CategoryMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CategoryMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Category numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CategoryMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(category.FieldDescription) {
		fields = append(fields, category.FieldDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CategoryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CategoryMutation) ClearField(name string) error {
	switch name {
	case category.FieldDescription:
		m.ClearDescription()
		return nil
	}
	return fmt.Errorf("unknown Category nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CategoryMutation) ResetField(name string) error {
	switch name {
	case category.FieldName:
		m.ResetName()
		return nil
	case category.FieldDescription:
		m.ResetDescription()
		return nil
	case category.FieldType:
		m.ResetType()
		return nil
	}
	return fmt.Errorf("unknown Category field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CategoryMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.tenant != nil {
		edges = append(edges, category.EdgeTenant)
	}
	if m.products != nil {
		edges = append(edges, category.EdgeProducts)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CategoryMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case category.EdgeTenant:
		if id := m.tenant; id != nil {
			return []ent.Value{*id}
		}
	case category.EdgeProducts:
		ids := make([]ent.Value, 0, len(m.products))
		for id := range m.products {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CategoryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedproducts != nil {
		edges = append(edges, category.EdgeProducts)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CategoryMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case category.EdgeProducts:
		ids := make([]ent.Value, 0, len(m.removedproducts))
		for id := range m.removedproducts {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CategoryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedtenant {
		edges = append(edges, category.EdgeTenant)
	}
	if m.clearedproducts {
		edges = append(edges, category.EdgeProducts)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CategoryMutation) EdgeCleared(name string) bool {
	switch name {
	case category.EdgeTenant:
		return m.clearedtenant
	case category.EdgeProducts:
		return m.clearedproducts
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CategoryMutation) ClearEdge(name string) error {
	switch name {
	case category.EdgeTenant:
		m.ClearTenant()
		return nil
	}
	return fmt.Errorf("unknown Category unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CategoryMutation) ResetEdge(name string) error {
	switch name {
	case category.EdgeTenant:
		m.ResetTenant()
		return nil
	case category.EdgeProducts:
		m.ResetProducts()
		return nil
	}
	return fmt.Errorf("unknown Category edge %s", name)
}

// CompensationAgreementMutation represents an operation that mutates the CompensationAgreement nodes in the graph.
type CompensationAgreementMutation struct {
	config
	op              Op
	typ             string
	id              *int
	base_salary     *decimal.Decimal
	currency        *string
	effective_date  *time.Time
	status          *compensationagreement.Status
	created_at      *time.Time
	clearedFields   map[string]struct{}
	tenant          *int
	clearedtenant   bool
	employee        *int
	clearedemployee bool
	done            bool
	oldValue        func(context.Context) (*CompensationAgreement, error)
	predicates      []predicate.CompensationAgreement
}

var _ ent.Mutation = (*CompensationAgreementMutation)(nil)

// compensationagreementOption allows management of the mutation configuration using functional options.
type compensationagreementOption func(*CompensationAgreementMutation)

// newCompensationAgreementMutation creates new mutation for the CompensationAgreement entity.
func newCompensationAgreementMutation(c config, op Op, opts ...compensationagreementOption) *CompensationAgreementMutation {
	m := &CompensationAgreementMutation{
		config:        c,
		op:            op,
		typ:           TypeCompensationAgreement,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCompensationAgreementID sets the ID field of the mutation.
func withCompensationAgreementID(id int) compensationagreementOption {
	return func(m *CompensationAgreementMutation) {
		var (
			err   error
			once  sync.Once
			value *CompensationAgreement
		)
		m.oldValue = func(ctx context.Context) (*CompensationAgreement, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CompensationAgreement.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCompensationAgreement sets the old CompensationAgreement of the mutation.
func withCompensationAgreement(node *CompensationAgreement) compensationagreementOption {
	return func(m *CompensationAgreementMutation) {
		m.oldValue = func(context.Context) (*CompensationAgreement, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CompensationAgreementMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CompensationAgreementMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CompensationAgreementMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CompensationAgreementMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().CompensationAgreement.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetBaseSalary sets the "base_salary" field.
func (m *CompensationAgreementMutation) SetBaseSalary(d decimal.Decimal) {
	m.base_salary = &d
}

// BaseSalary returns the value of the "base_salary" field in the mutation.
func (m *CompensationAgreementMutation) BaseSalary() (r decimal.Decimal, exists bool) {
	v := m.base_salary
	if v == nil {
		return
	}
	return *v, true
}

// OldBaseSalary returns the old "base_salary" field's value of the CompensationAgreement entity.
// If the CompensationAgreement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CompensationAgreementMutation) OldBaseSalary(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBaseSalary is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBaseSalary requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBaseSalary: %w", err)
	}
	return oldValue.BaseSalary, nil
}

// ResetBaseSalary resets all changes to the "base_salary" field.
func (m *CompensationAgreementMutation) ResetBaseSalary() {
	m.base_salary = nil
}

// SetCurrency sets the "currency" field.
func (m *CompensationAgreementMutation) SetCurrency(s string) {
	m.currency = &s
}

// Currency returns the value of the "currency" field in the mutation.
func (m *CompensationAgreementMutation) Currency() (r string, exists bool) {
	v := m.currency
	if v == nil {
		return
	}
	return *v, true
}

// OldCurrency returns the old "currency" field's value of the CompensationAgreement entity.
// If the CompensationAgreement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CompensationAgreementMutation) OldCurrency(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCurrency is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCurrency requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCurrency: %w", err)
	}
	return oldValue.Currency, nil
}

// ResetCurrency resets all changes to the "currency" field.
func (m *CompensationAgreementMutation) ResetCurrency() {
	m.currency = nil
}

// SetEffectiveDate sets the "effective_date" field.
func (m *CompensationAgreementMutation) SetEffectiveDate(t time.Time) {
	m.effective_date = &t
}

// EffectiveDate returns the value of the "effective_date" field in the mutation.
func (m *CompensationAgreementMutation) EffectiveDate() (r time.Time, exists bool) {
	v := m.effective_date
	if v == nil {
		return
	}
	return *v, true
}

// OldEffectiveDate returns the old "effective_date" field's value of the CompensationAgreement entity.
// If the CompensationAgreement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CompensationAgreementMutation) OldEffectiveDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEffectiveDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEffectiveDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEffectiveDate: %w", err)
	}
	return oldValue.EffectiveDate, nil
}

// ResetEffectiveDate resets all changes to the "effective_date" field.
func (m *CompensationAgreementMutation) ResetEffectiveDate() {
	m.effective_date = nil
}

// SetStatus sets the "status" field.
func (m *CompensationAgreementMutation) SetStatus(c compensationagreement.Status) {
	m.status = &c
}

// Status returns the value of the "status" field in the mutation.
func (m *CompensationAgreementMutation) Status() (r compensationagreement.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the CompensationAgreement entity.
// If the CompensationAgreement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CompensationAgreementMutation) OldStatus(ctx context.Context) (v compensationagreement.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *CompensationAgreementMutation) ResetStatus() {
	m.status = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *CompensationAgreementMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *CompensationAgreementMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the CompensationAgreement entity.
// If the CompensationAgreement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CompensationAgreementMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *CompensationAgreementMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetTenantID sets the "tenant" edge to the Tenant entity by id.
func (m *CompensationAgreementMutation) SetTenantID(id int) {
	m.tenant = &id
}

// ClearTenant clears the "tenant" edge to the Tenant entity.
func (m *CompensationAgreementMutation) ClearTenant() {
	m.clearedtenant = true
}

// TenantCleared reports if the "tenant" edge to the Tenant entity was cleared.
func (m *CompensationAgreementMutation) TenantCleared() bool {
	return m.clearedtenant
}

// TenantID returns the "tenant" edge ID in the mutation.
func (m *CompensationAgreementMutation) TenantID() (id int, exists bool) {
	if m.tenant != nil {
		return *m.tenant, true
	}
	return
}

// TenantIDs returns the "tenant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TenantID instead. It exists only for internal usage by the builders.
func (m *CompensationAgreementMutation) TenantIDs() (ids []int) {
	if id := m.tenant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTenant resets all changes to the "tenant" edge.
func (m *CompensationAgreementMutation) ResetTenant() {
	m.tenant = nil
	m.clearedtenant = false
}

// SetEmployeeID sets the "employee" edge to the Employee entity by id.
func (m *CompensationAgreementMutation) SetEmployeeID(id int) {
	m.employee = &id
}

// ClearEmployee clears the "employee" edge to the Employee entity.
func (m *CompensationAgreementMutation) ClearEmployee() {
	m.clearedemployee = true
}

// EmployeeCleared reports if the "employee" edge to the Employee entity was cleared.
func (m *CompensationAgreementMutation) EmployeeCleared() bool {
	return m.clearedemployee
}

// EmployeeID returns the "employee" edge ID in the mutation.
func (m *CompensationAgreementMutation) EmployeeID() (id int, exists bool) {
	if m.employee != nil {
		return *m.employee, true
	}
	return
}

// EmployeeIDs returns the "employee" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// EmployeeID instead. It exists only for internal usage by the builders.
func (m *CompensationAgreementMutation) EmployeeIDs() (ids []int) {
	if id := m.employee; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEmployee resets all changes to the "employee" edge.
func (m *CompensationAgreementMutation) ResetEmployee() {
	m.employee = nil
	m.clearedemployee = false
}

// Where appends a list predicates to the CompensationAgreementMutation builder.
func (m *CompensationAgreementMutation) Where(ps ...predicate.CompensationAgreement) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CompensationAgreementMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CompensationAgreementMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.CompensationAgreement, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CompensationAgreementMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CompensationAgreementMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (CompensationAgreement).
func (m *CompensationAgreementMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CompensationAgreementMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.base_salary != nil {
		fields = append(fields, compensationagreement.FieldBaseSalary)
	}
	if m.currency != nil {
		fields = append(fields, compensationagreement.FieldCurrency)
	}
	if m.effective_date != nil {
		fields = append(fields, compensationagreement.FieldEffectiveDate)
	}
	if m.status != nil {
		fields = append(fields, compensationagreement.FieldStatus)
	}
	if m.created_at != nil {
		fields = append(fields, compensationagreement.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CompensationAgreementMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case compensationagreement.FieldBaseSalary:
		return m.BaseSalary()
	case compensationagreement.FieldCurrency:
		return m.Currency()
	case compensationagreement.FieldEffectiveDate:
		return m.EffectiveDate()
	case compensationagreement.FieldStatus:
		return m.Status()
	case compensationagreement.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CompensationAgreementMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case compensationagreement.FieldBaseSalary:
		return m.OldBaseSalary(ctx)
	case compensationagreement.FieldCurrency:
		return m.OldCurrency(ctx)
	case compensationagreement.FieldEffectiveDate:
		return m.OldEffectiveDate(ctx)
	case compensationagreement.FieldStatus:
		return m.OldStatus(ctx)
	case compensationagreement.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown CompensationAgreement field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CompensationAgreementMutation) SetField(name string, value ent.Value) error {
	switch name {
	case compensationagreement.FieldBaseSalary:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBaseSalary(v)
		return nil
	case compensationagreement.FieldCurrency:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCurrency(v)
		return nil
	case compensationagreement.FieldEffectiveDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEffectiveDate(v)
		return nil
	case compensationagreement.FieldStatus:
		v, ok := value.(compensationagreement.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case compensationagreement.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown CompensationAgreement field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CompensationAgreementMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CompensationAgreementMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CompensationAgreementMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown CompensationAgreement numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CompensationAgreementMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CompensationAgreementMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CompensationAgreementMutation) ClearField(name string) error {
	return fmt.Errorf("unknown CompensationAgreement nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CompensationAgreementMutation) ResetField(name string) error {
	switch name {
	case compensationagreement.FieldBaseSalary:
		m.ResetBaseSalary()
		return nil
	case compensationagreement.FieldCurrency:
		m.ResetCurrency()
		return nil
	case compensationagreement.FieldEffectiveDate:
		m.ResetEffectiveDate()
		return nil
	case compensationagreement.FieldStatus:
		m.ResetStatus()
		return nil
	case compensationagreement.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown CompensationAgreement field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CompensationAgreementMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.tenant != nil {
		edges = append(edges, compensationagreement.EdgeTenant)
	}
	if m.employee != nil {
		edges = append(edges, compensationagreement.EdgeEmployee)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CompensationAgreementMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case compensationagreement.EdgeTenant:
		if id := m.tenant; id != nil {
			return []ent.Value{*id}
		}
	case compensationagreement.EdgeEmployee:
		if id := m.employee; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CompensationAgreementMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CompensationAgreementMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CompensationAgreementMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedtenant {
		edges = append(edges, compensationagreement.EdgeTenant)
	}
	if m.clearedemployee {
		edges = append(edges, compensationagreement.EdgeEmployee)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CompensationAgreementMutation) EdgeCleared(name string) bool {
	switch name {
	case compensationagreement.EdgeTenant:
		return m.clearedtenant
	case compensationagreement.EdgeEmployee:
		return m.clearedemployee
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CompensationAgreementMutation) ClearEdge(name string) error {
	switch name {
	case compensationagreement.EdgeTenant:
		m.ClearTenant()
		return nil
	case compensationagreement.EdgeEmployee:
		m.ClearEmployee()
		return nil
	}
	return fmt.Errorf("unknown CompensationAgreement unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CompensationAgreementMutation) ResetEdge(name string) error {
	switch name {
	case compensationagreement.EdgeTenant:
		m.ResetTenant()
		return nil
	case compensationagreement.EdgeEmployee:
		m.ResetEmployee()
		return nil
	}
	return fmt.Errorf("unknown CompensationAgreement edge %s", name)
}

// ContactMutation represents an operation that mutates the Contact nodes in the graph.
type ContactMutation struct {
	config
	op                Op
	typ               string
	id                *int
	name              *string
	email             *string
	phone             *string
	address           *string
	_type             *string
	loyalty_points    *int
	addloyalty_points *int
	lifetime_value    *decimal.Decimal
	created_at        *time.Time
	updated_at        *time.Time
	clearedFields     map[string]struct{}
	tenant            *int
	clearedtenant     bool
	done              bool
	oldValue          func(context.Context) (*Contact, error)
	predicates        []predicate.Contact
}

var _ ent.Mutation = (*ContactMutation)(nil)

// contactOption allows management of the mutation configuration using functional options.
type contactOption func(*ContactMutation)

// newContactMutation creates new mutation for the Contact entity.
func newContactMutation(c config, op Op, opts ...contactOption) *ContactMutation {
	m := &ContactMutation{
		config:        c,
		op:            op,
		typ:           TypeContact,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withContactID sets the ID field of the mutation.
func withContactID(id int) contactOption {
	return func(m *ContactMutation) {
		var (
			err   error
			once  sync.Once
			value *Contact
		)
		m.oldValue = func(ctx context.Context) (*Contact, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Contact.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withContact sets the old Contact of the mutation.
func withContact(node *Contact) contactOption {
	return func(m *ContactMutation) {
		m.oldValue = func(context.Context) (*Contact, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ContactMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ContactMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ContactMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ContactMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Contact.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *ContactMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ContactMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Contact entity.
// If the Contact object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContactMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ContactMutation) ResetName() {
	m.name = nil
}

// SetEmail sets the "email" field.
func (m *ContactMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *ContactMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the Contact entity.
// If the Contact object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContactMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ClearEmail clears the value of the "email" field.
func (m *ContactMutation) ClearEmail() {
	m.email = nil
	m.clearedFields[contact.FieldEmail] = struct{}{}
}

// EmailCleared returns if the "email" field was cleared in this mutation.
func (m *ContactMutation) EmailCleared() bool {
	_, ok := m.clearedFields[contact.FieldEmail]
	return ok
}

// ResetEmail resets all changes to the "email" field.
func (m *ContactMutation) ResetEmail() {
	m.email = nil
	delete(m.clearedFields, contact.FieldEmail)
}

// SetPhone sets the "phone" field.
func (m *ContactMutation) SetPhone(s string) {
	m.phone = &s
}

// Phone returns the value of the "phone" field in the mutation.
func (m *ContactMutation) Phone() (r string, exists bool) {
	v := m.phone
	if v == nil {
		return
	}
	return *v, true
}

// OldPhone returns the old "phone" field's value of the Contact entity.
// If the Contact object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContactMutation) OldPhone(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPhone is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPhone requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhone: %w", err)
	}
	return oldValue.Phone, nil
}

// ClearPhone clears the value of the "phone" field.
func (m *ContactMutation) ClearPhone() {
	m.phone = nil
	m.clearedFields[contact.FieldPhone] = struct{}{}
}

// PhoneCleared returns if the "phone" field was cleared in this mutation.
func (m *ContactMutation) PhoneCleared() bool {
	_, ok := m.clearedFields[contact.FieldPhone]
	return ok
}

// ResetPhone resets all changes to the "phone" field.
func (m *ContactMutation) ResetPhone() {
	m.phone = nil
	delete(m.clearedFields, contact.FieldPhone)
}

// SetAddress sets the "address" field.
func (m *ContactMutation) SetAddress(s string) {
	m.address = &s
}

// Address returns the value of the "address" field in the mutation.
func (m *ContactMutation) Address() (r string, exists bool) {
	v := m.address
	if v == nil {
		return
	}
	return *v, true
}

// OldAddress returns the old "address" field's value of the Contact entity.
// If the Contact object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContactMutation) OldAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAddress: %w", err)
	}
	return oldValue.Address, nil
}

// ClearAddress clears the value of the "address" field.
func (m *ContactMutation) ClearAddress() {
	m.address = nil
	m.clearedFields[contact.FieldAddress] = struct{}{}
}

// AddressCleared returns if the "address" field was cleared in this mutation.
func (m *ContactMutation) AddressCleared() bool {
	_, ok := m.clearedFields[contact.FieldAddress]
	return ok
}

// ResetAddress resets all changes to the "address" field.
func (m *ContactMutation) ResetAddress() {
	m.address = nil
	delete(m.clearedFields, contact.FieldAddress)
}

// SetType sets the "type" field.
func (m *ContactMutation) SetType(s string) {
	m._type = &s
}

// GetType returns the value of the "type" field in the mutation.
func (m *ContactMutation) GetType() (r string, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Contact entity.
// If the Contact object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContactMutation) OldType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *ContactMutation) ResetType() {
	m._type = nil
}

// SetLoyaltyPoints sets the "loyalty_points" field.
func (m *ContactMutation) SetLoyaltyPoints(i int) {
	m.loyalty_points = &i
	m.addloyalty_points = nil
}

// LoyaltyPoints returns the value of the "loyalty_points" field in the mutation.
func (m *ContactMutation) LoyaltyPoints() (r int, exists bool) {
	v := m.loyalty_points
	if v == nil {
		return
	}
	return *v, true
}

// OldLoyaltyPoints returns the old "loyalty_points" field's value of the Contact entity.
// If the Contact object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContactMutation) OldLoyaltyPoints(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLoyaltyPoints is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLoyaltyPoints requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLoyaltyPoints: %w", err)
	}
	return oldValue.LoyaltyPoints, nil
}

// AddLoyaltyPoints adds i to the "loyalty_points" field.
func (m *ContactMutation) AddLoyaltyPoints(i int) {
	if m.addloyalty_points != nil {
		*m.addloyalty_points += i
	} else {
		m.addloyalty_points = &i
	}
}

// AddedLoyaltyPoints returns the value that was added to the "loyalty_points" field in this mutation.
func (m *ContactMutation) AddedLoyaltyPoints() (r int, exists bool) {
	v := m.addloyalty_points
	if v == nil {
		return
	}
	return *v, true
}

// ResetLoyaltyPoints resets all changes to the "loyalty_points" field.
func (m *ContactMutation) ResetLoyaltyPoints() {
	m.loyalty_points = nil
	m.addloyalty_points = nil
}

// SetLifetimeValue sets the "lifetime_value" field.
func (m *ContactMutation) SetLifetimeValue(d decimal.Decimal) {
	m.lifetime_value = &d
}

// LifetimeValue returns the value of the "lifetime_value" field in the mutation.
func (m *ContactMutation) LifetimeValue() (r decimal.Decimal, exists bool) {
	v := m.lifetime_value
	if v == nil {
		return
	}
	return *v, true
}

// OldLifetimeValue returns the old "lifetime_value" field's value of the Contact entity.
// If the Contact object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContactMutation) OldLifetimeValue(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLifetimeValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLifetimeValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLifetimeValue: %w", err)
	}
	return oldValue.LifetimeValue, nil
}

// ResetLifetimeValue resets all changes to the "lifetime_value" field.
func (m *ContactMutation) ResetLifetimeValue() {
	m.lifetime_value = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *ContactMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ContactMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Contact entity.
// If the Contact object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContactMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ContactMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ContactMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ContactMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Contact entity.
// If the Contact object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContactMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ContactMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetTenantID sets the "tenant" edge to the Tenant entity by id.
func (m *ContactMutation) SetTenantID(id int) {
	m.tenant = &id
}

// ClearTenant clears the "tenant" edge to the Tenant entity.
func (m *ContactMutation) ClearTenant() {
	m.clearedtenant = true
}

// TenantCleared reports if the "tenant" edge to the Tenant entity was cleared.
func (m *ContactMutation) TenantCleared() bool {
	return m.clearedtenant
}

// TenantID returns the "tenant" edge ID in the mutation.
func (m *ContactMutation) TenantID() (id int, exists bool) {
	if m.tenant != nil {
		return *m.tenant, true
	}
	return
}

// TenantIDs returns the "tenant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TenantID instead. It exists only for internal usage by the builders.
func (m *ContactMutation) TenantIDs() (ids []int) {
	if id := m.tenant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTenant resets all changes to the "tenant" edge.
func (m *ContactMutation) ResetTenant() {
	m.tenant = nil
	m.clearedtenant = false
}

// Where appends a list predicates to the ContactMutation builder.
func (m *ContactMutation) Where(ps ...predicate.Contact) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ContactMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ContactMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Contact, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ContactMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ContactMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Contact).
func (m *ContactMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ContactMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.name != nil {
		fields = append(fields, contact.FieldName)
	}
	if m.email != nil {
		fields = append(fields, contact.FieldEmail)
	}
	if m.phone != nil {
		fields = append(fields, contact.FieldPhone)
	}
	if m.address != nil {
		fields = append(fields, contact.FieldAddress)
	}
	if m._type != nil {
		fields = append(fields, contact.FieldType)
	}
	if m.loyalty_points != nil {
		fields = append(fields, contact.FieldLoyaltyPoints)
	}
	if m.lifetime_value != nil {
		fields = append(fields, contact.FieldLifetimeValue)
	}
	if m.created_at != nil {
		fields = append(fields, contact.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, contact.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ContactMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case contact.FieldName:
		return m.Name()
	case contact.FieldEmail:
		return m.Email()
	case contact.FieldPhone:
		return m.Phone()
	case contact.FieldAddress:
		return m.Address()
	case contact.FieldType:
		return m.GetType()
	case contact.FieldLoyaltyPoints:
		return m.LoyaltyPoints()
	case contact.FieldLifetimeValue:
		return m.LifetimeValue()
	case contact.FieldCreatedAt:
		return m.CreatedAt()
	case contact.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ContactMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case contact.FieldName:
		return m.OldName(ctx)
	case contact.FieldEmail:
		return m.OldEmail(ctx)
	case contact.FieldPhone:
		return m.OldPhone(ctx)
	case contact.FieldAddress:
		return m.OldAddress(ctx)
	case contact.FieldType:
		return m.OldType(ctx)
	case contact.FieldLoyaltyPoints:
		return m.OldLoyaltyPoints(ctx)
	case contact.FieldLifetimeValue:
		return m.OldLifetimeValue(ctx)
	case contact.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case contact.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Contact field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ContactMutation) SetField(name string, value ent.Value) error {
	switch name {
	case contact.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case contact.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case contact.FieldPhone:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhone(v)
		return nil
	case contact.FieldAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAddress(v)
		return nil
	case contact.FieldType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case contact.FieldLoyaltyPoints:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLoyaltyPoints(v)
		return nil
	case contact.FieldLifetimeValue:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLifetimeValue(v)
		return nil
	case contact.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case contact.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Contact field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ContactMutation) AddedFields() []string {
	var fields []string
	if m.addloyalty_points != nil {
		fields = append(fields, contact.FieldLoyaltyPoints)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ContactMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case contact.FieldLoyaltyPoints:
		return m.AddedLoyaltyPoints()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ContactMutation) AddField(name string, value ent.Value) error {
	switch name {
	case contact.FieldLoyaltyPoints:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLoyaltyPoints(v)
		return nil
	}
	return fmt.Errorf("unknown Contact numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ContactMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(contact.FieldEmail) {
		fields = append(fields, contact.FieldEmail)
	}
	if m.FieldCleared(contact.FieldPhone) {
		fields = append(fields, contact.FieldPhone)
	}
	if m.FieldCleared(contact.FieldAddress) {
		fields = append(fields, contact.FieldAddress)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ContactMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ContactMutation) ClearField(name string) error {
	switch name {
	case contact.FieldEmail:
		m.ClearEmail()
		return nil
	case contact.FieldPhone:
		m.ClearPhone()
		return nil
	case contact.FieldAddress:
		m.ClearAddress()
		return nil
	}
	return fmt.Errorf("unknown Contact nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ContactMutation) ResetField(name string) error {
	switch name {
	case contact.FieldName:
		m.ResetName()
		return nil
	case contact.FieldEmail:
		m.ResetEmail()
		return nil
	case contact.FieldPhone:
		m.ResetPhone()
		return nil
	case contact.FieldAddress:
		m.ResetAddress()
		return nil
	case contact.FieldType:
		m.ResetType()
		return nil
	case contact.FieldLoyaltyPoints:
		m.ResetLoyaltyPoints()
		return nil
	case contact.FieldLifetimeValue:
		m.ResetLifetimeValue()
		return nil
	case contact.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case contact.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Contact field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ContactMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.tenant != nil {
		edges = append(edges, contact.EdgeTenant)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ContactMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case contact.EdgeTenant:
		if id := m.tenant; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ContactMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ContactMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ContactMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedtenant {
		edges = append(edges, contact.EdgeTenant)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ContactMutation) EdgeCleared(name string) bool {
	switch name {
	case contact.EdgeTenant:
		return m.clearedtenant
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ContactMutation) ClearEdge(name string) error {
	switch name {
	case contact.EdgeTenant:
		m.ClearTenant()
		return nil
	}
	return fmt.Errorf("unknown Contact unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ContactMutation) ResetEdge(name string) error {
	switch name {
	case contact.EdgeTenant:
		m.ResetTenant()
		return nil
	}
	return fmt.Errorf("unknown Contact edge %s", name)
}

// ContractMutation represents an operation that mutates the Contract nodes in the graph.
type ContractMutation struct {
	config
	op                         Op
	typ                        string
	id                         *int
	name                       *string
	_type                      *contract.Type
	total_hours                *float64
	addtotal_hours             *float64
	remaining_hours            *float64
	addremaining_hours         *float64
	grace_threshold_percent    *float64
	addgrace_threshold_percent *float64
	start_date                 *time.Time
	end_date                   *time.Time
	is_active                  *bool
	clearedFields              map[string]struct{}
	tenant                     *int
	clearedtenant              bool
	done                       bool
	oldValue                   func(context.Context) (*Contract, error)
	predicates                 []predicate.Contract
}

var _ ent.Mutation = (*ContractMutation)(nil)

// contractOption allows management of the mutation configuration using functional options.
type contractOption func(*ContractMutation)

// newContractMutation creates new mutation for the Contract entity.
func newContractMutation(c config, op Op, opts ...contractOption) *ContractMutation {
	m := &ContractMutation{
		config:        c,
		op:            op,
		typ:           TypeContract,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withContractID sets the ID field of the mutation.
func withContractID(id int) contractOption {
	return func(m *ContractMutation) {
		var (
			err   error
			once  sync.Once
			value *Contract
		)
		m.oldValue = func(ctx context.Context) (*Contract, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Contract.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withContract sets the old Contract of the mutation.
func withContract(node *Contract) contractOption {
	return func(m *ContractMutation) {
		m.oldValue = func(context.Context) (*Contract, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ContractMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ContractMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ContractMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ContractMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Contract.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *ContractMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ContractMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Contract entity.
// If the Contract object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContractMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ContractMutation) ResetName() {
	m.name = nil
}

// SetType sets the "type" field.
func (m *ContractMutation) SetType(c contract.Type) {
	m._type = &c
}

// GetType returns the value of the "type" field in the mutation.
func (m *ContractMutation) GetType() (r contract.Type, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Contract entity.
// If the Contract object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContractMutation) OldType(ctx context.Context) (v contract.Type, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *ContractMutation) ResetType() {
	m._type = nil
}

// SetTotalHours sets the "total_hours" field.
func (m *ContractMutation) SetTotalHours(f float64) {
	m.total_hours = &f
	m.addtotal_hours = nil
}

// TotalHours returns the value of the "total_hours" field in the mutation.
func (m *ContractMutation) TotalHours() (r float64, exists bool) {
	v := m.total_hours
	if v == nil {
		return
	}
	return *v, true
}

// OldTotalHours returns the old "total_hours" field's value of the Contract entity.
// If the Contract object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContractMutation) OldTotalHours(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTotalHours is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTotalHours requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTotalHours: %w", err)
	}
	return oldValue.TotalHours, nil
}

// AddTotalHours adds f to the "total_hours" field.
func (m *ContractMutation) AddTotalHours(f float64) {
	if m.addtotal_hours != nil {
		*m.addtotal_hours += f
	} else {
		m.addtotal_hours = &f
	}
}

// AddedTotalHours returns the value that was added to the "total_hours" field in this mutation.
func (m *ContractMutation) AddedTotalHours() (r float64, exists bool) {
	v := m.addtotal_hours
	if v == nil {
		return
	}
	return *v, true
}

// ResetTotalHours resets all changes to the "total_hours" field.
func (m *ContractMutation) ResetTotalHours() {
	m.total_hours = nil
	m.addtotal_hours = nil
}

// SetRemainingHours sets the "remaining_hours" field.
func (m *ContractMutation) SetRemainingHours(f float64) {
	m.remaining_hours = &f
	m.addremaining_hours = nil
}

// RemainingHours returns the value of the "remaining_hours" field in the mutation.
func (m *ContractMutation) RemainingHours() (r float64, exists bool) {
	v := m.remaining_hours
	if v == nil {
		return
	}
	return *v, true
}

// OldRemainingHours returns the old "remaining_hours" field's value of the Contract entity.
// If the Contract object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContractMutation) OldRemainingHours(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRemainingHours is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRemainingHours requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemainingHours: %w", err)
	}
	return oldValue.RemainingHours, nil
}

// AddRemainingHours adds f to the "remaining_hours" field.
func (m *ContractMutation) AddRemainingHours(f float64) {
	if m.addremaining_hours != nil {
		*m.addremaining_hours += f
	} else {
		m.addremaining_hours = &f
	}
}

// AddedRemainingHours returns the value that was added to the "remaining_hours" field in this mutation.
func (m *ContractMutation) AddedRemainingHours() (r float64, exists bool) {
	v := m.addremaining_hours
	if v == nil {
		return
	}
	return *v, true
}

// ResetRemainingHours resets all changes to the "remaining_hours" field.
func (m *ContractMutation) ResetRemainingHours() {
	m.remaining_hours = nil
	m.addremaining_hours = nil
}

// SetGraceThresholdPercent sets the "grace_threshold_percent" field.
func (m *ContractMutation) SetGraceThresholdPercent(f float64) {
	m.grace_threshold_percent = &f
	m.addgrace_threshold_percent = nil
}

// GraceThresholdPercent returns the value of the "grace_threshold_percent" field in the mutation.
func (m *ContractMutation) GraceThresholdPercent() (r float64, exists bool) {
	v := m.grace_threshold_percent
	if v == nil {
		return
	}
	return *v, true
}

// OldGraceThresholdPercent returns the old "grace_threshold_percent" field's value of the Contract entity.
// If the Contract object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContractMutation) OldGraceThresholdPercent(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGraceThresholdPercent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGraceThresholdPercent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGraceThresholdPercent: %w", err)
	}
	return oldValue.GraceThresholdPercent, nil
}

// AddGraceThresholdPercent adds f to the "grace_threshold_percent" field.
func (m *ContractMutation) AddGraceThresholdPercent(f float64) {
	if m.addgrace_threshold_percent != nil {
		*m.addgrace_threshold_percent += f
	} else {
		m.addgrace_threshold_percent = &f
	}
}

// AddedGraceThresholdPercent returns the value that was added to the "grace_threshold_percent" field in this mutation.
func (m *ContractMutation) AddedGraceThresholdPercent() (r float64, exists bool) {
	v := m.addgrace_threshold_percent
	if v == nil {
		return
	}
	return *v, true
}

// ResetGraceThresholdPercent resets all changes to the "grace_threshold_percent" field.
func (m *ContractMutation) ResetGraceThresholdPercent() {
	m.grace_threshold_percent = nil
	m.addgrace_threshold_percent = nil
}

// SetStartDate sets the "start_date" field.
func (m *ContractMutation) SetStartDate(t time.Time) {
	m.start_date = &t
}

// StartDate returns the value of the "start_date" field in the mutation.
func (m *ContractMutation) StartDate() (r time.Time, exists bool) {
	v := m.start_date
	if v == nil {
		return
	}
	return *v, true
}

// OldStartDate returns the old "start_date" field's value of the Contract entity.
// If the Contract object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContractMutation) OldStartDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartDate: %w", err)
	}
	return oldValue.StartDate, nil
}

// ResetStartDate resets all changes to the "start_date" field.
func (m *ContractMutation) ResetStartDate() {
	m.start_date = nil
}

// SetEndDate sets the "end_date" field.
func (m *ContractMutation) SetEndDate(t time.Time) {
	m.end_date = &t
}

// EndDate returns the value of the "end_date" field in the mutation.
func (m *ContractMutation) EndDate() (r time.Time, exists bool) {
	v := m.end_date
	if v == nil {
		return
	}
	return *v, true
}

// OldEndDate returns the old "end_date" field's value of the Contract entity.
// If the Contract object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContractMutation) OldEndDate(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEndDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEndDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndDate: %w", err)
	}
	return oldValue.EndDate, nil
}

// ClearEndDate clears the value of the "end_date" field.
func (m *ContractMutation) ClearEndDate() {
	m.end_date = nil
	m.clearedFields[contract.FieldEndDate] = struct{}{}
}

// EndDateCleared returns if the "end_date" field was cleared in this mutation.
func (m *ContractMutation) EndDateCleared() bool {
	_, ok := m.clearedFields[contract.FieldEndDate]
	return ok
}

// ResetEndDate resets all changes to the "end_date" field.
func (m *ContractMutation) ResetEndDate() {
	m.end_date = nil
	delete(m.clearedFields, contract.FieldEndDate)
}

// SetIsActive sets the "is_active" field.
func (m *ContractMutation) SetIsActive(b bool) {
	m.is_active = &b
}

// IsActive returns the value of the "is_active" field in the mutation.
func (m *ContractMutation) IsActive() (r bool, exists bool) {
	v := m.is_active
	if v == nil {
		return
	}
	return *v, true
}

// OldIsActive returns the old "is_active" field's value of the Contract entity.
// If the Contract object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContractMutation) OldIsActive(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsActive is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsActive requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsActive: %w", err)
	}
	return oldValue.IsActive, nil
}

// ResetIsActive resets all changes to the "is_active" field.
func (m *ContractMutation) ResetIsActive() {
	m.is_active = nil
}

// SetTenantID sets the "tenant" edge to the Tenant entity by id.
func (m *ContractMutation) SetTenantID(id int) {
	m.tenant = &id
}

// ClearTenant clears the "tenant" edge to the Tenant entity.
func (m *ContractMutation) ClearTenant() {
	m.clearedtenant = true
}

// TenantCleared reports if the "tenant" edge to the Tenant entity was cleared.
func (m *ContractMutation) TenantCleared() bool {
	return m.clearedtenant
}

// TenantID returns the "tenant" edge ID in the mutation.
func (m *ContractMutation) TenantID() (id int, exists bool) {
	if m.tenant != nil {
		return *m.tenant, true
	}
	return
}

// TenantIDs returns the "tenant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TenantID instead. It exists only for internal usage by the builders.
func (m *ContractMutation) TenantIDs() (ids []int) {
	if id := m.tenant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTenant resets all changes to the "tenant" edge.
func (m *ContractMutation) ResetTenant() {
	m.tenant = nil
	m.clearedtenant = false
}

// Where appends a list predicates to the ContractMutation builder.
func (m *ContractMutation) Where(ps ...predicate.Contract) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ContractMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ContractMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Contract, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ContractMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ContractMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Contract).
func (m *ContractMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ContractMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.name != nil {
		fields = append(fields, contract.FieldName)
	}
	if m._type != nil {
		fields = append(fields, contract.FieldType)
	}
	if m.total_hours != nil {
		fields = append(fields, contract.FieldTotalHours)
	}
	if m.remaining_hours != nil {
		fields = append(fields, contract.FieldRemainingHours)
	}
	if m.grace_threshold_percent != nil {
		fields = append(fields, contract.FieldGraceThresholdPercent)
	}
	if m.start_date != nil {
		fields = append(fields, contract.FieldStartDate)
	}
	if m.end_date != nil {
		fields = append(fields, contract.FieldEndDate)
	}
	if m.is_active != nil {
		fields = append(fields, contract.FieldIsActive)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ContractMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case contract.FieldName:
		return m.Name()
	case contract.FieldType:
		return m.GetType()
	case contract.FieldTotalHours:
		return m.TotalHours()
	case contract.FieldRemainingHours:
		return m.RemainingHours()
	case contract.FieldGraceThresholdPercent:
		return m.GraceThresholdPercent()
	case contract.FieldStartDate:
		return m.StartDate()
	case contract.FieldEndDate:
		return m.EndDate()
	case contract.FieldIsActive:
		return m.IsActive()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ContractMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case contract.FieldName:
		return m.OldName(ctx)
	case contract.FieldType:
		return m.OldType(ctx)
	case contract.FieldTotalHours:
		return m.OldTotalHours(ctx)
	case contract.FieldRemainingHours:
		return m.OldRemainingHours(ctx)
	case contract.FieldGraceThresholdPercent:
		return m.OldGraceThresholdPercent(ctx)
	case contract.FieldStartDate:
		return m.OldStartDate(ctx)
	case contract.FieldEndDate:
		return m.OldEndDate(ctx)
	case contract.FieldIsActive:
		return m.OldIsActive(ctx)
	}
	return nil, fmt.Errorf("unknown Contract field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ContractMutation) SetField(name string, value ent.Value) error {
	switch name {
	case contract.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case contract.FieldType:
		v, ok := value.(contract.Type)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case contract.FieldTotalHours:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTotalHours(v)
		return nil
	case contract.FieldRemainingHours:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemainingHours(v)
		return nil
	case contract.FieldGraceThresholdPercent:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGraceThresholdPercent(v)
		return nil
	case contract.FieldStartDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartDate(v)
		return nil
	case contract.FieldEndDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndDate(v)
		return nil
	case contract.FieldIsActive:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsActive(v)
		return nil
	}
	return fmt.Errorf("unknown Contract field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ContractMutation) AddedFields() []string {
	var fields []string
	if m.addtotal_hours != nil {
		fields = append(fields, contract.FieldTotalHours)
	}
	if m.addremaining_hours != nil {
		fields = append(fields, contract.FieldRemainingHours)
	}
	if m.addgrace_threshold_percent != nil {
		fields = append(fields, contract.FieldGraceThresholdPercent)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ContractMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case contract.FieldTotalHours:
		return m.AddedTotalHours()
	case contract.FieldRemainingHours:
		return m.AddedRemainingHours()
	case contract.FieldGraceThresholdPercent:
		return m.AddedGraceThresholdPercent()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ContractMutation) AddField(name string, value ent.Value) error {
	switch name {
	case contract.FieldTotalHours:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTotalHours(v)
		return nil
	case contract.FieldRemainingHours:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRemainingHours(v)
		return nil
	case contract.FieldGraceThresholdPercent:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddGraceThresholdPercent(v)
		return nil
	}
	return fmt.Errorf("unknown Contract numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ContractMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(contract.FieldEndDate) {
		fields = append(fields, contract.FieldEndDate)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ContractMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ContractMutation) ClearField(name string) error {
	switch name {
	case contract.FieldEndDate:
		m.ClearEndDate()
		return nil
	}
	return fmt.Errorf("unknown Contract nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ContractMutation) ResetField(name string) error {
	switch name {
	case contract.FieldName:
		m.ResetName()
		return nil
	case contract.FieldType:
		m.ResetType()
		return nil
	case contract.FieldTotalHours:
		m.ResetTotalHours()
		return nil
	case contract.FieldRemainingHours:
		m.ResetRemainingHours()
		return nil
	case contract.FieldGraceThresholdPercent:
		m.ResetGraceThresholdPercent()
		return nil
	case contract.FieldStartDate:
		m.ResetStartDate()
		return nil
	case contract.FieldEndDate:
		m.ResetEndDate()
		return nil
	case contract.FieldIsActive:
		m.ResetIsActive()
		return nil
	}
	return fmt.Errorf("unknown Contract field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ContractMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.tenant != nil {
		edges = append(edges, contract.EdgeTenant)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ContractMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case contract.EdgeTenant:
		if id := m.tenant; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ContractMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ContractMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ContractMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedtenant {
		edges = append(edges, contract.EdgeTenant)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ContractMutation) EdgeCleared(name string) bool {
	switch name {
	case contract.EdgeTenant:
		return m.clearedtenant
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ContractMutation) ClearEdge(name string) error {
	switch name {
	case contract.EdgeTenant:
		m.ClearTenant()
		return nil
	}
	return fmt.Errorf("unknown Contract unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ContractMutation) ResetEdge(name string) error {
	switch name {
	case contract.EdgeTenant:
		m.ResetTenant()
		return nil
	}
	return fmt.Errorf("unknown Contract edge %s", name)
}

// CredentialMutation represents an operation that mutates the Credential nodes in the graph.
type CredentialMutation struct {
	config
	op                    Op
	typ                   string
	id                    *int
	name                  *string
	username              *string
	password_encrypted    *[]byte
	last_revealed_at      *time.Time
	metadata              *map[string]interface{}
	created_at            *time.Time
	clearedFields         map[string]struct{}
	tenant                *int
	clearedtenant         bool
	asset                 *int
	clearedasset          bool
	one_time_links        map[int]struct{}
	removedone_time_links map[int]struct{}
	clearedone_time_links bool
	done                  bool
	oldValue              func(context.Context) (*Credential, error)
	predicates            []predicate.Credential
}

var _ ent.Mutation = (*CredentialMutation)(nil)

// credentialOption allows management of the mutation configuration using functional options.
type credentialOption func(*CredentialMutation)

// newCredentialMutation creates new mutation for the Credential entity.
func newCredentialMutation(c config, op Op, opts ...credentialOption) *CredentialMutation {
	m := &CredentialMutation{
		config:        c,
		op:            op,
		typ:           TypeCredential,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCredentialID sets the ID field of the mutation.
func withCredentialID(id int) credentialOption {
	return func(m *CredentialMutation) {
		var (
			err   error
			once  sync.Once
			value *Credential
		)
		m.oldValue = func(ctx context.Context) (*Credential, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Credential.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCredential sets the old Credential of the mutation.
func withCredential(node *Credential) credentialOption {
	return func(m *CredentialMutation) {
		m.oldValue = func(context.Context) (*Credential, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CredentialMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CredentialMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CredentialMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CredentialMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Credential.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *CredentialMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *CredentialMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Credential entity.
// If the Credential object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CredentialMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *CredentialMutation) ResetName() {
	m.name = nil
}

// SetUsername sets the "username" field.
func (m *CredentialMutation) SetUsername(s string) {
	m.username = &s
}

// Username returns the value of the "username" field in the mutation.
func (m *CredentialMutation) Username() (r string, exists bool) {
	v := m.username
	if v == nil {
		return
	}
	return *v, true
}

// OldUsername returns the old "username" field's value of the Credential entity.
// If the Credential object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CredentialMutation) OldUsername(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsername is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsername requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsername: %w", err)
	}
	return oldValue.Username, nil
}

// ClearUsername clears the value of the "username" field.
func (m *CredentialMutation) ClearUsername() {
	m.username = nil
	m.clearedFields[credential.FieldUsername] = struct{}{}
}

// UsernameCleared returns if the "username" field was cleared in this mutation.
func (m *CredentialMutation) UsernameCleared() bool {
	_, ok := m.clearedFields[credential.FieldUsername]
	return ok
}

// ResetUsername resets all changes to the "username" field.
func (m *CredentialMutation) ResetUsername() {
	m.username = nil
	delete(m.clearedFields, credential.FieldUsername)
}

// SetPasswordEncrypted sets the "password_encrypted" field.
func (m *CredentialMutation) SetPasswordEncrypted(b []byte) {
	m.password_encrypted = &b
}

// PasswordEncrypted returns the value of the "password_encrypted" field in the mutation.
func (m *CredentialMutation) PasswordEncrypted() (r []byte, exists bool) {
	v := m.password_encrypted
	if v == nil {
		return
	}
	return *v, true
}

// OldPasswordEncrypted returns the old "password_encrypted" field's value of the Credential entity.
// If the Credential object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CredentialMutation) OldPasswordEncrypted(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPasswordEncrypted is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPasswordEncrypted requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPasswordEncrypted: %w", err)
	}
	return oldValue.PasswordEncrypted, nil
}

// ResetPasswordEncrypted resets all changes to the "password_encrypted" field.
func (m *CredentialMutation) ResetPasswordEncrypted() {
	m.password_encrypted = nil
}

// SetLastRevealedAt sets the "last_revealed_at" field.
func (m *CredentialMutation) SetLastRevealedAt(t time.Time) {
	m.last_revealed_at = &t
}

// LastRevealedAt returns the value of the "last_revealed_at" field in the mutation.
func (m *CredentialMutation) LastRevealedAt() (r time.Time, exists bool) {
	v := m.last_revealed_at
	if v == nil {
		return
	}
	return *v, true
}

// OldLastRevealedAt returns the old "last_revealed_at" field's value of the Credential entity.
// If the Credential object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CredentialMutation) OldLastRevealedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastRevealedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastRevealedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastRevealedAt: %w", err)
	}
	return oldValue.LastRevealedAt, nil
}

// ClearLastRevealedAt clears the value of the "last_revealed_at" field.
func (m *CredentialMutation) ClearLastRevealedAt() {
	m.last_revealed_at = nil
	m.clearedFields[credential.FieldLastRevealedAt] = struct{}{}
}

// LastRevealedAtCleared returns if the "last_revealed_at" field was cleared in this mutation.
func (m *CredentialMutation) LastRevealedAtCleared() bool {
	_, ok := m.clearedFields[credential.FieldLastRevealedAt]
	return ok
}

// ResetLastRevealedAt resets all changes to the "last_revealed_at" field.
func (m *CredentialMutation) ResetLastRevealedAt() {
	m.last_revealed_at = nil
	delete(m.clearedFields, credential.FieldLastRevealedAt)
}

// SetMetadata sets the "metadata" field.
func (m *CredentialMutation) SetMetadata(value map[string]interface{}) {
	m.metadata = &value
}

// Metadata returns the value of the "metadata" field in the mutation.
func (m *CredentialMutation) Metadata() (r map[string]interface{}, exists bool) {
	v := m.metadata
	if v == nil {
		return
	}
	return *v, true
}

// OldMetadata returns the old "metadata" field's value of the Credential entity.
// If the Credential object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CredentialMutation) OldMetadata(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMetadata is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMetadata requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetadata: %w", err)
	}
	return oldValue.Metadata, nil
}

// ClearMetadata clears the value of the "metadata" field.
func (m *CredentialMutation) ClearMetadata() {
	m.metadata = nil
	m.clearedFields[credential.FieldMetadata] = struct{}{}
}

// MetadataCleared returns if the "metadata" field was cleared in this mutation.
func (m *CredentialMutation) MetadataCleared() bool {
	_, ok := m.clearedFields[credential.FieldMetadata]
	return ok
}

// ResetMetadata resets all changes to the "metadata" field.
func (m *CredentialMutation) ResetMetadata() {
	m.metadata = nil
	delete(m.clearedFields, credential.FieldMetadata)
}

// SetCreatedAt sets the "created_at" field.
func (m *CredentialMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *CredentialMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Credential entity.
// If the Credential object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CredentialMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *CredentialMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetTenantID sets the "tenant" edge to the Tenant entity by id.
func (m *CredentialMutation) SetTenantID(id int) {
	m.tenant = &id
}

// ClearTenant clears the "tenant" edge to the Tenant entity.
func (m *CredentialMutation) ClearTenant() {
	m.clearedtenant = true
}

// TenantCleared reports if the "tenant" edge to the Tenant entity was cleared.
func (m *CredentialMutation) TenantCleared() bool {
	return m.clearedtenant
}

// TenantID returns the "tenant" edge ID in the mutation.
func (m *CredentialMutation) TenantID() (id int, exists bool) {
	if m.tenant != nil {
		return *m.tenant, true
	}
	return
}

// TenantIDs returns the "tenant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TenantID instead. It exists only for internal usage by the builders.
func (m *CredentialMutation) TenantIDs() (ids []int) {
	if id := m.tenant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTenant resets all changes to the "tenant" edge.
func (m *CredentialMutation) ResetTenant() {
	m.tenant = nil
	m.clearedtenant = false
}

// SetAssetID sets the "asset" edge to the Asset entity by id.
func (m *CredentialMutation) SetAssetID(id int) {
	m.asset = &id
}

// ClearAsset clears the "asset" edge to the Asset entity.
func (m *CredentialMutation) ClearAsset() {
	m.clearedasset = true
}

// AssetCleared reports if the "asset" edge to the Asset entity was cleared.
func (m *CredentialMutation) AssetCleared() bool {
	return m.clearedasset
}

// AssetID returns the "asset" edge ID in the mutation.
func (m *CredentialMutation) AssetID() (id int, exists bool) {
	if m.asset != nil {
		return *m.asset, true
	}
	return
}

// AssetIDs returns the "asset" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AssetID instead. It exists only for internal usage by the builders.
func (m *CredentialMutation) AssetIDs() (ids []int) {
	if id := m.asset; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAsset resets all changes to the "asset" edge.
func (m *CredentialMutation) ResetAsset() {
	m.asset = nil
	m.clearedasset = false
}

// AddOneTimeLinkIDs adds the "one_time_links" edge to the OneTimeLink entity by ids.
func (m *CredentialMutation) AddOneTimeLinkIDs(ids ...int) {
	if m.one_time_links == nil {
		m.one_time_links = make(map[int]struct{})
	}
	for i := range ids {
		m.one_time_links[ids[i]] = struct{}{}
	}
}

// ClearOneTimeLinks clears the "one_time_links" edge to the OneTimeLink entity.
func (m *CredentialMutation) ClearOneTimeLinks() {
	m.clearedone_time_links = true
}

// OneTimeLinksCleared reports if the "one_time_links" edge to the OneTimeLink entity was cleared.
func (m *CredentialMutation) OneTimeLinksCleared() bool {
	return m.clearedone_time_links
}

// RemoveOneTimeLinkIDs removes the "one_time_links" edge to the OneTimeLink entity by IDs.
func (m *CredentialMutation) RemoveOneTimeLinkIDs(ids ...int) {
	if m.removedone_time_links == nil {
		m.removedone_time_links = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.one_time_links, ids[i])
		m.removedone_time_links[ids[i]] = struct{}{}
	}
}

// RemovedOneTimeLinks returns the removed IDs of the "one_time_links" edge to the OneTimeLink entity.
func (m *CredentialMutation) RemovedOneTimeLinksIDs() (ids []int) {
	for id := range m.removedone_time_links {
		ids = append(ids, id)
	}
	return
}

// OneTimeLinksIDs returns the "one_time_links" edge IDs in the mutation.
func (m *CredentialMutation) OneTimeLinksIDs() (ids []int) {
	for id := range m.one_time_links {
		ids = append(ids, id)
	}
	return
}

// ResetOneTimeLinks resets all changes to the "one_time_links" edge.
func (m *CredentialMutation) ResetOneTimeLinks() {
	m.one_time_links = nil
	m.clearedone_time_links = false
	m.removedone_time_links = nil
}

// Where appends a list predicates to the CredentialMutation builder.
func (m *CredentialMutation) Where(ps ...predicate.Credential) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CredentialMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CredentialMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Credential, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CredentialMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CredentialMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Credential).
func (m *CredentialMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CredentialMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.name != nil {
		fields = append(fields, credential.FieldName)
	}
	if m.username != nil {
		fields = append(fields, credential.FieldUsername)
	}
	if m.password_encrypted != nil {
		fields = append(fields, credential.FieldPasswordEncrypted)
	}
	if m.last_revealed_at != nil {
		fields = append(fields, credential.FieldLastRevealedAt)
	}
	if m.metadata != nil {
		fields = append(fields, credential.FieldMetadata)
	}
	if m.created_at != nil {
		fields = append(fields, credential.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CredentialMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case credential.FieldName:
		return m.Name()
	case credential.FieldUsername:
		return m.Username()
	case credential.FieldPasswordEncrypted:
		return m.PasswordEncrypted()
	case credential.FieldLastRevealedAt:
		return m.LastRevealedAt()
	case credential.FieldMetadata:
		return m.Metadata()
	case credential.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CredentialMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case credential.FieldName:
		return m.OldName(ctx)
	case credential.FieldUsername:
		return m.OldUsername(ctx)
	case credential.FieldPasswordEncrypted:
		return m.OldPasswordEncrypted(ctx)
	case credential.FieldLastRevealedAt:
		return m.OldLastRevealedAt(ctx)
	case credential.FieldMetadata:
		return m.OldMetadata(ctx)
	case credential.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Credential field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CredentialMutation) SetField(name string, value ent.Value) error {
	switch name {
	case credential.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case credential.FieldUsername:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsername(v)
		return nil
	case credential.FieldPasswordEncrypted:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPasswordEncrypted(v)
		return nil
	case credential.FieldLastRevealedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastRevealedAt(v)
		return nil
	case credential.FieldMetadata:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetadata(v)
		return nil
	case credential.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Credential field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CredentialMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CredentialMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CredentialMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Credential numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CredentialMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(credential.FieldUsername) {
		fields = append(fields, credential.FieldUsername)
	}
	if m.FieldCleared(credential.FieldLastRevealedAt) {
		fields = append(fields, credential.FieldLastRevealedAt)
	}
	if m.FieldCleared(credential.FieldMetadata) {
		fields = append(fields, credential.FieldMetadata)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CredentialMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CredentialMutation) ClearField(name string) error {
	switch name {
	case credential.FieldUsername:
		m.ClearUsername()
		return nil
	case credential.FieldLastRevealedAt:
		m.ClearLastRevealedAt()
		return nil
	case credential.FieldMetadata:
		m.ClearMetadata()
		return nil
	}
	return fmt.Errorf("unknown Credential nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CredentialMutation) ResetField(name string) error {
	switch name {
	case credential.FieldName:
		m.ResetName()
		return nil
	case credential.FieldUsername:
		m.ResetUsername()
		return nil
	case credential.FieldPasswordEncrypted:
		m.ResetPasswordEncrypted()
		return nil
	case credential.FieldLastRevealedAt:
		m.ResetLastRevealedAt()
		return nil
	case credential.FieldMetadata:
		m.ResetMetadata()
		return nil
	case credential.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown Credential field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CredentialMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.tenant != nil {
		edges = append(edges, credential.EdgeTenant)
	}
	if m.asset != nil {
		edges = append(edges, credential.EdgeAsset)
	}
	if m.one_time_links != nil {
		edges = append(edges, credential.EdgeOneTimeLinks)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CredentialMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case credential.EdgeTenant:
		if id := m.tenant; id != nil {
			return []ent.Value{*id}
		}
	case credential.EdgeAsset:
		if id := m.asset; id != nil {
			return []ent.Value{*id}
		}
	case credential.EdgeOneTimeLinks:
		ids := make([]ent.Value, 0, len(m.one_time_links))
		for id := range m.one_time_links {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CredentialMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedone_time_links != nil {
		edges = append(edges, credential.EdgeOneTimeLinks)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CredentialMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case credential.EdgeOneTimeLinks:
		ids := make([]ent.Value, 0, len(m.removedone_time_links))
		for id := range m.removedone_time_links {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CredentialMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedtenant {
		edges = append(edges, credential.EdgeTenant)
	}
	if m.clearedasset {
		edges = append(edges, credential.EdgeAsset)
	}
	if m.clearedone_time_links {
		edges = append(edges, credential.EdgeOneTimeLinks)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CredentialMutation) EdgeCleared(name string) bool {
	switch name {
	case credential.EdgeTenant:
		return m.clearedtenant
	case credential.EdgeAsset:
		return m.clearedasset
	case credential.EdgeOneTimeLinks:
		return m.clearedone_time_links
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CredentialMutation) ClearEdge(name string) error {
	switch name {
	case credential.EdgeTenant:
		m.ClearTenant()
		return nil
	case credential.EdgeAsset:
		m.ClearAsset()
		return nil
	}
	return fmt.Errorf("unknown Credential unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CredentialMutation) ResetEdge(name string) error {
	switch name {
	case credential.EdgeTenant:
		m.ResetTenant()
		return nil
	case credential.EdgeAsset:
		m.ResetAsset()
		return nil
	case credential.EdgeOneTimeLinks:
		m.ResetOneTimeLinks()
		return nil
	}
	return fmt.Errorf("unknown Credential edge %s", name)
}

// DepartmentMutation represents an operation that mutates the Department nodes in the graph.
type DepartmentMutation struct {
	config
	op              Op
	typ             string
	id              *int
	name            *string
	code            *string
	description     *string
	clearedFields   map[string]struct{}
	parent          *int
	clearedparent   bool
	children        map[int]struct{}
	removedchildren map[int]struct{}
	clearedchildren bool
	members         map[int]struct{}
	removedmembers  map[int]struct{}
	clearedmembers  bool
	head            *int
	clearedhead     bool
	tenant          *int
	clearedtenant   bool
	done            bool
	oldValue        func(context.Context) (*Department, error)
	predicates      []predicate.Department
}

var _ ent.Mutation = (*DepartmentMutation)(nil)

// departmentOption allows management of the mutation configuration using functional options.
type departmentOption func(*DepartmentMutation)

// newDepartmentMutation creates new mutation for the Department entity.
func newDepartmentMutation(c config, op Op, opts ...departmentOption) *DepartmentMutation {
	m := &DepartmentMutation{
		config:        c,
		op:            op,
		typ:           TypeDepartment,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDepartmentID sets the ID field of the mutation.
func withDepartmentID(id int) departmentOption {
	return func(m *DepartmentMutation) {
		var (
			err   error
			once  sync.Once
			value *Department
		)
		m.oldValue = func(ctx context.Context) (*Department, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Department.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDepartment sets the old Department of the mutation.
func withDepartment(node *Department) departmentOption {
	return func(m *DepartmentMutation) {
		m.oldValue = func(context.Context) (*Department, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DepartmentMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DepartmentMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *DepartmentMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *DepartmentMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Department.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *DepartmentMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *DepartmentMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Department entity.
// If the Department object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DepartmentMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *DepartmentMutation) ResetName() {
	m.name = nil
}

// SetCode sets the "code" field.
func (m *DepartmentMutation) SetCode(s string) {
	m.code = &s
}

// Code returns the value of the "code" field in the mutation.
func (m *DepartmentMutation) Code() (r string, exists bool) {
	v := m.code
	if v == nil {
		return
	}
	return *v, true
}

// OldCode returns the old "code" field's value of the Department entity.
// If the Department object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DepartmentMutation) OldCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCode: %w", err)
	}
	return oldValue.Code, nil
}

// ResetCode resets all changes to the "code" field.
func (m *DepartmentMutation) ResetCode() {
	m.code = nil
}

// SetDescription sets the "description" field.
func (m *DepartmentMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *DepartmentMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Department entity.
// If the Department object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DepartmentMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *DepartmentMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[department.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *DepartmentMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[department.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *DepartmentMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, department.FieldDescription)
}

// SetParentID sets the "parent" edge to the Department entity by id.
func (m *DepartmentMutation) SetParentID(id int) {
	m.parent = &id
}

// ClearParent clears the "parent" edge to the Department entity.
func (m *DepartmentMutation) ClearParent() {
	m.clearedparent = true
}

// ParentCleared reports if the "parent" edge to the Department entity was cleared.
func (m *DepartmentMutation) ParentCleared() bool {
	return m.clearedparent
}

// ParentID returns the "parent" edge ID in the mutation.
func (m *DepartmentMutation) ParentID() (id int, exists bool) {
	if m.parent != nil {
		return *m.parent, true
	}
	return
}

// ParentIDs returns the "parent" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ParentID instead. It exists only for internal usage by the builders.
func (m *DepartmentMutation) ParentIDs() (ids []int) {
	if id := m.parent; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetParent resets all changes to the "parent" edge.
func (m *DepartmentMutation) ResetParent() {
	m.parent = nil
	m.clearedparent = false
}

// AddChildIDs adds the "children" edge to the Department entity by ids.
func (m *DepartmentMutation) AddChildIDs(ids ...int) {
	if m.children == nil {
		m.children = make(map[int]struct{})
	}
	for i := range ids {
		m.children[ids[i]] = struct{}{}
	}
}

// ClearChildren clears the "children" edge to the Department entity.
func (m *DepartmentMutation) ClearChildren() {
	m.clearedchildren = true
}

// ChildrenCleared reports if the "children" edge to the Department entity was cleared.
func (m *DepartmentMutation) ChildrenCleared() bool {
	return m.clearedchildren
}

// RemoveChildIDs removes the "children" edge to the Department entity by IDs.
func (m *DepartmentMutation) RemoveChildIDs(ids ...int) {
	if m.removedchildren == nil {
		m.removedchildren = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.children, ids[i])
		m.removedchildren[ids[i]] = struct{}{}
	}
}

// RemovedChildren returns the removed IDs of the "children" edge to the Department entity.
func (m *DepartmentMutation) RemovedChildrenIDs() (ids []int) {
	for id := range m.removedchildren {
		ids = append(ids, id)
	}
	return
}

// ChildrenIDs returns the "children" edge IDs in the mutation.
func (m *DepartmentMutation) ChildrenIDs() (ids []int) {
	for id := range m.children {
		ids = append(ids, id)
	}
	return
}

// ResetChildren resets all changes to the "children" edge.
func (m *DepartmentMutation) ResetChildren() {
	m.children = nil
	m.clearedchildren = false
	m.removedchildren = nil
}

// AddMemberIDs adds the "members" edge to the Employee entity by ids.
func (m *DepartmentMutation) AddMemberIDs(ids ...int) {
	if m.members == nil {
		m.members = make(map[int]struct{})
	}
	for i := range ids {
		m.members[ids[i]] = struct{}{}
	}
}

// ClearMembers clears the "members" edge to the Employee entity.
func (m *DepartmentMutation) ClearMembers() {
	m.clearedmembers = true
}

// MembersCleared reports if the "members" edge to the Employee entity was cleared.
func (m *DepartmentMutation) MembersCleared() bool {
	return m.clearedmembers
}

// RemoveMemberIDs removes the "members" edge to the Employee entity by IDs.
func (m *DepartmentMutation) RemoveMemberIDs(ids ...int) {
	if m.removedmembers == nil {
		m.removedmembers = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.members, ids[i])
		m.removedmembers[ids[i]] = struct{}{}
	}
}

// RemovedMembers returns the removed IDs of the "members" edge to the Employee entity.
func (m *DepartmentMutation) RemovedMembersIDs() (ids []int) {
	for id := range m.removedmembers {
		ids = append(ids, id)
	}
	return
}

// MembersIDs returns the "members" edge IDs in the mutation.
func (m *DepartmentMutation) MembersIDs() (ids []int) {
	for id := range m.members {
		ids = append(ids, id)
	}
	return
}

// ResetMembers resets all changes to the "members" edge.
func (m *DepartmentMutation) ResetMembers() {
	m.members = nil
	m.clearedmembers = false
	m.removedmembers = nil
}

// SetHeadID sets the "head" edge to the Employee entity by id.
func (m *DepartmentMutation) SetHeadID(id int) {
	m.head = &id
}

// ClearHead clears the "head" edge to the Employee entity.
func (m *DepartmentMutation) ClearHead() {
	m.clearedhead = true
}

// HeadCleared reports if the "head" edge to the Employee entity was cleared.
func (m *DepartmentMutation) HeadCleared() bool {
	return m.clearedhead
}

// HeadID returns the "head" edge ID in the mutation.
func (m *DepartmentMutation) HeadID() (id int, exists bool) {
	if m.head != nil {
		return *m.head, true
	}
	return
}

// HeadIDs returns the "head" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// HeadID instead. It exists only for internal usage by the builders.
func (m *DepartmentMutation) HeadIDs() (ids []int) {
	if id := m.head; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetHead resets all changes to the "head" edge.
func (m *DepartmentMutation) ResetHead() {
	m.head = nil
	m.clearedhead = false
}

// SetTenantID sets the "tenant" edge to the Tenant entity by id.
func (m *DepartmentMutation) SetTenantID(id int) {
	m.tenant = &id
}

// ClearTenant clears the "tenant" edge to the Tenant entity.
func (m *DepartmentMutation) ClearTenant() {
	m.clearedtenant = true
}

// TenantCleared reports if the "tenant" edge to the Tenant entity was cleared.
func (m *DepartmentMutation) TenantCleared() bool {
	return m.clearedtenant
}

// TenantID returns the "tenant" edge ID in the mutation.
func (m *DepartmentMutation) TenantID() (id int, exists bool) {
	if m.tenant != nil {
		return *m.tenant, true
	}
	return
}

// TenantIDs returns the "tenant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TenantID instead. It exists only for internal usage by the builders.
func (m *DepartmentMutation) TenantIDs() (ids []int) {
	if id := m.tenant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTenant resets all changes to the "tenant" edge.
func (m *DepartmentMutation) ResetTenant() {
	m.tenant = nil
	m.clearedtenant = false
}

// Where appends a list predicates to the DepartmentMutation builder.
func (m *DepartmentMutation) Where(ps ...predicate.Department) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the DepartmentMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *DepartmentMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Department, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *DepartmentMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *DepartmentMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Department).
func (m *DepartmentMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DepartmentMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.name != nil {
		fields = append(fields, department.FieldName)
	}
	if m.code != nil {
		fields = append(fields, department.FieldCode)
	}
	if m.description != nil {
		fields = append(fields, department.FieldDescription)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DepartmentMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case department.FieldName:
		return m.Name()
	case department.FieldCode:
		return m.Code()
	case department.FieldDescription:
		return m.Description()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DepartmentMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case department.FieldName:
		return m.OldName(ctx)
	case department.FieldCode:
		return m.OldCode(ctx)
	case department.FieldDescription:
		return m.OldDescription(ctx)
	}
	return nil, fmt.Errorf("unknown Department field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DepartmentMutation) SetField(name string, value ent.Value) error {
	switch name {
	case department.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case department.FieldCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCode(v)
		return nil
	case department.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	}
	return fmt.Errorf("unknown Department field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DepartmentMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DepartmentMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DepartmentMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Department numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DepartmentMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(department.FieldDescription) {
		fields = append(fields, department.FieldDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DepartmentMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DepartmentMutation) ClearField(name string) error {
	switch name {
	case department.FieldDescription:
		m.ClearDescription()
		return nil
	}
	return fmt.Errorf("unknown Department nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DepartmentMutation) ResetField(name string) error {
	switch name {
	case department.FieldName:
		m.ResetName()
		return nil
	case department.FieldCode:
		m.ResetCode()
		return nil
	case department.FieldDescription:
		m.ResetDescription()
		return nil
	}
	return fmt.Errorf("unknown Department field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DepartmentMutation) AddedEdges() []string {
	edges := make([]string, 0, 5)
	if m.parent != nil {
		edges = append(edges, department.EdgeParent)
	}
	if m.children != nil {
		edges = append(edges, department.EdgeChildren)
	}
	if m.members != nil {
		edges = append(edges, department.EdgeMembers)
	}
	if m.head != nil {
		edges = append(edges, department.EdgeHead)
	}
	if m.tenant != nil {
		edges = append(edges, department.EdgeTenant)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DepartmentMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case department.EdgeParent:
		if id := m.parent; id != nil {
			return []ent.Value{*id}
		}
	case department.EdgeChildren:
		ids := make([]ent.Value, 0, len(m.children))
		for id := range m.children {
			ids = append(ids, id)
		}
		return ids
	case department.EdgeMembers:
		ids := make([]ent.Value, 0, len(m.members))
		for id := range m.members {
			ids = append(ids, id)
		}
		return ids
	case department.EdgeHead:
		if id := m.head; id != nil {
			return []ent.Value{*id}
		}
	case department.EdgeTenant:
		if id := m.tenant; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DepartmentMutation) RemovedEdges() []string {
	edges := make([]string, 0, 5)
	if m.removedchildren != nil {
		edges = append(edges, department.EdgeChildren)
	}
	if m.removedmembers != nil {
		edges = append(edges, department.EdgeMembers)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DepartmentMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case department.EdgeChildren:
		ids := make([]ent.Value, 0, len(m.removedchildren))
		for id := range m.removedchildren {
			ids = append(ids, id)
		}
		return ids
	case department.EdgeMembers:
		ids := make([]ent.Value, 0, len(m.removedmembers))
		for id := range m.removedmembers {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DepartmentMutation) ClearedEdges() []string {
	edges := make([]string, 0, 5)
	if m.clearedparent {
		edges = append(edges, department.EdgeParent)
	}
	if m.clearedchildren {
		edges = append(edges, department.EdgeChildren)
	}
	if m.clearedmembers {
		edges = append(edges, department.EdgeMembers)
	}
	if m.clearedhead {
		edges = append(edges, department.EdgeHead)
	}
	if m.clearedtenant {
		edges = append(edges, department.EdgeTenant)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DepartmentMutation) EdgeCleared(name string) bool {
	switch name {
	case department.EdgeParent:
		return m.clearedparent
	case department.EdgeChildren:
		return m.clearedchildren
	case department.EdgeMembers:
		return m.clearedmembers
	case department.EdgeHead:
		return m.clearedhead
	case department.EdgeTenant:
		return m.clearedtenant
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DepartmentMutation) ClearEdge(name string) error {
	switch name {
	case department.EdgeParent:
		m.ClearParent()
		return nil
	case department.EdgeHead:
		m.ClearHead()
		return nil
	case department.EdgeTenant:
		m.ClearTenant()
		return nil
	}
	return fmt.Errorf("unknown Department unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DepartmentMutation) ResetEdge(name string) error {
	switch name {
	case department.EdgeParent:
		m.ResetParent()
		return nil
	case department.EdgeChildren:
		m.ResetChildren()
		return nil
	case department.EdgeMembers:
		m.ResetMembers()
		return nil
	case department.EdgeHead:
		m.ResetHead()
		return nil
	case department.EdgeTenant:
		m.ResetTenant()
		return nil
	}
	return fmt.Errorf("unknown Department edge %s", name)
}

// DetectionEventMutation represents an operation that mutates the DetectionEvent nodes in the graph.
type DetectionEventMutation struct {
	config
	op             Op
	typ            string
	id             *int
	label          *string
	confidence     *float64
	addconfidence  *float64
	box            *map[string]float64
	timestamp      *time.Time
	thumbnail_path *string
	metadata       *map[string]interface{}
	clearedFields  map[string]struct{}
	camera         *int
	clearedcamera  bool
	tenant         *int
	clearedtenant  bool
	done           bool
	oldValue       func(context.Context) (*DetectionEvent, error)
	predicates     []predicate.DetectionEvent
}

var _ ent.Mutation = (*DetectionEventMutation)(nil)

// detectioneventOption allows management of the mutation configuration using functional options.
type detectioneventOption func(*DetectionEventMutation)

// newDetectionEventMutation creates new mutation for the DetectionEvent entity.
func newDetectionEventMutation(c config, op Op, opts ...detectioneventOption) *DetectionEventMutation {
	m := &DetectionEventMutation{
		config:        c,
		op:            op,
		typ:           TypeDetectionEvent,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDetectionEventID sets the ID field of the mutation.
func withDetectionEventID(id int) detectioneventOption {
	return func(m *DetectionEventMutation) {
		var (
			err   error
			once  sync.Once
			value *DetectionEvent
		)
		m.oldValue = func(ctx context.Context) (*DetectionEvent, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().DetectionEvent.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDetectionEvent sets the old DetectionEvent of the mutation.
func withDetectionEvent(node *DetectionEvent) detectioneventOption {
	return func(m *DetectionEventMutation) {
		m.oldValue = func(context.Context) (*DetectionEvent, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DetectionEventMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DetectionEventMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *DetectionEventMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *DetectionEventMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().DetectionEvent.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetLabel sets the "label" field.
func (m *DetectionEventMutation) SetLabel(s string) {
	m.label = &s
}

// Label returns the value of the "label" field in the mutation.
func (m *DetectionEventMutation) Label() (r string, exists bool) {
	v := m.label
	if v == nil {
		return
	}
	return *v, true
}

// OldLabel returns the old "label" field's value of the DetectionEvent entity.
// If the DetectionEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DetectionEventMutation) OldLabel(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLabel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLabel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLabel: %w", err)
	}
	return oldValue.Label, nil
}

// ResetLabel resets all changes to the "label" field.
func (m *DetectionEventMutation) ResetLabel() {
	m.label = nil
}

// SetConfidence sets the "confidence" field.
func (m *DetectionEventMutation) SetConfidence(f float64) {
	m.confidence = &f
	m.addconfidence = nil
}

// Confidence returns the value of the "confidence" field in the mutation.
func (m *DetectionEventMutation) Confidence() (r float64, exists bool) {
	v := m.confidence
	if v == nil {
		return
	}
	return *v, true
}

// OldConfidence returns the old "confidence" field's value of the DetectionEvent entity.
// If the DetectionEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DetectionEventMutation) OldConfidence(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldConfidence is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldConfidence requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldConfidence: %w", err)
	}
	return oldValue.Confidence, nil
}

// AddConfidence adds f to the "confidence" field.
func (m *DetectionEventMutation) AddConfidence(f float64) {
	if m.addconfidence != nil {
		*m.addconfidence += f
	} else {
		m.addconfidence = &f
	}
}

// AddedConfidence returns the value that was added to the "confidence" field in this mutation.
func (m *DetectionEventMutation) AddedConfidence() (r float64, exists bool) {
	v := m.addconfidence
	if v == nil {
		return
	}
	return *v, true
}

// ResetConfidence resets all changes to the "confidence" field.
func (m *DetectionEventMutation) ResetConfidence() {
	m.confidence = nil
	m.addconfidence = nil
}

// SetBox sets the "box" field.
func (m *DetectionEventMutation) SetBox(value map[string]float64) {
	m.box = &value
}

// Box returns the value of the "box" field in the mutation.
func (m *DetectionEventMutation) Box() (r map[string]float64, exists bool) {
	v := m.box
	if v == nil {
		return
	}
	return *v, true
}

// OldBox returns the old "box" field's value of the DetectionEvent entity.
// If the DetectionEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DetectionEventMutation) OldBox(ctx context.Context) (v map[string]float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBox is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBox requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBox: %w", err)
	}
	return oldValue.Box, nil
}

// ResetBox resets all changes to the "box" field.
func (m *DetectionEventMutation) ResetBox() {
	m.box = nil
}

// SetTimestamp sets the "timestamp" field.
func (m *DetectionEventMutation) SetTimestamp(t time.Time) {
	m.timestamp = &t
}

// Timestamp returns the value of the "timestamp" field in the mutation.
func (m *DetectionEventMutation) Timestamp() (r time.Time, exists bool) {
	v := m.timestamp
	if v == nil {
		return
	}
	return *v, true
}

// OldTimestamp returns the old "timestamp" field's value of the DetectionEvent entity.
// If the DetectionEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DetectionEventMutation) OldTimestamp(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTimestamp is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTimestamp requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTimestamp: %w", err)
	}
	return oldValue.Timestamp, nil
}

// ResetTimestamp resets all changes to the "timestamp" field.
func (m *DetectionEventMutation) ResetTimestamp() {
	m.timestamp = nil
}

// SetThumbnailPath sets the "thumbnail_path" field.
func (m *DetectionEventMutation) SetThumbnailPath(s string) {
	m.thumbnail_path = &s
}

// ThumbnailPath returns the value of the "thumbnail_path" field in the mutation.
func (m *DetectionEventMutation) ThumbnailPath() (r string, exists bool) {
	v := m.thumbnail_path
	if v == nil {
		return
	}
	return *v, true
}

// OldThumbnailPath returns the old "thumbnail_path" field's value of the DetectionEvent entity.
// If the DetectionEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DetectionEventMutation) OldThumbnailPath(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldThumbnailPath is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldThumbnailPath requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldThumbnailPath: %w", err)
	}
	return oldValue.ThumbnailPath, nil
}

// ClearThumbnailPath clears the value of the "thumbnail_path" field.
func (m *DetectionEventMutation) ClearThumbnailPath() {
	m.thumbnail_path = nil
	m.clearedFields[detectionevent.FieldThumbnailPath] = struct{}{}
}

// ThumbnailPathCleared returns if the "thumbnail_path" field was cleared in this mutation.
func (m *DetectionEventMutation) ThumbnailPathCleared() bool {
	_, ok := m.clearedFields[detectionevent.FieldThumbnailPath]
	return ok
}

// ResetThumbnailPath resets all changes to the "thumbnail_path" field.
func (m *DetectionEventMutation) ResetThumbnailPath() {
	m.thumbnail_path = nil
	delete(m.clearedFields, detectionevent.FieldThumbnailPath)
}

// SetMetadata sets the "metadata" field.
func (m *DetectionEventMutation) SetMetadata(value map[string]interface{}) {
	m.metadata = &value
}

// Metadata returns the value of the "metadata" field in the mutation.
func (m *DetectionEventMutation) Metadata() (r map[string]interface{}, exists bool) {
	v := m.metadata
	if v == nil {
		return
	}
	return *v, true
}

// OldMetadata returns the old "metadata" field's value of the DetectionEvent entity.
// If the DetectionEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DetectionEventMutation) OldMetadata(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMetadata is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMetadata requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetadata: %w", err)
	}
	return oldValue.Metadata, nil
}

// ClearMetadata clears the value of the "metadata" field.
func (m *DetectionEventMutation) ClearMetadata() {
	m.metadata = nil
	m.clearedFields[detectionevent.FieldMetadata] = struct{}{}
}

// MetadataCleared returns if the "metadata" field was cleared in this mutation.
func (m *DetectionEventMutation) MetadataCleared() bool {
	_, ok := m.clearedFields[detectionevent.FieldMetadata]
	return ok
}

// ResetMetadata resets all changes to the "metadata" field.
func (m *DetectionEventMutation) ResetMetadata() {
	m.metadata = nil
	delete(m.clearedFields, detectionevent.FieldMetadata)
}

// SetCameraID sets the "camera" edge to the Camera entity by id.
func (m *DetectionEventMutation) SetCameraID(id int) {
	m.camera = &id
}

// ClearCamera clears the "camera" edge to the Camera entity.
func (m *DetectionEventMutation) ClearCamera() {
	m.clearedcamera = true
}

// CameraCleared reports if the "camera" edge to the Camera entity was cleared.
func (m *DetectionEventMutation) CameraCleared() bool {
	return m.clearedcamera
}

// CameraID returns the "camera" edge ID in the mutation.
func (m *DetectionEventMutation) CameraID() (id int, exists bool) {
	if m.camera != nil {
		return *m.camera, true
	}
	return
}

// CameraIDs returns the "camera" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CameraID instead. It exists only for internal usage by the builders.
func (m *DetectionEventMutation) CameraIDs() (ids []int) {
	if id := m.camera; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCamera resets all changes to the "camera" edge.
func (m *DetectionEventMutation) ResetCamera() {
	m.camera = nil
	m.clearedcamera = false
}

// SetTenantID sets the "tenant" edge to the Tenant entity by id.
func (m *DetectionEventMutation) SetTenantID(id int) {
	m.tenant = &id
}

// ClearTenant clears the "tenant" edge to the Tenant entity.
func (m *DetectionEventMutation) ClearTenant() {
	m.clearedtenant = true
}

// TenantCleared reports if the "tenant" edge to the Tenant entity was cleared.
func (m *DetectionEventMutation) TenantCleared() bool {
	return m.clearedtenant
}

// TenantID returns the "tenant" edge ID in the mutation.
func (m *DetectionEventMutation) TenantID() (id int, exists bool) {
	if m.tenant != nil {
		return *m.tenant, true
	}
	return
}

// TenantIDs returns the "tenant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TenantID instead. It exists only for internal usage by the builders.
func (m *DetectionEventMutation) TenantIDs() (ids []int) {
	if id := m.tenant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTenant resets all changes to the "tenant" edge.
func (m *DetectionEventMutation) ResetTenant() {
	m.tenant = nil
	m.clearedtenant = false
}

// Where appends a list predicates to the DetectionEventMutation builder.
func (m *DetectionEventMutation) Where(ps ...predicate.DetectionEvent) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the DetectionEventMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *DetectionEventMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.DetectionEvent, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *DetectionEventMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *DetectionEventMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (DetectionEvent).
func (m *DetectionEventMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DetectionEventMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.label != nil {
		fields = append(fields, detectionevent.FieldLabel)
	}
	if m.confidence != nil {
		fields = append(fields, detectionevent.FieldConfidence)
	}
	if m.box != nil {
		fields = append(fields, detectionevent.FieldBox)
	}
	if m.timestamp != nil {
		fields = append(fields, detectionevent.FieldTimestamp)
	}
	if m.thumbnail_path != nil {
		fields = append(fields, detectionevent.FieldThumbnailPath)
	}
	if m.metadata != nil {
		fields = append(fields, detectionevent.FieldMetadata)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DetectionEventMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case detectionevent.FieldLabel:
		return m.Label()
	case detectionevent.FieldConfidence:
		return m.Confidence()
	case detectionevent.FieldBox:
		return m.Box()
	case detectionevent.FieldTimestamp:
		return m.Timestamp()
	case detectionevent.FieldThumbnailPath:
		return m.ThumbnailPath()
	case detectionevent.FieldMetadata:
		return m.Metadata()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DetectionEventMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case detectionevent.FieldLabel:
		return m.OldLabel(ctx)
	case detectionevent.FieldConfidence:
		return m.OldConfidence(ctx)
	case detectionevent.FieldBox:
		return m.OldBox(ctx)
	case detectionevent.FieldTimestamp:
		return m.OldTimestamp(ctx)
	case detectionevent.FieldThumbnailPath:
		return m.OldThumbnailPath(ctx)
	case detectionevent.FieldMetadata:
		return m.OldMetadata(ctx)
	}
	return nil, fmt.Errorf("unknown DetectionEvent field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DetectionEventMutation) SetField(name string, value ent.Value) error {
	switch name {
	case detectionevent.FieldLabel:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLabel(v)
		return nil
	case detectionevent.FieldConfidence:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetConfidence(v)
		return nil
	case detectionevent.FieldBox:
		v, ok := value.(map[string]float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBox(v)
		return nil
	case detectionevent.FieldTimestamp:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTimestamp(v)
		return nil
	case detectionevent.FieldThumbnailPath:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetThumbnailPath(v)
		return nil
	case detectionevent.FieldMetadata:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetadata(v)
		return nil
	}
	return fmt.Errorf("unknown DetectionEvent field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DetectionEventMutation) AddedFields() []string {
	var fields []string
	if m.addconfidence != nil {
		fields = append(fields, detectionevent.FieldConfidence)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DetectionEventMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case detectionevent.FieldConfidence:
		return m.AddedConfidence()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DetectionEventMutation) AddField(name string, value ent.Value) error {
	switch name {
	case detectionevent.FieldConfidence:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddConfidence(v)
		return nil
	}
	return fmt.Errorf("unknown DetectionEvent numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DetectionEventMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(detectionevent.FieldThumbnailPath) {
		fields = append(fields, detectionevent.FieldThumbnailPath)
	}
	if m.FieldCleared(detectionevent.FieldMetadata) {
		fields = append(fields, detectionevent.FieldMetadata)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DetectionEventMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DetectionEventMutation) ClearField(name string) error {
	switch name {
	case detectionevent.FieldThumbnailPath:
		m.ClearThumbnailPath()
		return nil
	case detectionevent.FieldMetadata:
		m.ClearMetadata()
		return nil
	}
	return fmt.Errorf("unknown DetectionEvent nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DetectionEventMutation) ResetField(name string) error {
	switch name {
	case detectionevent.FieldLabel:
		m.ResetLabel()
		return nil
	case detectionevent.FieldConfidence:
		m.ResetConfidence()
		return nil
	case detectionevent.FieldBox:
		m.ResetBox()
		return nil
	case detectionevent.FieldTimestamp:
		m.ResetTimestamp()
		return nil
	case detectionevent.FieldThumbnailPath:
		m.ResetThumbnailPath()
		return nil
	case detectionevent.FieldMetadata:
		m.ResetMetadata()
		return nil
	}
	return fmt.Errorf("unknown DetectionEvent field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DetectionEventMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.camera != nil {
		edges = append(edges, detectionevent.EdgeCamera)
	}
	if m.tenant != nil {
		edges = append(edges, detectionevent.EdgeTenant)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DetectionEventMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case detectionevent.EdgeCamera:
		if id := m.camera; id != nil {
			return []ent.Value{*id}
		}
	case detectionevent.EdgeTenant:
		if id := m.tenant; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DetectionEventMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DetectionEventMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DetectionEventMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedcamera {
		edges = append(edges, detectionevent.EdgeCamera)
	}
	if m.clearedtenant {
		edges = append(edges, detectionevent.EdgeTenant)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DetectionEventMutation) EdgeCleared(name string) bool {
	switch name {
	case detectionevent.EdgeCamera:
		return m.clearedcamera
	case detectionevent.EdgeTenant:
		return m.clearedtenant
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DetectionEventMutation) ClearEdge(name string) error {
	switch name {
	case detectionevent.EdgeCamera:
		m.ClearCamera()
		return nil
	case detectionevent.EdgeTenant:
		m.ClearTenant()
		return nil
	}
	return fmt.Errorf("unknown DetectionEvent unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DetectionEventMutation) ResetEdge(name string) error {
	switch name {
	case detectionevent.EdgeCamera:
		m.ResetCamera()
		return nil
	case detectionevent.EdgeTenant:
		m.ResetTenant()
		return nil
	}
	return fmt.Errorf("unknown DetectionEvent edge %s", name)
}

// DiscoveryEntryMutation represents an operation that mutates the DiscoveryEntry nodes in the graph.
type DiscoveryEntryMutation struct {
	config
	op            Op
	typ           string
	id            *int
	hardware_id   *string
	name          *string
	hostname      *string
	ip            *string
	mac           *string
	_type         *string
	metadata      *map[string]interface{}
	status        *discoveryentry.Status
	discovered_at *time.Time
	clearedFields map[string]struct{}
	tenant        *int
	clearedtenant bool
	done          bool
	oldValue      func(context.Context) (*DiscoveryEntry, error)
	predicates    []predicate.DiscoveryEntry
}

var _ ent.Mutation = (*DiscoveryEntryMutation)(nil)

// discoveryentryOption allows management of the mutation configuration using functional options.
type discoveryentryOption func(*DiscoveryEntryMutation)

// newDiscoveryEntryMutation creates new mutation for the DiscoveryEntry entity.
func newDiscoveryEntryMutation(c config, op Op, opts ...discoveryentryOption) *DiscoveryEntryMutation {
	m := &DiscoveryEntryMutation{
		config:        c,
		op:            op,
		typ:           TypeDiscoveryEntry,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDiscoveryEntryID sets the ID field of the mutation.
func withDiscoveryEntryID(id int) discoveryentryOption {
	return func(m *DiscoveryEntryMutation) {
		var (
			err   error
			once  sync.Once
			value *DiscoveryEntry
		)
		m.oldValue = func(ctx context.Context) (*DiscoveryEntry, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().DiscoveryEntry.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDiscoveryEntry sets the old DiscoveryEntry of the mutation.
func withDiscoveryEntry(node *DiscoveryEntry) discoveryentryOption {
	return func(m *DiscoveryEntryMutation) {
		m.oldValue = func(context.Context) (*DiscoveryEntry, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DiscoveryEntryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DiscoveryEntryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *DiscoveryEntryMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *DiscoveryEntryMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().DiscoveryEntry.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetHardwareID sets the "hardware_id" field.
func (m *DiscoveryEntryMutation) SetHardwareID(s string) {
	m.hardware_id = &s
}

// HardwareID returns the value of the "hardware_id" field in the mutation.
func (m *DiscoveryEntryMutation) HardwareID() (r string, exists bool) {
	v := m.hardware_id
	if v == nil {
		return
	}
	return *v, true
}

// OldHardwareID returns the old "hardware_id" field's value of the DiscoveryEntry entity.
// If the DiscoveryEntry object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DiscoveryEntryMutation) OldHardwareID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHardwareID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHardwareID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHardwareID: %w", err)
	}
	return oldValue.HardwareID, nil
}

// ResetHardwareID resets all changes to the "hardware_id" field.
func (m *DiscoveryEntryMutation) ResetHardwareID() {
	m.hardware_id = nil
}

// SetName sets the "name" field.
func (m *DiscoveryEntryMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *DiscoveryEntryMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the DiscoveryEntry entity.
// If the DiscoveryEntry object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DiscoveryEntryMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *DiscoveryEntryMutation) ResetName() {
	m.name = nil
}

// SetHostname sets the "hostname" field.
func (m *DiscoveryEntryMutation) SetHostname(s string) {
	m.hostname = &s
}

// Hostname returns the value of the "hostname" field in the mutation.
func (m *DiscoveryEntryMutation) Hostname() (r string, exists bool) {
	v := m.hostname
	if v == nil {
		return
	}
	return *v, true
}

// OldHostname returns the old "hostname" field's value of the DiscoveryEntry entity.
// If the DiscoveryEntry object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DiscoveryEntryMutation) OldHostname(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHostname is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHostname requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHostname: %w", err)
	}
	return oldValue.Hostname, nil
}

// ClearHostname clears the value of the "hostname" field.
func (m *DiscoveryEntryMutation) ClearHostname() {
	m.hostname = nil
	m.clearedFields[discoveryentry.FieldHostname] = struct{}{}
}

// HostnameCleared returns if the "hostname" field was cleared in this mutation.
func (m *DiscoveryEntryMutation) HostnameCleared() bool {
	_, ok := m.clearedFields[discoveryentry.FieldHostname]
	return ok
}

// ResetHostname resets all changes to the "hostname" field.
func (m *DiscoveryEntryMutation) ResetHostname() {
	m.hostname = nil
	delete(m.clearedFields, discoveryentry.FieldHostname)
}

// SetIP sets the "ip" field.
func (m *DiscoveryEntryMutation) SetIP(s string) {
	m.ip = &s
}

// IP returns the value of the "ip" field in the mutation.
func (m *DiscoveryEntryMutation) IP() (r string, exists bool) {
	v := m.ip
	if v == nil {
		return
	}
	return *v, true
}

// OldIP returns the old "ip" field's value of the DiscoveryEntry entity.
// If the DiscoveryEntry object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DiscoveryEntryMutation) OldIP(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIP is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIP requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIP: %w", err)
	}
	return oldValue.IP, nil
}

// ClearIP clears the value of the "ip" field.
func (m *DiscoveryEntryMutation) ClearIP() {
	m.ip = nil
	m.clearedFields[discoveryentry.FieldIP] = struct{}{}
}

// IPCleared returns if the "ip" field was cleared in this mutation.
func (m *DiscoveryEntryMutation) IPCleared() bool {
	_, ok := m.clearedFields[discoveryentry.FieldIP]
	return ok
}

// ResetIP resets all changes to the "ip" field.
func (m *DiscoveryEntryMutation) ResetIP() {
	m.ip = nil
	delete(m.clearedFields, discoveryentry.FieldIP)
}

// SetMAC sets the "mac" field.
func (m *DiscoveryEntryMutation) SetMAC(s string) {
	m.mac = &s
}

// MAC returns the value of the "mac" field in the mutation.
func (m *DiscoveryEntryMutation) MAC() (r string, exists bool) {
	v := m.mac
	if v == nil {
		return
	}
	return *v, true
}

// OldMAC returns the old "mac" field's value of the DiscoveryEntry entity.
// If the DiscoveryEntry object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DiscoveryEntryMutation) OldMAC(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMAC is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMAC requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMAC: %w", err)
	}
	return oldValue.MAC, nil
}

// ClearMAC clears the value of the "mac" field.
func (m *DiscoveryEntryMutation) ClearMAC() {
	m.mac = nil
	m.clearedFields[discoveryentry.FieldMAC] = struct{}{}
}

// MACCleared returns if the "mac" field was cleared in this mutation.
func (m *DiscoveryEntryMutation) MACCleared() bool {
	_, ok := m.clearedFields[discoveryentry.FieldMAC]
	return ok
}

// ResetMAC resets all changes to the "mac" field.
func (m *DiscoveryEntryMutation) ResetMAC() {
	m.mac = nil
	delete(m.clearedFields, discoveryentry.FieldMAC)
}

// SetType sets the "type" field.
func (m *DiscoveryEntryMutation) SetType(s string) {
	m._type = &s
}

// GetType returns the value of the "type" field in the mutation.
func (m *DiscoveryEntryMutation) GetType() (r string, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the DiscoveryEntry entity.
// If the DiscoveryEntry object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DiscoveryEntryMutation) OldType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *DiscoveryEntryMutation) ResetType() {
	m._type = nil
}

// SetMetadata sets the "metadata" field.
func (m *DiscoveryEntryMutation) SetMetadata(value map[string]interface{}) {
	m.metadata = &value
}

// Metadata returns the value of the "metadata" field in the mutation.
func (m *DiscoveryEntryMutation) Metadata() (r map[string]interface{}, exists bool) {
	v := m.metadata
	if v == nil {
		return
	}
	return *v, true
}

// OldMetadata returns the old "metadata" field's value of the DiscoveryEntry entity.
// If the DiscoveryEntry object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DiscoveryEntryMutation) OldMetadata(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMetadata is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMetadata requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetadata: %w", err)
	}
	return oldValue.Metadata, nil
}

// ResetMetadata resets all changes to the "metadata" field.
func (m *DiscoveryEntryMutation) ResetMetadata() {
	m.metadata = nil
}

// SetStatus sets the "status" field.
func (m *DiscoveryEntryMutation) SetStatus(d discoveryentry.Status) {
	m.status = &d
}

// Status returns the value of the "status" field in the mutation.
func (m *DiscoveryEntryMutation) Status() (r discoveryentry.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the DiscoveryEntry entity.
// If the DiscoveryEntry object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DiscoveryEntryMutation) OldStatus(ctx context.Context) (v discoveryentry.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *DiscoveryEntryMutation) ResetStatus() {
	m.status = nil
}

// SetDiscoveredAt sets the "discovered_at" field.
func (m *DiscoveryEntryMutation) SetDiscoveredAt(t time.Time) {
	m.discovered_at = &t
}

// DiscoveredAt returns the value of the "discovered_at" field in the mutation.
func (m *DiscoveryEntryMutation) DiscoveredAt() (r time.Time, exists bool) {
	v := m.discovered_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDiscoveredAt returns the old "discovered_at" field's value of the DiscoveryEntry entity.
// If the DiscoveryEntry object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DiscoveryEntryMutation) OldDiscoveredAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDiscoveredAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDiscoveredAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDiscoveredAt: %w", err)
	}
	return oldValue.DiscoveredAt, nil
}

// ResetDiscoveredAt resets all changes to the "discovered_at" field.
func (m *DiscoveryEntryMutation) ResetDiscoveredAt() {
	m.discovered_at = nil
}

// SetTenantID sets the "tenant" edge to the Tenant entity by id.
func (m *DiscoveryEntryMutation) SetTenantID(id int) {
	m.tenant = &id
}

// ClearTenant clears the "tenant" edge to the Tenant entity.
func (m *DiscoveryEntryMutation) ClearTenant() {
	m.clearedtenant = true
}

// TenantCleared reports if the "tenant" edge to the Tenant entity was cleared.
func (m *DiscoveryEntryMutation) TenantCleared() bool {
	return m.clearedtenant
}

// TenantID returns the "tenant" edge ID in the mutation.
func (m *DiscoveryEntryMutation) TenantID() (id int, exists bool) {
	if m.tenant != nil {
		return *m.tenant, true
	}
	return
}

// TenantIDs returns the "tenant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TenantID instead. It exists only for internal usage by the builders.
func (m *DiscoveryEntryMutation) TenantIDs() (ids []int) {
	if id := m.tenant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTenant resets all changes to the "tenant" edge.
func (m *DiscoveryEntryMutation) ResetTenant() {
	m.tenant = nil
	m.clearedtenant = false
}

// Where appends a list predicates to the DiscoveryEntryMutation builder.
func (m *DiscoveryEntryMutation) Where(ps ...predicate.DiscoveryEntry) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the DiscoveryEntryMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *DiscoveryEntryMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.DiscoveryEntry, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *DiscoveryEntryMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *DiscoveryEntryMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (DiscoveryEntry).
func (m *DiscoveryEntryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DiscoveryEntryMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.hardware_id != nil {
		fields = append(fields, discoveryentry.FieldHardwareID)
	}
	if m.name != nil {
		fields = append(fields, discoveryentry.FieldName)
	}
	if m.hostname != nil {
		fields = append(fields, discoveryentry.FieldHostname)
	}
	if m.ip != nil {
		fields = append(fields, discoveryentry.FieldIP)
	}
	if m.mac != nil {
		fields = append(fields, discoveryentry.FieldMAC)
	}
	if m._type != nil {
		fields = append(fields, discoveryentry.FieldType)
	}
	if m.metadata != nil {
		fields = append(fields, discoveryentry.FieldMetadata)
	}
	if m.status != nil {
		fields = append(fields, discoveryentry.FieldStatus)
	}
	if m.discovered_at != nil {
		fields = append(fields, discoveryentry.FieldDiscoveredAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DiscoveryEntryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case discoveryentry.FieldHardwareID:
		return m.HardwareID()
	case discoveryentry.FieldName:
		return m.Name()
	case discoveryentry.FieldHostname:
		return m.Hostname()
	case discoveryentry.FieldIP:
		return m.IP()
	case discoveryentry.FieldMAC:
		return m.MAC()
	case discoveryentry.FieldType:
		return m.GetType()
	case discoveryentry.FieldMetadata:
		return m.Metadata()
	case discoveryentry.FieldStatus:
		return m.Status()
	case discoveryentry.FieldDiscoveredAt:
		return m.DiscoveredAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DiscoveryEntryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case discoveryentry.FieldHardwareID:
		return m.OldHardwareID(ctx)
	case discoveryentry.FieldName:
		return m.OldName(ctx)
	case discoveryentry.FieldHostname:
		return m.OldHostname(ctx)
	case discoveryentry.FieldIP:
		return m.OldIP(ctx)
	case discoveryentry.FieldMAC:
		return m.OldMAC(ctx)
	case discoveryentry.FieldType:
		return m.OldType(ctx)
	case discoveryentry.FieldMetadata:
		return m.OldMetadata(ctx)
	case discoveryentry.FieldStatus:
		return m.OldStatus(ctx)
	case discoveryentry.FieldDiscoveredAt:
		return m.OldDiscoveredAt(ctx)
	}
	return nil, fmt.Errorf("unknown DiscoveryEntry field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DiscoveryEntryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case discoveryentry.FieldHardwareID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHardwareID(v)
		return nil
	case discoveryentry.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case discoveryentry.FieldHostname:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHostname(v)
		return nil
	case discoveryentry.FieldIP:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIP(v)
		return nil
	case discoveryentry.FieldMAC:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMAC(v)
		return nil
	case discoveryentry.FieldType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case discoveryentry.FieldMetadata:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetadata(v)
		return nil
	case discoveryentry.FieldStatus:
		v, ok := value.(discoveryentry.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case discoveryentry.FieldDiscoveredAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDiscoveredAt(v)
		return nil
	}
	return fmt.Errorf("unknown DiscoveryEntry field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DiscoveryEntryMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DiscoveryEntryMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DiscoveryEntryMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown DiscoveryEntry numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DiscoveryEntryMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(discoveryentry.FieldHostname) {
		fields = append(fields, discoveryentry.FieldHostname)
	}
	if m.FieldCleared(discoveryentry.FieldIP) {
		fields = append(fields, discoveryentry.FieldIP)
	}
	if m.FieldCleared(discoveryentry.FieldMAC) {
		fields = append(fields, discoveryentry.FieldMAC)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DiscoveryEntryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DiscoveryEntryMutation) ClearField(name string) error {
	switch name {
	case discoveryentry.FieldHostname:
		m.ClearHostname()
		return nil
	case discoveryentry.FieldIP:
		m.ClearIP()
		return nil
	case discoveryentry.FieldMAC:
		m.ClearMAC()
		return nil
	}
	return fmt.Errorf("unknown DiscoveryEntry nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DiscoveryEntryMutation) ResetField(name string) error {
	switch name {
	case discoveryentry.FieldHardwareID:
		m.ResetHardwareID()
		return nil
	case discoveryentry.FieldName:
		m.ResetName()
		return nil
	case discoveryentry.FieldHostname:
		m.ResetHostname()
		return nil
	case discoveryentry.FieldIP:
		m.ResetIP()
		return nil
	case discoveryentry.FieldMAC:
		m.ResetMAC()
		return nil
	case discoveryentry.FieldType:
		m.ResetType()
		return nil
	case discoveryentry.FieldMetadata:
		m.ResetMetadata()
		return nil
	case discoveryentry.FieldStatus:
		m.ResetStatus()
		return nil
	case discoveryentry.FieldDiscoveredAt:
		m.ResetDiscoveredAt()
		return nil
	}
	return fmt.Errorf("unknown DiscoveryEntry field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DiscoveryEntryMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.tenant != nil {
		edges = append(edges, discoveryentry.EdgeTenant)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DiscoveryEntryMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case discoveryentry.EdgeTenant:
		if id := m.tenant; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DiscoveryEntryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DiscoveryEntryMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DiscoveryEntryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedtenant {
		edges = append(edges, discoveryentry.EdgeTenant)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DiscoveryEntryMutation) EdgeCleared(name string) bool {
	switch name {
	case discoveryentry.EdgeTenant:
		return m.clearedtenant
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DiscoveryEntryMutation) ClearEdge(name string) error {
	switch name {
	case discoveryentry.EdgeTenant:
		m.ClearTenant()
		return nil
	}
	return fmt.Errorf("unknown DiscoveryEntry unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DiscoveryEntryMutation) ResetEdge(name string) error {
	switch name {
	case discoveryentry.EdgeTenant:
		m.ResetTenant()
		return nil
	}
	return fmt.Errorf("unknown DiscoveryEntry edge %s", name)
}

// EmployeeMutation represents an operation that mutates the Employee nodes in the graph.
type EmployeeMutation struct {
	config
	op                             Op
	typ                            string
	id                             *int
	zitadel_id                     *string
	employee_id                    *string
	first_name                     *string
	last_name                      *string
	email                          *string
	phone                          *string
	status                         *employee.Status
	salary_encrypted               *string
	bank_details_encrypted         *string
	signature_hash                 *string
	signed_at                      *time.Time
	hipo_status                    *bool
	created_at                     *time.Time
	updated_at                     *time.Time
	clearedFields                  map[string]struct{}
	tenant                         *int
	clearedtenant                  bool
	department                     *int
	cleareddepartment              bool
	manager                        *int
	clearedmanager                 bool
	subordinates                   map[int]struct{}
	removedsubordinates            map[int]struct{}
	clearedsubordinates            bool
	compensation_agreements        map[int]struct{}
	removedcompensation_agreements map[int]struct{}
	clearedcompensation_agreements bool
	succession_plans               map[int]struct{}
	removedsuccession_plans        map[int]struct{}
	clearedsuccession_plans        bool
	backup_for                     map[int]struct{}
	removedbackup_for              map[int]struct{}
	clearedbackup_for              bool
	expense_account                *int
	clearedexpense_account         bool
	time_off_requests              map[int]struct{}
	removedtime_off_requests       map[int]struct{}
	clearedtime_off_requests       bool
	approved_time_off              map[int]struct{}
	removedapproved_time_off       map[int]struct{}
	clearedapproved_time_off       bool
	time_off_balances              map[int]struct{}
	removedtime_off_balances       map[int]struct{}
	clearedtime_off_balances       bool
	performance_reviews            map[int]struct{}
	removedperformance_reviews     map[int]struct{}
	clearedperformance_reviews     bool
	conducted_reviews              map[int]struct{}
	removedconducted_reviews       map[int]struct{}
	clearedconducted_reviews       bool
	goals                          map[int]struct{}
	removedgoals                   map[int]struct{}
	clearedgoals                   bool
	asset_assignments              map[int]struct{}
	removedasset_assignments       map[int]struct{}
	clearedasset_assignments       bool
	time_entries                   map[int]struct{}
	removedtime_entries            map[int]struct{}
	clearedtime_entries            bool
	conducted_interviews           map[int]struct{}
	removedconducted_interviews    map[int]struct{}
	clearedconducted_interviews    bool
	benefit_enrollments            map[int]struct{}
	removedbenefit_enrollments     map[int]struct{}
	clearedbenefit_enrollments     bool
	done                           bool
	oldValue                       func(context.Context) (*Employee, error)
	predicates                     []predicate.Employee
}

var _ ent.Mutation = (*EmployeeMutation)(nil)

// employeeOption allows management of the mutation configuration using functional options.
type employeeOption func(*EmployeeMutation)

// newEmployeeMutation creates new mutation for the Employee entity.
func newEmployeeMutation(c config, op Op, opts ...employeeOption) *EmployeeMutation {
	m := &EmployeeMutation{
		config:        c,
		op:            op,
		typ:           TypeEmployee,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withEmployeeID sets the ID field of the mutation.
func withEmployeeID(id int) employeeOption {
	return func(m *EmployeeMutation) {
		var (
			err   error
			once  sync.Once
			value *Employee
		)
		m.oldValue = func(ctx context.Context) (*Employee, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Employee.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withEmployee sets the old Employee of the mutation.
func withEmployee(node *Employee) employeeOption {
	return func(m *EmployeeMutation) {
		m.oldValue = func(context.Context) (*Employee, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m EmployeeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m EmployeeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *EmployeeMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *EmployeeMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Employee.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetZitadelID sets the "zitadel_id" field.
func (m *EmployeeMutation) SetZitadelID(s string) {
	m.zitadel_id = &s
}

// ZitadelID returns the value of the "zitadel_id" field in the mutation.
func (m *EmployeeMutation) ZitadelID() (r string, exists bool) {
	v := m.zitadel_id
	if v == nil {
		return
	}
	return *v, true
}

// OldZitadelID returns the old "zitadel_id" field's value of the Employee entity.
// If the Employee object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeeMutation) OldZitadelID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldZitadelID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldZitadelID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldZitadelID: %w", err)
	}
	return oldValue.ZitadelID, nil
}

// ResetZitadelID resets all changes to the "zitadel_id" field.
func (m *EmployeeMutation) ResetZitadelID() {
	m.zitadel_id = nil
}

// SetEmployeeID sets the "employee_id" field.
func (m *EmployeeMutation) SetEmployeeID(s string) {
	m.employee_id = &s
}

// EmployeeID returns the value of the "employee_id" field in the mutation.
func (m *EmployeeMutation) EmployeeID() (r string, exists bool) {
	v := m.employee_id
	if v == nil {
		return
	}
	return *v, true
}

// OldEmployeeID returns the old "employee_id" field's value of the Employee entity.
// If the Employee object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeeMutation) OldEmployeeID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmployeeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmployeeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmployeeID: %w", err)
	}
	return oldValue.EmployeeID, nil
}

// ResetEmployeeID resets all changes to the "employee_id" field.
func (m *EmployeeMutation) ResetEmployeeID() {
	m.employee_id = nil
}

// SetFirstName sets the "first_name" field.
func (m *EmployeeMutation) SetFirstName(s string) {
	m.first_name = &s
}

// FirstName returns the value of the "first_name" field in the mutation.
func (m *EmployeeMutation) FirstName() (r string, exists bool) {
	v := m.first_name
	if v == nil {
		return
	}
	return *v, true
}

// OldFirstName returns the old "first_name" field's value of the Employee entity.
// If the Employee object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeeMutation) OldFirstName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFirstName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFirstName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFirstName: %w", err)
	}
	return oldValue.FirstName, nil
}

// ResetFirstName resets all changes to the "first_name" field.
func (m *EmployeeMutation) ResetFirstName() {
	m.first_name = nil
}

// SetLastName sets the "last_name" field.
func (m *EmployeeMutation) SetLastName(s string) {
	m.last_name = &s
}

// LastName returns the value of the "last_name" field in the mutation.
func (m *EmployeeMutation) LastName() (r string, exists bool) {
	v := m.last_name
	if v == nil {
		return
	}
	return *v, true
}

// OldLastName returns the old "last_name" field's value of the Employee entity.
// If the Employee object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeeMutation) OldLastName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastName: %w", err)
	}
	return oldValue.LastName, nil
}

// ResetLastName resets all changes to the "last_name" field.
func (m *EmployeeMutation) ResetLastName() {
	m.last_name = nil
}

// SetEmail sets the "email" field.
func (m *EmployeeMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *EmployeeMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the Employee entity.
// If the Employee object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeeMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail resets all changes to the "email" field.
func (m *EmployeeMutation) ResetEmail() {
	m.email = nil
}

// SetPhone sets the "phone" field.
func (m *EmployeeMutation) SetPhone(s string) {
	m.phone = &s
}

// Phone returns the value of the "phone" field in the mutation.
func (m *EmployeeMutation) Phone() (r string, exists bool) {
	v := m.phone
	if v == nil {
		return
	}
	return *v, true
}

// OldPhone returns the old "phone" field's value of the Employee entity.
// If the Employee object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeeMutation) OldPhone(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPhone is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPhone requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhone: %w", err)
	}
	return oldValue.Phone, nil
}

// ClearPhone clears the value of the "phone" field.
func (m *EmployeeMutation) ClearPhone() {
	m.phone = nil
	m.clearedFields[employee.FieldPhone] = struct{}{}
}

// PhoneCleared returns if the "phone" field was cleared in this mutation.
func (m *EmployeeMutation) PhoneCleared() bool {
	_, ok := m.clearedFields[employee.FieldPhone]
	return ok
}

// ResetPhone resets all changes to the "phone" field.
func (m *EmployeeMutation) ResetPhone() {
	m.phone = nil
	delete(m.clearedFields, employee.FieldPhone)
}

// SetStatus sets the "status" field.
func (m *EmployeeMutation) SetStatus(e employee.Status) {
	m.status = &e
}

// Status returns the value of the "status" field in the mutation.
func (m *EmployeeMutation) Status() (r employee.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Employee entity.
// If the Employee object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeeMutation) OldStatus(ctx context.Context) (v employee.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *EmployeeMutation) ResetStatus() {
	m.status = nil
}

// SetSalaryEncrypted sets the "salary_encrypted" field.
func (m *EmployeeMutation) SetSalaryEncrypted(s string) {
	m.salary_encrypted = &s
}

// SalaryEncrypted returns the value of the "salary_encrypted" field in the mutation.
func (m *EmployeeMutation) SalaryEncrypted() (r string, exists bool) {
	v := m.salary_encrypted
	if v == nil {
		return
	}
	return *v, true
}

// OldSalaryEncrypted returns the old "salary_encrypted" field's value of the Employee entity.
// If the Employee object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeeMutation) OldSalaryEncrypted(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSalaryEncrypted is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSalaryEncrypted requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSalaryEncrypted: %w", err)
	}
	return oldValue.SalaryEncrypted, nil
}

// ResetSalaryEncrypted resets all changes to the "salary_encrypted" field.
func (m *EmployeeMutation) ResetSalaryEncrypted() {
	m.salary_encrypted = nil
}

// SetBankDetailsEncrypted sets the "bank_details_encrypted" field.
func (m *EmployeeMutation) SetBankDetailsEncrypted(s string) {
	m.bank_details_encrypted = &s
}

// BankDetailsEncrypted returns the value of the "bank_details_encrypted" field in the mutation.
func (m *EmployeeMutation) BankDetailsEncrypted() (r string, exists bool) {
	v := m.bank_details_encrypted
	if v == nil {
		return
	}
	return *v, true
}

// OldBankDetailsEncrypted returns the old "bank_details_encrypted" field's value of the Employee entity.
// If the Employee object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeeMutation) OldBankDetailsEncrypted(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBankDetailsEncrypted is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBankDetailsEncrypted requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBankDetailsEncrypted: %w", err)
	}
	return oldValue.BankDetailsEncrypted, nil
}

// ClearBankDetailsEncrypted clears the value of the "bank_details_encrypted" field.
func (m *EmployeeMutation) ClearBankDetailsEncrypted() {
	m.bank_details_encrypted = nil
	m.clearedFields[employee.FieldBankDetailsEncrypted] = struct{}{}
}

// BankDetailsEncryptedCleared returns if the "bank_details_encrypted" field was cleared in this mutation.
func (m *EmployeeMutation) BankDetailsEncryptedCleared() bool {
	_, ok := m.clearedFields[employee.FieldBankDetailsEncrypted]
	return ok
}

// ResetBankDetailsEncrypted resets all changes to the "bank_details_encrypted" field.
func (m *EmployeeMutation) ResetBankDetailsEncrypted() {
	m.bank_details_encrypted = nil
	delete(m.clearedFields, employee.FieldBankDetailsEncrypted)
}

// SetSignatureHash sets the "signature_hash" field.
func (m *EmployeeMutation) SetSignatureHash(s string) {
	m.signature_hash = &s
}

// SignatureHash returns the value of the "signature_hash" field in the mutation.
func (m *EmployeeMutation) SignatureHash() (r string, exists bool) {
	v := m.signature_hash
	if v == nil {
		return
	}
	return *v, true
}

// OldSignatureHash returns the old "signature_hash" field's value of the Employee entity.
// If the Employee object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeeMutation) OldSignatureHash(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSignatureHash is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSignatureHash requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSignatureHash: %w", err)
	}
	return oldValue.SignatureHash, nil
}

// ClearSignatureHash clears the value of the "signature_hash" field.
func (m *EmployeeMutation) ClearSignatureHash() {
	m.signature_hash = nil
	m.clearedFields[employee.FieldSignatureHash] = struct{}{}
}

// SignatureHashCleared returns if the "signature_hash" field was cleared in this mutation.
func (m *EmployeeMutation) SignatureHashCleared() bool {
	_, ok := m.clearedFields[employee.FieldSignatureHash]
	return ok
}

// ResetSignatureHash resets all changes to the "signature_hash" field.
func (m *EmployeeMutation) ResetSignatureHash() {
	m.signature_hash = nil
	delete(m.clearedFields, employee.FieldSignatureHash)
}

// SetSignedAt sets the "signed_at" field.
func (m *EmployeeMutation) SetSignedAt(t time.Time) {
	m.signed_at = &t
}

// SignedAt returns the value of the "signed_at" field in the mutation.
func (m *EmployeeMutation) SignedAt() (r time.Time, exists bool) {
	v := m.signed_at
	if v == nil {
		return
	}
	return *v, true
}

// OldSignedAt returns the old "signed_at" field's value of the Employee entity.
// If the Employee object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeeMutation) OldSignedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSignedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSignedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSignedAt: %w", err)
	}
	return oldValue.SignedAt, nil
}

// ClearSignedAt clears the value of the "signed_at" field.
func (m *EmployeeMutation) ClearSignedAt() {
	m.signed_at = nil
	m.clearedFields[employee.FieldSignedAt] = struct{}{}
}

// SignedAtCleared returns if the "signed_at" field was cleared in this mutation.
func (m *EmployeeMutation) SignedAtCleared() bool {
	_, ok := m.clearedFields[employee.FieldSignedAt]
	return ok
}

// ResetSignedAt resets all changes to the "signed_at" field.
func (m *EmployeeMutation) ResetSignedAt() {
	m.signed_at = nil
	delete(m.clearedFields, employee.FieldSignedAt)
}

// SetHipoStatus sets the "hipo_status" field.
func (m *EmployeeMutation) SetHipoStatus(b bool) {
	m.hipo_status = &b
}

// HipoStatus returns the value of the "hipo_status" field in the mutation.
func (m *EmployeeMutation) HipoStatus() (r bool, exists bool) {
	v := m.hipo_status
	if v == nil {
		return
	}
	return *v, true
}

// OldHipoStatus returns the old "hipo_status" field's value of the Employee entity.
// If the Employee object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeeMutation) OldHipoStatus(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHipoStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHipoStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHipoStatus: %w", err)
	}
	return oldValue.HipoStatus, nil
}

// ResetHipoStatus resets all changes to the "hipo_status" field.
func (m *EmployeeMutation) ResetHipoStatus() {
	m.hipo_status = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *EmployeeMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *EmployeeMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Employee entity.
// If the Employee object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeeMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *EmployeeMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *EmployeeMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *EmployeeMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Employee entity.
// If the Employee object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeeMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *EmployeeMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetTenantID sets the "tenant" edge to the Tenant entity by id.
func (m *EmployeeMutation) SetTenantID(id int) {
	m.tenant = &id
}

// ClearTenant clears the "tenant" edge to the Tenant entity.
func (m *EmployeeMutation) ClearTenant() {
	m.clearedtenant = true
}

// TenantCleared reports if the "tenant" edge to the Tenant entity was cleared.
func (m *EmployeeMutation) TenantCleared() bool {
	return m.clearedtenant
}

// TenantID returns the "tenant" edge ID in the mutation.
func (m *EmployeeMutation) TenantID() (id int, exists bool) {
	if m.tenant != nil {
		return *m.tenant, true
	}
	return
}

// TenantIDs returns the "tenant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TenantID instead. It exists only for internal usage by the builders.
func (m *EmployeeMutation) TenantIDs() (ids []int) {
	if id := m.tenant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTenant resets all changes to the "tenant" edge.
func (m *EmployeeMutation) ResetTenant() {
	m.tenant = nil
	m.clearedtenant = false
}

// SetDepartmentID sets the "department" edge to the Department entity by id.
func (m *EmployeeMutation) SetDepartmentID(id int) {
	m.department = &id
}

// ClearDepartment clears the "department" edge to the Department entity.
func (m *EmployeeMutation) ClearDepartment() {
	m.cleareddepartment = true
}

// DepartmentCleared reports if the "department" edge to the Department entity was cleared.
func (m *EmployeeMutation) DepartmentCleared() bool {
	return m.cleareddepartment
}

// DepartmentID returns the "department" edge ID in the mutation.
func (m *EmployeeMutation) DepartmentID() (id int, exists bool) {
	if m.department != nil {
		return *m.department, true
	}
	return
}

// DepartmentIDs returns the "department" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// DepartmentID instead. It exists only for internal usage by the builders.
func (m *EmployeeMutation) DepartmentIDs() (ids []int) {
	if id := m.department; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDepartment resets all changes to the "department" edge.
func (m *EmployeeMutation) ResetDepartment() {
	m.department = nil
	m.cleareddepartment = false
}

// SetManagerID sets the "manager" edge to the Employee entity by id.
func (m *EmployeeMutation) SetManagerID(id int) {
	m.manager = &id
}

// ClearManager clears the "manager" edge to the Employee entity.
func (m *EmployeeMutation) ClearManager() {
	m.clearedmanager = true
}

// ManagerCleared reports if the "manager" edge to the Employee entity was cleared.
func (m *EmployeeMutation) ManagerCleared() bool {
	return m.clearedmanager
}

// ManagerID returns the "manager" edge ID in the mutation.
func (m *EmployeeMutation) ManagerID() (id int, exists bool) {
	if m.manager != nil {
		return *m.manager, true
	}
	return
}

// ManagerIDs returns the "manager" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ManagerID instead. It exists only for internal usage by the builders.
func (m *EmployeeMutation) ManagerIDs() (ids []int) {
	if id := m.manager; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetManager resets all changes to the "manager" edge.
func (m *EmployeeMutation) ResetManager() {
	m.manager = nil
	m.clearedmanager = false
}

// AddSubordinateIDs adds the "subordinates" edge to the Employee entity by ids.
func (m *EmployeeMutation) AddSubordinateIDs(ids ...int) {
	if m.subordinates == nil {
		m.subordinates = make(map[int]struct{})
	}
	for i := range ids {
		m.subordinates[ids[i]] = struct{}{}
	}
}

// ClearSubordinates clears the "subordinates" edge to the Employee entity.
func (m *EmployeeMutation) ClearSubordinates() {
	m.clearedsubordinates = true
}

// SubordinatesCleared reports if the "subordinates" edge to the Employee entity was cleared.
func (m *EmployeeMutation) SubordinatesCleared() bool {
	return m.clearedsubordinates
}

// RemoveSubordinateIDs removes the "subordinates" edge to the Employee entity by IDs.
func (m *EmployeeMutation) RemoveSubordinateIDs(ids ...int) {
	if m.removedsubordinates == nil {
		m.removedsubordinates = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.subordinates, ids[i])
		m.removedsubordinates[ids[i]] = struct{}{}
	}
}

// RemovedSubordinates returns the removed IDs of the "subordinates" edge to the Employee entity.
func (m *EmployeeMutation) RemovedSubordinatesIDs() (ids []int) {
	for id := range m.removedsubordinates {
		ids = append(ids, id)
	}
	return
}

// SubordinatesIDs returns the "subordinates" edge IDs in the mutation.
func (m *EmployeeMutation) SubordinatesIDs() (ids []int) {
	for id := range m.subordinates {
		ids = append(ids, id)
	}
	return
}

// ResetSubordinates resets all changes to the "subordinates" edge.
func (m *EmployeeMutation) ResetSubordinates() {
	m.subordinates = nil
	m.clearedsubordinates = false
	m.removedsubordinates = nil
}

// AddCompensationAgreementIDs adds the "compensation_agreements" edge to the CompensationAgreement entity by ids.
func (m *EmployeeMutation) AddCompensationAgreementIDs(ids ...int) {
	if m.compensation_agreements == nil {
		m.compensation_agreements = make(map[int]struct{})
	}
	for i := range ids {
		m.compensation_agreements[ids[i]] = struct{}{}
	}
}

// ClearCompensationAgreements clears the "compensation_agreements" edge to the CompensationAgreement entity.
func (m *EmployeeMutation) ClearCompensationAgreements() {
	m.clearedcompensation_agreements = true
}

// CompensationAgreementsCleared reports if the "compensation_agreements" edge to the CompensationAgreement entity was cleared.
func (m *EmployeeMutation) CompensationAgreementsCleared() bool {
	return m.clearedcompensation_agreements
}

// RemoveCompensationAgreementIDs removes the "compensation_agreements" edge to the CompensationAgreement entity by IDs.
func (m *EmployeeMutation) RemoveCompensationAgreementIDs(ids ...int) {
	if m.removedcompensation_agreements == nil {
		m.removedcompensation_agreements = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.compensation_agreements, ids[i])
		m.removedcompensation_agreements[ids[i]] = struct{}{}
	}
}

// RemovedCompensationAgreements returns the removed IDs of the "compensation_agreements" edge to the CompensationAgreement entity.
func (m *EmployeeMutation) RemovedCompensationAgreementsIDs() (ids []int) {
	for id := range m.removedcompensation_agreements {
		ids = append(ids, id)
	}
	return
}

// CompensationAgreementsIDs returns the "compensation_agreements" edge IDs in the mutation.
func (m *EmployeeMutation) CompensationAgreementsIDs() (ids []int) {
	for id := range m.compensation_agreements {
		ids = append(ids, id)
	}
	return
}

// ResetCompensationAgreements resets all changes to the "compensation_agreements" edge.
func (m *EmployeeMutation) ResetCompensationAgreements() {
	m.compensation_agreements = nil
	m.clearedcompensation_agreements = false
	m.removedcompensation_agreements = nil
}

// AddSuccessionPlanIDs adds the "succession_plans" edge to the SuccessionMap entity by ids.
func (m *EmployeeMutation) AddSuccessionPlanIDs(ids ...int) {
	if m.succession_plans == nil {
		m.succession_plans = make(map[int]struct{})
	}
	for i := range ids {
		m.succession_plans[ids[i]] = struct{}{}
	}
}

// ClearSuccessionPlans clears the "succession_plans" edge to the SuccessionMap entity.
func (m *EmployeeMutation) ClearSuccessionPlans() {
	m.clearedsuccession_plans = true
}

// SuccessionPlansCleared reports if the "succession_plans" edge to the SuccessionMap entity was cleared.
func (m *EmployeeMutation) SuccessionPlansCleared() bool {
	return m.clearedsuccession_plans
}

// RemoveSuccessionPlanIDs removes the "succession_plans" edge to the SuccessionMap entity by IDs.
func (m *EmployeeMutation) RemoveSuccessionPlanIDs(ids ...int) {
	if m.removedsuccession_plans == nil {
		m.removedsuccession_plans = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.succession_plans, ids[i])
		m.removedsuccession_plans[ids[i]] = struct{}{}
	}
}

// RemovedSuccessionPlans returns the removed IDs of the "succession_plans" edge to the SuccessionMap entity.
func (m *EmployeeMutation) RemovedSuccessionPlansIDs() (ids []int) {
	for id := range m.removedsuccession_plans {
		ids = append(ids, id)
	}
	return
}

// SuccessionPlansIDs returns the "succession_plans" edge IDs in the mutation.
func (m *EmployeeMutation) SuccessionPlansIDs() (ids []int) {
	for id := range m.succession_plans {
		ids = append(ids, id)
	}
	return
}

// ResetSuccessionPlans resets all changes to the "succession_plans" edge.
func (m *EmployeeMutation) ResetSuccessionPlans() {
	m.succession_plans = nil
	m.clearedsuccession_plans = false
	m.removedsuccession_plans = nil
}

// AddBackupForIDs adds the "backup_for" edge to the SuccessionMap entity by ids.
func (m *EmployeeMutation) AddBackupForIDs(ids ...int) {
	if m.backup_for == nil {
		m.backup_for = make(map[int]struct{})
	}
	for i := range ids {
		m.backup_for[ids[i]] = struct{}{}
	}
}

// ClearBackupFor clears the "backup_for" edge to the SuccessionMap entity.
func (m *EmployeeMutation) ClearBackupFor() {
	m.clearedbackup_for = true
}

// BackupForCleared reports if the "backup_for" edge to the SuccessionMap entity was cleared.
func (m *EmployeeMutation) BackupForCleared() bool {
	return m.clearedbackup_for
}

// RemoveBackupForIDs removes the "backup_for" edge to the SuccessionMap entity by IDs.
func (m *EmployeeMutation) RemoveBackupForIDs(ids ...int) {
	if m.removedbackup_for == nil {
		m.removedbackup_for = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.backup_for, ids[i])
		m.removedbackup_for[ids[i]] = struct{}{}
	}
}

// RemovedBackupFor returns the removed IDs of the "backup_for" edge to the SuccessionMap entity.
func (m *EmployeeMutation) RemovedBackupForIDs() (ids []int) {
	for id := range m.removedbackup_for {
		ids = append(ids, id)
	}
	return
}

// BackupForIDs returns the "backup_for" edge IDs in the mutation.
func (m *EmployeeMutation) BackupForIDs() (ids []int) {
	for id := range m.backup_for {
		ids = append(ids, id)
	}
	return
}

// ResetBackupFor resets all changes to the "backup_for" edge.
func (m *EmployeeMutation) ResetBackupFor() {
	m.backup_for = nil
	m.clearedbackup_for = false
	m.removedbackup_for = nil
}

// SetExpenseAccountID sets the "expense_account" edge to the Account entity by id.
func (m *EmployeeMutation) SetExpenseAccountID(id int) {
	m.expense_account = &id
}

// ClearExpenseAccount clears the "expense_account" edge to the Account entity.
func (m *EmployeeMutation) ClearExpenseAccount() {
	m.clearedexpense_account = true
}

// ExpenseAccountCleared reports if the "expense_account" edge to the Account entity was cleared.
func (m *EmployeeMutation) ExpenseAccountCleared() bool {
	return m.clearedexpense_account
}

// ExpenseAccountID returns the "expense_account" edge ID in the mutation.
func (m *EmployeeMutation) ExpenseAccountID() (id int, exists bool) {
	if m.expense_account != nil {
		return *m.expense_account, true
	}
	return
}

// ExpenseAccountIDs returns the "expense_account" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ExpenseAccountID instead. It exists only for internal usage by the builders.
func (m *EmployeeMutation) ExpenseAccountIDs() (ids []int) {
	if id := m.expense_account; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetExpenseAccount resets all changes to the "expense_account" edge.
func (m *EmployeeMutation) ResetExpenseAccount() {
	m.expense_account = nil
	m.clearedexpense_account = false
}

// AddTimeOffRequestIDs adds the "time_off_requests" edge to the TimeOffRequest entity by ids.
func (m *EmployeeMutation) AddTimeOffRequestIDs(ids ...int) {
	if m.time_off_requests == nil {
		m.time_off_requests = make(map[int]struct{})
	}
	for i := range ids {
		m.time_off_requests[ids[i]] = struct{}{}
	}
}

// ClearTimeOffRequests clears the "time_off_requests" edge to the TimeOffRequest entity.
func (m *EmployeeMutation) ClearTimeOffRequests() {
	m.clearedtime_off_requests = true
}

// TimeOffRequestsCleared reports if the "time_off_requests" edge to the TimeOffRequest entity was cleared.
func (m *EmployeeMutation) TimeOffRequestsCleared() bool {
	return m.clearedtime_off_requests
}

// RemoveTimeOffRequestIDs removes the "time_off_requests" edge to the TimeOffRequest entity by IDs.
func (m *EmployeeMutation) RemoveTimeOffRequestIDs(ids ...int) {
	if m.removedtime_off_requests == nil {
		m.removedtime_off_requests = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.time_off_requests, ids[i])
		m.removedtime_off_requests[ids[i]] = struct{}{}
	}
}

// RemovedTimeOffRequests returns the removed IDs of the "time_off_requests" edge to the TimeOffRequest entity.
func (m *EmployeeMutation) RemovedTimeOffRequestsIDs() (ids []int) {
	for id := range m.removedtime_off_requests {
		ids = append(ids, id)
	}
	return
}

// TimeOffRequestsIDs returns the "time_off_requests" edge IDs in the mutation.
func (m *EmployeeMutation) TimeOffRequestsIDs() (ids []int) {
	for id := range m.time_off_requests {
		ids = append(ids, id)
	}
	return
}

// ResetTimeOffRequests resets all changes to the "time_off_requests" edge.
func (m *EmployeeMutation) ResetTimeOffRequests() {
	m.time_off_requests = nil
	m.clearedtime_off_requests = false
	m.removedtime_off_requests = nil
}

// AddApprovedTimeOffIDs adds the "approved_time_off" edge to the TimeOffRequest entity by ids.
func (m *EmployeeMutation) AddApprovedTimeOffIDs(ids ...int) {
	if m.approved_time_off == nil {
		m.approved_time_off = make(map[int]struct{})
	}
	for i := range ids {
		m.approved_time_off[ids[i]] = struct{}{}
	}
}

// ClearApprovedTimeOff clears the "approved_time_off" edge to the TimeOffRequest entity.
func (m *EmployeeMutation) ClearApprovedTimeOff() {
	m.clearedapproved_time_off = true
}

// ApprovedTimeOffCleared reports if the "approved_time_off" edge to the TimeOffRequest entity was cleared.
func (m *EmployeeMutation) ApprovedTimeOffCleared() bool {
	return m.clearedapproved_time_off
}

// RemoveApprovedTimeOffIDs removes the "approved_time_off" edge to the TimeOffRequest entity by IDs.
func (m *EmployeeMutation) RemoveApprovedTimeOffIDs(ids ...int) {
	if m.removedapproved_time_off == nil {
		m.removedapproved_time_off = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.approved_time_off, ids[i])
		m.removedapproved_time_off[ids[i]] = struct{}{}
	}
}

// RemovedApprovedTimeOff returns the removed IDs of the "approved_time_off" edge to the TimeOffRequest entity.
func (m *EmployeeMutation) RemovedApprovedTimeOffIDs() (ids []int) {
	for id := range m.removedapproved_time_off {
		ids = append(ids, id)
	}
	return
}

// ApprovedTimeOffIDs returns the "approved_time_off" edge IDs in the mutation.
func (m *EmployeeMutation) ApprovedTimeOffIDs() (ids []int) {
	for id := range m.approved_time_off {
		ids = append(ids, id)
	}
	return
}

// ResetApprovedTimeOff resets all changes to the "approved_time_off" edge.
func (m *EmployeeMutation) ResetApprovedTimeOff() {
	m.approved_time_off = nil
	m.clearedapproved_time_off = false
	m.removedapproved_time_off = nil
}

// AddTimeOffBalanceIDs adds the "time_off_balances" edge to the TimeOffBalance entity by ids.
func (m *EmployeeMutation) AddTimeOffBalanceIDs(ids ...int) {
	if m.time_off_balances == nil {
		m.time_off_balances = make(map[int]struct{})
	}
	for i := range ids {
		m.time_off_balances[ids[i]] = struct{}{}
	}
}

// ClearTimeOffBalances clears the "time_off_balances" edge to the TimeOffBalance entity.
func (m *EmployeeMutation) ClearTimeOffBalances() {
	m.clearedtime_off_balances = true
}

// TimeOffBalancesCleared reports if the "time_off_balances" edge to the TimeOffBalance entity was cleared.
func (m *EmployeeMutation) TimeOffBalancesCleared() bool {
	return m.clearedtime_off_balances
}

// RemoveTimeOffBalanceIDs removes the "time_off_balances" edge to the TimeOffBalance entity by IDs.
func (m *EmployeeMutation) RemoveTimeOffBalanceIDs(ids ...int) {
	if m.removedtime_off_balances == nil {
		m.removedtime_off_balances = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.time_off_balances, ids[i])
		m.removedtime_off_balances[ids[i]] = struct{}{}
	}
}

// RemovedTimeOffBalances returns the removed IDs of the "time_off_balances" edge to the TimeOffBalance entity.
func (m *EmployeeMutation) RemovedTimeOffBalancesIDs() (ids []int) {
	for id := range m.removedtime_off_balances {
		ids = append(ids, id)
	}
	return
}

// TimeOffBalancesIDs returns the "time_off_balances" edge IDs in the mutation.
func (m *EmployeeMutation) TimeOffBalancesIDs() (ids []int) {
	for id := range m.time_off_balances {
		ids = append(ids, id)
	}
	return
}

// ResetTimeOffBalances resets all changes to the "time_off_balances" edge.
func (m *EmployeeMutation) ResetTimeOffBalances() {
	m.time_off_balances = nil
	m.clearedtime_off_balances = false
	m.removedtime_off_balances = nil
}

// AddPerformanceReviewIDs adds the "performance_reviews" edge to the PerformanceReview entity by ids.
func (m *EmployeeMutation) AddPerformanceReviewIDs(ids ...int) {
	if m.performance_reviews == nil {
		m.performance_reviews = make(map[int]struct{})
	}
	for i := range ids {
		m.performance_reviews[ids[i]] = struct{}{}
	}
}

// ClearPerformanceReviews clears the "performance_reviews" edge to the PerformanceReview entity.
func (m *EmployeeMutation) ClearPerformanceReviews() {
	m.clearedperformance_reviews = true
}

// PerformanceReviewsCleared reports if the "performance_reviews" edge to the PerformanceReview entity was cleared.
func (m *EmployeeMutation) PerformanceReviewsCleared() bool {
	return m.clearedperformance_reviews
}

// RemovePerformanceReviewIDs removes the "performance_reviews" edge to the PerformanceReview entity by IDs.
func (m *EmployeeMutation) RemovePerformanceReviewIDs(ids ...int) {
	if m.removedperformance_reviews == nil {
		m.removedperformance_reviews = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.performance_reviews, ids[i])
		m.removedperformance_reviews[ids[i]] = struct{}{}
	}
}

// RemovedPerformanceReviews returns the removed IDs of the "performance_reviews" edge to the PerformanceReview entity.
func (m *EmployeeMutation) RemovedPerformanceReviewsIDs() (ids []int) {
	for id := range m.removedperformance_reviews {
		ids = append(ids, id)
	}
	return
}

// PerformanceReviewsIDs returns the "performance_reviews" edge IDs in the mutation.
func (m *EmployeeMutation) PerformanceReviewsIDs() (ids []int) {
	for id := range m.performance_reviews {
		ids = append(ids, id)
	}
	return
}

// ResetPerformanceReviews resets all changes to the "performance_reviews" edge.
func (m *EmployeeMutation) ResetPerformanceReviews() {
	m.performance_reviews = nil
	m.clearedperformance_reviews = false
	m.removedperformance_reviews = nil
}

// AddConductedReviewIDs adds the "conducted_reviews" edge to the PerformanceReview entity by ids.
func (m *EmployeeMutation) AddConductedReviewIDs(ids ...int) {
	if m.conducted_reviews == nil {
		m.conducted_reviews = make(map[int]struct{})
	}
	for i := range ids {
		m.conducted_reviews[ids[i]] = struct{}{}
	}
}

// ClearConductedReviews clears the "conducted_reviews" edge to the PerformanceReview entity.
func (m *EmployeeMutation) ClearConductedReviews() {
	m.clearedconducted_reviews = true
}

// ConductedReviewsCleared reports if the "conducted_reviews" edge to the PerformanceReview entity was cleared.
func (m *EmployeeMutation) ConductedReviewsCleared() bool {
	return m.clearedconducted_reviews
}

// RemoveConductedReviewIDs removes the "conducted_reviews" edge to the PerformanceReview entity by IDs.
func (m *EmployeeMutation) RemoveConductedReviewIDs(ids ...int) {
	if m.removedconducted_reviews == nil {
		m.removedconducted_reviews = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.conducted_reviews, ids[i])
		m.removedconducted_reviews[ids[i]] = struct{}{}
	}
}

// RemovedConductedReviews returns the removed IDs of the "conducted_reviews" edge to the PerformanceReview entity.
func (m *EmployeeMutation) RemovedConductedReviewsIDs() (ids []int) {
	for id := range m.removedconducted_reviews {
		ids = append(ids, id)
	}
	return
}

// ConductedReviewsIDs returns the "conducted_reviews" edge IDs in the mutation.
func (m *EmployeeMutation) ConductedReviewsIDs() (ids []int) {
	for id := range m.conducted_reviews {
		ids = append(ids, id)
	}
	return
}

// ResetConductedReviews resets all changes to the "conducted_reviews" edge.
func (m *EmployeeMutation) ResetConductedReviews() {
	m.conducted_reviews = nil
	m.clearedconducted_reviews = false
	m.removedconducted_reviews = nil
}

// AddGoalIDs adds the "goals" edge to the Goal entity by ids.
func (m *EmployeeMutation) AddGoalIDs(ids ...int) {
	if m.goals == nil {
		m.goals = make(map[int]struct{})
	}
	for i := range ids {
		m.goals[ids[i]] = struct{}{}
	}
}

// ClearGoals clears the "goals" edge to the Goal entity.
func (m *EmployeeMutation) ClearGoals() {
	m.clearedgoals = true
}

// GoalsCleared reports if the "goals" edge to the Goal entity was cleared.
func (m *EmployeeMutation) GoalsCleared() bool {
	return m.clearedgoals
}

// RemoveGoalIDs removes the "goals" edge to the Goal entity by IDs.
func (m *EmployeeMutation) RemoveGoalIDs(ids ...int) {
	if m.removedgoals == nil {
		m.removedgoals = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.goals, ids[i])
		m.removedgoals[ids[i]] = struct{}{}
	}
}

// RemovedGoals returns the removed IDs of the "goals" edge to the Goal entity.
func (m *EmployeeMutation) RemovedGoalsIDs() (ids []int) {
	for id := range m.removedgoals {
		ids = append(ids, id)
	}
	return
}

// GoalsIDs returns the "goals" edge IDs in the mutation.
func (m *EmployeeMutation) GoalsIDs() (ids []int) {
	for id := range m.goals {
		ids = append(ids, id)
	}
	return
}

// ResetGoals resets all changes to the "goals" edge.
func (m *EmployeeMutation) ResetGoals() {
	m.goals = nil
	m.clearedgoals = false
	m.removedgoals = nil
}

// AddAssetAssignmentIDs adds the "asset_assignments" edge to the AssetAssignment entity by ids.
func (m *EmployeeMutation) AddAssetAssignmentIDs(ids ...int) {
	if m.asset_assignments == nil {
		m.asset_assignments = make(map[int]struct{})
	}
	for i := range ids {
		m.asset_assignments[ids[i]] = struct{}{}
	}
}

// ClearAssetAssignments clears the "asset_assignments" edge to the AssetAssignment entity.
func (m *EmployeeMutation) ClearAssetAssignments() {
	m.clearedasset_assignments = true
}

// AssetAssignmentsCleared reports if the "asset_assignments" edge to the AssetAssignment entity was cleared.
func (m *EmployeeMutation) AssetAssignmentsCleared() bool {
	return m.clearedasset_assignments
}

// RemoveAssetAssignmentIDs removes the "asset_assignments" edge to the AssetAssignment entity by IDs.
func (m *EmployeeMutation) RemoveAssetAssignmentIDs(ids ...int) {
	if m.removedasset_assignments == nil {
		m.removedasset_assignments = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.asset_assignments, ids[i])
		m.removedasset_assignments[ids[i]] = struct{}{}
	}
}

// RemovedAssetAssignments returns the removed IDs of the "asset_assignments" edge to the AssetAssignment entity.
func (m *EmployeeMutation) RemovedAssetAssignmentsIDs() (ids []int) {
	for id := range m.removedasset_assignments {
		ids = append(ids, id)
	}
	return
}

// AssetAssignmentsIDs returns the "asset_assignments" edge IDs in the mutation.
func (m *EmployeeMutation) AssetAssignmentsIDs() (ids []int) {
	for id := range m.asset_assignments {
		ids = append(ids, id)
	}
	return
}

// ResetAssetAssignments resets all changes to the "asset_assignments" edge.
func (m *EmployeeMutation) ResetAssetAssignments() {
	m.asset_assignments = nil
	m.clearedasset_assignments = false
	m.removedasset_assignments = nil
}

// AddTimeEntryIDs adds the "time_entries" edge to the TimeEntry entity by ids.
func (m *EmployeeMutation) AddTimeEntryIDs(ids ...int) {
	if m.time_entries == nil {
		m.time_entries = make(map[int]struct{})
	}
	for i := range ids {
		m.time_entries[ids[i]] = struct{}{}
	}
}

// ClearTimeEntries clears the "time_entries" edge to the TimeEntry entity.
func (m *EmployeeMutation) ClearTimeEntries() {
	m.clearedtime_entries = true
}

// TimeEntriesCleared reports if the "time_entries" edge to the TimeEntry entity was cleared.
func (m *EmployeeMutation) TimeEntriesCleared() bool {
	return m.clearedtime_entries
}

// RemoveTimeEntryIDs removes the "time_entries" edge to the TimeEntry entity by IDs.
func (m *EmployeeMutation) RemoveTimeEntryIDs(ids ...int) {
	if m.removedtime_entries == nil {
		m.removedtime_entries = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.time_entries, ids[i])
		m.removedtime_entries[ids[i]] = struct{}{}
	}
}

// RemovedTimeEntries returns the removed IDs of the "time_entries" edge to the TimeEntry entity.
func (m *EmployeeMutation) RemovedTimeEntriesIDs() (ids []int) {
	for id := range m.removedtime_entries {
		ids = append(ids, id)
	}
	return
}

// TimeEntriesIDs returns the "time_entries" edge IDs in the mutation.
func (m *EmployeeMutation) TimeEntriesIDs() (ids []int) {
	for id := range m.time_entries {
		ids = append(ids, id)
	}
	return
}

// ResetTimeEntries resets all changes to the "time_entries" edge.
func (m *EmployeeMutation) ResetTimeEntries() {
	m.time_entries = nil
	m.clearedtime_entries = false
	m.removedtime_entries = nil
}

// AddConductedInterviewIDs adds the "conducted_interviews" edge to the Interview entity by ids.
func (m *EmployeeMutation) AddConductedInterviewIDs(ids ...int) {
	if m.conducted_interviews == nil {
		m.conducted_interviews = make(map[int]struct{})
	}
	for i := range ids {
		m.conducted_interviews[ids[i]] = struct{}{}
	}
}

// ClearConductedInterviews clears the "conducted_interviews" edge to the Interview entity.
func (m *EmployeeMutation) ClearConductedInterviews() {
	m.clearedconducted_interviews = true
}

// ConductedInterviewsCleared reports if the "conducted_interviews" edge to the Interview entity was cleared.
func (m *EmployeeMutation) ConductedInterviewsCleared() bool {
	return m.clearedconducted_interviews
}

// RemoveConductedInterviewIDs removes the "conducted_interviews" edge to the Interview entity by IDs.
func (m *EmployeeMutation) RemoveConductedInterviewIDs(ids ...int) {
	if m.removedconducted_interviews == nil {
		m.removedconducted_interviews = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.conducted_interviews, ids[i])
		m.removedconducted_interviews[ids[i]] = struct{}{}
	}
}

// RemovedConductedInterviews returns the removed IDs of the "conducted_interviews" edge to the Interview entity.
func (m *EmployeeMutation) RemovedConductedInterviewsIDs() (ids []int) {
	for id := range m.removedconducted_interviews {
		ids = append(ids, id)
	}
	return
}

// ConductedInterviewsIDs returns the "conducted_interviews" edge IDs in the mutation.
func (m *EmployeeMutation) ConductedInterviewsIDs() (ids []int) {
	for id := range m.conducted_interviews {
		ids = append(ids, id)
	}
	return
}

// ResetConductedInterviews resets all changes to the "conducted_interviews" edge.
func (m *EmployeeMutation) ResetConductedInterviews() {
	m.conducted_interviews = nil
	m.clearedconducted_interviews = false
	m.removedconducted_interviews = nil
}

// AddBenefitEnrollmentIDs adds the "benefit_enrollments" edge to the BenefitEnrollment entity by ids.
func (m *EmployeeMutation) AddBenefitEnrollmentIDs(ids ...int) {
	if m.benefit_enrollments == nil {
		m.benefit_enrollments = make(map[int]struct{})
	}
	for i := range ids {
		m.benefit_enrollments[ids[i]] = struct{}{}
	}
}

// ClearBenefitEnrollments clears the "benefit_enrollments" edge to the BenefitEnrollment entity.
func (m *EmployeeMutation) ClearBenefitEnrollments() {
	m.clearedbenefit_enrollments = true
}

// BenefitEnrollmentsCleared reports if the "benefit_enrollments" edge to the BenefitEnrollment entity was cleared.
func (m *EmployeeMutation) BenefitEnrollmentsCleared() bool {
	return m.clearedbenefit_enrollments
}

// RemoveBenefitEnrollmentIDs removes the "benefit_enrollments" edge to the BenefitEnrollment entity by IDs.
func (m *EmployeeMutation) RemoveBenefitEnrollmentIDs(ids ...int) {
	if m.removedbenefit_enrollments == nil {
		m.removedbenefit_enrollments = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.benefit_enrollments, ids[i])
		m.removedbenefit_enrollments[ids[i]] = struct{}{}
	}
}

// RemovedBenefitEnrollments returns the removed IDs of the "benefit_enrollments" edge to the BenefitEnrollment entity.
func (m *EmployeeMutation) RemovedBenefitEnrollmentsIDs() (ids []int) {
	for id := range m.removedbenefit_enrollments {
		ids = append(ids, id)
	}
	return
}

// BenefitEnrollmentsIDs returns the "benefit_enrollments" edge IDs in the mutation.
func (m *EmployeeMutation) BenefitEnrollmentsIDs() (ids []int) {
	for id := range m.benefit_enrollments {
		ids = append(ids, id)
	}
	return
}

// ResetBenefitEnrollments resets all changes to the "benefit_enrollments" edge.
func (m *EmployeeMutation) ResetBenefitEnrollments() {
	m.benefit_enrollments = nil
	m.clearedbenefit_enrollments = false
	m.removedbenefit_enrollments = nil
}

// Where appends a list predicates to the EmployeeMutation builder.
func (m *EmployeeMutation) Where(ps ...predicate.Employee) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the EmployeeMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *EmployeeMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Employee, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *EmployeeMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *EmployeeMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Employee).
func (m *EmployeeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *EmployeeMutation) Fields() []string {
	fields := make([]string, 0, 14)
	if m.zitadel_id != nil {
		fields = append(fields, employee.FieldZitadelID)
	}
	if m.employee_id != nil {
		fields = append(fields, employee.FieldEmployeeID)
	}
	if m.first_name != nil {
		fields = append(fields, employee.FieldFirstName)
	}
	if m.last_name != nil {
		fields = append(fields, employee.FieldLastName)
	}
	if m.email != nil {
		fields = append(fields, employee.FieldEmail)
	}
	if m.phone != nil {
		fields = append(fields, employee.FieldPhone)
	}
	if m.status != nil {
		fields = append(fields, employee.FieldStatus)
	}
	if m.salary_encrypted != nil {
		fields = append(fields, employee.FieldSalaryEncrypted)
	}
	if m.bank_details_encrypted != nil {
		fields = append(fields, employee.FieldBankDetailsEncrypted)
	}
	if m.signature_hash != nil {
		fields = append(fields, employee.FieldSignatureHash)
	}
	if m.signed_at != nil {
		fields = append(fields, employee.FieldSignedAt)
	}
	if m.hipo_status != nil {
		fields = append(fields, employee.FieldHipoStatus)
	}
	if m.created_at != nil {
		fields = append(fields, employee.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, employee.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *EmployeeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case employee.FieldZitadelID:
		return m.ZitadelID()
	case employee.FieldEmployeeID:
		return m.EmployeeID()
	case employee.FieldFirstName:
		return m.FirstName()
	case employee.FieldLastName:
		return m.LastName()
	case employee.FieldEmail:
		return m.Email()
	case employee.FieldPhone:
		return m.Phone()
	case employee.FieldStatus:
		return m.Status()
	case employee.FieldSalaryEncrypted:
		return m.SalaryEncrypted()
	case employee.FieldBankDetailsEncrypted:
		return m.BankDetailsEncrypted()
	case employee.FieldSignatureHash:
		return m.SignatureHash()
	case employee.FieldSignedAt:
		return m.SignedAt()
	case employee.FieldHipoStatus:
		return m.HipoStatus()
	case employee.FieldCreatedAt:
		return m.CreatedAt()
	case employee.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *EmployeeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case employee.FieldZitadelID:
		return m.OldZitadelID(ctx)
	case employee.FieldEmployeeID:
		return m.OldEmployeeID(ctx)
	case employee.FieldFirstName:
		return m.OldFirstName(ctx)
	case employee.FieldLastName:
		return m.OldLastName(ctx)
	case employee.FieldEmail:
		return m.OldEmail(ctx)
	case employee.FieldPhone:
		return m.OldPhone(ctx)
	case employee.FieldStatus:
		return m.OldStatus(ctx)
	case employee.FieldSalaryEncrypted:
		return m.OldSalaryEncrypted(ctx)
	case employee.FieldBankDetailsEncrypted:
		return m.OldBankDetailsEncrypted(ctx)
	case employee.FieldSignatureHash:
		return m.OldSignatureHash(ctx)
	case employee.FieldSignedAt:
		return m.OldSignedAt(ctx)
	case employee.FieldHipoStatus:
		return m.OldHipoStatus(ctx)
	case employee.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case employee.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Employee field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EmployeeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case employee.FieldZitadelID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetZitadelID(v)
		return nil
	case employee.FieldEmployeeID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmployeeID(v)
		return nil
	case employee.FieldFirstName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFirstName(v)
		return nil
	case employee.FieldLastName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastName(v)
		return nil
	case employee.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case employee.FieldPhone:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhone(v)
		return nil
	case employee.FieldStatus:
		v, ok := value.(employee.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case employee.FieldSalaryEncrypted:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSalaryEncrypted(v)
		return nil
	case employee.FieldBankDetailsEncrypted:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBankDetailsEncrypted(v)
		return nil
	case employee.FieldSignatureHash:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSignatureHash(v)
		return nil
	case employee.FieldSignedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSignedAt(v)
		return nil
	case employee.FieldHipoStatus:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHipoStatus(v)
		return nil
	case employee.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case employee.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Employee field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *EmployeeMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *EmployeeMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EmployeeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Employee numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *EmployeeMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(employee.FieldPhone) {
		fields = append(fields, employee.FieldPhone)
	}
	if m.FieldCleared(employee.FieldBankDetailsEncrypted) {
		fields = append(fields, employee.FieldBankDetailsEncrypted)
	}
	if m.FieldCleared(employee.FieldSignatureHash) {
		fields = append(fields, employee.FieldSignatureHash)
	}
	if m.FieldCleared(employee.FieldSignedAt) {
		fields = append(fields, employee.FieldSignedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *EmployeeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *EmployeeMutation) ClearField(name string) error {
	switch name {
	case employee.FieldPhone:
		m.ClearPhone()
		return nil
	case employee.FieldBankDetailsEncrypted:
		m.ClearBankDetailsEncrypted()
		return nil
	case employee.FieldSignatureHash:
		m.ClearSignatureHash()
		return nil
	case employee.FieldSignedAt:
		m.ClearSignedAt()
		return nil
	}
	return fmt.Errorf("unknown Employee nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *EmployeeMutation) ResetField(name string) error {
	switch name {
	case employee.FieldZitadelID:
		m.ResetZitadelID()
		return nil
	case employee.FieldEmployeeID:
		m.ResetEmployeeID()
		return nil
	case employee.FieldFirstName:
		m.ResetFirstName()
		return nil
	case employee.FieldLastName:
		m.ResetLastName()
		return nil
	case employee.FieldEmail:
		m.ResetEmail()
		return nil
	case employee.FieldPhone:
		m.ResetPhone()
		return nil
	case employee.FieldStatus:
		m.ResetStatus()
		return nil
	case employee.FieldSalaryEncrypted:
		m.ResetSalaryEncrypted()
		return nil
	case employee.FieldBankDetailsEncrypted:
		m.ResetBankDetailsEncrypted()
		return nil
	case employee.FieldSignatureHash:
		m.ResetSignatureHash()
		return nil
	case employee.FieldSignedAt:
		m.ResetSignedAt()
		return nil
	case employee.FieldHipoStatus:
		m.ResetHipoStatus()
		return nil
	case employee.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case employee.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Employee field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *EmployeeMutation) AddedEdges() []string {
	edges := make([]string, 0, 18)
	if m.tenant != nil {
		edges = append(edges, employee.EdgeTenant)
	}
	if m.department != nil {
		edges = append(edges, employee.EdgeDepartment)
	}
	if m.manager != nil {
		edges = append(edges, employee.EdgeManager)
	}
	if m.subordinates != nil {
		edges = append(edges, employee.EdgeSubordinates)
	}
	if m.compensation_agreements != nil {
		edges = append(edges, employee.EdgeCompensationAgreements)
	}
	if m.succession_plans != nil {
		edges = append(edges, employee.EdgeSuccessionPlans)
	}
	if m.backup_for != nil {
		edges = append(edges, employee.EdgeBackupFor)
	}
	if m.expense_account != nil {
		edges = append(edges, employee.EdgeExpenseAccount)
	}
	if m.time_off_requests != nil {
		edges = append(edges, employee.EdgeTimeOffRequests)
	}
	if m.approved_time_off != nil {
		edges = append(edges, employee.EdgeApprovedTimeOff)
	}
	if m.time_off_balances != nil {
		edges = append(edges, employee.EdgeTimeOffBalances)
	}
	if m.performance_reviews != nil {
		edges = append(edges, employee.EdgePerformanceReviews)
	}
	if m.conducted_reviews != nil {
		edges = append(edges, employee.EdgeConductedReviews)
	}
	if m.goals != nil {
		edges = append(edges, employee.EdgeGoals)
	}
	if m.asset_assignments != nil {
		edges = append(edges, employee.EdgeAssetAssignments)
	}
	if m.time_entries != nil {
		edges = append(edges, employee.EdgeTimeEntries)
	}
	if m.conducted_interviews != nil {
		edges = append(edges, employee.EdgeConductedInterviews)
	}
	if m.benefit_enrollments != nil {
		edges = append(edges, employee.EdgeBenefitEnrollments)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *EmployeeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case employee.EdgeTenant:
		if id := m.tenant; id != nil {
			return []ent.Value{*id}
		}
	case employee.EdgeDepartment:
		if id := m.department; id != nil {
			return []ent.Value{*id}
		}
	case employee.EdgeManager:
		if id := m.manager; id != nil {
			return []ent.Value{*id}
		}
	case employee.EdgeSubordinates:
		ids := make([]ent.Value, 0, len(m.subordinates))
		for id := range m.subordinates {
			ids = append(ids, id)
		}
		return ids
	case employee.EdgeCompensationAgreements:
		ids := make([]ent.Value, 0, len(m.compensation_agreements))
		for id := range m.compensation_agreements {
			ids = append(ids, id)
		}
		return ids
	case employee.EdgeSuccessionPlans:
		ids := make([]ent.Value, 0, len(m.succession_plans))
		for id := range m.succession_plans {
			ids = append(ids, id)
		}
		return ids
	case employee.EdgeBackupFor:
		ids := make([]ent.Value, 0, len(m.backup_for))
		for id := range m.backup_for {
			ids = append(ids, id)
		}
		return ids
	case employee.EdgeExpenseAccount:
		if id := m.expense_account; id != nil {
			return []ent.Value{*id}
		}
	case employee.EdgeTimeOffRequests:
		ids := make([]ent.Value, 0, len(m.time_off_requests))
		for id := range m.time_off_requests {
			ids = append(ids, id)
		}
		return ids
	case employee.EdgeApprovedTimeOff:
		ids := make([]ent.Value, 0, len(m.approved_time_off))
		for id := range m.approved_time_off {
			ids = append(ids, id)
		}
		return ids
	case employee.EdgeTimeOffBalances:
		ids := make([]ent.Value, 0, len(m.time_off_balances))
		for id := range m.time_off_balances {
			ids = append(ids, id)
		}
		return ids
	case employee.EdgePerformanceReviews:
		ids := make([]ent.Value, 0, len(m.performance_reviews))
		for id := range m.performance_reviews {
			ids = append(ids, id)
		}
		return ids
	case employee.EdgeConductedReviews:
		ids := make([]ent.Value, 0, len(m.conducted_reviews))
		for id := range m.conducted_reviews {
			ids = append(ids, id)
		}
		return ids
	case employee.EdgeGoals:
		ids := make([]ent.Value, 0, len(m.goals))
		for id := range m.goals {
			ids = append(ids, id)
		}
		return ids
	case employee.EdgeAssetAssignments:
		ids := make([]ent.Value, 0, len(m.asset_assignments))
		for id := range m.asset_assignments {
			ids = append(ids, id)
		}
		return ids
	case employee.EdgeTimeEntries:
		ids := make([]ent.Value, 0, len(m.time_entries))
		for id := range m.time_entries {
			ids = append(ids, id)
		}
		return ids
	case employee.EdgeConductedInterviews:
		ids := make([]ent.Value, 0, len(m.conducted_interviews))
		for id := range m.conducted_interviews {
			ids = append(ids, id)
		}
		return ids
	case employee.EdgeBenefitEnrollments:
		ids := make([]ent.Value, 0, len(m.benefit_enrollments))
		for id := range m.benefit_enrollments {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *EmployeeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 18)
	if m.removedsubordinates != nil {
		edges = append(edges, employee.EdgeSubordinates)
	}
	if m.removedcompensation_agreements != nil {
		edges = append(edges, employee.EdgeCompensationAgreements)
	}
	if m.removedsuccession_plans != nil {
		edges = append(edges, employee.EdgeSuccessionPlans)
	}
	if m.removedbackup_for != nil {
		edges = append(edges, employee.EdgeBackupFor)
	}
	if m.removedtime_off_requests != nil {
		edges = append(edges, employee.EdgeTimeOffRequests)
	}
	if m.removedapproved_time_off != nil {
		edges = append(edges, employee.EdgeApprovedTimeOff)
	}
	if m.removedtime_off_balances != nil {
		edges = append(edges, employee.EdgeTimeOffBalances)
	}
	if m.removedperformance_reviews != nil {
		edges = append(edges, employee.EdgePerformanceReviews)
	}
	if m.removedconducted_reviews != nil {
		edges = append(edges, employee.EdgeConductedReviews)
	}
	if m.removedgoals != nil {
		edges = append(edges, employee.EdgeGoals)
	}
	if m.removedasset_assignments != nil {
		edges = append(edges, employee.EdgeAssetAssignments)
	}
	if m.removedtime_entries != nil {
		edges = append(edges, employee.EdgeTimeEntries)
	}
	if m.removedconducted_interviews != nil {
		edges = append(edges, employee.EdgeConductedInterviews)
	}
	if m.removedbenefit_enrollments != nil {
		edges = append(edges, employee.EdgeBenefitEnrollments)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *EmployeeMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case employee.EdgeSubordinates:
		ids := make([]ent.Value, 0, len(m.removedsubordinates))
		for id := range m.removedsubordinates {
			ids = append(ids, id)
		}
		return ids
	case employee.EdgeCompensationAgreements:
		ids := make([]ent.Value, 0, len(m.removedcompensation_agreements))
		for id := range m.removedcompensation_agreements {
			ids = append(ids, id)
		}
		return ids
	case employee.EdgeSuccessionPlans:
		ids := make([]ent.Value, 0, len(m.removedsuccession_plans))
		for id := range m.removedsuccession_plans {
			ids = append(ids, id)
		}
		return ids
	case employee.EdgeBackupFor:
		ids := make([]ent.Value, 0, len(m.removedbackup_for))
		for id := range m.removedbackup_for {
			ids = append(ids, id)
		}
		return ids
	case employee.EdgeTimeOffRequests:
		ids := make([]ent.Value, 0, len(m.removedtime_off_requests))
		for id := range m.removedtime_off_requests {
			ids = append(ids, id)
		}
		return ids
	case employee.EdgeApprovedTimeOff:
		ids := make([]ent.Value, 0, len(m.removedapproved_time_off))
		for id := range m.removedapproved_time_off {
			ids = append(ids, id)
		}
		return ids
	case employee.EdgeTimeOffBalances:
		ids := make([]ent.Value, 0, len(m.removedtime_off_balances))
		for id := range m.removedtime_off_balances {
			ids = append(ids, id)
		}
		return ids
	case employee.EdgePerformanceReviews:
		ids := make([]ent.Value, 0, len(m.removedperformance_reviews))
		for id := range m.removedperformance_reviews {
			ids = append(ids, id)
		}
		return ids
	case employee.EdgeConductedReviews:
		ids := make([]ent.Value, 0, len(m.removedconducted_reviews))
		for id := range m.removedconducted_reviews {
			ids = append(ids, id)
		}
		return ids
	case employee.EdgeGoals:
		ids := make([]ent.Value, 0, len(m.removedgoals))
		for id := range m.removedgoals {
			ids = append(ids, id)
		}
		return ids
	case employee.EdgeAssetAssignments:
		ids := make([]ent.Value, 0, len(m.removedasset_assignments))
		for id := range m.removedasset_assignments {
			ids = append(ids, id)
		}
		return ids
	case employee.EdgeTimeEntries:
		ids := make([]ent.Value, 0, len(m.removedtime_entries))
		for id := range m.removedtime_entries {
			ids = append(ids, id)
		}
		return ids
	case employee.EdgeConductedInterviews:
		ids := make([]ent.Value, 0, len(m.removedconducted_interviews))
		for id := range m.removedconducted_interviews {
			ids = append(ids, id)
		}
		return ids
	case employee.EdgeBenefitEnrollments:
		ids := make([]ent.Value, 0, len(m.removedbenefit_enrollments))
		for id := range m.removedbenefit_enrollments {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *EmployeeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 18)
	if m.clearedtenant {
		edges = append(edges, employee.EdgeTenant)
	}
	if m.cleareddepartment {
		edges = append(edges, employee.EdgeDepartment)
	}
	if m.clearedmanager {
		edges = append(edges, employee.EdgeManager)
	}
	if m.clearedsubordinates {
		edges = append(edges, employee.EdgeSubordinates)
	}
	if m.clearedcompensation_agreements {
		edges = append(edges, employee.EdgeCompensationAgreements)
	}
	if m.clearedsuccession_plans {
		edges = append(edges, employee.EdgeSuccessionPlans)
	}
	if m.clearedbackup_for {
		edges = append(edges, employee.EdgeBackupFor)
	}
	if m.clearedexpense_account {
		edges = append(edges, employee.EdgeExpenseAccount)
	}
	if m.clearedtime_off_requests {
		edges = append(edges, employee.EdgeTimeOffRequests)
	}
	if m.clearedapproved_time_off {
		edges = append(edges, employee.EdgeApprovedTimeOff)
	}
	if m.clearedtime_off_balances {
		edges = append(edges, employee.EdgeTimeOffBalances)
	}
	if m.clearedperformance_reviews {
		edges = append(edges, employee.EdgePerformanceReviews)
	}
	if m.clearedconducted_reviews {
		edges = append(edges, employee.EdgeConductedReviews)
	}
	if m.clearedgoals {
		edges = append(edges, employee.EdgeGoals)
	}
	if m.clearedasset_assignments {
		edges = append(edges, employee.EdgeAssetAssignments)
	}
	if m.clearedtime_entries {
		edges = append(edges, employee.EdgeTimeEntries)
	}
	if m.clearedconducted_interviews {
		edges = append(edges, employee.EdgeConductedInterviews)
	}
	if m.clearedbenefit_enrollments {
		edges = append(edges, employee.EdgeBenefitEnrollments)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *EmployeeMutation) EdgeCleared(name string) bool {
	switch name {
	case employee.EdgeTenant:
		return m.clearedtenant
	case employee.EdgeDepartment:
		return m.cleareddepartment
	case employee.EdgeManager:
		return m.clearedmanager
	case employee.EdgeSubordinates:
		return m.clearedsubordinates
	case employee.EdgeCompensationAgreements:
		return m.clearedcompensation_agreements
	case employee.EdgeSuccessionPlans:
		return m.clearedsuccession_plans
	case employee.EdgeBackupFor:
		return m.clearedbackup_for
	case employee.EdgeExpenseAccount:
		return m.clearedexpense_account
	case employee.EdgeTimeOffRequests:
		return m.clearedtime_off_requests
	case employee.EdgeApprovedTimeOff:
		return m.clearedapproved_time_off
	case employee.EdgeTimeOffBalances:
		return m.clearedtime_off_balances
	case employee.EdgePerformanceReviews:
		return m.clearedperformance_reviews
	case employee.EdgeConductedReviews:
		return m.clearedconducted_reviews
	case employee.EdgeGoals:
		return m.clearedgoals
	case employee.EdgeAssetAssignments:
		return m.clearedasset_assignments
	case employee.EdgeTimeEntries:
		return m.clearedtime_entries
	case employee.EdgeConductedInterviews:
		return m.clearedconducted_interviews
	case employee.EdgeBenefitEnrollments:
		return m.clearedbenefit_enrollments
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *EmployeeMutation) ClearEdge(name string) error {
	switch name {
	case employee.EdgeTenant:
		m.ClearTenant()
		return nil
	case employee.EdgeDepartment:
		m.ClearDepartment()
		return nil
	case employee.EdgeManager:
		m.ClearManager()
		return nil
	case employee.EdgeExpenseAccount:
		m.ClearExpenseAccount()
		return nil
	}
	return fmt.Errorf("unknown Employee unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *EmployeeMutation) ResetEdge(name string) error {
	switch name {
	case employee.EdgeTenant:
		m.ResetTenant()
		return nil
	case employee.EdgeDepartment:
		m.ResetDepartment()
		return nil
	case employee.EdgeManager:
		m.ResetManager()
		return nil
	case employee.EdgeSubordinates:
		m.ResetSubordinates()
		return nil
	case employee.EdgeCompensationAgreements:
		m.ResetCompensationAgreements()
		return nil
	case employee.EdgeSuccessionPlans:
		m.ResetSuccessionPlans()
		return nil
	case employee.EdgeBackupFor:
		m.ResetBackupFor()
		return nil
	case employee.EdgeExpenseAccount:
		m.ResetExpenseAccount()
		return nil
	case employee.EdgeTimeOffRequests:
		m.ResetTimeOffRequests()
		return nil
	case employee.EdgeApprovedTimeOff:
		m.ResetApprovedTimeOff()
		return nil
	case employee.EdgeTimeOffBalances:
		m.ResetTimeOffBalances()
		return nil
	case employee.EdgePerformanceReviews:
		m.ResetPerformanceReviews()
		return nil
	case employee.EdgeConductedReviews:
		m.ResetConductedReviews()
		return nil
	case employee.EdgeGoals:
		m.ResetGoals()
		return nil
	case employee.EdgeAssetAssignments:
		m.ResetAssetAssignments()
		return nil
	case employee.EdgeTimeEntries:
		m.ResetTimeEntries()
		return nil
	case employee.EdgeConductedInterviews:
		m.ResetConductedInterviews()
		return nil
	case employee.EdgeBenefitEnrollments:
		m.ResetBenefitEnrollments()
		return nil
	}
	return fmt.Errorf("unknown Employee edge %s", name)
}

// GoalMutation represents an operation that mutates the Goal nodes in the graph.
type GoalMutation struct {
	config
	op              Op
	typ             string
	id              *int
	title           *string
	description     *string
	category        *goal.Category
	status          *goal.Status
	progress        *int
	addprogress     *int
	target_date     *time.Time
	key_results     *string
	manager_notes   *string
	completed_at    *time.Time
	created_at      *time.Time
	updated_at      *time.Time
	clearedFields   map[string]struct{}
	tenant          *int
	clearedtenant   bool
	employee        *int
	clearedemployee bool
	done            bool
	oldValue        func(context.Context) (*Goal, error)
	predicates      []predicate.Goal
}

var _ ent.Mutation = (*GoalMutation)(nil)

// goalOption allows management of the mutation configuration using functional options.
type goalOption func(*GoalMutation)

// newGoalMutation creates new mutation for the Goal entity.
func newGoalMutation(c config, op Op, opts ...goalOption) *GoalMutation {
	m := &GoalMutation{
		config:        c,
		op:            op,
		typ:           TypeGoal,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withGoalID sets the ID field of the mutation.
func withGoalID(id int) goalOption {
	return func(m *GoalMutation) {
		var (
			err   error
			once  sync.Once
			value *Goal
		)
		m.oldValue = func(ctx context.Context) (*Goal, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Goal.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withGoal sets the old Goal of the mutation.
func withGoal(node *Goal) goalOption {
	return func(m *GoalMutation) {
		m.oldValue = func(context.Context) (*Goal, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m GoalMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m GoalMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *GoalMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *GoalMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Goal.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTitle sets the "title" field.
func (m *GoalMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *GoalMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the Goal entity.
// If the Goal object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoalMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *GoalMutation) ResetTitle() {
	m.title = nil
}

// SetDescription sets the "description" field.
func (m *GoalMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *GoalMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Goal entity.
// If the Goal object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoalMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *GoalMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[goal.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *GoalMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[goal.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *GoalMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, goal.FieldDescription)
}

// SetCategory sets the "category" field.
func (m *GoalMutation) SetCategory(_go goal.Category) {
	m.category = &_go
}

// Category returns the value of the "category" field in the mutation.
func (m *GoalMutation) Category() (r goal.Category, exists bool) {
	v := m.category
	if v == nil {
		return
	}
	return *v, true
}

// OldCategory returns the old "category" field's value of the Goal entity.
// If the Goal object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoalMutation) OldCategory(ctx context.Context) (v goal.Category, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCategory is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCategory requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCategory: %w", err)
	}
	return oldValue.Category, nil
}

// ResetCategory resets all changes to the "category" field.
func (m *GoalMutation) ResetCategory() {
	m.category = nil
}

// SetStatus sets the "status" field.
func (m *GoalMutation) SetStatus(_go goal.Status) {
	m.status = &_go
}

// Status returns the value of the "status" field in the mutation.
func (m *GoalMutation) Status() (r goal.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Goal entity.
// If the Goal object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoalMutation) OldStatus(ctx context.Context) (v goal.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *GoalMutation) ResetStatus() {
	m.status = nil
}

// SetProgress sets the "progress" field.
func (m *GoalMutation) SetProgress(i int) {
	m.progress = &i
	m.addprogress = nil
}

// Progress returns the value of the "progress" field in the mutation.
func (m *GoalMutation) Progress() (r int, exists bool) {
	v := m.progress
	if v == nil {
		return
	}
	return *v, true
}

// OldProgress returns the old "progress" field's value of the Goal entity.
// If the Goal object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoalMutation) OldProgress(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProgress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProgress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProgress: %w", err)
	}
	return oldValue.Progress, nil
}

// AddProgress adds i to the "progress" field.
func (m *GoalMutation) AddProgress(i int) {
	if m.addprogress != nil {
		*m.addprogress += i
	} else {
		m.addprogress = &i
	}
}

// AddedProgress returns the value that was added to the "progress" field in this mutation.
func (m *GoalMutation) AddedProgress() (r int, exists bool) {
	v := m.addprogress
	if v == nil {
		return
	}
	return *v, true
}

// ResetProgress resets all changes to the "progress" field.
func (m *GoalMutation) ResetProgress() {
	m.progress = nil
	m.addprogress = nil
}

// SetTargetDate sets the "target_date" field.
func (m *GoalMutation) SetTargetDate(t time.Time) {
	m.target_date = &t
}

// TargetDate returns the value of the "target_date" field in the mutation.
func (m *GoalMutation) TargetDate() (r time.Time, exists bool) {
	v := m.target_date
	if v == nil {
		return
	}
	return *v, true
}

// OldTargetDate returns the old "target_date" field's value of the Goal entity.
// If the Goal object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoalMutation) OldTargetDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTargetDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTargetDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTargetDate: %w", err)
	}
	return oldValue.TargetDate, nil
}

// ClearTargetDate clears the value of the "target_date" field.
func (m *GoalMutation) ClearTargetDate() {
	m.target_date = nil
	m.clearedFields[goal.FieldTargetDate] = struct{}{}
}

// TargetDateCleared returns if the "target_date" field was cleared in this mutation.
func (m *GoalMutation) TargetDateCleared() bool {
	_, ok := m.clearedFields[goal.FieldTargetDate]
	return ok
}

// ResetTargetDate resets all changes to the "target_date" field.
func (m *GoalMutation) ResetTargetDate() {
	m.target_date = nil
	delete(m.clearedFields, goal.FieldTargetDate)
}

// SetKeyResults sets the "key_results" field.
func (m *GoalMutation) SetKeyResults(s string) {
	m.key_results = &s
}

// KeyResults returns the value of the "key_results" field in the mutation.
func (m *GoalMutation) KeyResults() (r string, exists bool) {
	v := m.key_results
	if v == nil {
		return
	}
	return *v, true
}

// OldKeyResults returns the old "key_results" field's value of the Goal entity.
// If the Goal object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoalMutation) OldKeyResults(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKeyResults is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKeyResults requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKeyResults: %w", err)
	}
	return oldValue.KeyResults, nil
}

// ClearKeyResults clears the value of the "key_results" field.
func (m *GoalMutation) ClearKeyResults() {
	m.key_results = nil
	m.clearedFields[goal.FieldKeyResults] = struct{}{}
}

// KeyResultsCleared returns if the "key_results" field was cleared in this mutation.
func (m *GoalMutation) KeyResultsCleared() bool {
	_, ok := m.clearedFields[goal.FieldKeyResults]
	return ok
}

// ResetKeyResults resets all changes to the "key_results" field.
func (m *GoalMutation) ResetKeyResults() {
	m.key_results = nil
	delete(m.clearedFields, goal.FieldKeyResults)
}

// SetManagerNotes sets the "manager_notes" field.
func (m *GoalMutation) SetManagerNotes(s string) {
	m.manager_notes = &s
}

// ManagerNotes returns the value of the "manager_notes" field in the mutation.
func (m *GoalMutation) ManagerNotes() (r string, exists bool) {
	v := m.manager_notes
	if v == nil {
		return
	}
	return *v, true
}

// OldManagerNotes returns the old "manager_notes" field's value of the Goal entity.
// If the Goal object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoalMutation) OldManagerNotes(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldManagerNotes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldManagerNotes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldManagerNotes: %w", err)
	}
	return oldValue.ManagerNotes, nil
}

// ClearManagerNotes clears the value of the "manager_notes" field.
func (m *GoalMutation) ClearManagerNotes() {
	m.manager_notes = nil
	m.clearedFields[goal.FieldManagerNotes] = struct{}{}
}

// ManagerNotesCleared returns if the "manager_notes" field was cleared in this mutation.
func (m *GoalMutation) ManagerNotesCleared() bool {
	_, ok := m.clearedFields[goal.FieldManagerNotes]
	return ok
}

// ResetManagerNotes resets all changes to the "manager_notes" field.
func (m *GoalMutation) ResetManagerNotes() {
	m.manager_notes = nil
	delete(m.clearedFields, goal.FieldManagerNotes)
}

// SetCompletedAt sets the "completed_at" field.
func (m *GoalMutation) SetCompletedAt(t time.Time) {
	m.completed_at = &t
}

// CompletedAt returns the value of the "completed_at" field in the mutation.
func (m *GoalMutation) CompletedAt() (r time.Time, exists bool) {
	v := m.completed_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCompletedAt returns the old "completed_at" field's value of the Goal entity.
// If the Goal object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoalMutation) OldCompletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCompletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCompletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCompletedAt: %w", err)
	}
	return oldValue.CompletedAt, nil
}

// ClearCompletedAt clears the value of the "completed_at" field.
func (m *GoalMutation) ClearCompletedAt() {
	m.completed_at = nil
	m.clearedFields[goal.FieldCompletedAt] = struct{}{}
}

// CompletedAtCleared returns if the "completed_at" field was cleared in this mutation.
func (m *GoalMutation) CompletedAtCleared() bool {
	_, ok := m.clearedFields[goal.FieldCompletedAt]
	return ok
}

// ResetCompletedAt resets all changes to the "completed_at" field.
func (m *GoalMutation) ResetCompletedAt() {
	m.completed_at = nil
	delete(m.clearedFields, goal.FieldCompletedAt)
}

// SetCreatedAt sets the "created_at" field.
func (m *GoalMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *GoalMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Goal entity.
// If the Goal object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoalMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *GoalMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *GoalMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *GoalMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Goal entity.
// If the Goal object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoalMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *GoalMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetTenantID sets the "tenant" edge to the Tenant entity by id.
func (m *GoalMutation) SetTenantID(id int) {
	m.tenant = &id
}

// ClearTenant clears the "tenant" edge to the Tenant entity.
func (m *GoalMutation) ClearTenant() {
	m.clearedtenant = true
}

// TenantCleared reports if the "tenant" edge to the Tenant entity was cleared.
func (m *GoalMutation) TenantCleared() bool {
	return m.clearedtenant
}

// TenantID returns the "tenant" edge ID in the mutation.
func (m *GoalMutation) TenantID() (id int, exists bool) {
	if m.tenant != nil {
		return *m.tenant, true
	}
	return
}

// TenantIDs returns the "tenant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TenantID instead. It exists only for internal usage by the builders.
func (m *GoalMutation) TenantIDs() (ids []int) {
	if id := m.tenant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTenant resets all changes to the "tenant" edge.
func (m *GoalMutation) ResetTenant() {
	m.tenant = nil
	m.clearedtenant = false
}

// SetEmployeeID sets the "employee" edge to the Employee entity by id.
func (m *GoalMutation) SetEmployeeID(id int) {
	m.employee = &id
}

// ClearEmployee clears the "employee" edge to the Employee entity.
func (m *GoalMutation) ClearEmployee() {
	m.clearedemployee = true
}

// EmployeeCleared reports if the "employee" edge to the Employee entity was cleared.
func (m *GoalMutation) EmployeeCleared() bool {
	return m.clearedemployee
}

// EmployeeID returns the "employee" edge ID in the mutation.
func (m *GoalMutation) EmployeeID() (id int, exists bool) {
	if m.employee != nil {
		return *m.employee, true
	}
	return
}

// EmployeeIDs returns the "employee" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// EmployeeID instead. It exists only for internal usage by the builders.
func (m *GoalMutation) EmployeeIDs() (ids []int) {
	if id := m.employee; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEmployee resets all changes to the "employee" edge.
func (m *GoalMutation) ResetEmployee() {
	m.employee = nil
	m.clearedemployee = false
}

// Where appends a list predicates to the GoalMutation builder.
func (m *GoalMutation) Where(ps ...predicate.Goal) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the GoalMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *GoalMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Goal, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *GoalMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *GoalMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Goal).
func (m *GoalMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *GoalMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.title != nil {
		fields = append(fields, goal.FieldTitle)
	}
	if m.description != nil {
		fields = append(fields, goal.FieldDescription)
	}
	if m.category != nil {
		fields = append(fields, goal.FieldCategory)
	}
	if m.status != nil {
		fields = append(fields, goal.FieldStatus)
	}
	if m.progress != nil {
		fields = append(fields, goal.FieldProgress)
	}
	if m.target_date != nil {
		fields = append(fields, goal.FieldTargetDate)
	}
	if m.key_results != nil {
		fields = append(fields, goal.FieldKeyResults)
	}
	if m.manager_notes != nil {
		fields = append(fields, goal.FieldManagerNotes)
	}
	if m.completed_at != nil {
		fields = append(fields, goal.FieldCompletedAt)
	}
	if m.created_at != nil {
		fields = append(fields, goal.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, goal.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *GoalMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case goal.FieldTitle:
		return m.Title()
	case goal.FieldDescription:
		return m.Description()
	case goal.FieldCategory:
		return m.Category()
	case goal.FieldStatus:
		return m.Status()
	case goal.FieldProgress:
		return m.Progress()
	case goal.FieldTargetDate:
		return m.TargetDate()
	case goal.FieldKeyResults:
		return m.KeyResults()
	case goal.FieldManagerNotes:
		return m.ManagerNotes()
	case goal.FieldCompletedAt:
		return m.CompletedAt()
	case goal.FieldCreatedAt:
		return m.CreatedAt()
	case goal.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *GoalMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case goal.FieldTitle:
		return m.OldTitle(ctx)
	case goal.FieldDescription:
		return m.OldDescription(ctx)
	case goal.FieldCategory:
		return m.OldCategory(ctx)
	case goal.FieldStatus:
		return m.OldStatus(ctx)
	case goal.FieldProgress:
		return m.OldProgress(ctx)
	case goal.FieldTargetDate:
		return m.OldTargetDate(ctx)
	case goal.FieldKeyResults:
		return m.OldKeyResults(ctx)
	case goal.FieldManagerNotes:
		return m.OldManagerNotes(ctx)
	case goal.FieldCompletedAt:
		return m.OldCompletedAt(ctx)
	case goal.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case goal.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Goal field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GoalMutation) SetField(name string, value ent.Value) error {
	switch name {
	case goal.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case goal.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case goal.FieldCategory:
		v, ok := value.(goal.Category)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCategory(v)
		return nil
	case goal.FieldStatus:
		v, ok := value.(goal.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case goal.FieldProgress:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProgress(v)
		return nil
	case goal.FieldTargetDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTargetDate(v)
		return nil
	case goal.FieldKeyResults:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKeyResults(v)
		return nil
	case goal.FieldManagerNotes:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetManagerNotes(v)
		return nil
	case goal.FieldCompletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCompletedAt(v)
		return nil
	case goal.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case goal.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Goal field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *GoalMutation) AddedFields() []string {
	var fields []string
	if m.addprogress != nil {
		fields = append(fields, goal.FieldProgress)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *GoalMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case goal.FieldProgress:
		return m.AddedProgress()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GoalMutation) AddField(name string, value ent.Value) error {
	switch name {
	case goal.FieldProgress:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddProgress(v)
		return nil
	}
	return fmt.Errorf("unknown Goal numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *GoalMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(goal.FieldDescription) {
		fields = append(fields, goal.FieldDescription)
	}
	if m.FieldCleared(goal.FieldTargetDate) {
		fields = append(fields, goal.FieldTargetDate)
	}
	if m.FieldCleared(goal.FieldKeyResults) {
		fields = append(fields, goal.FieldKeyResults)
	}
	if m.FieldCleared(goal.FieldManagerNotes) {
		fields = append(fields, goal.FieldManagerNotes)
	}
	if m.FieldCleared(goal.FieldCompletedAt) {
		fields = append(fields, goal.FieldCompletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *GoalMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *GoalMutation) ClearField(name string) error {
	switch name {
	case goal.FieldDescription:
		m.ClearDescription()
		return nil
	case goal.FieldTargetDate:
		m.ClearTargetDate()
		return nil
	case goal.FieldKeyResults:
		m.ClearKeyResults()
		return nil
	case goal.FieldManagerNotes:
		m.ClearManagerNotes()
		return nil
	case goal.FieldCompletedAt:
		m.ClearCompletedAt()
		return nil
	}
	return fmt.Errorf("unknown Goal nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *GoalMutation) ResetField(name string) error {
	switch name {
	case goal.FieldTitle:
		m.ResetTitle()
		return nil
	case goal.FieldDescription:
		m.ResetDescription()
		return nil
	case goal.FieldCategory:
		m.ResetCategory()
		return nil
	case goal.FieldStatus:
		m.ResetStatus()
		return nil
	case goal.FieldProgress:
		m.ResetProgress()
		return nil
	case goal.FieldTargetDate:
		m.ResetTargetDate()
		return nil
	case goal.FieldKeyResults:
		m.ResetKeyResults()
		return nil
	case goal.FieldManagerNotes:
		m.ResetManagerNotes()
		return nil
	case goal.FieldCompletedAt:
		m.ResetCompletedAt()
		return nil
	case goal.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case goal.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Goal field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *GoalMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.tenant != nil {
		edges = append(edges, goal.EdgeTenant)
	}
	if m.employee != nil {
		edges = append(edges, goal.EdgeEmployee)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *GoalMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case goal.EdgeTenant:
		if id := m.tenant; id != nil {
			return []ent.Value{*id}
		}
	case goal.EdgeEmployee:
		if id := m.employee; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *GoalMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *GoalMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *GoalMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedtenant {
		edges = append(edges, goal.EdgeTenant)
	}
	if m.clearedemployee {
		edges = append(edges, goal.EdgeEmployee)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *GoalMutation) EdgeCleared(name string) bool {
	switch name {
	case goal.EdgeTenant:
		return m.clearedtenant
	case goal.EdgeEmployee:
		return m.clearedemployee
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *GoalMutation) ClearEdge(name string) error {
	switch name {
	case goal.EdgeTenant:
		m.ClearTenant()
		return nil
	case goal.EdgeEmployee:
		m.ClearEmployee()
		return nil
	}
	return fmt.Errorf("unknown Goal unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *GoalMutation) ResetEdge(name string) error {
	switch name {
	case goal.EdgeTenant:
		m.ResetTenant()
		return nil
	case goal.EdgeEmployee:
		m.ResetEmployee()
		return nil
	}
	return fmt.Errorf("unknown Goal edge %s", name)
}

// HealthScoreSnapshotMutation represents an operation that mutates the HealthScoreSnapshot nodes in the graph.
type HealthScoreSnapshotMutation struct {
	config
	op                   Op
	typ                  string
	id                   *int
	overall_score        *float64
	addoverall_score     *float64
	performance_score    *float64
	addperformance_score *float64
	security_score       *float64
	addsecurity_score    *float64
	lifecycle_score      *float64
	addlifecycle_score   *float64
	metadata             *map[string]interface{}
	timestamp            *time.Time
	clearedFields        map[string]struct{}
	tenant               *int
	clearedtenant        bool
	done                 bool
	oldValue             func(context.Context) (*HealthScoreSnapshot, error)
	predicates           []predicate.HealthScoreSnapshot
}

var _ ent.Mutation = (*HealthScoreSnapshotMutation)(nil)

// healthscoresnapshotOption allows management of the mutation configuration using functional options.
type healthscoresnapshotOption func(*HealthScoreSnapshotMutation)

// newHealthScoreSnapshotMutation creates new mutation for the HealthScoreSnapshot entity.
func newHealthScoreSnapshotMutation(c config, op Op, opts ...healthscoresnapshotOption) *HealthScoreSnapshotMutation {
	m := &HealthScoreSnapshotMutation{
		config:        c,
		op:            op,
		typ:           TypeHealthScoreSnapshot,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withHealthScoreSnapshotID sets the ID field of the mutation.
func withHealthScoreSnapshotID(id int) healthscoresnapshotOption {
	return func(m *HealthScoreSnapshotMutation) {
		var (
			err   error
			once  sync.Once
			value *HealthScoreSnapshot
		)
		m.oldValue = func(ctx context.Context) (*HealthScoreSnapshot, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().HealthScoreSnapshot.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withHealthScoreSnapshot sets the old HealthScoreSnapshot of the mutation.
func withHealthScoreSnapshot(node *HealthScoreSnapshot) healthscoresnapshotOption {
	return func(m *HealthScoreSnapshotMutation) {
		m.oldValue = func(context.Context) (*HealthScoreSnapshot, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m HealthScoreSnapshotMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m HealthScoreSnapshotMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *HealthScoreSnapshotMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *HealthScoreSnapshotMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().HealthScoreSnapshot.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetOverallScore sets the "overall_score" field.
func (m *HealthScoreSnapshotMutation) SetOverallScore(f float64) {
	m.overall_score = &f
	m.addoverall_score = nil
}

// OverallScore returns the value of the "overall_score" field in the mutation.
func (m *HealthScoreSnapshotMutation) OverallScore() (r float64, exists bool) {
	v := m.overall_score
	if v == nil {
		return
	}
	return *v, true
}

// OldOverallScore returns the old "overall_score" field's value of the HealthScoreSnapshot entity.
// If the HealthScoreSnapshot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HealthScoreSnapshotMutation) OldOverallScore(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOverallScore is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOverallScore requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOverallScore: %w", err)
	}
	return oldValue.OverallScore, nil
}

// AddOverallScore adds f to the "overall_score" field.
func (m *HealthScoreSnapshotMutation) AddOverallScore(f float64) {
	if m.addoverall_score != nil {
		*m.addoverall_score += f
	} else {
		m.addoverall_score = &f
	}
}

// AddedOverallScore returns the value that was added to the "overall_score" field in this mutation.
func (m *HealthScoreSnapshotMutation) AddedOverallScore() (r float64, exists bool) {
	v := m.addoverall_score
	if v == nil {
		return
	}
	return *v, true
}

// ResetOverallScore resets all changes to the "overall_score" field.
func (m *HealthScoreSnapshotMutation) ResetOverallScore() {
	m.overall_score = nil
	m.addoverall_score = nil
}

// SetPerformanceScore sets the "performance_score" field.
func (m *HealthScoreSnapshotMutation) SetPerformanceScore(f float64) {
	m.performance_score = &f
	m.addperformance_score = nil
}

// PerformanceScore returns the value of the "performance_score" field in the mutation.
func (m *HealthScoreSnapshotMutation) PerformanceScore() (r float64, exists bool) {
	v := m.performance_score
	if v == nil {
		return
	}
	return *v, true
}

// OldPerformanceScore returns the old "performance_score" field's value of the HealthScoreSnapshot entity.
// If the HealthScoreSnapshot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HealthScoreSnapshotMutation) OldPerformanceScore(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPerformanceScore is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPerformanceScore requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPerformanceScore: %w", err)
	}
	return oldValue.PerformanceScore, nil
}

// AddPerformanceScore adds f to the "performance_score" field.
func (m *HealthScoreSnapshotMutation) AddPerformanceScore(f float64) {
	if m.addperformance_score != nil {
		*m.addperformance_score += f
	} else {
		m.addperformance_score = &f
	}
}

// AddedPerformanceScore returns the value that was added to the "performance_score" field in this mutation.
func (m *HealthScoreSnapshotMutation) AddedPerformanceScore() (r float64, exists bool) {
	v := m.addperformance_score
	if v == nil {
		return
	}
	return *v, true
}

// ResetPerformanceScore resets all changes to the "performance_score" field.
func (m *HealthScoreSnapshotMutation) ResetPerformanceScore() {
	m.performance_score = nil
	m.addperformance_score = nil
}

// SetSecurityScore sets the "security_score" field.
func (m *HealthScoreSnapshotMutation) SetSecurityScore(f float64) {
	m.security_score = &f
	m.addsecurity_score = nil
}

// SecurityScore returns the value of the "security_score" field in the mutation.
func (m *HealthScoreSnapshotMutation) SecurityScore() (r float64, exists bool) {
	v := m.security_score
	if v == nil {
		return
	}
	return *v, true
}

// OldSecurityScore returns the old "security_score" field's value of the HealthScoreSnapshot entity.
// If the HealthScoreSnapshot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HealthScoreSnapshotMutation) OldSecurityScore(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSecurityScore is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSecurityScore requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSecurityScore: %w", err)
	}
	return oldValue.SecurityScore, nil
}

// AddSecurityScore adds f to the "security_score" field.
func (m *HealthScoreSnapshotMutation) AddSecurityScore(f float64) {
	if m.addsecurity_score != nil {
		*m.addsecurity_score += f
	} else {
		m.addsecurity_score = &f
	}
}

// AddedSecurityScore returns the value that was added to the "security_score" field in this mutation.
func (m *HealthScoreSnapshotMutation) AddedSecurityScore() (r float64, exists bool) {
	v := m.addsecurity_score
	if v == nil {
		return
	}
	return *v, true
}

// ResetSecurityScore resets all changes to the "security_score" field.
func (m *HealthScoreSnapshotMutation) ResetSecurityScore() {
	m.security_score = nil
	m.addsecurity_score = nil
}

// SetLifecycleScore sets the "lifecycle_score" field.
func (m *HealthScoreSnapshotMutation) SetLifecycleScore(f float64) {
	m.lifecycle_score = &f
	m.addlifecycle_score = nil
}

// LifecycleScore returns the value of the "lifecycle_score" field in the mutation.
func (m *HealthScoreSnapshotMutation) LifecycleScore() (r float64, exists bool) {
	v := m.lifecycle_score
	if v == nil {
		return
	}
	return *v, true
}

// OldLifecycleScore returns the old "lifecycle_score" field's value of the HealthScoreSnapshot entity.
// If the HealthScoreSnapshot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HealthScoreSnapshotMutation) OldLifecycleScore(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLifecycleScore is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLifecycleScore requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLifecycleScore: %w", err)
	}
	return oldValue.LifecycleScore, nil
}

// AddLifecycleScore adds f to the "lifecycle_score" field.
func (m *HealthScoreSnapshotMutation) AddLifecycleScore(f float64) {
	if m.addlifecycle_score != nil {
		*m.addlifecycle_score += f
	} else {
		m.addlifecycle_score = &f
	}
}

// AddedLifecycleScore returns the value that was added to the "lifecycle_score" field in this mutation.
func (m *HealthScoreSnapshotMutation) AddedLifecycleScore() (r float64, exists bool) {
	v := m.addlifecycle_score
	if v == nil {
		return
	}
	return *v, true
}

// ResetLifecycleScore resets all changes to the "lifecycle_score" field.
func (m *HealthScoreSnapshotMutation) ResetLifecycleScore() {
	m.lifecycle_score = nil
	m.addlifecycle_score = nil
}

// SetMetadata sets the "metadata" field.
func (m *HealthScoreSnapshotMutation) SetMetadata(value map[string]interface{}) {
	m.metadata = &value
}

// Metadata returns the value of the "metadata" field in the mutation.
func (m *HealthScoreSnapshotMutation) Metadata() (r map[string]interface{}, exists bool) {
	v := m.metadata
	if v == nil {
		return
	}
	return *v, true
}

// OldMetadata returns the old "metadata" field's value of the HealthScoreSnapshot entity.
// If the HealthScoreSnapshot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HealthScoreSnapshotMutation) OldMetadata(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMetadata is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMetadata requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetadata: %w", err)
	}
	return oldValue.Metadata, nil
}

// ClearMetadata clears the value of the "metadata" field.
func (m *HealthScoreSnapshotMutation) ClearMetadata() {
	m.metadata = nil
	m.clearedFields[healthscoresnapshot.FieldMetadata] = struct{}{}
}

// MetadataCleared returns if the "metadata" field was cleared in this mutation.
func (m *HealthScoreSnapshotMutation) MetadataCleared() bool {
	_, ok := m.clearedFields[healthscoresnapshot.FieldMetadata]
	return ok
}

// ResetMetadata resets all changes to the "metadata" field.
func (m *HealthScoreSnapshotMutation) ResetMetadata() {
	m.metadata = nil
	delete(m.clearedFields, healthscoresnapshot.FieldMetadata)
}

// SetTimestamp sets the "timestamp" field.
func (m *HealthScoreSnapshotMutation) SetTimestamp(t time.Time) {
	m.timestamp = &t
}

// Timestamp returns the value of the "timestamp" field in the mutation.
func (m *HealthScoreSnapshotMutation) Timestamp() (r time.Time, exists bool) {
	v := m.timestamp
	if v == nil {
		return
	}
	return *v, true
}

// OldTimestamp returns the old "timestamp" field's value of the HealthScoreSnapshot entity.
// If the HealthScoreSnapshot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HealthScoreSnapshotMutation) OldTimestamp(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTimestamp is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTimestamp requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTimestamp: %w", err)
	}
	return oldValue.Timestamp, nil
}

// ResetTimestamp resets all changes to the "timestamp" field.
func (m *HealthScoreSnapshotMutation) ResetTimestamp() {
	m.timestamp = nil
}

// SetTenantID sets the "tenant" edge to the Tenant entity by id.
func (m *HealthScoreSnapshotMutation) SetTenantID(id int) {
	m.tenant = &id
}

// ClearTenant clears the "tenant" edge to the Tenant entity.
func (m *HealthScoreSnapshotMutation) ClearTenant() {
	m.clearedtenant = true
}

// TenantCleared reports if the "tenant" edge to the Tenant entity was cleared.
func (m *HealthScoreSnapshotMutation) TenantCleared() bool {
	return m.clearedtenant
}

// TenantID returns the "tenant" edge ID in the mutation.
func (m *HealthScoreSnapshotMutation) TenantID() (id int, exists bool) {
	if m.tenant != nil {
		return *m.tenant, true
	}
	return
}

// TenantIDs returns the "tenant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TenantID instead. It exists only for internal usage by the builders.
func (m *HealthScoreSnapshotMutation) TenantIDs() (ids []int) {
	if id := m.tenant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTenant resets all changes to the "tenant" edge.
func (m *HealthScoreSnapshotMutation) ResetTenant() {
	m.tenant = nil
	m.clearedtenant = false
}

// Where appends a list predicates to the HealthScoreSnapshotMutation builder.
func (m *HealthScoreSnapshotMutation) Where(ps ...predicate.HealthScoreSnapshot) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the HealthScoreSnapshotMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *HealthScoreSnapshotMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.HealthScoreSnapshot, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *HealthScoreSnapshotMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *HealthScoreSnapshotMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (HealthScoreSnapshot).
func (m *HealthScoreSnapshotMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *HealthScoreSnapshotMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.overall_score != nil {
		fields = append(fields, healthscoresnapshot.FieldOverallScore)
	}
	if m.performance_score != nil {
		fields = append(fields, healthscoresnapshot.FieldPerformanceScore)
	}
	if m.security_score != nil {
		fields = append(fields, healthscoresnapshot.FieldSecurityScore)
	}
	if m.lifecycle_score != nil {
		fields = append(fields, healthscoresnapshot.FieldLifecycleScore)
	}
	if m.metadata != nil {
		fields = append(fields, healthscoresnapshot.FieldMetadata)
	}
	if m.timestamp != nil {
		fields = append(fields, healthscoresnapshot.FieldTimestamp)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *HealthScoreSnapshotMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case healthscoresnapshot.FieldOverallScore:
		return m.OverallScore()
	case healthscoresnapshot.FieldPerformanceScore:
		return m.PerformanceScore()
	case healthscoresnapshot.FieldSecurityScore:
		return m.SecurityScore()
	case healthscoresnapshot.FieldLifecycleScore:
		return m.LifecycleScore()
	case healthscoresnapshot.FieldMetadata:
		return m.Metadata()
	case healthscoresnapshot.FieldTimestamp:
		return m.Timestamp()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *HealthScoreSnapshotMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case healthscoresnapshot.FieldOverallScore:
		return m.OldOverallScore(ctx)
	case healthscoresnapshot.FieldPerformanceScore:
		return m.OldPerformanceScore(ctx)
	case healthscoresnapshot.FieldSecurityScore:
		return m.OldSecurityScore(ctx)
	case healthscoresnapshot.FieldLifecycleScore:
		return m.OldLifecycleScore(ctx)
	case healthscoresnapshot.FieldMetadata:
		return m.OldMetadata(ctx)
	case healthscoresnapshot.FieldTimestamp:
		return m.OldTimestamp(ctx)
	}
	return nil, fmt.Errorf("unknown HealthScoreSnapshot field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *HealthScoreSnapshotMutation) SetField(name string, value ent.Value) error {
	switch name {
	case healthscoresnapshot.FieldOverallScore:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOverallScore(v)
		return nil
	case healthscoresnapshot.FieldPerformanceScore:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPerformanceScore(v)
		return nil
	case healthscoresnapshot.FieldSecurityScore:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSecurityScore(v)
		return nil
	case healthscoresnapshot.FieldLifecycleScore:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLifecycleScore(v)
		return nil
	case healthscoresnapshot.FieldMetadata:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetadata(v)
		return nil
	case healthscoresnapshot.FieldTimestamp:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTimestamp(v)
		return nil
	}
	return fmt.Errorf("unknown HealthScoreSnapshot field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *HealthScoreSnapshotMutation) AddedFields() []string {
	var fields []string
	if m.addoverall_score != nil {
		fields = append(fields, healthscoresnapshot.FieldOverallScore)
	}
	if m.addperformance_score != nil {
		fields = append(fields, healthscoresnapshot.FieldPerformanceScore)
	}
	if m.addsecurity_score != nil {
		fields = append(fields, healthscoresnapshot.FieldSecurityScore)
	}
	if m.addlifecycle_score != nil {
		fields = append(fields, healthscoresnapshot.FieldLifecycleScore)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *HealthScoreSnapshotMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case healthscoresnapshot.FieldOverallScore:
		return m.AddedOverallScore()
	case healthscoresnapshot.FieldPerformanceScore:
		return m.AddedPerformanceScore()
	case healthscoresnapshot.FieldSecurityScore:
		return m.AddedSecurityScore()
	case healthscoresnapshot.FieldLifecycleScore:
		return m.AddedLifecycleScore()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *HealthScoreSnapshotMutation) AddField(name string, value ent.Value) error {
	switch name {
	case healthscoresnapshot.FieldOverallScore:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOverallScore(v)
		return nil
	case healthscoresnapshot.FieldPerformanceScore:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPerformanceScore(v)
		return nil
	case healthscoresnapshot.FieldSecurityScore:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSecurityScore(v)
		return nil
	case healthscoresnapshot.FieldLifecycleScore:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLifecycleScore(v)
		return nil
	}
	return fmt.Errorf("unknown HealthScoreSnapshot numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *HealthScoreSnapshotMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(healthscoresnapshot.FieldMetadata) {
		fields = append(fields, healthscoresnapshot.FieldMetadata)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *HealthScoreSnapshotMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *HealthScoreSnapshotMutation) ClearField(name string) error {
	switch name {
	case healthscoresnapshot.FieldMetadata:
		m.ClearMetadata()
		return nil
	}
	return fmt.Errorf("unknown HealthScoreSnapshot nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *HealthScoreSnapshotMutation) ResetField(name string) error {
	switch name {
	case healthscoresnapshot.FieldOverallScore:
		m.ResetOverallScore()
		return nil
	case healthscoresnapshot.FieldPerformanceScore:
		m.ResetPerformanceScore()
		return nil
	case healthscoresnapshot.FieldSecurityScore:
		m.ResetSecurityScore()
		return nil
	case healthscoresnapshot.FieldLifecycleScore:
		m.ResetLifecycleScore()
		return nil
	case healthscoresnapshot.FieldMetadata:
		m.ResetMetadata()
		return nil
	case healthscoresnapshot.FieldTimestamp:
		m.ResetTimestamp()
		return nil
	}
	return fmt.Errorf("unknown HealthScoreSnapshot field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *HealthScoreSnapshotMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.tenant != nil {
		edges = append(edges, healthscoresnapshot.EdgeTenant)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *HealthScoreSnapshotMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case healthscoresnapshot.EdgeTenant:
		if id := m.tenant; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *HealthScoreSnapshotMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *HealthScoreSnapshotMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *HealthScoreSnapshotMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedtenant {
		edges = append(edges, healthscoresnapshot.EdgeTenant)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *HealthScoreSnapshotMutation) EdgeCleared(name string) bool {
	switch name {
	case healthscoresnapshot.EdgeTenant:
		return m.clearedtenant
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *HealthScoreSnapshotMutation) ClearEdge(name string) error {
	switch name {
	case healthscoresnapshot.EdgeTenant:
		m.ClearTenant()
		return nil
	}
	return fmt.Errorf("unknown HealthScoreSnapshot unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *HealthScoreSnapshotMutation) ResetEdge(name string) error {
	switch name {
	case healthscoresnapshot.EdgeTenant:
		m.ResetTenant()
		return nil
	}
	return fmt.Errorf("unknown HealthScoreSnapshot edge %s", name)
}

// IVRFlowMutation represents an operation that mutates the IVRFlow nodes in the graph.
type IVRFlowMutation struct {
	config
	op            Op
	typ           string
	id            *int
	name          *string
	nodes         *map[string]interface{}
	flow_edges    *map[string]interface{}
	is_active     *bool
	version       *int
	addversion    *int
	created_at    *time.Time
	updated_at    *time.Time
	clearedFields map[string]struct{}
	tenant        *int
	clearedtenant bool
	done          bool
	oldValue      func(context.Context) (*IVRFlow, error)
	predicates    []predicate.IVRFlow
}

var _ ent.Mutation = (*IVRFlowMutation)(nil)

// ivrflowOption allows management of the mutation configuration using functional options.
type ivrflowOption func(*IVRFlowMutation)

// newIVRFlowMutation creates new mutation for the IVRFlow entity.
func newIVRFlowMutation(c config, op Op, opts ...ivrflowOption) *IVRFlowMutation {
	m := &IVRFlowMutation{
		config:        c,
		op:            op,
		typ:           TypeIVRFlow,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withIVRFlowID sets the ID field of the mutation.
func withIVRFlowID(id int) ivrflowOption {
	return func(m *IVRFlowMutation) {
		var (
			err   error
			once  sync.Once
			value *IVRFlow
		)
		m.oldValue = func(ctx context.Context) (*IVRFlow, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().IVRFlow.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withIVRFlow sets the old IVRFlow of the mutation.
func withIVRFlow(node *IVRFlow) ivrflowOption {
	return func(m *IVRFlowMutation) {
		m.oldValue = func(context.Context) (*IVRFlow, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m IVRFlowMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m IVRFlowMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *IVRFlowMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *IVRFlowMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().IVRFlow.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *IVRFlowMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *IVRFlowMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the IVRFlow entity.
// If the IVRFlow object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IVRFlowMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *IVRFlowMutation) ResetName() {
	m.name = nil
}

// SetNodes sets the "nodes" field.
func (m *IVRFlowMutation) SetNodes(value map[string]interface{}) {
	m.nodes = &value
}

// Nodes returns the value of the "nodes" field in the mutation.
func (m *IVRFlowMutation) Nodes() (r map[string]interface{}, exists bool) {
	v := m.nodes
	if v == nil {
		return
	}
	return *v, true
}

// OldNodes returns the old "nodes" field's value of the IVRFlow entity.
// If the IVRFlow object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IVRFlowMutation) OldNodes(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNodes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNodes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNodes: %w", err)
	}
	return oldValue.Nodes, nil
}

// ResetNodes resets all changes to the "nodes" field.
func (m *IVRFlowMutation) ResetNodes() {
	m.nodes = nil
}

// SetFlowEdges sets the "flow_edges" field.
func (m *IVRFlowMutation) SetFlowEdges(value map[string]interface{}) {
	m.flow_edges = &value
}

// FlowEdges returns the value of the "flow_edges" field in the mutation.
func (m *IVRFlowMutation) FlowEdges() (r map[string]interface{}, exists bool) {
	v := m.flow_edges
	if v == nil {
		return
	}
	return *v, true
}

// OldFlowEdges returns the old "flow_edges" field's value of the IVRFlow entity.
// If the IVRFlow object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IVRFlowMutation) OldFlowEdges(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFlowEdges is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFlowEdges requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFlowEdges: %w", err)
	}
	return oldValue.FlowEdges, nil
}

// ResetFlowEdges resets all changes to the "flow_edges" field.
func (m *IVRFlowMutation) ResetFlowEdges() {
	m.flow_edges = nil
}

// SetIsActive sets the "is_active" field.
func (m *IVRFlowMutation) SetIsActive(b bool) {
	m.is_active = &b
}

// IsActive returns the value of the "is_active" field in the mutation.
func (m *IVRFlowMutation) IsActive() (r bool, exists bool) {
	v := m.is_active
	if v == nil {
		return
	}
	return *v, true
}

// OldIsActive returns the old "is_active" field's value of the IVRFlow entity.
// If the IVRFlow object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IVRFlowMutation) OldIsActive(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsActive is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsActive requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsActive: %w", err)
	}
	return oldValue.IsActive, nil
}

// ResetIsActive resets all changes to the "is_active" field.
func (m *IVRFlowMutation) ResetIsActive() {
	m.is_active = nil
}

// SetVersion sets the "version" field.
func (m *IVRFlowMutation) SetVersion(i int) {
	m.version = &i
	m.addversion = nil
}

// Version returns the value of the "version" field in the mutation.
func (m *IVRFlowMutation) Version() (r int, exists bool) {
	v := m.version
	if v == nil {
		return
	}
	return *v, true
}

// OldVersion returns the old "version" field's value of the IVRFlow entity.
// If the IVRFlow object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IVRFlowMutation) OldVersion(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVersion: %w", err)
	}
	return oldValue.Version, nil
}

// AddVersion adds i to the "version" field.
func (m *IVRFlowMutation) AddVersion(i int) {
	if m.addversion != nil {
		*m.addversion += i
	} else {
		m.addversion = &i
	}
}

// AddedVersion returns the value that was added to the "version" field in this mutation.
func (m *IVRFlowMutation) AddedVersion() (r int, exists bool) {
	v := m.addversion
	if v == nil {
		return
	}
	return *v, true
}

// ResetVersion resets all changes to the "version" field.
func (m *IVRFlowMutation) ResetVersion() {
	m.version = nil
	m.addversion = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *IVRFlowMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *IVRFlowMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the IVRFlow entity.
// If the IVRFlow object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IVRFlowMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *IVRFlowMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *IVRFlowMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *IVRFlowMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the IVRFlow entity.
// If the IVRFlow object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IVRFlowMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *IVRFlowMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetTenantID sets the "tenant" edge to the Tenant entity by id.
func (m *IVRFlowMutation) SetTenantID(id int) {
	m.tenant = &id
}

// ClearTenant clears the "tenant" edge to the Tenant entity.
func (m *IVRFlowMutation) ClearTenant() {
	m.clearedtenant = true
}

// TenantCleared reports if the "tenant" edge to the Tenant entity was cleared.
func (m *IVRFlowMutation) TenantCleared() bool {
	return m.clearedtenant
}

// TenantID returns the "tenant" edge ID in the mutation.
func (m *IVRFlowMutation) TenantID() (id int, exists bool) {
	if m.tenant != nil {
		return *m.tenant, true
	}
	return
}

// TenantIDs returns the "tenant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TenantID instead. It exists only for internal usage by the builders.
func (m *IVRFlowMutation) TenantIDs() (ids []int) {
	if id := m.tenant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTenant resets all changes to the "tenant" edge.
func (m *IVRFlowMutation) ResetTenant() {
	m.tenant = nil
	m.clearedtenant = false
}

// Where appends a list predicates to the IVRFlowMutation builder.
func (m *IVRFlowMutation) Where(ps ...predicate.IVRFlow) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the IVRFlowMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *IVRFlowMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.IVRFlow, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *IVRFlowMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *IVRFlowMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (IVRFlow).
func (m *IVRFlowMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *IVRFlowMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.name != nil {
		fields = append(fields, ivrflow.FieldName)
	}
	if m.nodes != nil {
		fields = append(fields, ivrflow.FieldNodes)
	}
	if m.flow_edges != nil {
		fields = append(fields, ivrflow.FieldFlowEdges)
	}
	if m.is_active != nil {
		fields = append(fields, ivrflow.FieldIsActive)
	}
	if m.version != nil {
		fields = append(fields, ivrflow.FieldVersion)
	}
	if m.created_at != nil {
		fields = append(fields, ivrflow.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, ivrflow.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *IVRFlowMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case ivrflow.FieldName:
		return m.Name()
	case ivrflow.FieldNodes:
		return m.Nodes()
	case ivrflow.FieldFlowEdges:
		return m.FlowEdges()
	case ivrflow.FieldIsActive:
		return m.IsActive()
	case ivrflow.FieldVersion:
		return m.Version()
	case ivrflow.FieldCreatedAt:
		return m.CreatedAt()
	case ivrflow.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *IVRFlowMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case ivrflow.FieldName:
		return m.OldName(ctx)
	case ivrflow.FieldNodes:
		return m.OldNodes(ctx)
	case ivrflow.FieldFlowEdges:
		return m.OldFlowEdges(ctx)
	case ivrflow.FieldIsActive:
		return m.OldIsActive(ctx)
	case ivrflow.FieldVersion:
		return m.OldVersion(ctx)
	case ivrflow.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case ivrflow.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown IVRFlow field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *IVRFlowMutation) SetField(name string, value ent.Value) error {
	switch name {
	case ivrflow.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case ivrflow.FieldNodes:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNodes(v)
		return nil
	case ivrflow.FieldFlowEdges:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFlowEdges(v)
		return nil
	case ivrflow.FieldIsActive:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsActive(v)
		return nil
	case ivrflow.FieldVersion:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVersion(v)
		return nil
	case ivrflow.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case ivrflow.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown IVRFlow field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *IVRFlowMutation) AddedFields() []string {
	var fields []string
	if m.addversion != nil {
		fields = append(fields, ivrflow.FieldVersion)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *IVRFlowMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case ivrflow.FieldVersion:
		return m.AddedVersion()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *IVRFlowMutation) AddField(name string, value ent.Value) error {
	switch name {
	case ivrflow.FieldVersion:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddVersion(v)
		return nil
	}
	return fmt.Errorf("unknown IVRFlow numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *IVRFlowMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *IVRFlowMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *IVRFlowMutation) ClearField(name string) error {
	return fmt.Errorf("unknown IVRFlow nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *IVRFlowMutation) ResetField(name string) error {
	switch name {
	case ivrflow.FieldName:
		m.ResetName()
		return nil
	case ivrflow.FieldNodes:
		m.ResetNodes()
		return nil
	case ivrflow.FieldFlowEdges:
		m.ResetFlowEdges()
		return nil
	case ivrflow.FieldIsActive:
		m.ResetIsActive()
		return nil
	case ivrflow.FieldVersion:
		m.ResetVersion()
		return nil
	case ivrflow.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case ivrflow.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown IVRFlow field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *IVRFlowMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.tenant != nil {
		edges = append(edges, ivrflow.EdgeTenant)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *IVRFlowMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case ivrflow.EdgeTenant:
		if id := m.tenant; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *IVRFlowMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *IVRFlowMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *IVRFlowMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedtenant {
		edges = append(edges, ivrflow.EdgeTenant)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *IVRFlowMutation) EdgeCleared(name string) bool {
	switch name {
	case ivrflow.EdgeTenant:
		return m.clearedtenant
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *IVRFlowMutation) ClearEdge(name string) error {
	switch name {
	case ivrflow.EdgeTenant:
		m.ClearTenant()
		return nil
	}
	return fmt.Errorf("unknown IVRFlow unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *IVRFlowMutation) ResetEdge(name string) error {
	switch name {
	case ivrflow.EdgeTenant:
		m.ResetTenant()
		return nil
	}
	return fmt.Errorf("unknown IVRFlow edge %s", name)
}

// InterviewMutation represents an operation that mutates the Interview nodes in the graph.
type InterviewMutation struct {
	config
	op                  Op
	typ                 string
	id                  *int
	scheduled_at        *time.Time
	_type               *interview.Type
	status              *interview.Status
	feedback            *string
	created_at          *time.Time
	updated_at          *time.Time
	clearedFields       map[string]struct{}
	tenant              *int
	clearedtenant       bool
	application         *int
	clearedapplication  bool
	interviewers        map[int]struct{}
	removedinterviewers map[int]struct{}
	clearedinterviewers bool
	done                bool
	oldValue            func(context.Context) (*Interview, error)
	predicates          []predicate.Interview
}

var _ ent.Mutation = (*InterviewMutation)(nil)

// interviewOption allows management of the mutation configuration using functional options.
type interviewOption func(*InterviewMutation)

// newInterviewMutation creates new mutation for the Interview entity.
func newInterviewMutation(c config, op Op, opts ...interviewOption) *InterviewMutation {
	m := &InterviewMutation{
		config:        c,
		op:            op,
		typ:           TypeInterview,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withInterviewID sets the ID field of the mutation.
func withInterviewID(id int) interviewOption {
	return func(m *InterviewMutation) {
		var (
			err   error
			once  sync.Once
			value *Interview
		)
		m.oldValue = func(ctx context.Context) (*Interview, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Interview.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withInterview sets the old Interview of the mutation.
func withInterview(node *Interview) interviewOption {
	return func(m *InterviewMutation) {
		m.oldValue = func(context.Context) (*Interview, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m InterviewMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m InterviewMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *InterviewMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *InterviewMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Interview.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetScheduledAt sets the "scheduled_at" field.
func (m *InterviewMutation) SetScheduledAt(t time.Time) {
	m.scheduled_at = &t
}

// ScheduledAt returns the value of the "scheduled_at" field in the mutation.
func (m *InterviewMutation) ScheduledAt() (r time.Time, exists bool) {
	v := m.scheduled_at
	if v == nil {
		return
	}
	return *v, true
}

// OldScheduledAt returns the old "scheduled_at" field's value of the Interview entity.
// If the Interview object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InterviewMutation) OldScheduledAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldScheduledAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldScheduledAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldScheduledAt: %w", err)
	}
	return oldValue.ScheduledAt, nil
}

// ResetScheduledAt resets all changes to the "scheduled_at" field.
func (m *InterviewMutation) ResetScheduledAt() {
	m.scheduled_at = nil
}

// SetType sets the "type" field.
func (m *InterviewMutation) SetType(i interview.Type) {
	m._type = &i
}

// GetType returns the value of the "type" field in the mutation.
func (m *InterviewMutation) GetType() (r interview.Type, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Interview entity.
// If the Interview object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InterviewMutation) OldType(ctx context.Context) (v interview.Type, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *InterviewMutation) ResetType() {
	m._type = nil
}

// SetStatus sets the "status" field.
func (m *InterviewMutation) SetStatus(i interview.Status) {
	m.status = &i
}

// Status returns the value of the "status" field in the mutation.
func (m *InterviewMutation) Status() (r interview.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Interview entity.
// If the Interview object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InterviewMutation) OldStatus(ctx context.Context) (v interview.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *InterviewMutation) ResetStatus() {
	m.status = nil
}

// SetFeedback sets the "feedback" field.
func (m *InterviewMutation) SetFeedback(s string) {
	m.feedback = &s
}

// Feedback returns the value of the "feedback" field in the mutation.
func (m *InterviewMutation) Feedback() (r string, exists bool) {
	v := m.feedback
	if v == nil {
		return
	}
	return *v, true
}

// OldFeedback returns the old "feedback" field's value of the Interview entity.
// If the Interview object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InterviewMutation) OldFeedback(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFeedback is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFeedback requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFeedback: %w", err)
	}
	return oldValue.Feedback, nil
}

// ClearFeedback clears the value of the "feedback" field.
func (m *InterviewMutation) ClearFeedback() {
	m.feedback = nil
	m.clearedFields[interview.FieldFeedback] = struct{}{}
}

// FeedbackCleared returns if the "feedback" field was cleared in this mutation.
func (m *InterviewMutation) FeedbackCleared() bool {
	_, ok := m.clearedFields[interview.FieldFeedback]
	return ok
}

// ResetFeedback resets all changes to the "feedback" field.
func (m *InterviewMutation) ResetFeedback() {
	m.feedback = nil
	delete(m.clearedFields, interview.FieldFeedback)
}

// SetCreatedAt sets the "created_at" field.
func (m *InterviewMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *InterviewMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Interview entity.
// If the Interview object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InterviewMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *InterviewMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *InterviewMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *InterviewMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Interview entity.
// If the Interview object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InterviewMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *InterviewMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetTenantID sets the "tenant" edge to the Tenant entity by id.
func (m *InterviewMutation) SetTenantID(id int) {
	m.tenant = &id
}

// ClearTenant clears the "tenant" edge to the Tenant entity.
func (m *InterviewMutation) ClearTenant() {
	m.clearedtenant = true
}

// TenantCleared reports if the "tenant" edge to the Tenant entity was cleared.
func (m *InterviewMutation) TenantCleared() bool {
	return m.clearedtenant
}

// TenantID returns the "tenant" edge ID in the mutation.
func (m *InterviewMutation) TenantID() (id int, exists bool) {
	if m.tenant != nil {
		return *m.tenant, true
	}
	return
}

// TenantIDs returns the "tenant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TenantID instead. It exists only for internal usage by the builders.
func (m *InterviewMutation) TenantIDs() (ids []int) {
	if id := m.tenant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTenant resets all changes to the "tenant" edge.
func (m *InterviewMutation) ResetTenant() {
	m.tenant = nil
	m.clearedtenant = false
}

// SetApplicationID sets the "application" edge to the Application entity by id.
func (m *InterviewMutation) SetApplicationID(id int) {
	m.application = &id
}

// ClearApplication clears the "application" edge to the Application entity.
func (m *InterviewMutation) ClearApplication() {
	m.clearedapplication = true
}

// ApplicationCleared reports if the "application" edge to the Application entity was cleared.
func (m *InterviewMutation) ApplicationCleared() bool {
	return m.clearedapplication
}

// ApplicationID returns the "application" edge ID in the mutation.
func (m *InterviewMutation) ApplicationID() (id int, exists bool) {
	if m.application != nil {
		return *m.application, true
	}
	return
}

// ApplicationIDs returns the "application" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ApplicationID instead. It exists only for internal usage by the builders.
func (m *InterviewMutation) ApplicationIDs() (ids []int) {
	if id := m.application; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetApplication resets all changes to the "application" edge.
func (m *InterviewMutation) ResetApplication() {
	m.application = nil
	m.clearedapplication = false
}

// AddInterviewerIDs adds the "interviewers" edge to the Employee entity by ids.
func (m *InterviewMutation) AddInterviewerIDs(ids ...int) {
	if m.interviewers == nil {
		m.interviewers = make(map[int]struct{})
	}
	for i := range ids {
		m.interviewers[ids[i]] = struct{}{}
	}
}

// ClearInterviewers clears the "interviewers" edge to the Employee entity.
func (m *InterviewMutation) ClearInterviewers() {
	m.clearedinterviewers = true
}

// InterviewersCleared reports if the "interviewers" edge to the Employee entity was cleared.
func (m *InterviewMutation) InterviewersCleared() bool {
	return m.clearedinterviewers
}

// RemoveInterviewerIDs removes the "interviewers" edge to the Employee entity by IDs.
func (m *InterviewMutation) RemoveInterviewerIDs(ids ...int) {
	if m.removedinterviewers == nil {
		m.removedinterviewers = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.interviewers, ids[i])
		m.removedinterviewers[ids[i]] = struct{}{}
	}
}

// RemovedInterviewers returns the removed IDs of the "interviewers" edge to the Employee entity.
func (m *InterviewMutation) RemovedInterviewersIDs() (ids []int) {
	for id := range m.removedinterviewers {
		ids = append(ids, id)
	}
	return
}

// InterviewersIDs returns the "interviewers" edge IDs in the mutation.
func (m *InterviewMutation) InterviewersIDs() (ids []int) {
	for id := range m.interviewers {
		ids = append(ids, id)
	}
	return
}

// ResetInterviewers resets all changes to the "interviewers" edge.
func (m *InterviewMutation) ResetInterviewers() {
	m.interviewers = nil
	m.clearedinterviewers = false
	m.removedinterviewers = nil
}

// Where appends a list predicates to the InterviewMutation builder.
func (m *InterviewMutation) Where(ps ...predicate.Interview) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the InterviewMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *InterviewMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Interview, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *InterviewMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *InterviewMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Interview).
func (m *InterviewMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *InterviewMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.scheduled_at != nil {
		fields = append(fields, interview.FieldScheduledAt)
	}
	if m._type != nil {
		fields = append(fields, interview.FieldType)
	}
	if m.status != nil {
		fields = append(fields, interview.FieldStatus)
	}
	if m.feedback != nil {
		fields = append(fields, interview.FieldFeedback)
	}
	if m.created_at != nil {
		fields = append(fields, interview.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, interview.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *InterviewMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case interview.FieldScheduledAt:
		return m.ScheduledAt()
	case interview.FieldType:
		return m.GetType()
	case interview.FieldStatus:
		return m.Status()
	case interview.FieldFeedback:
		return m.Feedback()
	case interview.FieldCreatedAt:
		return m.CreatedAt()
	case interview.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *InterviewMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case interview.FieldScheduledAt:
		return m.OldScheduledAt(ctx)
	case interview.FieldType:
		return m.OldType(ctx)
	case interview.FieldStatus:
		return m.OldStatus(ctx)
	case interview.FieldFeedback:
		return m.OldFeedback(ctx)
	case interview.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case interview.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Interview field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *InterviewMutation) SetField(name string, value ent.Value) error {
	switch name {
	case interview.FieldScheduledAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetScheduledAt(v)
		return nil
	case interview.FieldType:
		v, ok := value.(interview.Type)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case interview.FieldStatus:
		v, ok := value.(interview.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case interview.FieldFeedback:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFeedback(v)
		return nil
	case interview.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case interview.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Interview field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *InterviewMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *InterviewMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *InterviewMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Interview numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *InterviewMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(interview.FieldFeedback) {
		fields = append(fields, interview.FieldFeedback)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *InterviewMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *InterviewMutation) ClearField(name string) error {
	switch name {
	case interview.FieldFeedback:
		m.ClearFeedback()
		return nil
	}
	return fmt.Errorf("unknown Interview nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *InterviewMutation) ResetField(name string) error {
	switch name {
	case interview.FieldScheduledAt:
		m.ResetScheduledAt()
		return nil
	case interview.FieldType:
		m.ResetType()
		return nil
	case interview.FieldStatus:
		m.ResetStatus()
		return nil
	case interview.FieldFeedback:
		m.ResetFeedback()
		return nil
	case interview.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case interview.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Interview field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *InterviewMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.tenant != nil {
		edges = append(edges, interview.EdgeTenant)
	}
	if m.application != nil {
		edges = append(edges, interview.EdgeApplication)
	}
	if m.interviewers != nil {
		edges = append(edges, interview.EdgeInterviewers)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *InterviewMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case interview.EdgeTenant:
		if id := m.tenant; id != nil {
			return []ent.Value{*id}
		}
	case interview.EdgeApplication:
		if id := m.application; id != nil {
			return []ent.Value{*id}
		}
	case interview.EdgeInterviewers:
		ids := make([]ent.Value, 0, len(m.interviewers))
		for id := range m.interviewers {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *InterviewMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedinterviewers != nil {
		edges = append(edges, interview.EdgeInterviewers)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *InterviewMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case interview.EdgeInterviewers:
		ids := make([]ent.Value, 0, len(m.removedinterviewers))
		for id := range m.removedinterviewers {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *InterviewMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedtenant {
		edges = append(edges, interview.EdgeTenant)
	}
	if m.clearedapplication {
		edges = append(edges, interview.EdgeApplication)
	}
	if m.clearedinterviewers {
		edges = append(edges, interview.EdgeInterviewers)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *InterviewMutation) EdgeCleared(name string) bool {
	switch name {
	case interview.EdgeTenant:
		return m.clearedtenant
	case interview.EdgeApplication:
		return m.clearedapplication
	case interview.EdgeInterviewers:
		return m.clearedinterviewers
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *InterviewMutation) ClearEdge(name string) error {
	switch name {
	case interview.EdgeTenant:
		m.ClearTenant()
		return nil
	case interview.EdgeApplication:
		m.ClearApplication()
		return nil
	}
	return fmt.Errorf("unknown Interview unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *InterviewMutation) ResetEdge(name string) error {
	switch name {
	case interview.EdgeTenant:
		m.ResetTenant()
		return nil
	case interview.EdgeApplication:
		m.ResetApplication()
		return nil
	case interview.EdgeInterviewers:
		m.ResetInterviewers()
		return nil
	}
	return fmt.Errorf("unknown Interview edge %s", name)
}

// InventoryCountMutation represents an operation that mutates the InventoryCount nodes in the graph.
type InventoryCountMutation struct {
	config
	op             Op
	typ            string
	id             *int
	counted_qty    *decimal.Decimal
	system_qty     *decimal.Decimal
	variance       *decimal.Decimal
	counted_at     *time.Time
	counted_by     *string
	notes          *string
	clearedFields  map[string]struct{}
	tenant         *int
	clearedtenant  bool
	product        *int
	clearedproduct bool
	done           bool
	oldValue       func(context.Context) (*InventoryCount, error)
	predicates     []predicate.InventoryCount
}

var _ ent.Mutation = (*InventoryCountMutation)(nil)

// inventorycountOption allows management of the mutation configuration using functional options.
type inventorycountOption func(*InventoryCountMutation)

// newInventoryCountMutation creates new mutation for the InventoryCount entity.
func newInventoryCountMutation(c config, op Op, opts ...inventorycountOption) *InventoryCountMutation {
	m := &InventoryCountMutation{
		config:        c,
		op:            op,
		typ:           TypeInventoryCount,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withInventoryCountID sets the ID field of the mutation.
func withInventoryCountID(id int) inventorycountOption {
	return func(m *InventoryCountMutation) {
		var (
			err   error
			once  sync.Once
			value *InventoryCount
		)
		m.oldValue = func(ctx context.Context) (*InventoryCount, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().InventoryCount.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withInventoryCount sets the old InventoryCount of the mutation.
func withInventoryCount(node *InventoryCount) inventorycountOption {
	return func(m *InventoryCountMutation) {
		m.oldValue = func(context.Context) (*InventoryCount, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m InventoryCountMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m InventoryCountMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *InventoryCountMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *InventoryCountMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().InventoryCount.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCountedQty sets the "counted_qty" field.
func (m *InventoryCountMutation) SetCountedQty(d decimal.Decimal) {
	m.counted_qty = &d
}

// CountedQty returns the value of the "counted_qty" field in the mutation.
func (m *InventoryCountMutation) CountedQty() (r decimal.Decimal, exists bool) {
	v := m.counted_qty
	if v == nil {
		return
	}
	return *v, true
}

// OldCountedQty returns the old "counted_qty" field's value of the InventoryCount entity.
// If the InventoryCount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InventoryCountMutation) OldCountedQty(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCountedQty is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCountedQty requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCountedQty: %w", err)
	}
	return oldValue.CountedQty, nil
}

// ResetCountedQty resets all changes to the "counted_qty" field.
func (m *InventoryCountMutation) ResetCountedQty() {
	m.counted_qty = nil
}

// SetSystemQty sets the "system_qty" field.
func (m *InventoryCountMutation) SetSystemQty(d decimal.Decimal) {
	m.system_qty = &d
}

// SystemQty returns the value of the "system_qty" field in the mutation.
func (m *InventoryCountMutation) SystemQty() (r decimal.Decimal, exists bool) {
	v := m.system_qty
	if v == nil {
		return
	}
	return *v, true
}

// OldSystemQty returns the old "system_qty" field's value of the InventoryCount entity.
// If the InventoryCount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InventoryCountMutation) OldSystemQty(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSystemQty is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSystemQty requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSystemQty: %w", err)
	}
	return oldValue.SystemQty, nil
}

// ResetSystemQty resets all changes to the "system_qty" field.
func (m *InventoryCountMutation) ResetSystemQty() {
	m.system_qty = nil
}

// SetVariance sets the "variance" field.
func (m *InventoryCountMutation) SetVariance(d decimal.Decimal) {
	m.variance = &d
}

// Variance returns the value of the "variance" field in the mutation.
func (m *InventoryCountMutation) Variance() (r decimal.Decimal, exists bool) {
	v := m.variance
	if v == nil {
		return
	}
	return *v, true
}

// OldVariance returns the old "variance" field's value of the InventoryCount entity.
// If the InventoryCount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InventoryCountMutation) OldVariance(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVariance is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVariance requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVariance: %w", err)
	}
	return oldValue.Variance, nil
}

// ResetVariance resets all changes to the "variance" field.
func (m *InventoryCountMutation) ResetVariance() {
	m.variance = nil
}

// SetCountedAt sets the "counted_at" field.
func (m *InventoryCountMutation) SetCountedAt(t time.Time) {
	m.counted_at = &t
}

// CountedAt returns the value of the "counted_at" field in the mutation.
func (m *InventoryCountMutation) CountedAt() (r time.Time, exists bool) {
	v := m.counted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCountedAt returns the old "counted_at" field's value of the InventoryCount entity.
// If the InventoryCount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InventoryCountMutation) OldCountedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCountedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCountedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCountedAt: %w", err)
	}
	return oldValue.CountedAt, nil
}

// ResetCountedAt resets all changes to the "counted_at" field.
func (m *InventoryCountMutation) ResetCountedAt() {
	m.counted_at = nil
}

// SetCountedBy sets the "counted_by" field.
func (m *InventoryCountMutation) SetCountedBy(s string) {
	m.counted_by = &s
}

// CountedBy returns the value of the "counted_by" field in the mutation.
func (m *InventoryCountMutation) CountedBy() (r string, exists bool) {
	v := m.counted_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCountedBy returns the old "counted_by" field's value of the InventoryCount entity.
// If the InventoryCount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InventoryCountMutation) OldCountedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCountedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCountedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCountedBy: %w", err)
	}
	return oldValue.CountedBy, nil
}

// ClearCountedBy clears the value of the "counted_by" field.
func (m *InventoryCountMutation) ClearCountedBy() {
	m.counted_by = nil
	m.clearedFields[inventorycount.FieldCountedBy] = struct{}{}
}

// CountedByCleared returns if the "counted_by" field was cleared in this mutation.
func (m *InventoryCountMutation) CountedByCleared() bool {
	_, ok := m.clearedFields[inventorycount.FieldCountedBy]
	return ok
}

// ResetCountedBy resets all changes to the "counted_by" field.
func (m *InventoryCountMutation) ResetCountedBy() {
	m.counted_by = nil
	delete(m.clearedFields, inventorycount.FieldCountedBy)
}

// SetNotes sets the "notes" field.
func (m *InventoryCountMutation) SetNotes(s string) {
	m.notes = &s
}

// Notes returns the value of the "notes" field in the mutation.
func (m *InventoryCountMutation) Notes() (r string, exists bool) {
	v := m.notes
	if v == nil {
		return
	}
	return *v, true
}

// OldNotes returns the old "notes" field's value of the InventoryCount entity.
// If the InventoryCount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InventoryCountMutation) OldNotes(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNotes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNotes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNotes: %w", err)
	}
	return oldValue.Notes, nil
}

// ClearNotes clears the value of the "notes" field.
func (m *InventoryCountMutation) ClearNotes() {
	m.notes = nil
	m.clearedFields[inventorycount.FieldNotes] = struct{}{}
}

// NotesCleared returns if the "notes" field was cleared in this mutation.
func (m *InventoryCountMutation) NotesCleared() bool {
	_, ok := m.clearedFields[inventorycount.FieldNotes]
	return ok
}

// ResetNotes resets all changes to the "notes" field.
func (m *InventoryCountMutation) ResetNotes() {
	m.notes = nil
	delete(m.clearedFields, inventorycount.FieldNotes)
}

// SetTenantID sets the "tenant" edge to the Tenant entity by id.
func (m *InventoryCountMutation) SetTenantID(id int) {
	m.tenant = &id
}

// ClearTenant clears the "tenant" edge to the Tenant entity.
func (m *InventoryCountMutation) ClearTenant() {
	m.clearedtenant = true
}

// TenantCleared reports if the "tenant" edge to the Tenant entity was cleared.
func (m *InventoryCountMutation) TenantCleared() bool {
	return m.clearedtenant
}

// TenantID returns the "tenant" edge ID in the mutation.
func (m *InventoryCountMutation) TenantID() (id int, exists bool) {
	if m.tenant != nil {
		return *m.tenant, true
	}
	return
}

// TenantIDs returns the "tenant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TenantID instead. It exists only for internal usage by the builders.
func (m *InventoryCountMutation) TenantIDs() (ids []int) {
	if id := m.tenant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTenant resets all changes to the "tenant" edge.
func (m *InventoryCountMutation) ResetTenant() {
	m.tenant = nil
	m.clearedtenant = false
}

// SetProductID sets the "product" edge to the Product entity by id.
func (m *InventoryCountMutation) SetProductID(id int) {
	m.product = &id
}

// ClearProduct clears the "product" edge to the Product entity.
func (m *InventoryCountMutation) ClearProduct() {
	m.clearedproduct = true
}

// ProductCleared reports if the "product" edge to the Product entity was cleared.
func (m *InventoryCountMutation) ProductCleared() bool {
	return m.clearedproduct
}

// ProductID returns the "product" edge ID in the mutation.
func (m *InventoryCountMutation) ProductID() (id int, exists bool) {
	if m.product != nil {
		return *m.product, true
	}
	return
}

// ProductIDs returns the "product" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProductID instead. It exists only for internal usage by the builders.
func (m *InventoryCountMutation) ProductIDs() (ids []int) {
	if id := m.product; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProduct resets all changes to the "product" edge.
func (m *InventoryCountMutation) ResetProduct() {
	m.product = nil
	m.clearedproduct = false
}

// Where appends a list predicates to the InventoryCountMutation builder.
func (m *InventoryCountMutation) Where(ps ...predicate.InventoryCount) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the InventoryCountMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *InventoryCountMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.InventoryCount, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *InventoryCountMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *InventoryCountMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (InventoryCount).
func (m *InventoryCountMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *InventoryCountMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.counted_qty != nil {
		fields = append(fields, inventorycount.FieldCountedQty)
	}
	if m.system_qty != nil {
		fields = append(fields, inventorycount.FieldSystemQty)
	}
	if m.variance != nil {
		fields = append(fields, inventorycount.FieldVariance)
	}
	if m.counted_at != nil {
		fields = append(fields, inventorycount.FieldCountedAt)
	}
	if m.counted_by != nil {
		fields = append(fields, inventorycount.FieldCountedBy)
	}
	if m.notes != nil {
		fields = append(fields, inventorycount.FieldNotes)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *InventoryCountMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case inventorycount.FieldCountedQty:
		return m.CountedQty()
	case inventorycount.FieldSystemQty:
		return m.SystemQty()
	case inventorycount.FieldVariance:
		return m.Variance()
	case inventorycount.FieldCountedAt:
		return m.CountedAt()
	case inventorycount.FieldCountedBy:
		return m.CountedBy()
	case inventorycount.FieldNotes:
		return m.Notes()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *InventoryCountMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case inventorycount.FieldCountedQty:
		return m.OldCountedQty(ctx)
	case inventorycount.FieldSystemQty:
		return m.OldSystemQty(ctx)
	case inventorycount.FieldVariance:
		return m.OldVariance(ctx)
	case inventorycount.FieldCountedAt:
		return m.OldCountedAt(ctx)
	case inventorycount.FieldCountedBy:
		return m.OldCountedBy(ctx)
	case inventorycount.FieldNotes:
		return m.OldNotes(ctx)
	}
	return nil, fmt.Errorf("unknown InventoryCount field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *InventoryCountMutation) SetField(name string, value ent.Value) error {
	switch name {
	case inventorycount.FieldCountedQty:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCountedQty(v)
		return nil
	case inventorycount.FieldSystemQty:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSystemQty(v)
		return nil
	case inventorycount.FieldVariance:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVariance(v)
		return nil
	case inventorycount.FieldCountedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCountedAt(v)
		return nil
	case inventorycount.FieldCountedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCountedBy(v)
		return nil
	case inventorycount.FieldNotes:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNotes(v)
		return nil
	}
	return fmt.Errorf("unknown InventoryCount field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *InventoryCountMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *InventoryCountMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *InventoryCountMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown InventoryCount numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *InventoryCountMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(inventorycount.FieldCountedBy) {
		fields = append(fields, inventorycount.FieldCountedBy)
	}
	if m.FieldCleared(inventorycount.FieldNotes) {
		fields = append(fields, inventorycount.FieldNotes)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *InventoryCountMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *InventoryCountMutation) ClearField(name string) error {
	switch name {
	case inventorycount.FieldCountedBy:
		m.ClearCountedBy()
		return nil
	case inventorycount.FieldNotes:
		m.ClearNotes()
		return nil
	}
	return fmt.Errorf("unknown InventoryCount nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *InventoryCountMutation) ResetField(name string) error {
	switch name {
	case inventorycount.FieldCountedQty:
		m.ResetCountedQty()
		return nil
	case inventorycount.FieldSystemQty:
		m.ResetSystemQty()
		return nil
	case inventorycount.FieldVariance:
		m.ResetVariance()
		return nil
	case inventorycount.FieldCountedAt:
		m.ResetCountedAt()
		return nil
	case inventorycount.FieldCountedBy:
		m.ResetCountedBy()
		return nil
	case inventorycount.FieldNotes:
		m.ResetNotes()
		return nil
	}
	return fmt.Errorf("unknown InventoryCount field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *InventoryCountMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.tenant != nil {
		edges = append(edges, inventorycount.EdgeTenant)
	}
	if m.product != nil {
		edges = append(edges, inventorycount.EdgeProduct)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *InventoryCountMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case inventorycount.EdgeTenant:
		if id := m.tenant; id != nil {
			return []ent.Value{*id}
		}
	case inventorycount.EdgeProduct:
		if id := m.product; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *InventoryCountMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *InventoryCountMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *InventoryCountMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedtenant {
		edges = append(edges, inventorycount.EdgeTenant)
	}
	if m.clearedproduct {
		edges = append(edges, inventorycount.EdgeProduct)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *InventoryCountMutation) EdgeCleared(name string) bool {
	switch name {
	case inventorycount.EdgeTenant:
		return m.clearedtenant
	case inventorycount.EdgeProduct:
		return m.clearedproduct
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *InventoryCountMutation) ClearEdge(name string) error {
	switch name {
	case inventorycount.EdgeTenant:
		m.ClearTenant()
		return nil
	case inventorycount.EdgeProduct:
		m.ClearProduct()
		return nil
	}
	return fmt.Errorf("unknown InventoryCount unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *InventoryCountMutation) ResetEdge(name string) error {
	switch name {
	case inventorycount.EdgeTenant:
		m.ResetTenant()
		return nil
	case inventorycount.EdgeProduct:
		m.ResetProduct()
		return nil
	}
	return fmt.Errorf("unknown InventoryCount edge %s", name)
}

// InventoryReservationMutation represents an operation that mutates the InventoryReservation nodes in the graph.
type InventoryReservationMutation struct {
	config
	op             Op
	typ            string
	id             *int
	quantity       *decimal.Decimal
	expires_at     *time.Time
	status         *inventoryreservation.Status
	created_at     *time.Time
	clearedFields  map[string]struct{}
	product        *int
	clearedproduct bool
	tenant         *int
	clearedtenant  bool
	done           bool
	oldValue       func(context.Context) (*InventoryReservation, error)
	predicates     []predicate.InventoryReservation
}

var _ ent.Mutation = (*InventoryReservationMutation)(nil)

// inventoryreservationOption allows management of the mutation configuration using functional options.
type inventoryreservationOption func(*InventoryReservationMutation)

// newInventoryReservationMutation creates new mutation for the InventoryReservation entity.
func newInventoryReservationMutation(c config, op Op, opts ...inventoryreservationOption) *InventoryReservationMutation {
	m := &InventoryReservationMutation{
		config:        c,
		op:            op,
		typ:           TypeInventoryReservation,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withInventoryReservationID sets the ID field of the mutation.
func withInventoryReservationID(id int) inventoryreservationOption {
	return func(m *InventoryReservationMutation) {
		var (
			err   error
			once  sync.Once
			value *InventoryReservation
		)
		m.oldValue = func(ctx context.Context) (*InventoryReservation, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().InventoryReservation.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withInventoryReservation sets the old InventoryReservation of the mutation.
func withInventoryReservation(node *InventoryReservation) inventoryreservationOption {
	return func(m *InventoryReservationMutation) {
		m.oldValue = func(context.Context) (*InventoryReservation, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m InventoryReservationMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m InventoryReservationMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *InventoryReservationMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *InventoryReservationMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().InventoryReservation.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetQuantity sets the "quantity" field.
func (m *InventoryReservationMutation) SetQuantity(d decimal.Decimal) {
	m.quantity = &d
}

// Quantity returns the value of the "quantity" field in the mutation.
func (m *InventoryReservationMutation) Quantity() (r decimal.Decimal, exists bool) {
	v := m.quantity
	if v == nil {
		return
	}
	return *v, true
}

// OldQuantity returns the old "quantity" field's value of the InventoryReservation entity.
// If the InventoryReservation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InventoryReservationMutation) OldQuantity(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldQuantity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldQuantity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldQuantity: %w", err)
	}
	return oldValue.Quantity, nil
}

// ResetQuantity resets all changes to the "quantity" field.
func (m *InventoryReservationMutation) ResetQuantity() {
	m.quantity = nil
}

// SetExpiresAt sets the "expires_at" field.
func (m *InventoryReservationMutation) SetExpiresAt(t time.Time) {
	m.expires_at = &t
}

// ExpiresAt returns the value of the "expires_at" field in the mutation.
func (m *InventoryReservationMutation) ExpiresAt() (r time.Time, exists bool) {
	v := m.expires_at
	if v == nil {
		return
	}
	return *v, true
}

// OldExpiresAt returns the old "expires_at" field's value of the InventoryReservation entity.
// If the InventoryReservation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InventoryReservationMutation) OldExpiresAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpiresAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpiresAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpiresAt: %w", err)
	}
	return oldValue.ExpiresAt, nil
}

// ResetExpiresAt resets all changes to the "expires_at" field.
func (m *InventoryReservationMutation) ResetExpiresAt() {
	m.expires_at = nil
}

// SetStatus sets the "status" field.
func (m *InventoryReservationMutation) SetStatus(i inventoryreservation.Status) {
	m.status = &i
}

// Status returns the value of the "status" field in the mutation.
func (m *InventoryReservationMutation) Status() (r inventoryreservation.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the InventoryReservation entity.
// If the InventoryReservation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InventoryReservationMutation) OldStatus(ctx context.Context) (v inventoryreservation.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *InventoryReservationMutation) ResetStatus() {
	m.status = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *InventoryReservationMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *InventoryReservationMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the InventoryReservation entity.
// If the InventoryReservation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InventoryReservationMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *InventoryReservationMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetProductID sets the "product" edge to the Product entity by id.
func (m *InventoryReservationMutation) SetProductID(id int) {
	m.product = &id
}

// ClearProduct clears the "product" edge to the Product entity.
func (m *InventoryReservationMutation) ClearProduct() {
	m.clearedproduct = true
}

// ProductCleared reports if the "product" edge to the Product entity was cleared.
func (m *InventoryReservationMutation) ProductCleared() bool {
	return m.clearedproduct
}

// ProductID returns the "product" edge ID in the mutation.
func (m *InventoryReservationMutation) ProductID() (id int, exists bool) {
	if m.product != nil {
		return *m.product, true
	}
	return
}

// ProductIDs returns the "product" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProductID instead. It exists only for internal usage by the builders.
func (m *InventoryReservationMutation) ProductIDs() (ids []int) {
	if id := m.product; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProduct resets all changes to the "product" edge.
func (m *InventoryReservationMutation) ResetProduct() {
	m.product = nil
	m.clearedproduct = false
}

// SetTenantID sets the "tenant" edge to the Tenant entity by id.
func (m *InventoryReservationMutation) SetTenantID(id int) {
	m.tenant = &id
}

// ClearTenant clears the "tenant" edge to the Tenant entity.
func (m *InventoryReservationMutation) ClearTenant() {
	m.clearedtenant = true
}

// TenantCleared reports if the "tenant" edge to the Tenant entity was cleared.
func (m *InventoryReservationMutation) TenantCleared() bool {
	return m.clearedtenant
}

// TenantID returns the "tenant" edge ID in the mutation.
func (m *InventoryReservationMutation) TenantID() (id int, exists bool) {
	if m.tenant != nil {
		return *m.tenant, true
	}
	return
}

// TenantIDs returns the "tenant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TenantID instead. It exists only for internal usage by the builders.
func (m *InventoryReservationMutation) TenantIDs() (ids []int) {
	if id := m.tenant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTenant resets all changes to the "tenant" edge.
func (m *InventoryReservationMutation) ResetTenant() {
	m.tenant = nil
	m.clearedtenant = false
}

// Where appends a list predicates to the InventoryReservationMutation builder.
func (m *InventoryReservationMutation) Where(ps ...predicate.InventoryReservation) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the InventoryReservationMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *InventoryReservationMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.InventoryReservation, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *InventoryReservationMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *InventoryReservationMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (InventoryReservation).
func (m *InventoryReservationMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *InventoryReservationMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.quantity != nil {
		fields = append(fields, inventoryreservation.FieldQuantity)
	}
	if m.expires_at != nil {
		fields = append(fields, inventoryreservation.FieldExpiresAt)
	}
	if m.status != nil {
		fields = append(fields, inventoryreservation.FieldStatus)
	}
	if m.created_at != nil {
		fields = append(fields, inventoryreservation.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *InventoryReservationMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case inventoryreservation.FieldQuantity:
		return m.Quantity()
	case inventoryreservation.FieldExpiresAt:
		return m.ExpiresAt()
	case inventoryreservation.FieldStatus:
		return m.Status()
	case inventoryreservation.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *InventoryReservationMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case inventoryreservation.FieldQuantity:
		return m.OldQuantity(ctx)
	case inventoryreservation.FieldExpiresAt:
		return m.OldExpiresAt(ctx)
	case inventoryreservation.FieldStatus:
		return m.OldStatus(ctx)
	case inventoryreservation.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown InventoryReservation field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *InventoryReservationMutation) SetField(name string, value ent.Value) error {
	switch name {
	case inventoryreservation.FieldQuantity:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetQuantity(v)
		return nil
	case inventoryreservation.FieldExpiresAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpiresAt(v)
		return nil
	case inventoryreservation.FieldStatus:
		v, ok := value.(inventoryreservation.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case inventoryreservation.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown InventoryReservation field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *InventoryReservationMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *InventoryReservationMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *InventoryReservationMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown InventoryReservation numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *InventoryReservationMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *InventoryReservationMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *InventoryReservationMutation) ClearField(name string) error {
	return fmt.Errorf("unknown InventoryReservation nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *InventoryReservationMutation) ResetField(name string) error {
	switch name {
	case inventoryreservation.FieldQuantity:
		m.ResetQuantity()
		return nil
	case inventoryreservation.FieldExpiresAt:
		m.ResetExpiresAt()
		return nil
	case inventoryreservation.FieldStatus:
		m.ResetStatus()
		return nil
	case inventoryreservation.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown InventoryReservation field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *InventoryReservationMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.product != nil {
		edges = append(edges, inventoryreservation.EdgeProduct)
	}
	if m.tenant != nil {
		edges = append(edges, inventoryreservation.EdgeTenant)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *InventoryReservationMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case inventoryreservation.EdgeProduct:
		if id := m.product; id != nil {
			return []ent.Value{*id}
		}
	case inventoryreservation.EdgeTenant:
		if id := m.tenant; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *InventoryReservationMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *InventoryReservationMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *InventoryReservationMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedproduct {
		edges = append(edges, inventoryreservation.EdgeProduct)
	}
	if m.clearedtenant {
		edges = append(edges, inventoryreservation.EdgeTenant)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *InventoryReservationMutation) EdgeCleared(name string) bool {
	switch name {
	case inventoryreservation.EdgeProduct:
		return m.clearedproduct
	case inventoryreservation.EdgeTenant:
		return m.clearedtenant
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *InventoryReservationMutation) ClearEdge(name string) error {
	switch name {
	case inventoryreservation.EdgeProduct:
		m.ClearProduct()
		return nil
	case inventoryreservation.EdgeTenant:
		m.ClearTenant()
		return nil
	}
	return fmt.Errorf("unknown InventoryReservation unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *InventoryReservationMutation) ResetEdge(name string) error {
	switch name {
	case inventoryreservation.EdgeProduct:
		m.ResetProduct()
		return nil
	case inventoryreservation.EdgeTenant:
		m.ResetTenant()
		return nil
	}
	return fmt.Errorf("unknown InventoryReservation edge %s", name)
}

// JobMutation represents an operation that mutates the Job nodes in the graph.
type JobMutation struct {
	config
	op                Op
	typ               string
	id                *int
	name              *string
	cron_schedule     *string
	next_run          *time.Time
	last_run          *time.Time
	targets           *[]string
	appendtargets     []string
	created_at        *time.Time
	updated_at        *time.Time
	clearedFields     map[string]struct{}
	tenant            *int
	clearedtenant     bool
	script            *int
	clearedscript     bool
	executions        map[int]struct{}
	removedexecutions map[int]struct{}
	clearedexecutions bool
	done              bool
	oldValue          func(context.Context) (*Job, error)
	predicates        []predicate.Job
}

var _ ent.Mutation = (*JobMutation)(nil)

// jobOption allows management of the mutation configuration using functional options.
type jobOption func(*JobMutation)

// newJobMutation creates new mutation for the Job entity.
func newJobMutation(c config, op Op, opts ...jobOption) *JobMutation {
	m := &JobMutation{
		config:        c,
		op:            op,
		typ:           TypeJob,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withJobID sets the ID field of the mutation.
func withJobID(id int) jobOption {
	return func(m *JobMutation) {
		var (
			err   error
			once  sync.Once
			value *Job
		)
		m.oldValue = func(ctx context.Context) (*Job, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Job.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withJob sets the old Job of the mutation.
func withJob(node *Job) jobOption {
	return func(m *JobMutation) {
		m.oldValue = func(context.Context) (*Job, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m JobMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m JobMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *JobMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *JobMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Job.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *JobMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *JobMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Job entity.
// If the Job object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *JobMutation) ResetName() {
	m.name = nil
}

// SetCronSchedule sets the "cron_schedule" field.
func (m *JobMutation) SetCronSchedule(s string) {
	m.cron_schedule = &s
}

// CronSchedule returns the value of the "cron_schedule" field in the mutation.
func (m *JobMutation) CronSchedule() (r string, exists bool) {
	v := m.cron_schedule
	if v == nil {
		return
	}
	return *v, true
}

// OldCronSchedule returns the old "cron_schedule" field's value of the Job entity.
// If the Job object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobMutation) OldCronSchedule(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCronSchedule is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCronSchedule requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCronSchedule: %w", err)
	}
	return oldValue.CronSchedule, nil
}

// ClearCronSchedule clears the value of the "cron_schedule" field.
func (m *JobMutation) ClearCronSchedule() {
	m.cron_schedule = nil
	m.clearedFields[job.FieldCronSchedule] = struct{}{}
}

// CronScheduleCleared returns if the "cron_schedule" field was cleared in this mutation.
func (m *JobMutation) CronScheduleCleared() bool {
	_, ok := m.clearedFields[job.FieldCronSchedule]
	return ok
}

// ResetCronSchedule resets all changes to the "cron_schedule" field.
func (m *JobMutation) ResetCronSchedule() {
	m.cron_schedule = nil
	delete(m.clearedFields, job.FieldCronSchedule)
}

// SetNextRun sets the "next_run" field.
func (m *JobMutation) SetNextRun(t time.Time) {
	m.next_run = &t
}

// NextRun returns the value of the "next_run" field in the mutation.
func (m *JobMutation) NextRun() (r time.Time, exists bool) {
	v := m.next_run
	if v == nil {
		return
	}
	return *v, true
}

// OldNextRun returns the old "next_run" field's value of the Job entity.
// If the Job object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobMutation) OldNextRun(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNextRun is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNextRun requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNextRun: %w", err)
	}
	return oldValue.NextRun, nil
}

// ClearNextRun clears the value of the "next_run" field.
func (m *JobMutation) ClearNextRun() {
	m.next_run = nil
	m.clearedFields[job.FieldNextRun] = struct{}{}
}

// NextRunCleared returns if the "next_run" field was cleared in this mutation.
func (m *JobMutation) NextRunCleared() bool {
	_, ok := m.clearedFields[job.FieldNextRun]
	return ok
}

// ResetNextRun resets all changes to the "next_run" field.
func (m *JobMutation) ResetNextRun() {
	m.next_run = nil
	delete(m.clearedFields, job.FieldNextRun)
}

// SetLastRun sets the "last_run" field.
func (m *JobMutation) SetLastRun(t time.Time) {
	m.last_run = &t
}

// LastRun returns the value of the "last_run" field in the mutation.
func (m *JobMutation) LastRun() (r time.Time, exists bool) {
	v := m.last_run
	if v == nil {
		return
	}
	return *v, true
}

// OldLastRun returns the old "last_run" field's value of the Job entity.
// If the Job object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobMutation) OldLastRun(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastRun is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastRun requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastRun: %w", err)
	}
	return oldValue.LastRun, nil
}

// ClearLastRun clears the value of the "last_run" field.
func (m *JobMutation) ClearLastRun() {
	m.last_run = nil
	m.clearedFields[job.FieldLastRun] = struct{}{}
}

// LastRunCleared returns if the "last_run" field was cleared in this mutation.
func (m *JobMutation) LastRunCleared() bool {
	_, ok := m.clearedFields[job.FieldLastRun]
	return ok
}

// ResetLastRun resets all changes to the "last_run" field.
func (m *JobMutation) ResetLastRun() {
	m.last_run = nil
	delete(m.clearedFields, job.FieldLastRun)
}

// SetTargets sets the "targets" field.
func (m *JobMutation) SetTargets(s []string) {
	m.targets = &s
	m.appendtargets = nil
}

// Targets returns the value of the "targets" field in the mutation.
func (m *JobMutation) Targets() (r []string, exists bool) {
	v := m.targets
	if v == nil {
		return
	}
	return *v, true
}

// OldTargets returns the old "targets" field's value of the Job entity.
// If the Job object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobMutation) OldTargets(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTargets is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTargets requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTargets: %w", err)
	}
	return oldValue.Targets, nil
}

// AppendTargets adds s to the "targets" field.
func (m *JobMutation) AppendTargets(s []string) {
	m.appendtargets = append(m.appendtargets, s...)
}

// AppendedTargets returns the list of values that were appended to the "targets" field in this mutation.
func (m *JobMutation) AppendedTargets() ([]string, bool) {
	if len(m.appendtargets) == 0 {
		return nil, false
	}
	return m.appendtargets, true
}

// ResetTargets resets all changes to the "targets" field.
func (m *JobMutation) ResetTargets() {
	m.targets = nil
	m.appendtargets = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *JobMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *JobMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Job entity.
// If the Job object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *JobMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *JobMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *JobMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Job entity.
// If the Job object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *JobMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetTenantID sets the "tenant" edge to the Tenant entity by id.
func (m *JobMutation) SetTenantID(id int) {
	m.tenant = &id
}

// ClearTenant clears the "tenant" edge to the Tenant entity.
func (m *JobMutation) ClearTenant() {
	m.clearedtenant = true
}

// TenantCleared reports if the "tenant" edge to the Tenant entity was cleared.
func (m *JobMutation) TenantCleared() bool {
	return m.clearedtenant
}

// TenantID returns the "tenant" edge ID in the mutation.
func (m *JobMutation) TenantID() (id int, exists bool) {
	if m.tenant != nil {
		return *m.tenant, true
	}
	return
}

// TenantIDs returns the "tenant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TenantID instead. It exists only for internal usage by the builders.
func (m *JobMutation) TenantIDs() (ids []int) {
	if id := m.tenant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTenant resets all changes to the "tenant" edge.
func (m *JobMutation) ResetTenant() {
	m.tenant = nil
	m.clearedtenant = false
}

// SetScriptID sets the "script" edge to the Script entity by id.
func (m *JobMutation) SetScriptID(id int) {
	m.script = &id
}

// ClearScript clears the "script" edge to the Script entity.
func (m *JobMutation) ClearScript() {
	m.clearedscript = true
}

// ScriptCleared reports if the "script" edge to the Script entity was cleared.
func (m *JobMutation) ScriptCleared() bool {
	return m.clearedscript
}

// ScriptID returns the "script" edge ID in the mutation.
func (m *JobMutation) ScriptID() (id int, exists bool) {
	if m.script != nil {
		return *m.script, true
	}
	return
}

// ScriptIDs returns the "script" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ScriptID instead. It exists only for internal usage by the builders.
func (m *JobMutation) ScriptIDs() (ids []int) {
	if id := m.script; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetScript resets all changes to the "script" edge.
func (m *JobMutation) ResetScript() {
	m.script = nil
	m.clearedscript = false
}

// AddExecutionIDs adds the "executions" edge to the JobExecution entity by ids.
func (m *JobMutation) AddExecutionIDs(ids ...int) {
	if m.executions == nil {
		m.executions = make(map[int]struct{})
	}
	for i := range ids {
		m.executions[ids[i]] = struct{}{}
	}
}

// ClearExecutions clears the "executions" edge to the JobExecution entity.
func (m *JobMutation) ClearExecutions() {
	m.clearedexecutions = true
}

// ExecutionsCleared reports if the "executions" edge to the JobExecution entity was cleared.
func (m *JobMutation) ExecutionsCleared() bool {
	return m.clearedexecutions
}

// RemoveExecutionIDs removes the "executions" edge to the JobExecution entity by IDs.
func (m *JobMutation) RemoveExecutionIDs(ids ...int) {
	if m.removedexecutions == nil {
		m.removedexecutions = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.executions, ids[i])
		m.removedexecutions[ids[i]] = struct{}{}
	}
}

// RemovedExecutions returns the removed IDs of the "executions" edge to the JobExecution entity.
func (m *JobMutation) RemovedExecutionsIDs() (ids []int) {
	for id := range m.removedexecutions {
		ids = append(ids, id)
	}
	return
}

// ExecutionsIDs returns the "executions" edge IDs in the mutation.
func (m *JobMutation) ExecutionsIDs() (ids []int) {
	for id := range m.executions {
		ids = append(ids, id)
	}
	return
}

// ResetExecutions resets all changes to the "executions" edge.
func (m *JobMutation) ResetExecutions() {
	m.executions = nil
	m.clearedexecutions = false
	m.removedexecutions = nil
}

// Where appends a list predicates to the JobMutation builder.
func (m *JobMutation) Where(ps ...predicate.Job) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the JobMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *JobMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Job, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *JobMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *JobMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Job).
func (m *JobMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *JobMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.name != nil {
		fields = append(fields, job.FieldName)
	}
	if m.cron_schedule != nil {
		fields = append(fields, job.FieldCronSchedule)
	}
	if m.next_run != nil {
		fields = append(fields, job.FieldNextRun)
	}
	if m.last_run != nil {
		fields = append(fields, job.FieldLastRun)
	}
	if m.targets != nil {
		fields = append(fields, job.FieldTargets)
	}
	if m.created_at != nil {
		fields = append(fields, job.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, job.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *JobMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case job.FieldName:
		return m.Name()
	case job.FieldCronSchedule:
		return m.CronSchedule()
	case job.FieldNextRun:
		return m.NextRun()
	case job.FieldLastRun:
		return m.LastRun()
	case job.FieldTargets:
		return m.Targets()
	case job.FieldCreatedAt:
		return m.CreatedAt()
	case job.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *JobMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case job.FieldName:
		return m.OldName(ctx)
	case job.FieldCronSchedule:
		return m.OldCronSchedule(ctx)
	case job.FieldNextRun:
		return m.OldNextRun(ctx)
	case job.FieldLastRun:
		return m.OldLastRun(ctx)
	case job.FieldTargets:
		return m.OldTargets(ctx)
	case job.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case job.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Job field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *JobMutation) SetField(name string, value ent.Value) error {
	switch name {
	case job.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case job.FieldCronSchedule:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCronSchedule(v)
		return nil
	case job.FieldNextRun:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNextRun(v)
		return nil
	case job.FieldLastRun:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastRun(v)
		return nil
	case job.FieldTargets:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTargets(v)
		return nil
	case job.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case job.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Job field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *JobMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *JobMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *JobMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Job numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *JobMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(job.FieldCronSchedule) {
		fields = append(fields, job.FieldCronSchedule)
	}
	if m.FieldCleared(job.FieldNextRun) {
		fields = append(fields, job.FieldNextRun)
	}
	if m.FieldCleared(job.FieldLastRun) {
		fields = append(fields, job.FieldLastRun)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *JobMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *JobMutation) ClearField(name string) error {
	switch name {
	case job.FieldCronSchedule:
		m.ClearCronSchedule()
		return nil
	case job.FieldNextRun:
		m.ClearNextRun()
		return nil
	case job.FieldLastRun:
		m.ClearLastRun()
		return nil
	}
	return fmt.Errorf("unknown Job nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *JobMutation) ResetField(name string) error {
	switch name {
	case job.FieldName:
		m.ResetName()
		return nil
	case job.FieldCronSchedule:
		m.ResetCronSchedule()
		return nil
	case job.FieldNextRun:
		m.ResetNextRun()
		return nil
	case job.FieldLastRun:
		m.ResetLastRun()
		return nil
	case job.FieldTargets:
		m.ResetTargets()
		return nil
	case job.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case job.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Job field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *JobMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.tenant != nil {
		edges = append(edges, job.EdgeTenant)
	}
	if m.script != nil {
		edges = append(edges, job.EdgeScript)
	}
	if m.executions != nil {
		edges = append(edges, job.EdgeExecutions)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *JobMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case job.EdgeTenant:
		if id := m.tenant; id != nil {
			return []ent.Value{*id}
		}
	case job.EdgeScript:
		if id := m.script; id != nil {
			return []ent.Value{*id}
		}
	case job.EdgeExecutions:
		ids := make([]ent.Value, 0, len(m.executions))
		for id := range m.executions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *JobMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedexecutions != nil {
		edges = append(edges, job.EdgeExecutions)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *JobMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case job.EdgeExecutions:
		ids := make([]ent.Value, 0, len(m.removedexecutions))
		for id := range m.removedexecutions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *JobMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedtenant {
		edges = append(edges, job.EdgeTenant)
	}
	if m.clearedscript {
		edges = append(edges, job.EdgeScript)
	}
	if m.clearedexecutions {
		edges = append(edges, job.EdgeExecutions)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *JobMutation) EdgeCleared(name string) bool {
	switch name {
	case job.EdgeTenant:
		return m.clearedtenant
	case job.EdgeScript:
		return m.clearedscript
	case job.EdgeExecutions:
		return m.clearedexecutions
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *JobMutation) ClearEdge(name string) error {
	switch name {
	case job.EdgeTenant:
		m.ClearTenant()
		return nil
	case job.EdgeScript:
		m.ClearScript()
		return nil
	}
	return fmt.Errorf("unknown Job unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *JobMutation) ResetEdge(name string) error {
	switch name {
	case job.EdgeTenant:
		m.ResetTenant()
		return nil
	case job.EdgeScript:
		m.ResetScript()
		return nil
	case job.EdgeExecutions:
		m.ResetExecutions()
		return nil
	}
	return fmt.Errorf("unknown Job edge %s", name)
}

// JobExecutionMutation represents an operation that mutates the JobExecution nodes in the graph.
type JobExecutionMutation struct {
	config
	op            Op
	typ           string
	id            *int
	status        *jobexecution.Status
	output        *string
	started_at    *time.Time
	completed_at  *time.Time
	created_at    *time.Time
	clearedFields map[string]struct{}
	job           *int
	clearedjob    bool
	agent         *int
	clearedagent  bool
	done          bool
	oldValue      func(context.Context) (*JobExecution, error)
	predicates    []predicate.JobExecution
}

var _ ent.Mutation = (*JobExecutionMutation)(nil)

// jobexecutionOption allows management of the mutation configuration using functional options.
type jobexecutionOption func(*JobExecutionMutation)

// newJobExecutionMutation creates new mutation for the JobExecution entity.
func newJobExecutionMutation(c config, op Op, opts ...jobexecutionOption) *JobExecutionMutation {
	m := &JobExecutionMutation{
		config:        c,
		op:            op,
		typ:           TypeJobExecution,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withJobExecutionID sets the ID field of the mutation.
func withJobExecutionID(id int) jobexecutionOption {
	return func(m *JobExecutionMutation) {
		var (
			err   error
			once  sync.Once
			value *JobExecution
		)
		m.oldValue = func(ctx context.Context) (*JobExecution, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().JobExecution.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withJobExecution sets the old JobExecution of the mutation.
func withJobExecution(node *JobExecution) jobexecutionOption {
	return func(m *JobExecutionMutation) {
		m.oldValue = func(context.Context) (*JobExecution, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m JobExecutionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m JobExecutionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *JobExecutionMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *JobExecutionMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().JobExecution.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetStatus sets the "status" field.
func (m *JobExecutionMutation) SetStatus(j jobexecution.Status) {
	m.status = &j
}

// Status returns the value of the "status" field in the mutation.
func (m *JobExecutionMutation) Status() (r jobexecution.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the JobExecution entity.
// If the JobExecution object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobExecutionMutation) OldStatus(ctx context.Context) (v jobexecution.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *JobExecutionMutation) ResetStatus() {
	m.status = nil
}

// SetOutput sets the "output" field.
func (m *JobExecutionMutation) SetOutput(s string) {
	m.output = &s
}

// Output returns the value of the "output" field in the mutation.
func (m *JobExecutionMutation) Output() (r string, exists bool) {
	v := m.output
	if v == nil {
		return
	}
	return *v, true
}

// OldOutput returns the old "output" field's value of the JobExecution entity.
// If the JobExecution object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobExecutionMutation) OldOutput(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOutput is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOutput requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOutput: %w", err)
	}
	return oldValue.Output, nil
}

// ClearOutput clears the value of the "output" field.
func (m *JobExecutionMutation) ClearOutput() {
	m.output = nil
	m.clearedFields[jobexecution.FieldOutput] = struct{}{}
}

// OutputCleared returns if the "output" field was cleared in this mutation.
func (m *JobExecutionMutation) OutputCleared() bool {
	_, ok := m.clearedFields[jobexecution.FieldOutput]
	return ok
}

// ResetOutput resets all changes to the "output" field.
func (m *JobExecutionMutation) ResetOutput() {
	m.output = nil
	delete(m.clearedFields, jobexecution.FieldOutput)
}

// SetStartedAt sets the "started_at" field.
func (m *JobExecutionMutation) SetStartedAt(t time.Time) {
	m.started_at = &t
}

// StartedAt returns the value of the "started_at" field in the mutation.
func (m *JobExecutionMutation) StartedAt() (r time.Time, exists bool) {
	v := m.started_at
	if v == nil {
		return
	}
	return *v, true
}

// OldStartedAt returns the old "started_at" field's value of the JobExecution entity.
// If the JobExecution object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobExecutionMutation) OldStartedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartedAt: %w", err)
	}
	return oldValue.StartedAt, nil
}

// ClearStartedAt clears the value of the "started_at" field.
func (m *JobExecutionMutation) ClearStartedAt() {
	m.started_at = nil
	m.clearedFields[jobexecution.FieldStartedAt] = struct{}{}
}

// StartedAtCleared returns if the "started_at" field was cleared in this mutation.
func (m *JobExecutionMutation) StartedAtCleared() bool {
	_, ok := m.clearedFields[jobexecution.FieldStartedAt]
	return ok
}

// ResetStartedAt resets all changes to the "started_at" field.
func (m *JobExecutionMutation) ResetStartedAt() {
	m.started_at = nil
	delete(m.clearedFields, jobexecution.FieldStartedAt)
}

// SetCompletedAt sets the "completed_at" field.
func (m *JobExecutionMutation) SetCompletedAt(t time.Time) {
	m.completed_at = &t
}

// CompletedAt returns the value of the "completed_at" field in the mutation.
func (m *JobExecutionMutation) CompletedAt() (r time.Time, exists bool) {
	v := m.completed_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCompletedAt returns the old "completed_at" field's value of the JobExecution entity.
// If the JobExecution object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobExecutionMutation) OldCompletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCompletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCompletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCompletedAt: %w", err)
	}
	return oldValue.CompletedAt, nil
}

// ClearCompletedAt clears the value of the "completed_at" field.
func (m *JobExecutionMutation) ClearCompletedAt() {
	m.completed_at = nil
	m.clearedFields[jobexecution.FieldCompletedAt] = struct{}{}
}

// CompletedAtCleared returns if the "completed_at" field was cleared in this mutation.
func (m *JobExecutionMutation) CompletedAtCleared() bool {
	_, ok := m.clearedFields[jobexecution.FieldCompletedAt]
	return ok
}

// ResetCompletedAt resets all changes to the "completed_at" field.
func (m *JobExecutionMutation) ResetCompletedAt() {
	m.completed_at = nil
	delete(m.clearedFields, jobexecution.FieldCompletedAt)
}

// SetCreatedAt sets the "created_at" field.
func (m *JobExecutionMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *JobExecutionMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the JobExecution entity.
// If the JobExecution object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobExecutionMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *JobExecutionMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetJobID sets the "job" edge to the Job entity by id.
func (m *JobExecutionMutation) SetJobID(id int) {
	m.job = &id
}

// ClearJob clears the "job" edge to the Job entity.
func (m *JobExecutionMutation) ClearJob() {
	m.clearedjob = true
}

// JobCleared reports if the "job" edge to the Job entity was cleared.
func (m *JobExecutionMutation) JobCleared() bool {
	return m.clearedjob
}

// JobID returns the "job" edge ID in the mutation.
func (m *JobExecutionMutation) JobID() (id int, exists bool) {
	if m.job != nil {
		return *m.job, true
	}
	return
}

// JobIDs returns the "job" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// JobID instead. It exists only for internal usage by the builders.
func (m *JobExecutionMutation) JobIDs() (ids []int) {
	if id := m.job; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetJob resets all changes to the "job" edge.
func (m *JobExecutionMutation) ResetJob() {
	m.job = nil
	m.clearedjob = false
}

// SetAgentID sets the "agent" edge to the Agent entity by id.
func (m *JobExecutionMutation) SetAgentID(id int) {
	m.agent = &id
}

// ClearAgent clears the "agent" edge to the Agent entity.
func (m *JobExecutionMutation) ClearAgent() {
	m.clearedagent = true
}

// AgentCleared reports if the "agent" edge to the Agent entity was cleared.
func (m *JobExecutionMutation) AgentCleared() bool {
	return m.clearedagent
}

// AgentID returns the "agent" edge ID in the mutation.
func (m *JobExecutionMutation) AgentID() (id int, exists bool) {
	if m.agent != nil {
		return *m.agent, true
	}
	return
}

// AgentIDs returns the "agent" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AgentID instead. It exists only for internal usage by the builders.
func (m *JobExecutionMutation) AgentIDs() (ids []int) {
	if id := m.agent; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAgent resets all changes to the "agent" edge.
func (m *JobExecutionMutation) ResetAgent() {
	m.agent = nil
	m.clearedagent = false
}

// Where appends a list predicates to the JobExecutionMutation builder.
func (m *JobExecutionMutation) Where(ps ...predicate.JobExecution) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the JobExecutionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *JobExecutionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.JobExecution, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *JobExecutionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *JobExecutionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (JobExecution).
func (m *JobExecutionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *JobExecutionMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.status != nil {
		fields = append(fields, jobexecution.FieldStatus)
	}
	if m.output != nil {
		fields = append(fields, jobexecution.FieldOutput)
	}
	if m.started_at != nil {
		fields = append(fields, jobexecution.FieldStartedAt)
	}
	if m.completed_at != nil {
		fields = append(fields, jobexecution.FieldCompletedAt)
	}
	if m.created_at != nil {
		fields = append(fields, jobexecution.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *JobExecutionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case jobexecution.FieldStatus:
		return m.Status()
	case jobexecution.FieldOutput:
		return m.Output()
	case jobexecution.FieldStartedAt:
		return m.StartedAt()
	case jobexecution.FieldCompletedAt:
		return m.CompletedAt()
	case jobexecution.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *JobExecutionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case jobexecution.FieldStatus:
		return m.OldStatus(ctx)
	case jobexecution.FieldOutput:
		return m.OldOutput(ctx)
	case jobexecution.FieldStartedAt:
		return m.OldStartedAt(ctx)
	case jobexecution.FieldCompletedAt:
		return m.OldCompletedAt(ctx)
	case jobexecution.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown JobExecution field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *JobExecutionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case jobexecution.FieldStatus:
		v, ok := value.(jobexecution.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case jobexecution.FieldOutput:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOutput(v)
		return nil
	case jobexecution.FieldStartedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartedAt(v)
		return nil
	case jobexecution.FieldCompletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCompletedAt(v)
		return nil
	case jobexecution.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown JobExecution field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *JobExecutionMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *JobExecutionMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *JobExecutionMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown JobExecution numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *JobExecutionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(jobexecution.FieldOutput) {
		fields = append(fields, jobexecution.FieldOutput)
	}
	if m.FieldCleared(jobexecution.FieldStartedAt) {
		fields = append(fields, jobexecution.FieldStartedAt)
	}
	if m.FieldCleared(jobexecution.FieldCompletedAt) {
		fields = append(fields, jobexecution.FieldCompletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *JobExecutionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *JobExecutionMutation) ClearField(name string) error {
	switch name {
	case jobexecution.FieldOutput:
		m.ClearOutput()
		return nil
	case jobexecution.FieldStartedAt:
		m.ClearStartedAt()
		return nil
	case jobexecution.FieldCompletedAt:
		m.ClearCompletedAt()
		return nil
	}
	return fmt.Errorf("unknown JobExecution nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *JobExecutionMutation) ResetField(name string) error {
	switch name {
	case jobexecution.FieldStatus:
		m.ResetStatus()
		return nil
	case jobexecution.FieldOutput:
		m.ResetOutput()
		return nil
	case jobexecution.FieldStartedAt:
		m.ResetStartedAt()
		return nil
	case jobexecution.FieldCompletedAt:
		m.ResetCompletedAt()
		return nil
	case jobexecution.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown JobExecution field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *JobExecutionMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.job != nil {
		edges = append(edges, jobexecution.EdgeJob)
	}
	if m.agent != nil {
		edges = append(edges, jobexecution.EdgeAgent)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *JobExecutionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case jobexecution.EdgeJob:
		if id := m.job; id != nil {
			return []ent.Value{*id}
		}
	case jobexecution.EdgeAgent:
		if id := m.agent; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *JobExecutionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *JobExecutionMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *JobExecutionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedjob {
		edges = append(edges, jobexecution.EdgeJob)
	}
	if m.clearedagent {
		edges = append(edges, jobexecution.EdgeAgent)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *JobExecutionMutation) EdgeCleared(name string) bool {
	switch name {
	case jobexecution.EdgeJob:
		return m.clearedjob
	case jobexecution.EdgeAgent:
		return m.clearedagent
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *JobExecutionMutation) ClearEdge(name string) error {
	switch name {
	case jobexecution.EdgeJob:
		m.ClearJob()
		return nil
	case jobexecution.EdgeAgent:
		m.ClearAgent()
		return nil
	}
	return fmt.Errorf("unknown JobExecution unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *JobExecutionMutation) ResetEdge(name string) error {
	switch name {
	case jobexecution.EdgeJob:
		m.ResetJob()
		return nil
	case jobexecution.EdgeAgent:
		m.ResetAgent()
		return nil
	}
	return fmt.Errorf("unknown JobExecution edge %s", name)
}

// JobPostingMutation represents an operation that mutates the JobPosting nodes in the graph.
type JobPostingMutation struct {
	config
	op                  Op
	typ                 string
	id                  *int
	title               *string
	description         *string
	requirements        *string
	location            *string
	salary_range        *string
	status              *jobposting.Status
	created_at          *time.Time
	updated_at          *time.Time
	clearedFields       map[string]struct{}
	tenant              *int
	clearedtenant       bool
	applications        map[int]struct{}
	removedapplications map[int]struct{}
	clearedapplications bool
	done                bool
	oldValue            func(context.Context) (*JobPosting, error)
	predicates          []predicate.JobPosting
}

var _ ent.Mutation = (*JobPostingMutation)(nil)

// jobpostingOption allows management of the mutation configuration using functional options.
type jobpostingOption func(*JobPostingMutation)

// newJobPostingMutation creates new mutation for the JobPosting entity.
func newJobPostingMutation(c config, op Op, opts ...jobpostingOption) *JobPostingMutation {
	m := &JobPostingMutation{
		config:        c,
		op:            op,
		typ:           TypeJobPosting,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withJobPostingID sets the ID field of the mutation.
func withJobPostingID(id int) jobpostingOption {
	return func(m *JobPostingMutation) {
		var (
			err   error
			once  sync.Once
			value *JobPosting
		)
		m.oldValue = func(ctx context.Context) (*JobPosting, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().JobPosting.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withJobPosting sets the old JobPosting of the mutation.
func withJobPosting(node *JobPosting) jobpostingOption {
	return func(m *JobPostingMutation) {
		m.oldValue = func(context.Context) (*JobPosting, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m JobPostingMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m JobPostingMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *JobPostingMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *JobPostingMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().JobPosting.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTitle sets the "title" field.
func (m *JobPostingMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *JobPostingMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the JobPosting entity.
// If the JobPosting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobPostingMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *JobPostingMutation) ResetTitle() {
	m.title = nil
}

// SetDescription sets the "description" field.
func (m *JobPostingMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *JobPostingMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the JobPosting entity.
// If the JobPosting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobPostingMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *JobPostingMutation) ResetDescription() {
	m.description = nil
}

// SetRequirements sets the "requirements" field.
func (m *JobPostingMutation) SetRequirements(s string) {
	m.requirements = &s
}

// Requirements returns the value of the "requirements" field in the mutation.
func (m *JobPostingMutation) Requirements() (r string, exists bool) {
	v := m.requirements
	if v == nil {
		return
	}
	return *v, true
}

// OldRequirements returns the old "requirements" field's value of the JobPosting entity.
// If the JobPosting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobPostingMutation) OldRequirements(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRequirements is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRequirements requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRequirements: %w", err)
	}
	return oldValue.Requirements, nil
}

// ClearRequirements clears the value of the "requirements" field.
func (m *JobPostingMutation) ClearRequirements() {
	m.requirements = nil
	m.clearedFields[jobposting.FieldRequirements] = struct{}{}
}

// RequirementsCleared returns if the "requirements" field was cleared in this mutation.
func (m *JobPostingMutation) RequirementsCleared() bool {
	_, ok := m.clearedFields[jobposting.FieldRequirements]
	return ok
}

// ResetRequirements resets all changes to the "requirements" field.
func (m *JobPostingMutation) ResetRequirements() {
	m.requirements = nil
	delete(m.clearedFields, jobposting.FieldRequirements)
}

// SetLocation sets the "location" field.
func (m *JobPostingMutation) SetLocation(s string) {
	m.location = &s
}

// Location returns the value of the "location" field in the mutation.
func (m *JobPostingMutation) Location() (r string, exists bool) {
	v := m.location
	if v == nil {
		return
	}
	return *v, true
}

// OldLocation returns the old "location" field's value of the JobPosting entity.
// If the JobPosting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobPostingMutation) OldLocation(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLocation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLocation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLocation: %w", err)
	}
	return oldValue.Location, nil
}

// ClearLocation clears the value of the "location" field.
func (m *JobPostingMutation) ClearLocation() {
	m.location = nil
	m.clearedFields[jobposting.FieldLocation] = struct{}{}
}

// LocationCleared returns if the "location" field was cleared in this mutation.
func (m *JobPostingMutation) LocationCleared() bool {
	_, ok := m.clearedFields[jobposting.FieldLocation]
	return ok
}

// ResetLocation resets all changes to the "location" field.
func (m *JobPostingMutation) ResetLocation() {
	m.location = nil
	delete(m.clearedFields, jobposting.FieldLocation)
}

// SetSalaryRange sets the "salary_range" field.
func (m *JobPostingMutation) SetSalaryRange(s string) {
	m.salary_range = &s
}

// SalaryRange returns the value of the "salary_range" field in the mutation.
func (m *JobPostingMutation) SalaryRange() (r string, exists bool) {
	v := m.salary_range
	if v == nil {
		return
	}
	return *v, true
}

// OldSalaryRange returns the old "salary_range" field's value of the JobPosting entity.
// If the JobPosting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobPostingMutation) OldSalaryRange(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSalaryRange is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSalaryRange requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSalaryRange: %w", err)
	}
	return oldValue.SalaryRange, nil
}

// ClearSalaryRange clears the value of the "salary_range" field.
func (m *JobPostingMutation) ClearSalaryRange() {
	m.salary_range = nil
	m.clearedFields[jobposting.FieldSalaryRange] = struct{}{}
}

// SalaryRangeCleared returns if the "salary_range" field was cleared in this mutation.
func (m *JobPostingMutation) SalaryRangeCleared() bool {
	_, ok := m.clearedFields[jobposting.FieldSalaryRange]
	return ok
}

// ResetSalaryRange resets all changes to the "salary_range" field.
func (m *JobPostingMutation) ResetSalaryRange() {
	m.salary_range = nil
	delete(m.clearedFields, jobposting.FieldSalaryRange)
}

// SetStatus sets the "status" field.
func (m *JobPostingMutation) SetStatus(j jobposting.Status) {
	m.status = &j
}

// Status returns the value of the "status" field in the mutation.
func (m *JobPostingMutation) Status() (r jobposting.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the JobPosting entity.
// If the JobPosting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobPostingMutation) OldStatus(ctx context.Context) (v jobposting.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *JobPostingMutation) ResetStatus() {
	m.status = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *JobPostingMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *JobPostingMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the JobPosting entity.
// If the JobPosting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobPostingMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *JobPostingMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *JobPostingMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *JobPostingMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the JobPosting entity.
// If the JobPosting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobPostingMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *JobPostingMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetTenantID sets the "tenant" edge to the Tenant entity by id.
func (m *JobPostingMutation) SetTenantID(id int) {
	m.tenant = &id
}

// ClearTenant clears the "tenant" edge to the Tenant entity.
func (m *JobPostingMutation) ClearTenant() {
	m.clearedtenant = true
}

// TenantCleared reports if the "tenant" edge to the Tenant entity was cleared.
func (m *JobPostingMutation) TenantCleared() bool {
	return m.clearedtenant
}

// TenantID returns the "tenant" edge ID in the mutation.
func (m *JobPostingMutation) TenantID() (id int, exists bool) {
	if m.tenant != nil {
		return *m.tenant, true
	}
	return
}

// TenantIDs returns the "tenant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TenantID instead. It exists only for internal usage by the builders.
func (m *JobPostingMutation) TenantIDs() (ids []int) {
	if id := m.tenant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTenant resets all changes to the "tenant" edge.
func (m *JobPostingMutation) ResetTenant() {
	m.tenant = nil
	m.clearedtenant = false
}

// AddApplicationIDs adds the "applications" edge to the Application entity by ids.
func (m *JobPostingMutation) AddApplicationIDs(ids ...int) {
	if m.applications == nil {
		m.applications = make(map[int]struct{})
	}
	for i := range ids {
		m.applications[ids[i]] = struct{}{}
	}
}

// ClearApplications clears the "applications" edge to the Application entity.
func (m *JobPostingMutation) ClearApplications() {
	m.clearedapplications = true
}

// ApplicationsCleared reports if the "applications" edge to the Application entity was cleared.
func (m *JobPostingMutation) ApplicationsCleared() bool {
	return m.clearedapplications
}

// RemoveApplicationIDs removes the "applications" edge to the Application entity by IDs.
func (m *JobPostingMutation) RemoveApplicationIDs(ids ...int) {
	if m.removedapplications == nil {
		m.removedapplications = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.applications, ids[i])
		m.removedapplications[ids[i]] = struct{}{}
	}
}

// RemovedApplications returns the removed IDs of the "applications" edge to the Application entity.
func (m *JobPostingMutation) RemovedApplicationsIDs() (ids []int) {
	for id := range m.removedapplications {
		ids = append(ids, id)
	}
	return
}

// ApplicationsIDs returns the "applications" edge IDs in the mutation.
func (m *JobPostingMutation) ApplicationsIDs() (ids []int) {
	for id := range m.applications {
		ids = append(ids, id)
	}
	return
}

// ResetApplications resets all changes to the "applications" edge.
func (m *JobPostingMutation) ResetApplications() {
	m.applications = nil
	m.clearedapplications = false
	m.removedapplications = nil
}

// Where appends a list predicates to the JobPostingMutation builder.
func (m *JobPostingMutation) Where(ps ...predicate.JobPosting) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the JobPostingMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *JobPostingMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.JobPosting, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *JobPostingMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *JobPostingMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (JobPosting).
func (m *JobPostingMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *JobPostingMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.title != nil {
		fields = append(fields, jobposting.FieldTitle)
	}
	if m.description != nil {
		fields = append(fields, jobposting.FieldDescription)
	}
	if m.requirements != nil {
		fields = append(fields, jobposting.FieldRequirements)
	}
	if m.location != nil {
		fields = append(fields, jobposting.FieldLocation)
	}
	if m.salary_range != nil {
		fields = append(fields, jobposting.FieldSalaryRange)
	}
	if m.status != nil {
		fields = append(fields, jobposting.FieldStatus)
	}
	if m.created_at != nil {
		fields = append(fields, jobposting.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, jobposting.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *JobPostingMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case jobposting.FieldTitle:
		return m.Title()
	case jobposting.FieldDescription:
		return m.Description()
	case jobposting.FieldRequirements:
		return m.Requirements()
	case jobposting.FieldLocation:
		return m.Location()
	case jobposting.FieldSalaryRange:
		return m.SalaryRange()
	case jobposting.FieldStatus:
		return m.Status()
	case jobposting.FieldCreatedAt:
		return m.CreatedAt()
	case jobposting.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *JobPostingMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case jobposting.FieldTitle:
		return m.OldTitle(ctx)
	case jobposting.FieldDescription:
		return m.OldDescription(ctx)
	case jobposting.FieldRequirements:
		return m.OldRequirements(ctx)
	case jobposting.FieldLocation:
		return m.OldLocation(ctx)
	case jobposting.FieldSalaryRange:
		return m.OldSalaryRange(ctx)
	case jobposting.FieldStatus:
		return m.OldStatus(ctx)
	case jobposting.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case jobposting.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown JobPosting field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *JobPostingMutation) SetField(name string, value ent.Value) error {
	switch name {
	case jobposting.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case jobposting.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case jobposting.FieldRequirements:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRequirements(v)
		return nil
	case jobposting.FieldLocation:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLocation(v)
		return nil
	case jobposting.FieldSalaryRange:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSalaryRange(v)
		return nil
	case jobposting.FieldStatus:
		v, ok := value.(jobposting.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case jobposting.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case jobposting.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown JobPosting field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *JobPostingMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *JobPostingMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *JobPostingMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown JobPosting numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *JobPostingMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(jobposting.FieldRequirements) {
		fields = append(fields, jobposting.FieldRequirements)
	}
	if m.FieldCleared(jobposting.FieldLocation) {
		fields = append(fields, jobposting.FieldLocation)
	}
	if m.FieldCleared(jobposting.FieldSalaryRange) {
		fields = append(fields, jobposting.FieldSalaryRange)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *JobPostingMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *JobPostingMutation) ClearField(name string) error {
	switch name {
	case jobposting.FieldRequirements:
		m.ClearRequirements()
		return nil
	case jobposting.FieldLocation:
		m.ClearLocation()
		return nil
	case jobposting.FieldSalaryRange:
		m.ClearSalaryRange()
		return nil
	}
	return fmt.Errorf("unknown JobPosting nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *JobPostingMutation) ResetField(name string) error {
	switch name {
	case jobposting.FieldTitle:
		m.ResetTitle()
		return nil
	case jobposting.FieldDescription:
		m.ResetDescription()
		return nil
	case jobposting.FieldRequirements:
		m.ResetRequirements()
		return nil
	case jobposting.FieldLocation:
		m.ResetLocation()
		return nil
	case jobposting.FieldSalaryRange:
		m.ResetSalaryRange()
		return nil
	case jobposting.FieldStatus:
		m.ResetStatus()
		return nil
	case jobposting.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case jobposting.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown JobPosting field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *JobPostingMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.tenant != nil {
		edges = append(edges, jobposting.EdgeTenant)
	}
	if m.applications != nil {
		edges = append(edges, jobposting.EdgeApplications)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *JobPostingMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case jobposting.EdgeTenant:
		if id := m.tenant; id != nil {
			return []ent.Value{*id}
		}
	case jobposting.EdgeApplications:
		ids := make([]ent.Value, 0, len(m.applications))
		for id := range m.applications {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *JobPostingMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedapplications != nil {
		edges = append(edges, jobposting.EdgeApplications)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *JobPostingMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case jobposting.EdgeApplications:
		ids := make([]ent.Value, 0, len(m.removedapplications))
		for id := range m.removedapplications {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *JobPostingMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedtenant {
		edges = append(edges, jobposting.EdgeTenant)
	}
	if m.clearedapplications {
		edges = append(edges, jobposting.EdgeApplications)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *JobPostingMutation) EdgeCleared(name string) bool {
	switch name {
	case jobposting.EdgeTenant:
		return m.clearedtenant
	case jobposting.EdgeApplications:
		return m.clearedapplications
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *JobPostingMutation) ClearEdge(name string) error {
	switch name {
	case jobposting.EdgeTenant:
		m.ClearTenant()
		return nil
	}
	return fmt.Errorf("unknown JobPosting unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *JobPostingMutation) ResetEdge(name string) error {
	switch name {
	case jobposting.EdgeTenant:
		m.ResetTenant()
		return nil
	case jobposting.EdgeApplications:
		m.ResetApplications()
		return nil
	}
	return fmt.Errorf("unknown JobPosting edge %s", name)
}

// JournalEntryMutation represents an operation that mutates the JournalEntry nodes in the graph.
type JournalEntryMutation struct {
	config
	op                 Op
	typ                string
	id                 *int
	amount             *decimal.Decimal
	direction          *journalentry.Direction
	created_at         *time.Time
	description        *string
	approval_status    *journalentry.ApprovalStatus
	clearedFields      map[string]struct{}
	account            *int
	clearedaccount     bool
	tenant             *int
	clearedtenant      bool
	transaction        *int
	clearedtransaction bool
	approved_by        *int
	clearedapproved_by bool
	done               bool
	oldValue           func(context.Context) (*JournalEntry, error)
	predicates         []predicate.JournalEntry
}

var _ ent.Mutation = (*JournalEntryMutation)(nil)

// journalentryOption allows management of the mutation configuration using functional options.
type journalentryOption func(*JournalEntryMutation)

// newJournalEntryMutation creates new mutation for the JournalEntry entity.
func newJournalEntryMutation(c config, op Op, opts ...journalentryOption) *JournalEntryMutation {
	m := &JournalEntryMutation{
		config:        c,
		op:            op,
		typ:           TypeJournalEntry,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withJournalEntryID sets the ID field of the mutation.
func withJournalEntryID(id int) journalentryOption {
	return func(m *JournalEntryMutation) {
		var (
			err   error
			once  sync.Once
			value *JournalEntry
		)
		m.oldValue = func(ctx context.Context) (*JournalEntry, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().JournalEntry.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withJournalEntry sets the old JournalEntry of the mutation.
func withJournalEntry(node *JournalEntry) journalentryOption {
	return func(m *JournalEntryMutation) {
		m.oldValue = func(context.Context) (*JournalEntry, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m JournalEntryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m JournalEntryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *JournalEntryMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *JournalEntryMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().JournalEntry.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetAmount sets the "amount" field.
func (m *JournalEntryMutation) SetAmount(d decimal.Decimal) {
	m.amount = &d
}

// Amount returns the value of the "amount" field in the mutation.
func (m *JournalEntryMutation) Amount() (r decimal.Decimal, exists bool) {
	v := m.amount
	if v == nil {
		return
	}
	return *v, true
}

// OldAmount returns the old "amount" field's value of the JournalEntry entity.
// If the JournalEntry object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JournalEntryMutation) OldAmount(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAmount: %w", err)
	}
	return oldValue.Amount, nil
}

// ResetAmount resets all changes to the "amount" field.
func (m *JournalEntryMutation) ResetAmount() {
	m.amount = nil
}

// SetDirection sets the "direction" field.
func (m *JournalEntryMutation) SetDirection(j journalentry.Direction) {
	m.direction = &j
}

// Direction returns the value of the "direction" field in the mutation.
func (m *JournalEntryMutation) Direction() (r journalentry.Direction, exists bool) {
	v := m.direction
	if v == nil {
		return
	}
	return *v, true
}

// OldDirection returns the old "direction" field's value of the JournalEntry entity.
// If the JournalEntry object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JournalEntryMutation) OldDirection(ctx context.Context) (v journalentry.Direction, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDirection is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDirection requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDirection: %w", err)
	}
	return oldValue.Direction, nil
}

// ResetDirection resets all changes to the "direction" field.
func (m *JournalEntryMutation) ResetDirection() {
	m.direction = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *JournalEntryMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *JournalEntryMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the JournalEntry entity.
// If the JournalEntry object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JournalEntryMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *JournalEntryMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetDescription sets the "description" field.
func (m *JournalEntryMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *JournalEntryMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the JournalEntry entity.
// If the JournalEntry object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JournalEntryMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *JournalEntryMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[journalentry.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *JournalEntryMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[journalentry.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *JournalEntryMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, journalentry.FieldDescription)
}

// SetApprovalStatus sets the "approval_status" field.
func (m *JournalEntryMutation) SetApprovalStatus(js journalentry.ApprovalStatus) {
	m.approval_status = &js
}

// ApprovalStatus returns the value of the "approval_status" field in the mutation.
func (m *JournalEntryMutation) ApprovalStatus() (r journalentry.ApprovalStatus, exists bool) {
	v := m.approval_status
	if v == nil {
		return
	}
	return *v, true
}

// OldApprovalStatus returns the old "approval_status" field's value of the JournalEntry entity.
// If the JournalEntry object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JournalEntryMutation) OldApprovalStatus(ctx context.Context) (v journalentry.ApprovalStatus, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldApprovalStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldApprovalStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldApprovalStatus: %w", err)
	}
	return oldValue.ApprovalStatus, nil
}

// ResetApprovalStatus resets all changes to the "approval_status" field.
func (m *JournalEntryMutation) ResetApprovalStatus() {
	m.approval_status = nil
}

// SetApprovedByID sets the "approved_by_id" field.
func (m *JournalEntryMutation) SetApprovedByID(i int) {
	m.approved_by = &i
}

// ApprovedByID returns the value of the "approved_by_id" field in the mutation.
func (m *JournalEntryMutation) ApprovedByID() (r int, exists bool) {
	v := m.approved_by
	if v == nil {
		return
	}
	return *v, true
}

// OldApprovedByID returns the old "approved_by_id" field's value of the JournalEntry entity.
// If the JournalEntry object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JournalEntryMutation) OldApprovedByID(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldApprovedByID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldApprovedByID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldApprovedByID: %w", err)
	}
	return oldValue.ApprovedByID, nil
}

// ClearApprovedByID clears the value of the "approved_by_id" field.
func (m *JournalEntryMutation) ClearApprovedByID() {
	m.approved_by = nil
	m.clearedFields[journalentry.FieldApprovedByID] = struct{}{}
}

// ApprovedByIDCleared returns if the "approved_by_id" field was cleared in this mutation.
func (m *JournalEntryMutation) ApprovedByIDCleared() bool {
	_, ok := m.clearedFields[journalentry.FieldApprovedByID]
	return ok
}

// ResetApprovedByID resets all changes to the "approved_by_id" field.
func (m *JournalEntryMutation) ResetApprovedByID() {
	m.approved_by = nil
	delete(m.clearedFields, journalentry.FieldApprovedByID)
}

// SetAccountID sets the "account" edge to the Account entity by id.
func (m *JournalEntryMutation) SetAccountID(id int) {
	m.account = &id
}

// ClearAccount clears the "account" edge to the Account entity.
func (m *JournalEntryMutation) ClearAccount() {
	m.clearedaccount = true
}

// AccountCleared reports if the "account" edge to the Account entity was cleared.
func (m *JournalEntryMutation) AccountCleared() bool {
	return m.clearedaccount
}

// AccountID returns the "account" edge ID in the mutation.
func (m *JournalEntryMutation) AccountID() (id int, exists bool) {
	if m.account != nil {
		return *m.account, true
	}
	return
}

// AccountIDs returns the "account" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AccountID instead. It exists only for internal usage by the builders.
func (m *JournalEntryMutation) AccountIDs() (ids []int) {
	if id := m.account; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAccount resets all changes to the "account" edge.
func (m *JournalEntryMutation) ResetAccount() {
	m.account = nil
	m.clearedaccount = false
}

// SetTenantID sets the "tenant" edge to the Tenant entity by id.
func (m *JournalEntryMutation) SetTenantID(id int) {
	m.tenant = &id
}

// ClearTenant clears the "tenant" edge to the Tenant entity.
func (m *JournalEntryMutation) ClearTenant() {
	m.clearedtenant = true
}

// TenantCleared reports if the "tenant" edge to the Tenant entity was cleared.
func (m *JournalEntryMutation) TenantCleared() bool {
	return m.clearedtenant
}

// TenantID returns the "tenant" edge ID in the mutation.
func (m *JournalEntryMutation) TenantID() (id int, exists bool) {
	if m.tenant != nil {
		return *m.tenant, true
	}
	return
}

// TenantIDs returns the "tenant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TenantID instead. It exists only for internal usage by the builders.
func (m *JournalEntryMutation) TenantIDs() (ids []int) {
	if id := m.tenant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTenant resets all changes to the "tenant" edge.
func (m *JournalEntryMutation) ResetTenant() {
	m.tenant = nil
	m.clearedtenant = false
}

// SetTransactionID sets the "transaction" edge to the Transaction entity by id.
func (m *JournalEntryMutation) SetTransactionID(id int) {
	m.transaction = &id
}

// ClearTransaction clears the "transaction" edge to the Transaction entity.
func (m *JournalEntryMutation) ClearTransaction() {
	m.clearedtransaction = true
}

// TransactionCleared reports if the "transaction" edge to the Transaction entity was cleared.
func (m *JournalEntryMutation) TransactionCleared() bool {
	return m.clearedtransaction
}

// TransactionID returns the "transaction" edge ID in the mutation.
func (m *JournalEntryMutation) TransactionID() (id int, exists bool) {
	if m.transaction != nil {
		return *m.transaction, true
	}
	return
}

// TransactionIDs returns the "transaction" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TransactionID instead. It exists only for internal usage by the builders.
func (m *JournalEntryMutation) TransactionIDs() (ids []int) {
	if id := m.transaction; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTransaction resets all changes to the "transaction" edge.
func (m *JournalEntryMutation) ResetTransaction() {
	m.transaction = nil
	m.clearedtransaction = false
}

// ClearApprovedBy clears the "approved_by" edge to the User entity.
func (m *JournalEntryMutation) ClearApprovedBy() {
	m.clearedapproved_by = true
	m.clearedFields[journalentry.FieldApprovedByID] = struct{}{}
}

// ApprovedByCleared reports if the "approved_by" edge to the User entity was cleared.
func (m *JournalEntryMutation) ApprovedByCleared() bool {
	return m.ApprovedByIDCleared() || m.clearedapproved_by
}

// ApprovedByIDs returns the "approved_by" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ApprovedByID instead. It exists only for internal usage by the builders.
func (m *JournalEntryMutation) ApprovedByIDs() (ids []int) {
	if id := m.approved_by; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetApprovedBy resets all changes to the "approved_by" edge.
func (m *JournalEntryMutation) ResetApprovedBy() {
	m.approved_by = nil
	m.clearedapproved_by = false
}

// Where appends a list predicates to the JournalEntryMutation builder.
func (m *JournalEntryMutation) Where(ps ...predicate.JournalEntry) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the JournalEntryMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *JournalEntryMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.JournalEntry, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *JournalEntryMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *JournalEntryMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (JournalEntry).
func (m *JournalEntryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *JournalEntryMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.amount != nil {
		fields = append(fields, journalentry.FieldAmount)
	}
	if m.direction != nil {
		fields = append(fields, journalentry.FieldDirection)
	}
	if m.created_at != nil {
		fields = append(fields, journalentry.FieldCreatedAt)
	}
	if m.description != nil {
		fields = append(fields, journalentry.FieldDescription)
	}
	if m.approval_status != nil {
		fields = append(fields, journalentry.FieldApprovalStatus)
	}
	if m.approved_by != nil {
		fields = append(fields, journalentry.FieldApprovedByID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *JournalEntryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case journalentry.FieldAmount:
		return m.Amount()
	case journalentry.FieldDirection:
		return m.Direction()
	case journalentry.FieldCreatedAt:
		return m.CreatedAt()
	case journalentry.FieldDescription:
		return m.Description()
	case journalentry.FieldApprovalStatus:
		return m.ApprovalStatus()
	case journalentry.FieldApprovedByID:
		return m.ApprovedByID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *JournalEntryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case journalentry.FieldAmount:
		return m.OldAmount(ctx)
	case journalentry.FieldDirection:
		return m.OldDirection(ctx)
	case journalentry.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case journalentry.FieldDescription:
		return m.OldDescription(ctx)
	case journalentry.FieldApprovalStatus:
		return m.OldApprovalStatus(ctx)
	case journalentry.FieldApprovedByID:
		return m.OldApprovedByID(ctx)
	}
	return nil, fmt.Errorf("unknown JournalEntry field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *JournalEntryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case journalentry.FieldAmount:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAmount(v)
		return nil
	case journalentry.FieldDirection:
		v, ok := value.(journalentry.Direction)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDirection(v)
		return nil
	case journalentry.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case journalentry.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case journalentry.FieldApprovalStatus:
		v, ok := value.(journalentry.ApprovalStatus)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetApprovalStatus(v)
		return nil
	case journalentry.FieldApprovedByID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetApprovedByID(v)
		return nil
	}
	return fmt.Errorf("unknown JournalEntry field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *JournalEntryMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *JournalEntryMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *JournalEntryMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown JournalEntry numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *JournalEntryMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(journalentry.FieldDescription) {
		fields = append(fields, journalentry.FieldDescription)
	}
	if m.FieldCleared(journalentry.FieldApprovedByID) {
		fields = append(fields, journalentry.FieldApprovedByID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *JournalEntryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *JournalEntryMutation) ClearField(name string) error {
	switch name {
	case journalentry.FieldDescription:
		m.ClearDescription()
		return nil
	case journalentry.FieldApprovedByID:
		m.ClearApprovedByID()
		return nil
	}
	return fmt.Errorf("unknown JournalEntry nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *JournalEntryMutation) ResetField(name string) error {
	switch name {
	case journalentry.FieldAmount:
		m.ResetAmount()
		return nil
	case journalentry.FieldDirection:
		m.ResetDirection()
		return nil
	case journalentry.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case journalentry.FieldDescription:
		m.ResetDescription()
		return nil
	case journalentry.FieldApprovalStatus:
		m.ResetApprovalStatus()
		return nil
	case journalentry.FieldApprovedByID:
		m.ResetApprovedByID()
		return nil
	}
	return fmt.Errorf("unknown JournalEntry field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *JournalEntryMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.account != nil {
		edges = append(edges, journalentry.EdgeAccount)
	}
	if m.tenant != nil {
		edges = append(edges, journalentry.EdgeTenant)
	}
	if m.transaction != nil {
		edges = append(edges, journalentry.EdgeTransaction)
	}
	if m.approved_by != nil {
		edges = append(edges, journalentry.EdgeApprovedBy)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *JournalEntryMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case journalentry.EdgeAccount:
		if id := m.account; id != nil {
			return []ent.Value{*id}
		}
	case journalentry.EdgeTenant:
		if id := m.tenant; id != nil {
			return []ent.Value{*id}
		}
	case journalentry.EdgeTransaction:
		if id := m.transaction; id != nil {
			return []ent.Value{*id}
		}
	case journalentry.EdgeApprovedBy:
		if id := m.approved_by; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *JournalEntryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *JournalEntryMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *JournalEntryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedaccount {
		edges = append(edges, journalentry.EdgeAccount)
	}
	if m.clearedtenant {
		edges = append(edges, journalentry.EdgeTenant)
	}
	if m.clearedtransaction {
		edges = append(edges, journalentry.EdgeTransaction)
	}
	if m.clearedapproved_by {
		edges = append(edges, journalentry.EdgeApprovedBy)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *JournalEntryMutation) EdgeCleared(name string) bool {
	switch name {
	case journalentry.EdgeAccount:
		return m.clearedaccount
	case journalentry.EdgeTenant:
		return m.clearedtenant
	case journalentry.EdgeTransaction:
		return m.clearedtransaction
	case journalentry.EdgeApprovedBy:
		return m.clearedapproved_by
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *JournalEntryMutation) ClearEdge(name string) error {
	switch name {
	case journalentry.EdgeAccount:
		m.ClearAccount()
		return nil
	case journalentry.EdgeTenant:
		m.ClearTenant()
		return nil
	case journalentry.EdgeTransaction:
		m.ClearTransaction()
		return nil
	case journalentry.EdgeApprovedBy:
		m.ClearApprovedBy()
		return nil
	}
	return fmt.Errorf("unknown JournalEntry unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *JournalEntryMutation) ResetEdge(name string) error {
	switch name {
	case journalentry.EdgeAccount:
		m.ResetAccount()
		return nil
	case journalentry.EdgeTenant:
		m.ResetTenant()
		return nil
	case journalentry.EdgeTransaction:
		m.ResetTransaction()
		return nil
	case journalentry.EdgeApprovedBy:
		m.ResetApprovedBy()
		return nil
	}
	return fmt.Errorf("unknown JournalEntry edge %s", name)
}

// LedgerEntryMutation represents an operation that mutates the LedgerEntry nodes in the graph.
type LedgerEntryMutation struct {
	config
	op                 Op
	typ                string
	id                 *int
	amount             *decimal.Decimal
	direction          *ledgerentry.Direction
	created_at         *time.Time
	clearedFields      map[string]struct{}
	transaction        *int
	clearedtransaction bool
	account            *int
	clearedaccount     bool
	tenant             *int
	clearedtenant      bool
	done               bool
	oldValue           func(context.Context) (*LedgerEntry, error)
	predicates         []predicate.LedgerEntry
}

var _ ent.Mutation = (*LedgerEntryMutation)(nil)

// ledgerentryOption allows management of the mutation configuration using functional options.
type ledgerentryOption func(*LedgerEntryMutation)

// newLedgerEntryMutation creates new mutation for the LedgerEntry entity.
func newLedgerEntryMutation(c config, op Op, opts ...ledgerentryOption) *LedgerEntryMutation {
	m := &LedgerEntryMutation{
		config:        c,
		op:            op,
		typ:           TypeLedgerEntry,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withLedgerEntryID sets the ID field of the mutation.
func withLedgerEntryID(id int) ledgerentryOption {
	return func(m *LedgerEntryMutation) {
		var (
			err   error
			once  sync.Once
			value *LedgerEntry
		)
		m.oldValue = func(ctx context.Context) (*LedgerEntry, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().LedgerEntry.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withLedgerEntry sets the old LedgerEntry of the mutation.
func withLedgerEntry(node *LedgerEntry) ledgerentryOption {
	return func(m *LedgerEntryMutation) {
		m.oldValue = func(context.Context) (*LedgerEntry, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m LedgerEntryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m LedgerEntryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *LedgerEntryMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *LedgerEntryMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().LedgerEntry.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetAmount sets the "amount" field.
func (m *LedgerEntryMutation) SetAmount(d decimal.Decimal) {
	m.amount = &d
}

// Amount returns the value of the "amount" field in the mutation.
func (m *LedgerEntryMutation) Amount() (r decimal.Decimal, exists bool) {
	v := m.amount
	if v == nil {
		return
	}
	return *v, true
}

// OldAmount returns the old "amount" field's value of the LedgerEntry entity.
// If the LedgerEntry object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LedgerEntryMutation) OldAmount(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAmount: %w", err)
	}
	return oldValue.Amount, nil
}

// ResetAmount resets all changes to the "amount" field.
func (m *LedgerEntryMutation) ResetAmount() {
	m.amount = nil
}

// SetDirection sets the "direction" field.
func (m *LedgerEntryMutation) SetDirection(l ledgerentry.Direction) {
	m.direction = &l
}

// Direction returns the value of the "direction" field in the mutation.
func (m *LedgerEntryMutation) Direction() (r ledgerentry.Direction, exists bool) {
	v := m.direction
	if v == nil {
		return
	}
	return *v, true
}

// OldDirection returns the old "direction" field's value of the LedgerEntry entity.
// If the LedgerEntry object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LedgerEntryMutation) OldDirection(ctx context.Context) (v ledgerentry.Direction, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDirection is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDirection requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDirection: %w", err)
	}
	return oldValue.Direction, nil
}

// ResetDirection resets all changes to the "direction" field.
func (m *LedgerEntryMutation) ResetDirection() {
	m.direction = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *LedgerEntryMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *LedgerEntryMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the LedgerEntry entity.
// If the LedgerEntry object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LedgerEntryMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *LedgerEntryMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetTransactionID sets the "transaction" edge to the Transaction entity by id.
func (m *LedgerEntryMutation) SetTransactionID(id int) {
	m.transaction = &id
}

// ClearTransaction clears the "transaction" edge to the Transaction entity.
func (m *LedgerEntryMutation) ClearTransaction() {
	m.clearedtransaction = true
}

// TransactionCleared reports if the "transaction" edge to the Transaction entity was cleared.
func (m *LedgerEntryMutation) TransactionCleared() bool {
	return m.clearedtransaction
}

// TransactionID returns the "transaction" edge ID in the mutation.
func (m *LedgerEntryMutation) TransactionID() (id int, exists bool) {
	if m.transaction != nil {
		return *m.transaction, true
	}
	return
}

// TransactionIDs returns the "transaction" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TransactionID instead. It exists only for internal usage by the builders.
func (m *LedgerEntryMutation) TransactionIDs() (ids []int) {
	if id := m.transaction; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTransaction resets all changes to the "transaction" edge.
func (m *LedgerEntryMutation) ResetTransaction() {
	m.transaction = nil
	m.clearedtransaction = false
}

// SetAccountID sets the "account" edge to the Account entity by id.
func (m *LedgerEntryMutation) SetAccountID(id int) {
	m.account = &id
}

// ClearAccount clears the "account" edge to the Account entity.
func (m *LedgerEntryMutation) ClearAccount() {
	m.clearedaccount = true
}

// AccountCleared reports if the "account" edge to the Account entity was cleared.
func (m *LedgerEntryMutation) AccountCleared() bool {
	return m.clearedaccount
}

// AccountID returns the "account" edge ID in the mutation.
func (m *LedgerEntryMutation) AccountID() (id int, exists bool) {
	if m.account != nil {
		return *m.account, true
	}
	return
}

// AccountIDs returns the "account" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AccountID instead. It exists only for internal usage by the builders.
func (m *LedgerEntryMutation) AccountIDs() (ids []int) {
	if id := m.account; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAccount resets all changes to the "account" edge.
func (m *LedgerEntryMutation) ResetAccount() {
	m.account = nil
	m.clearedaccount = false
}

// SetTenantID sets the "tenant" edge to the Tenant entity by id.
func (m *LedgerEntryMutation) SetTenantID(id int) {
	m.tenant = &id
}

// ClearTenant clears the "tenant" edge to the Tenant entity.
func (m *LedgerEntryMutation) ClearTenant() {
	m.clearedtenant = true
}

// TenantCleared reports if the "tenant" edge to the Tenant entity was cleared.
func (m *LedgerEntryMutation) TenantCleared() bool {
	return m.clearedtenant
}

// TenantID returns the "tenant" edge ID in the mutation.
func (m *LedgerEntryMutation) TenantID() (id int, exists bool) {
	if m.tenant != nil {
		return *m.tenant, true
	}
	return
}

// TenantIDs returns the "tenant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TenantID instead. It exists only for internal usage by the builders.
func (m *LedgerEntryMutation) TenantIDs() (ids []int) {
	if id := m.tenant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTenant resets all changes to the "tenant" edge.
func (m *LedgerEntryMutation) ResetTenant() {
	m.tenant = nil
	m.clearedtenant = false
}

// Where appends a list predicates to the LedgerEntryMutation builder.
func (m *LedgerEntryMutation) Where(ps ...predicate.LedgerEntry) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the LedgerEntryMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *LedgerEntryMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.LedgerEntry, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *LedgerEntryMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *LedgerEntryMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (LedgerEntry).
func (m *LedgerEntryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *LedgerEntryMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.amount != nil {
		fields = append(fields, ledgerentry.FieldAmount)
	}
	if m.direction != nil {
		fields = append(fields, ledgerentry.FieldDirection)
	}
	if m.created_at != nil {
		fields = append(fields, ledgerentry.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *LedgerEntryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case ledgerentry.FieldAmount:
		return m.Amount()
	case ledgerentry.FieldDirection:
		return m.Direction()
	case ledgerentry.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *LedgerEntryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case ledgerentry.FieldAmount:
		return m.OldAmount(ctx)
	case ledgerentry.FieldDirection:
		return m.OldDirection(ctx)
	case ledgerentry.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown LedgerEntry field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LedgerEntryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case ledgerentry.FieldAmount:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAmount(v)
		return nil
	case ledgerentry.FieldDirection:
		v, ok := value.(ledgerentry.Direction)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDirection(v)
		return nil
	case ledgerentry.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown LedgerEntry field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *LedgerEntryMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *LedgerEntryMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LedgerEntryMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown LedgerEntry numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *LedgerEntryMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *LedgerEntryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *LedgerEntryMutation) ClearField(name string) error {
	return fmt.Errorf("unknown LedgerEntry nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *LedgerEntryMutation) ResetField(name string) error {
	switch name {
	case ledgerentry.FieldAmount:
		m.ResetAmount()
		return nil
	case ledgerentry.FieldDirection:
		m.ResetDirection()
		return nil
	case ledgerentry.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown LedgerEntry field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *LedgerEntryMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.transaction != nil {
		edges = append(edges, ledgerentry.EdgeTransaction)
	}
	if m.account != nil {
		edges = append(edges, ledgerentry.EdgeAccount)
	}
	if m.tenant != nil {
		edges = append(edges, ledgerentry.EdgeTenant)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *LedgerEntryMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case ledgerentry.EdgeTransaction:
		if id := m.transaction; id != nil {
			return []ent.Value{*id}
		}
	case ledgerentry.EdgeAccount:
		if id := m.account; id != nil {
			return []ent.Value{*id}
		}
	case ledgerentry.EdgeTenant:
		if id := m.tenant; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *LedgerEntryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *LedgerEntryMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *LedgerEntryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedtransaction {
		edges = append(edges, ledgerentry.EdgeTransaction)
	}
	if m.clearedaccount {
		edges = append(edges, ledgerentry.EdgeAccount)
	}
	if m.clearedtenant {
		edges = append(edges, ledgerentry.EdgeTenant)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *LedgerEntryMutation) EdgeCleared(name string) bool {
	switch name {
	case ledgerentry.EdgeTransaction:
		return m.clearedtransaction
	case ledgerentry.EdgeAccount:
		return m.clearedaccount
	case ledgerentry.EdgeTenant:
		return m.clearedtenant
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *LedgerEntryMutation) ClearEdge(name string) error {
	switch name {
	case ledgerentry.EdgeTransaction:
		m.ClearTransaction()
		return nil
	case ledgerentry.EdgeAccount:
		m.ClearAccount()
		return nil
	case ledgerentry.EdgeTenant:
		m.ClearTenant()
		return nil
	}
	return fmt.Errorf("unknown LedgerEntry unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *LedgerEntryMutation) ResetEdge(name string) error {
	switch name {
	case ledgerentry.EdgeTransaction:
		m.ResetTransaction()
		return nil
	case ledgerentry.EdgeAccount:
		m.ResetAccount()
		return nil
	case ledgerentry.EdgeTenant:
		m.ResetTenant()
		return nil
	}
	return fmt.Errorf("unknown LedgerEntry edge %s", name)
}

// LegalHoldMutation represents an operation that mutates the LegalHold nodes in the graph.
type LegalHoldMutation struct {
	config
	op                Op
	typ               string
	id                *int
	name              *string
	description       *string
	start_date        *time.Time
	end_date          *time.Time
	active            *bool
	created_at        *time.Time
	clearedFields     map[string]struct{}
	tenant            *int
	clearedtenant     bool
	created_by        *int
	clearedcreated_by bool
	items             map[int]struct{}
	removeditems      map[int]struct{}
	cleareditems      bool
	done              bool
	oldValue          func(context.Context) (*LegalHold, error)
	predicates        []predicate.LegalHold
}

var _ ent.Mutation = (*LegalHoldMutation)(nil)

// legalholdOption allows management of the mutation configuration using functional options.
type legalholdOption func(*LegalHoldMutation)

// newLegalHoldMutation creates new mutation for the LegalHold entity.
func newLegalHoldMutation(c config, op Op, opts ...legalholdOption) *LegalHoldMutation {
	m := &LegalHoldMutation{
		config:        c,
		op:            op,
		typ:           TypeLegalHold,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withLegalHoldID sets the ID field of the mutation.
func withLegalHoldID(id int) legalholdOption {
	return func(m *LegalHoldMutation) {
		var (
			err   error
			once  sync.Once
			value *LegalHold
		)
		m.oldValue = func(ctx context.Context) (*LegalHold, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().LegalHold.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withLegalHold sets the old LegalHold of the mutation.
func withLegalHold(node *LegalHold) legalholdOption {
	return func(m *LegalHoldMutation) {
		m.oldValue = func(context.Context) (*LegalHold, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m LegalHoldMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m LegalHoldMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *LegalHoldMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *LegalHoldMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().LegalHold.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *LegalHoldMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *LegalHoldMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the LegalHold entity.
// If the LegalHold object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LegalHoldMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *LegalHoldMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *LegalHoldMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *LegalHoldMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the LegalHold entity.
// If the LegalHold object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LegalHoldMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *LegalHoldMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[legalhold.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *LegalHoldMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[legalhold.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *LegalHoldMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, legalhold.FieldDescription)
}

// SetStartDate sets the "start_date" field.
func (m *LegalHoldMutation) SetStartDate(t time.Time) {
	m.start_date = &t
}

// StartDate returns the value of the "start_date" field in the mutation.
func (m *LegalHoldMutation) StartDate() (r time.Time, exists bool) {
	v := m.start_date
	if v == nil {
		return
	}
	return *v, true
}

// OldStartDate returns the old "start_date" field's value of the LegalHold entity.
// If the LegalHold object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LegalHoldMutation) OldStartDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartDate: %w", err)
	}
	return oldValue.StartDate, nil
}

// ResetStartDate resets all changes to the "start_date" field.
func (m *LegalHoldMutation) ResetStartDate() {
	m.start_date = nil
}

// SetEndDate sets the "end_date" field.
func (m *LegalHoldMutation) SetEndDate(t time.Time) {
	m.end_date = &t
}

// EndDate returns the value of the "end_date" field in the mutation.
func (m *LegalHoldMutation) EndDate() (r time.Time, exists bool) {
	v := m.end_date
	if v == nil {
		return
	}
	return *v, true
}

// OldEndDate returns the old "end_date" field's value of the LegalHold entity.
// If the LegalHold object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LegalHoldMutation) OldEndDate(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEndDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEndDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndDate: %w", err)
	}
	return oldValue.EndDate, nil
}

// ClearEndDate clears the value of the "end_date" field.
func (m *LegalHoldMutation) ClearEndDate() {
	m.end_date = nil
	m.clearedFields[legalhold.FieldEndDate] = struct{}{}
}

// EndDateCleared returns if the "end_date" field was cleared in this mutation.
func (m *LegalHoldMutation) EndDateCleared() bool {
	_, ok := m.clearedFields[legalhold.FieldEndDate]
	return ok
}

// ResetEndDate resets all changes to the "end_date" field.
func (m *LegalHoldMutation) ResetEndDate() {
	m.end_date = nil
	delete(m.clearedFields, legalhold.FieldEndDate)
}

// SetActive sets the "active" field.
func (m *LegalHoldMutation) SetActive(b bool) {
	m.active = &b
}

// Active returns the value of the "active" field in the mutation.
func (m *LegalHoldMutation) Active() (r bool, exists bool) {
	v := m.active
	if v == nil {
		return
	}
	return *v, true
}

// OldActive returns the old "active" field's value of the LegalHold entity.
// If the LegalHold object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LegalHoldMutation) OldActive(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldActive is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldActive requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldActive: %w", err)
	}
	return oldValue.Active, nil
}

// ResetActive resets all changes to the "active" field.
func (m *LegalHoldMutation) ResetActive() {
	m.active = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *LegalHoldMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *LegalHoldMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the LegalHold entity.
// If the LegalHold object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LegalHoldMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *LegalHoldMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetTenantID sets the "tenant" edge to the Tenant entity by id.
func (m *LegalHoldMutation) SetTenantID(id int) {
	m.tenant = &id
}

// ClearTenant clears the "tenant" edge to the Tenant entity.
func (m *LegalHoldMutation) ClearTenant() {
	m.clearedtenant = true
}

// TenantCleared reports if the "tenant" edge to the Tenant entity was cleared.
func (m *LegalHoldMutation) TenantCleared() bool {
	return m.clearedtenant
}

// TenantID returns the "tenant" edge ID in the mutation.
func (m *LegalHoldMutation) TenantID() (id int, exists bool) {
	if m.tenant != nil {
		return *m.tenant, true
	}
	return
}

// TenantIDs returns the "tenant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TenantID instead. It exists only for internal usage by the builders.
func (m *LegalHoldMutation) TenantIDs() (ids []int) {
	if id := m.tenant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTenant resets all changes to the "tenant" edge.
func (m *LegalHoldMutation) ResetTenant() {
	m.tenant = nil
	m.clearedtenant = false
}

// SetCreatedByID sets the "created_by" edge to the User entity by id.
func (m *LegalHoldMutation) SetCreatedByID(id int) {
	m.created_by = &id
}

// ClearCreatedBy clears the "created_by" edge to the User entity.
func (m *LegalHoldMutation) ClearCreatedBy() {
	m.clearedcreated_by = true
}

// CreatedByCleared reports if the "created_by" edge to the User entity was cleared.
func (m *LegalHoldMutation) CreatedByCleared() bool {
	return m.clearedcreated_by
}

// CreatedByID returns the "created_by" edge ID in the mutation.
func (m *LegalHoldMutation) CreatedByID() (id int, exists bool) {
	if m.created_by != nil {
		return *m.created_by, true
	}
	return
}

// CreatedByIDs returns the "created_by" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CreatedByID instead. It exists only for internal usage by the builders.
func (m *LegalHoldMutation) CreatedByIDs() (ids []int) {
	if id := m.created_by; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCreatedBy resets all changes to the "created_by" edge.
func (m *LegalHoldMutation) ResetCreatedBy() {
	m.created_by = nil
	m.clearedcreated_by = false
}

// AddItemIDs adds the "items" edge to the VaultItem entity by ids.
func (m *LegalHoldMutation) AddItemIDs(ids ...int) {
	if m.items == nil {
		m.items = make(map[int]struct{})
	}
	for i := range ids {
		m.items[ids[i]] = struct{}{}
	}
}

// ClearItems clears the "items" edge to the VaultItem entity.
func (m *LegalHoldMutation) ClearItems() {
	m.cleareditems = true
}

// ItemsCleared reports if the "items" edge to the VaultItem entity was cleared.
func (m *LegalHoldMutation) ItemsCleared() bool {
	return m.cleareditems
}

// RemoveItemIDs removes the "items" edge to the VaultItem entity by IDs.
func (m *LegalHoldMutation) RemoveItemIDs(ids ...int) {
	if m.removeditems == nil {
		m.removeditems = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.items, ids[i])
		m.removeditems[ids[i]] = struct{}{}
	}
}

// RemovedItems returns the removed IDs of the "items" edge to the VaultItem entity.
func (m *LegalHoldMutation) RemovedItemsIDs() (ids []int) {
	for id := range m.removeditems {
		ids = append(ids, id)
	}
	return
}

// ItemsIDs returns the "items" edge IDs in the mutation.
func (m *LegalHoldMutation) ItemsIDs() (ids []int) {
	for id := range m.items {
		ids = append(ids, id)
	}
	return
}

// ResetItems resets all changes to the "items" edge.
func (m *LegalHoldMutation) ResetItems() {
	m.items = nil
	m.cleareditems = false
	m.removeditems = nil
}

// Where appends a list predicates to the LegalHoldMutation builder.
func (m *LegalHoldMutation) Where(ps ...predicate.LegalHold) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the LegalHoldMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *LegalHoldMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.LegalHold, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *LegalHoldMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *LegalHoldMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (LegalHold).
func (m *LegalHoldMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *LegalHoldMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.name != nil {
		fields = append(fields, legalhold.FieldName)
	}
	if m.description != nil {
		fields = append(fields, legalhold.FieldDescription)
	}
	if m.start_date != nil {
		fields = append(fields, legalhold.FieldStartDate)
	}
	if m.end_date != nil {
		fields = append(fields, legalhold.FieldEndDate)
	}
	if m.active != nil {
		fields = append(fields, legalhold.FieldActive)
	}
	if m.created_at != nil {
		fields = append(fields, legalhold.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *LegalHoldMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case legalhold.FieldName:
		return m.Name()
	case legalhold.FieldDescription:
		return m.Description()
	case legalhold.FieldStartDate:
		return m.StartDate()
	case legalhold.FieldEndDate:
		return m.EndDate()
	case legalhold.FieldActive:
		return m.Active()
	case legalhold.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *LegalHoldMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case legalhold.FieldName:
		return m.OldName(ctx)
	case legalhold.FieldDescription:
		return m.OldDescription(ctx)
	case legalhold.FieldStartDate:
		return m.OldStartDate(ctx)
	case legalhold.FieldEndDate:
		return m.OldEndDate(ctx)
	case legalhold.FieldActive:
		return m.OldActive(ctx)
	case legalhold.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown LegalHold field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LegalHoldMutation) SetField(name string, value ent.Value) error {
	switch name {
	case legalhold.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case legalhold.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case legalhold.FieldStartDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartDate(v)
		return nil
	case legalhold.FieldEndDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndDate(v)
		return nil
	case legalhold.FieldActive:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetActive(v)
		return nil
	case legalhold.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown LegalHold field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *LegalHoldMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *LegalHoldMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LegalHoldMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown LegalHold numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *LegalHoldMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(legalhold.FieldDescription) {
		fields = append(fields, legalhold.FieldDescription)
	}
	if m.FieldCleared(legalhold.FieldEndDate) {
		fields = append(fields, legalhold.FieldEndDate)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *LegalHoldMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *LegalHoldMutation) ClearField(name string) error {
	switch name {
	case legalhold.FieldDescription:
		m.ClearDescription()
		return nil
	case legalhold.FieldEndDate:
		m.ClearEndDate()
		return nil
	}
	return fmt.Errorf("unknown LegalHold nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *LegalHoldMutation) ResetField(name string) error {
	switch name {
	case legalhold.FieldName:
		m.ResetName()
		return nil
	case legalhold.FieldDescription:
		m.ResetDescription()
		return nil
	case legalhold.FieldStartDate:
		m.ResetStartDate()
		return nil
	case legalhold.FieldEndDate:
		m.ResetEndDate()
		return nil
	case legalhold.FieldActive:
		m.ResetActive()
		return nil
	case legalhold.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown LegalHold field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *LegalHoldMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.tenant != nil {
		edges = append(edges, legalhold.EdgeTenant)
	}
	if m.created_by != nil {
		edges = append(edges, legalhold.EdgeCreatedBy)
	}
	if m.items != nil {
		edges = append(edges, legalhold.EdgeItems)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *LegalHoldMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case legalhold.EdgeTenant:
		if id := m.tenant; id != nil {
			return []ent.Value{*id}
		}
	case legalhold.EdgeCreatedBy:
		if id := m.created_by; id != nil {
			return []ent.Value{*id}
		}
	case legalhold.EdgeItems:
		ids := make([]ent.Value, 0, len(m.items))
		for id := range m.items {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *LegalHoldMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removeditems != nil {
		edges = append(edges, legalhold.EdgeItems)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *LegalHoldMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case legalhold.EdgeItems:
		ids := make([]ent.Value, 0, len(m.removeditems))
		for id := range m.removeditems {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *LegalHoldMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedtenant {
		edges = append(edges, legalhold.EdgeTenant)
	}
	if m.clearedcreated_by {
		edges = append(edges, legalhold.EdgeCreatedBy)
	}
	if m.cleareditems {
		edges = append(edges, legalhold.EdgeItems)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *LegalHoldMutation) EdgeCleared(name string) bool {
	switch name {
	case legalhold.EdgeTenant:
		return m.clearedtenant
	case legalhold.EdgeCreatedBy:
		return m.clearedcreated_by
	case legalhold.EdgeItems:
		return m.cleareditems
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *LegalHoldMutation) ClearEdge(name string) error {
	switch name {
	case legalhold.EdgeTenant:
		m.ClearTenant()
		return nil
	case legalhold.EdgeCreatedBy:
		m.ClearCreatedBy()
		return nil
	}
	return fmt.Errorf("unknown LegalHold unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *LegalHoldMutation) ResetEdge(name string) error {
	switch name {
	case legalhold.EdgeTenant:
		m.ResetTenant()
		return nil
	case legalhold.EdgeCreatedBy:
		m.ResetCreatedBy()
		return nil
	case legalhold.EdgeItems:
		m.ResetItems()
		return nil
	}
	return fmt.Errorf("unknown LegalHold edge %s", name)
}

// MaintenanceScheduleMutation represents an operation that mutates the MaintenanceSchedule nodes in the graph.
type MaintenanceScheduleMutation struct {
	config
	op             Op
	typ            string
	id             *int
	scheduled_at   *time.Time
	completed_at   *time.Time
	notes          *string
	status         *maintenanceschedule.Status
	created_at     *time.Time
	clearedFields  map[string]struct{}
	tenant         *int
	clearedtenant  bool
	product        *int
	clearedproduct bool
	done           bool
	oldValue       func(context.Context) (*MaintenanceSchedule, error)
	predicates     []predicate.MaintenanceSchedule
}

var _ ent.Mutation = (*MaintenanceScheduleMutation)(nil)

// maintenancescheduleOption allows management of the mutation configuration using functional options.
type maintenancescheduleOption func(*MaintenanceScheduleMutation)

// newMaintenanceScheduleMutation creates new mutation for the MaintenanceSchedule entity.
func newMaintenanceScheduleMutation(c config, op Op, opts ...maintenancescheduleOption) *MaintenanceScheduleMutation {
	m := &MaintenanceScheduleMutation{
		config:        c,
		op:            op,
		typ:           TypeMaintenanceSchedule,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMaintenanceScheduleID sets the ID field of the mutation.
func withMaintenanceScheduleID(id int) maintenancescheduleOption {
	return func(m *MaintenanceScheduleMutation) {
		var (
			err   error
			once  sync.Once
			value *MaintenanceSchedule
		)
		m.oldValue = func(ctx context.Context) (*MaintenanceSchedule, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().MaintenanceSchedule.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMaintenanceSchedule sets the old MaintenanceSchedule of the mutation.
func withMaintenanceSchedule(node *MaintenanceSchedule) maintenancescheduleOption {
	return func(m *MaintenanceScheduleMutation) {
		m.oldValue = func(context.Context) (*MaintenanceSchedule, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MaintenanceScheduleMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MaintenanceScheduleMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *MaintenanceScheduleMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *MaintenanceScheduleMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().MaintenanceSchedule.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetScheduledAt sets the "scheduled_at" field.
func (m *MaintenanceScheduleMutation) SetScheduledAt(t time.Time) {
	m.scheduled_at = &t
}

// ScheduledAt returns the value of the "scheduled_at" field in the mutation.
func (m *MaintenanceScheduleMutation) ScheduledAt() (r time.Time, exists bool) {
	v := m.scheduled_at
	if v == nil {
		return
	}
	return *v, true
}

// OldScheduledAt returns the old "scheduled_at" field's value of the MaintenanceSchedule entity.
// If the MaintenanceSchedule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MaintenanceScheduleMutation) OldScheduledAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldScheduledAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldScheduledAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldScheduledAt: %w", err)
	}
	return oldValue.ScheduledAt, nil
}

// ResetScheduledAt resets all changes to the "scheduled_at" field.
func (m *MaintenanceScheduleMutation) ResetScheduledAt() {
	m.scheduled_at = nil
}

// SetCompletedAt sets the "completed_at" field.
func (m *MaintenanceScheduleMutation) SetCompletedAt(t time.Time) {
	m.completed_at = &t
}

// CompletedAt returns the value of the "completed_at" field in the mutation.
func (m *MaintenanceScheduleMutation) CompletedAt() (r time.Time, exists bool) {
	v := m.completed_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCompletedAt returns the old "completed_at" field's value of the MaintenanceSchedule entity.
// If the MaintenanceSchedule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MaintenanceScheduleMutation) OldCompletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCompletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCompletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCompletedAt: %w", err)
	}
	return oldValue.CompletedAt, nil
}

// ClearCompletedAt clears the value of the "completed_at" field.
func (m *MaintenanceScheduleMutation) ClearCompletedAt() {
	m.completed_at = nil
	m.clearedFields[maintenanceschedule.FieldCompletedAt] = struct{}{}
}

// CompletedAtCleared returns if the "completed_at" field was cleared in this mutation.
func (m *MaintenanceScheduleMutation) CompletedAtCleared() bool {
	_, ok := m.clearedFields[maintenanceschedule.FieldCompletedAt]
	return ok
}

// ResetCompletedAt resets all changes to the "completed_at" field.
func (m *MaintenanceScheduleMutation) ResetCompletedAt() {
	m.completed_at = nil
	delete(m.clearedFields, maintenanceschedule.FieldCompletedAt)
}

// SetNotes sets the "notes" field.
func (m *MaintenanceScheduleMutation) SetNotes(s string) {
	m.notes = &s
}

// Notes returns the value of the "notes" field in the mutation.
func (m *MaintenanceScheduleMutation) Notes() (r string, exists bool) {
	v := m.notes
	if v == nil {
		return
	}
	return *v, true
}

// OldNotes returns the old "notes" field's value of the MaintenanceSchedule entity.
// If the MaintenanceSchedule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MaintenanceScheduleMutation) OldNotes(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNotes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNotes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNotes: %w", err)
	}
	return oldValue.Notes, nil
}

// ClearNotes clears the value of the "notes" field.
func (m *MaintenanceScheduleMutation) ClearNotes() {
	m.notes = nil
	m.clearedFields[maintenanceschedule.FieldNotes] = struct{}{}
}

// NotesCleared returns if the "notes" field was cleared in this mutation.
func (m *MaintenanceScheduleMutation) NotesCleared() bool {
	_, ok := m.clearedFields[maintenanceschedule.FieldNotes]
	return ok
}

// ResetNotes resets all changes to the "notes" field.
func (m *MaintenanceScheduleMutation) ResetNotes() {
	m.notes = nil
	delete(m.clearedFields, maintenanceschedule.FieldNotes)
}

// SetStatus sets the "status" field.
func (m *MaintenanceScheduleMutation) SetStatus(value maintenanceschedule.Status) {
	m.status = &value
}

// Status returns the value of the "status" field in the mutation.
func (m *MaintenanceScheduleMutation) Status() (r maintenanceschedule.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the MaintenanceSchedule entity.
// If the MaintenanceSchedule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MaintenanceScheduleMutation) OldStatus(ctx context.Context) (v maintenanceschedule.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *MaintenanceScheduleMutation) ResetStatus() {
	m.status = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *MaintenanceScheduleMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *MaintenanceScheduleMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the MaintenanceSchedule entity.
// If the MaintenanceSchedule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MaintenanceScheduleMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *MaintenanceScheduleMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetTenantID sets the "tenant" edge to the Tenant entity by id.
func (m *MaintenanceScheduleMutation) SetTenantID(id int) {
	m.tenant = &id
}

// ClearTenant clears the "tenant" edge to the Tenant entity.
func (m *MaintenanceScheduleMutation) ClearTenant() {
	m.clearedtenant = true
}

// TenantCleared reports if the "tenant" edge to the Tenant entity was cleared.
func (m *MaintenanceScheduleMutation) TenantCleared() bool {
	return m.clearedtenant
}

// TenantID returns the "tenant" edge ID in the mutation.
func (m *MaintenanceScheduleMutation) TenantID() (id int, exists bool) {
	if m.tenant != nil {
		return *m.tenant, true
	}
	return
}

// TenantIDs returns the "tenant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TenantID instead. It exists only for internal usage by the builders.
func (m *MaintenanceScheduleMutation) TenantIDs() (ids []int) {
	if id := m.tenant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTenant resets all changes to the "tenant" edge.
func (m *MaintenanceScheduleMutation) ResetTenant() {
	m.tenant = nil
	m.clearedtenant = false
}

// SetProductID sets the "product" edge to the Product entity by id.
func (m *MaintenanceScheduleMutation) SetProductID(id int) {
	m.product = &id
}

// ClearProduct clears the "product" edge to the Product entity.
func (m *MaintenanceScheduleMutation) ClearProduct() {
	m.clearedproduct = true
}

// ProductCleared reports if the "product" edge to the Product entity was cleared.
func (m *MaintenanceScheduleMutation) ProductCleared() bool {
	return m.clearedproduct
}

// ProductID returns the "product" edge ID in the mutation.
func (m *MaintenanceScheduleMutation) ProductID() (id int, exists bool) {
	if m.product != nil {
		return *m.product, true
	}
	return
}

// ProductIDs returns the "product" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProductID instead. It exists only for internal usage by the builders.
func (m *MaintenanceScheduleMutation) ProductIDs() (ids []int) {
	if id := m.product; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProduct resets all changes to the "product" edge.
func (m *MaintenanceScheduleMutation) ResetProduct() {
	m.product = nil
	m.clearedproduct = false
}

// Where appends a list predicates to the MaintenanceScheduleMutation builder.
func (m *MaintenanceScheduleMutation) Where(ps ...predicate.MaintenanceSchedule) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the MaintenanceScheduleMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *MaintenanceScheduleMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.MaintenanceSchedule, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *MaintenanceScheduleMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *MaintenanceScheduleMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (MaintenanceSchedule).
func (m *MaintenanceScheduleMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *MaintenanceScheduleMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.scheduled_at != nil {
		fields = append(fields, maintenanceschedule.FieldScheduledAt)
	}
	if m.completed_at != nil {
		fields = append(fields, maintenanceschedule.FieldCompletedAt)
	}
	if m.notes != nil {
		fields = append(fields, maintenanceschedule.FieldNotes)
	}
	if m.status != nil {
		fields = append(fields, maintenanceschedule.FieldStatus)
	}
	if m.created_at != nil {
		fields = append(fields, maintenanceschedule.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *MaintenanceScheduleMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case maintenanceschedule.FieldScheduledAt:
		return m.ScheduledAt()
	case maintenanceschedule.FieldCompletedAt:
		return m.CompletedAt()
	case maintenanceschedule.FieldNotes:
		return m.Notes()
	case maintenanceschedule.FieldStatus:
		return m.Status()
	case maintenanceschedule.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *MaintenanceScheduleMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case maintenanceschedule.FieldScheduledAt:
		return m.OldScheduledAt(ctx)
	case maintenanceschedule.FieldCompletedAt:
		return m.OldCompletedAt(ctx)
	case maintenanceschedule.FieldNotes:
		return m.OldNotes(ctx)
	case maintenanceschedule.FieldStatus:
		return m.OldStatus(ctx)
	case maintenanceschedule.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown MaintenanceSchedule field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MaintenanceScheduleMutation) SetField(name string, value ent.Value) error {
	switch name {
	case maintenanceschedule.FieldScheduledAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetScheduledAt(v)
		return nil
	case maintenanceschedule.FieldCompletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCompletedAt(v)
		return nil
	case maintenanceschedule.FieldNotes:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNotes(v)
		return nil
	case maintenanceschedule.FieldStatus:
		v, ok := value.(maintenanceschedule.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case maintenanceschedule.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown MaintenanceSchedule field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *MaintenanceScheduleMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *MaintenanceScheduleMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MaintenanceScheduleMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown MaintenanceSchedule numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *MaintenanceScheduleMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(maintenanceschedule.FieldCompletedAt) {
		fields = append(fields, maintenanceschedule.FieldCompletedAt)
	}
	if m.FieldCleared(maintenanceschedule.FieldNotes) {
		fields = append(fields, maintenanceschedule.FieldNotes)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *MaintenanceScheduleMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *MaintenanceScheduleMutation) ClearField(name string) error {
	switch name {
	case maintenanceschedule.FieldCompletedAt:
		m.ClearCompletedAt()
		return nil
	case maintenanceschedule.FieldNotes:
		m.ClearNotes()
		return nil
	}
	return fmt.Errorf("unknown MaintenanceSchedule nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *MaintenanceScheduleMutation) ResetField(name string) error {
	switch name {
	case maintenanceschedule.FieldScheduledAt:
		m.ResetScheduledAt()
		return nil
	case maintenanceschedule.FieldCompletedAt:
		m.ResetCompletedAt()
		return nil
	case maintenanceschedule.FieldNotes:
		m.ResetNotes()
		return nil
	case maintenanceschedule.FieldStatus:
		m.ResetStatus()
		return nil
	case maintenanceschedule.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown MaintenanceSchedule field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *MaintenanceScheduleMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.tenant != nil {
		edges = append(edges, maintenanceschedule.EdgeTenant)
	}
	if m.product != nil {
		edges = append(edges, maintenanceschedule.EdgeProduct)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *MaintenanceScheduleMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case maintenanceschedule.EdgeTenant:
		if id := m.tenant; id != nil {
			return []ent.Value{*id}
		}
	case maintenanceschedule.EdgeProduct:
		if id := m.product; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *MaintenanceScheduleMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *MaintenanceScheduleMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *MaintenanceScheduleMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedtenant {
		edges = append(edges, maintenanceschedule.EdgeTenant)
	}
	if m.clearedproduct {
		edges = append(edges, maintenanceschedule.EdgeProduct)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *MaintenanceScheduleMutation) EdgeCleared(name string) bool {
	switch name {
	case maintenanceschedule.EdgeTenant:
		return m.clearedtenant
	case maintenanceschedule.EdgeProduct:
		return m.clearedproduct
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *MaintenanceScheduleMutation) ClearEdge(name string) error {
	switch name {
	case maintenanceschedule.EdgeTenant:
		m.ClearTenant()
		return nil
	case maintenanceschedule.EdgeProduct:
		m.ClearProduct()
		return nil
	}
	return fmt.Errorf("unknown MaintenanceSchedule unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *MaintenanceScheduleMutation) ResetEdge(name string) error {
	switch name {
	case maintenanceschedule.EdgeTenant:
		m.ResetTenant()
		return nil
	case maintenanceschedule.EdgeProduct:
		m.ResetProduct()
		return nil
	}
	return fmt.Errorf("unknown MaintenanceSchedule edge %s", name)
}

// NetworkBackupMutation represents an operation that mutates the NetworkBackup nodes in the graph.
type NetworkBackupMutation struct {
	config
	op            Op
	typ           string
	id            *int
	content_hash  *string
	vault_path    *string
	created_at    *time.Time
	clearedFields map[string]struct{}
	device        *int
	cleareddevice bool
	tenant        *int
	clearedtenant bool
	done          bool
	oldValue      func(context.Context) (*NetworkBackup, error)
	predicates    []predicate.NetworkBackup
}

var _ ent.Mutation = (*NetworkBackupMutation)(nil)

// networkbackupOption allows management of the mutation configuration using functional options.
type networkbackupOption func(*NetworkBackupMutation)

// newNetworkBackupMutation creates new mutation for the NetworkBackup entity.
func newNetworkBackupMutation(c config, op Op, opts ...networkbackupOption) *NetworkBackupMutation {
	m := &NetworkBackupMutation{
		config:        c,
		op:            op,
		typ:           TypeNetworkBackup,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withNetworkBackupID sets the ID field of the mutation.
func withNetworkBackupID(id int) networkbackupOption {
	return func(m *NetworkBackupMutation) {
		var (
			err   error
			once  sync.Once
			value *NetworkBackup
		)
		m.oldValue = func(ctx context.Context) (*NetworkBackup, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().NetworkBackup.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withNetworkBackup sets the old NetworkBackup of the mutation.
func withNetworkBackup(node *NetworkBackup) networkbackupOption {
	return func(m *NetworkBackupMutation) {
		m.oldValue = func(context.Context) (*NetworkBackup, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m NetworkBackupMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m NetworkBackupMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *NetworkBackupMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *NetworkBackupMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().NetworkBackup.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetContentHash sets the "content_hash" field.
func (m *NetworkBackupMutation) SetContentHash(s string) {
	m.content_hash = &s
}

// ContentHash returns the value of the "content_hash" field in the mutation.
func (m *NetworkBackupMutation) ContentHash() (r string, exists bool) {
	v := m.content_hash
	if v == nil {
		return
	}
	return *v, true
}

// OldContentHash returns the old "content_hash" field's value of the NetworkBackup entity.
// If the NetworkBackup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NetworkBackupMutation) OldContentHash(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContentHash is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContentHash requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContentHash: %w", err)
	}
	return oldValue.ContentHash, nil
}

// ResetContentHash resets all changes to the "content_hash" field.
func (m *NetworkBackupMutation) ResetContentHash() {
	m.content_hash = nil
}

// SetVaultPath sets the "vault_path" field.
func (m *NetworkBackupMutation) SetVaultPath(s string) {
	m.vault_path = &s
}

// VaultPath returns the value of the "vault_path" field in the mutation.
func (m *NetworkBackupMutation) VaultPath() (r string, exists bool) {
	v := m.vault_path
	if v == nil {
		return
	}
	return *v, true
}

// OldVaultPath returns the old "vault_path" field's value of the NetworkBackup entity.
// If the NetworkBackup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NetworkBackupMutation) OldVaultPath(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVaultPath is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVaultPath requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVaultPath: %w", err)
	}
	return oldValue.VaultPath, nil
}

// ResetVaultPath resets all changes to the "vault_path" field.
func (m *NetworkBackupMutation) ResetVaultPath() {
	m.vault_path = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *NetworkBackupMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *NetworkBackupMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the NetworkBackup entity.
// If the NetworkBackup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NetworkBackupMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *NetworkBackupMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetDeviceID sets the "device" edge to the NetworkDevice entity by id.
func (m *NetworkBackupMutation) SetDeviceID(id int) {
	m.device = &id
}

// ClearDevice clears the "device" edge to the NetworkDevice entity.
func (m *NetworkBackupMutation) ClearDevice() {
	m.cleareddevice = true
}

// DeviceCleared reports if the "device" edge to the NetworkDevice entity was cleared.
func (m *NetworkBackupMutation) DeviceCleared() bool {
	return m.cleareddevice
}

// DeviceID returns the "device" edge ID in the mutation.
func (m *NetworkBackupMutation) DeviceID() (id int, exists bool) {
	if m.device != nil {
		return *m.device, true
	}
	return
}

// DeviceIDs returns the "device" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// DeviceID instead. It exists only for internal usage by the builders.
func (m *NetworkBackupMutation) DeviceIDs() (ids []int) {
	if id := m.device; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDevice resets all changes to the "device" edge.
func (m *NetworkBackupMutation) ResetDevice() {
	m.device = nil
	m.cleareddevice = false
}

// SetTenantID sets the "tenant" edge to the Tenant entity by id.
func (m *NetworkBackupMutation) SetTenantID(id int) {
	m.tenant = &id
}

// ClearTenant clears the "tenant" edge to the Tenant entity.
func (m *NetworkBackupMutation) ClearTenant() {
	m.clearedtenant = true
}

// TenantCleared reports if the "tenant" edge to the Tenant entity was cleared.
func (m *NetworkBackupMutation) TenantCleared() bool {
	return m.clearedtenant
}

// TenantID returns the "tenant" edge ID in the mutation.
func (m *NetworkBackupMutation) TenantID() (id int, exists bool) {
	if m.tenant != nil {
		return *m.tenant, true
	}
	return
}

// TenantIDs returns the "tenant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TenantID instead. It exists only for internal usage by the builders.
func (m *NetworkBackupMutation) TenantIDs() (ids []int) {
	if id := m.tenant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTenant resets all changes to the "tenant" edge.
func (m *NetworkBackupMutation) ResetTenant() {
	m.tenant = nil
	m.clearedtenant = false
}

// Where appends a list predicates to the NetworkBackupMutation builder.
func (m *NetworkBackupMutation) Where(ps ...predicate.NetworkBackup) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the NetworkBackupMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *NetworkBackupMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.NetworkBackup, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *NetworkBackupMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *NetworkBackupMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (NetworkBackup).
func (m *NetworkBackupMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *NetworkBackupMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.content_hash != nil {
		fields = append(fields, networkbackup.FieldContentHash)
	}
	if m.vault_path != nil {
		fields = append(fields, networkbackup.FieldVaultPath)
	}
	if m.created_at != nil {
		fields = append(fields, networkbackup.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *NetworkBackupMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case networkbackup.FieldContentHash:
		return m.ContentHash()
	case networkbackup.FieldVaultPath:
		return m.VaultPath()
	case networkbackup.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *NetworkBackupMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case networkbackup.FieldContentHash:
		return m.OldContentHash(ctx)
	case networkbackup.FieldVaultPath:
		return m.OldVaultPath(ctx)
	case networkbackup.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown NetworkBackup field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NetworkBackupMutation) SetField(name string, value ent.Value) error {
	switch name {
	case networkbackup.FieldContentHash:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContentHash(v)
		return nil
	case networkbackup.FieldVaultPath:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVaultPath(v)
		return nil
	case networkbackup.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown NetworkBackup field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *NetworkBackupMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *NetworkBackupMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NetworkBackupMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown NetworkBackup numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *NetworkBackupMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *NetworkBackupMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *NetworkBackupMutation) ClearField(name string) error {
	return fmt.Errorf("unknown NetworkBackup nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *NetworkBackupMutation) ResetField(name string) error {
	switch name {
	case networkbackup.FieldContentHash:
		m.ResetContentHash()
		return nil
	case networkbackup.FieldVaultPath:
		m.ResetVaultPath()
		return nil
	case networkbackup.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown NetworkBackup field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *NetworkBackupMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.device != nil {
		edges = append(edges, networkbackup.EdgeDevice)
	}
	if m.tenant != nil {
		edges = append(edges, networkbackup.EdgeTenant)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *NetworkBackupMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case networkbackup.EdgeDevice:
		if id := m.device; id != nil {
			return []ent.Value{*id}
		}
	case networkbackup.EdgeTenant:
		if id := m.tenant; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *NetworkBackupMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *NetworkBackupMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *NetworkBackupMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleareddevice {
		edges = append(edges, networkbackup.EdgeDevice)
	}
	if m.clearedtenant {
		edges = append(edges, networkbackup.EdgeTenant)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *NetworkBackupMutation) EdgeCleared(name string) bool {
	switch name {
	case networkbackup.EdgeDevice:
		return m.cleareddevice
	case networkbackup.EdgeTenant:
		return m.clearedtenant
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *NetworkBackupMutation) ClearEdge(name string) error {
	switch name {
	case networkbackup.EdgeDevice:
		m.ClearDevice()
		return nil
	case networkbackup.EdgeTenant:
		m.ClearTenant()
		return nil
	}
	return fmt.Errorf("unknown NetworkBackup unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *NetworkBackupMutation) ResetEdge(name string) error {
	switch name {
	case networkbackup.EdgeDevice:
		m.ResetDevice()
		return nil
	case networkbackup.EdgeTenant:
		m.ResetTenant()
		return nil
	}
	return fmt.Errorf("unknown NetworkBackup edge %s", name)
}

// NetworkDeviceMutation represents an operation that mutates the NetworkDevice nodes in the graph.
type NetworkDeviceMutation struct {
	config
	op               Op
	typ              string
	id               *int
	name             *string
	ip_address       *string
	vendor           *string
	model            *string
	software_version *string
	status           *networkdevice.Status
	last_polled      *time.Time
	created_at       *time.Time
	updated_at       *time.Time
	clearedFields    map[string]struct{}
	ports            map[int]struct{}
	removedports     map[int]struct{}
	clearedports     bool
	backups          map[int]struct{}
	removedbackups   map[int]struct{}
	clearedbackups   bool
	tenant           *int
	clearedtenant    bool
	done             bool
	oldValue         func(context.Context) (*NetworkDevice, error)
	predicates       []predicate.NetworkDevice
}

var _ ent.Mutation = (*NetworkDeviceMutation)(nil)

// networkdeviceOption allows management of the mutation configuration using functional options.
type networkdeviceOption func(*NetworkDeviceMutation)

// newNetworkDeviceMutation creates new mutation for the NetworkDevice entity.
func newNetworkDeviceMutation(c config, op Op, opts ...networkdeviceOption) *NetworkDeviceMutation {
	m := &NetworkDeviceMutation{
		config:        c,
		op:            op,
		typ:           TypeNetworkDevice,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withNetworkDeviceID sets the ID field of the mutation.
func withNetworkDeviceID(id int) networkdeviceOption {
	return func(m *NetworkDeviceMutation) {
		var (
			err   error
			once  sync.Once
			value *NetworkDevice
		)
		m.oldValue = func(ctx context.Context) (*NetworkDevice, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().NetworkDevice.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withNetworkDevice sets the old NetworkDevice of the mutation.
func withNetworkDevice(node *NetworkDevice) networkdeviceOption {
	return func(m *NetworkDeviceMutation) {
		m.oldValue = func(context.Context) (*NetworkDevice, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m NetworkDeviceMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m NetworkDeviceMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *NetworkDeviceMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *NetworkDeviceMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().NetworkDevice.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *NetworkDeviceMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *NetworkDeviceMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the NetworkDevice entity.
// If the NetworkDevice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NetworkDeviceMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *NetworkDeviceMutation) ResetName() {
	m.name = nil
}

// SetIPAddress sets the "ip_address" field.
func (m *NetworkDeviceMutation) SetIPAddress(s string) {
	m.ip_address = &s
}

// IPAddress returns the value of the "ip_address" field in the mutation.
func (m *NetworkDeviceMutation) IPAddress() (r string, exists bool) {
	v := m.ip_address
	if v == nil {
		return
	}
	return *v, true
}

// OldIPAddress returns the old "ip_address" field's value of the NetworkDevice entity.
// If the NetworkDevice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NetworkDeviceMutation) OldIPAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIPAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIPAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIPAddress: %w", err)
	}
	return oldValue.IPAddress, nil
}

// ResetIPAddress resets all changes to the "ip_address" field.
func (m *NetworkDeviceMutation) ResetIPAddress() {
	m.ip_address = nil
}

// SetVendor sets the "vendor" field.
func (m *NetworkDeviceMutation) SetVendor(s string) {
	m.vendor = &s
}

// Vendor returns the value of the "vendor" field in the mutation.
func (m *NetworkDeviceMutation) Vendor() (r string, exists bool) {
	v := m.vendor
	if v == nil {
		return
	}
	return *v, true
}

// OldVendor returns the old "vendor" field's value of the NetworkDevice entity.
// If the NetworkDevice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NetworkDeviceMutation) OldVendor(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVendor is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVendor requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVendor: %w", err)
	}
	return oldValue.Vendor, nil
}

// ResetVendor resets all changes to the "vendor" field.
func (m *NetworkDeviceMutation) ResetVendor() {
	m.vendor = nil
}

// SetModel sets the "model" field.
func (m *NetworkDeviceMutation) SetModel(s string) {
	m.model = &s
}

// Model returns the value of the "model" field in the mutation.
func (m *NetworkDeviceMutation) Model() (r string, exists bool) {
	v := m.model
	if v == nil {
		return
	}
	return *v, true
}

// OldModel returns the old "model" field's value of the NetworkDevice entity.
// If the NetworkDevice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NetworkDeviceMutation) OldModel(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldModel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldModel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldModel: %w", err)
	}
	return oldValue.Model, nil
}

// ClearModel clears the value of the "model" field.
func (m *NetworkDeviceMutation) ClearModel() {
	m.model = nil
	m.clearedFields[networkdevice.FieldModel] = struct{}{}
}

// ModelCleared returns if the "model" field was cleared in this mutation.
func (m *NetworkDeviceMutation) ModelCleared() bool {
	_, ok := m.clearedFields[networkdevice.FieldModel]
	return ok
}

// ResetModel resets all changes to the "model" field.
func (m *NetworkDeviceMutation) ResetModel() {
	m.model = nil
	delete(m.clearedFields, networkdevice.FieldModel)
}

// SetSoftwareVersion sets the "software_version" field.
func (m *NetworkDeviceMutation) SetSoftwareVersion(s string) {
	m.software_version = &s
}

// SoftwareVersion returns the value of the "software_version" field in the mutation.
func (m *NetworkDeviceMutation) SoftwareVersion() (r string, exists bool) {
	v := m.software_version
	if v == nil {
		return
	}
	return *v, true
}

// OldSoftwareVersion returns the old "software_version" field's value of the NetworkDevice entity.
// If the NetworkDevice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NetworkDeviceMutation) OldSoftwareVersion(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSoftwareVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSoftwareVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSoftwareVersion: %w", err)
	}
	return oldValue.SoftwareVersion, nil
}

// ClearSoftwareVersion clears the value of the "software_version" field.
func (m *NetworkDeviceMutation) ClearSoftwareVersion() {
	m.software_version = nil
	m.clearedFields[networkdevice.FieldSoftwareVersion] = struct{}{}
}

// SoftwareVersionCleared returns if the "software_version" field was cleared in this mutation.
func (m *NetworkDeviceMutation) SoftwareVersionCleared() bool {
	_, ok := m.clearedFields[networkdevice.FieldSoftwareVersion]
	return ok
}

// ResetSoftwareVersion resets all changes to the "software_version" field.
func (m *NetworkDeviceMutation) ResetSoftwareVersion() {
	m.software_version = nil
	delete(m.clearedFields, networkdevice.FieldSoftwareVersion)
}

// SetStatus sets the "status" field.
func (m *NetworkDeviceMutation) SetStatus(n networkdevice.Status) {
	m.status = &n
}

// Status returns the value of the "status" field in the mutation.
func (m *NetworkDeviceMutation) Status() (r networkdevice.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the NetworkDevice entity.
// If the NetworkDevice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NetworkDeviceMutation) OldStatus(ctx context.Context) (v networkdevice.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *NetworkDeviceMutation) ResetStatus() {
	m.status = nil
}

// SetLastPolled sets the "last_polled" field.
func (m *NetworkDeviceMutation) SetLastPolled(t time.Time) {
	m.last_polled = &t
}

// LastPolled returns the value of the "last_polled" field in the mutation.
func (m *NetworkDeviceMutation) LastPolled() (r time.Time, exists bool) {
	v := m.last_polled
	if v == nil {
		return
	}
	return *v, true
}

// OldLastPolled returns the old "last_polled" field's value of the NetworkDevice entity.
// If the NetworkDevice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NetworkDeviceMutation) OldLastPolled(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastPolled is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastPolled requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastPolled: %w", err)
	}
	return oldValue.LastPolled, nil
}

// ClearLastPolled clears the value of the "last_polled" field.
func (m *NetworkDeviceMutation) ClearLastPolled() {
	m.last_polled = nil
	m.clearedFields[networkdevice.FieldLastPolled] = struct{}{}
}

// LastPolledCleared returns if the "last_polled" field was cleared in this mutation.
func (m *NetworkDeviceMutation) LastPolledCleared() bool {
	_, ok := m.clearedFields[networkdevice.FieldLastPolled]
	return ok
}

// ResetLastPolled resets all changes to the "last_polled" field.
func (m *NetworkDeviceMutation) ResetLastPolled() {
	m.last_polled = nil
	delete(m.clearedFields, networkdevice.FieldLastPolled)
}

// SetCreatedAt sets the "created_at" field.
func (m *NetworkDeviceMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *NetworkDeviceMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the NetworkDevice entity.
// If the NetworkDevice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NetworkDeviceMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *NetworkDeviceMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *NetworkDeviceMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *NetworkDeviceMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the NetworkDevice entity.
// If the NetworkDevice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NetworkDeviceMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *NetworkDeviceMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// AddPortIDs adds the "ports" edge to the NetworkPort entity by ids.
func (m *NetworkDeviceMutation) AddPortIDs(ids ...int) {
	if m.ports == nil {
		m.ports = make(map[int]struct{})
	}
	for i := range ids {
		m.ports[ids[i]] = struct{}{}
	}
}

// ClearPorts clears the "ports" edge to the NetworkPort entity.
func (m *NetworkDeviceMutation) ClearPorts() {
	m.clearedports = true
}

// PortsCleared reports if the "ports" edge to the NetworkPort entity was cleared.
func (m *NetworkDeviceMutation) PortsCleared() bool {
	return m.clearedports
}

// RemovePortIDs removes the "ports" edge to the NetworkPort entity by IDs.
func (m *NetworkDeviceMutation) RemovePortIDs(ids ...int) {
	if m.removedports == nil {
		m.removedports = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.ports, ids[i])
		m.removedports[ids[i]] = struct{}{}
	}
}

// RemovedPorts returns the removed IDs of the "ports" edge to the NetworkPort entity.
func (m *NetworkDeviceMutation) RemovedPortsIDs() (ids []int) {
	for id := range m.removedports {
		ids = append(ids, id)
	}
	return
}

// PortsIDs returns the "ports" edge IDs in the mutation.
func (m *NetworkDeviceMutation) PortsIDs() (ids []int) {
	for id := range m.ports {
		ids = append(ids, id)
	}
	return
}

// ResetPorts resets all changes to the "ports" edge.
func (m *NetworkDeviceMutation) ResetPorts() {
	m.ports = nil
	m.clearedports = false
	m.removedports = nil
}

// AddBackupIDs adds the "backups" edge to the NetworkBackup entity by ids.
func (m *NetworkDeviceMutation) AddBackupIDs(ids ...int) {
	if m.backups == nil {
		m.backups = make(map[int]struct{})
	}
	for i := range ids {
		m.backups[ids[i]] = struct{}{}
	}
}

// ClearBackups clears the "backups" edge to the NetworkBackup entity.
func (m *NetworkDeviceMutation) ClearBackups() {
	m.clearedbackups = true
}

// BackupsCleared reports if the "backups" edge to the NetworkBackup entity was cleared.
func (m *NetworkDeviceMutation) BackupsCleared() bool {
	return m.clearedbackups
}

// RemoveBackupIDs removes the "backups" edge to the NetworkBackup entity by IDs.
func (m *NetworkDeviceMutation) RemoveBackupIDs(ids ...int) {
	if m.removedbackups == nil {
		m.removedbackups = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.backups, ids[i])
		m.removedbackups[ids[i]] = struct{}{}
	}
}

// RemovedBackups returns the removed IDs of the "backups" edge to the NetworkBackup entity.
func (m *NetworkDeviceMutation) RemovedBackupsIDs() (ids []int) {
	for id := range m.removedbackups {
		ids = append(ids, id)
	}
	return
}

// BackupsIDs returns the "backups" edge IDs in the mutation.
func (m *NetworkDeviceMutation) BackupsIDs() (ids []int) {
	for id := range m.backups {
		ids = append(ids, id)
	}
	return
}

// ResetBackups resets all changes to the "backups" edge.
func (m *NetworkDeviceMutation) ResetBackups() {
	m.backups = nil
	m.clearedbackups = false
	m.removedbackups = nil
}

// SetTenantID sets the "tenant" edge to the Tenant entity by id.
func (m *NetworkDeviceMutation) SetTenantID(id int) {
	m.tenant = &id
}

// ClearTenant clears the "tenant" edge to the Tenant entity.
func (m *NetworkDeviceMutation) ClearTenant() {
	m.clearedtenant = true
}

// TenantCleared reports if the "tenant" edge to the Tenant entity was cleared.
func (m *NetworkDeviceMutation) TenantCleared() bool {
	return m.clearedtenant
}

// TenantID returns the "tenant" edge ID in the mutation.
func (m *NetworkDeviceMutation) TenantID() (id int, exists bool) {
	if m.tenant != nil {
		return *m.tenant, true
	}
	return
}

// TenantIDs returns the "tenant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TenantID instead. It exists only for internal usage by the builders.
func (m *NetworkDeviceMutation) TenantIDs() (ids []int) {
	if id := m.tenant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTenant resets all changes to the "tenant" edge.
func (m *NetworkDeviceMutation) ResetTenant() {
	m.tenant = nil
	m.clearedtenant = false
}

// Where appends a list predicates to the NetworkDeviceMutation builder.
func (m *NetworkDeviceMutation) Where(ps ...predicate.NetworkDevice) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the NetworkDeviceMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *NetworkDeviceMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.NetworkDevice, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *NetworkDeviceMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *NetworkDeviceMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (NetworkDevice).
func (m *NetworkDeviceMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *NetworkDeviceMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.name != nil {
		fields = append(fields, networkdevice.FieldName)
	}
	if m.ip_address != nil {
		fields = append(fields, networkdevice.FieldIPAddress)
	}
	if m.vendor != nil {
		fields = append(fields, networkdevice.FieldVendor)
	}
	if m.model != nil {
		fields = append(fields, networkdevice.FieldModel)
	}
	if m.software_version != nil {
		fields = append(fields, networkdevice.FieldSoftwareVersion)
	}
	if m.status != nil {
		fields = append(fields, networkdevice.FieldStatus)
	}
	if m.last_polled != nil {
		fields = append(fields, networkdevice.FieldLastPolled)
	}
	if m.created_at != nil {
		fields = append(fields, networkdevice.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, networkdevice.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *NetworkDeviceMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case networkdevice.FieldName:
		return m.Name()
	case networkdevice.FieldIPAddress:
		return m.IPAddress()
	case networkdevice.FieldVendor:
		return m.Vendor()
	case networkdevice.FieldModel:
		return m.Model()
	case networkdevice.FieldSoftwareVersion:
		return m.SoftwareVersion()
	case networkdevice.FieldStatus:
		return m.Status()
	case networkdevice.FieldLastPolled:
		return m.LastPolled()
	case networkdevice.FieldCreatedAt:
		return m.CreatedAt()
	case networkdevice.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *NetworkDeviceMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case networkdevice.FieldName:
		return m.OldName(ctx)
	case networkdevice.FieldIPAddress:
		return m.OldIPAddress(ctx)
	case networkdevice.FieldVendor:
		return m.OldVendor(ctx)
	case networkdevice.FieldModel:
		return m.OldModel(ctx)
	case networkdevice.FieldSoftwareVersion:
		return m.OldSoftwareVersion(ctx)
	case networkdevice.FieldStatus:
		return m.OldStatus(ctx)
	case networkdevice.FieldLastPolled:
		return m.OldLastPolled(ctx)
	case networkdevice.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case networkdevice.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown NetworkDevice field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NetworkDeviceMutation) SetField(name string, value ent.Value) error {
	switch name {
	case networkdevice.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case networkdevice.FieldIPAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIPAddress(v)
		return nil
	case networkdevice.FieldVendor:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVendor(v)
		return nil
	case networkdevice.FieldModel:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetModel(v)
		return nil
	case networkdevice.FieldSoftwareVersion:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSoftwareVersion(v)
		return nil
	case networkdevice.FieldStatus:
		v, ok := value.(networkdevice.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case networkdevice.FieldLastPolled:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastPolled(v)
		return nil
	case networkdevice.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case networkdevice.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown NetworkDevice field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *NetworkDeviceMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *NetworkDeviceMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NetworkDeviceMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown NetworkDevice numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *NetworkDeviceMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(networkdevice.FieldModel) {
		fields = append(fields, networkdevice.FieldModel)
	}
	if m.FieldCleared(networkdevice.FieldSoftwareVersion) {
		fields = append(fields, networkdevice.FieldSoftwareVersion)
	}
	if m.FieldCleared(networkdevice.FieldLastPolled) {
		fields = append(fields, networkdevice.FieldLastPolled)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *NetworkDeviceMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *NetworkDeviceMutation) ClearField(name string) error {
	switch name {
	case networkdevice.FieldModel:
		m.ClearModel()
		return nil
	case networkdevice.FieldSoftwareVersion:
		m.ClearSoftwareVersion()
		return nil
	case networkdevice.FieldLastPolled:
		m.ClearLastPolled()
		return nil
	}
	return fmt.Errorf("unknown NetworkDevice nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *NetworkDeviceMutation) ResetField(name string) error {
	switch name {
	case networkdevice.FieldName:
		m.ResetName()
		return nil
	case networkdevice.FieldIPAddress:
		m.ResetIPAddress()
		return nil
	case networkdevice.FieldVendor:
		m.ResetVendor()
		return nil
	case networkdevice.FieldModel:
		m.ResetModel()
		return nil
	case networkdevice.FieldSoftwareVersion:
		m.ResetSoftwareVersion()
		return nil
	case networkdevice.FieldStatus:
		m.ResetStatus()
		return nil
	case networkdevice.FieldLastPolled:
		m.ResetLastPolled()
		return nil
	case networkdevice.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case networkdevice.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown NetworkDevice field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *NetworkDeviceMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.ports != nil {
		edges = append(edges, networkdevice.EdgePorts)
	}
	if m.backups != nil {
		edges = append(edges, networkdevice.EdgeBackups)
	}
	if m.tenant != nil {
		edges = append(edges, networkdevice.EdgeTenant)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *NetworkDeviceMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case networkdevice.EdgePorts:
		ids := make([]ent.Value, 0, len(m.ports))
		for id := range m.ports {
			ids = append(ids, id)
		}
		return ids
	case networkdevice.EdgeBackups:
		ids := make([]ent.Value, 0, len(m.backups))
		for id := range m.backups {
			ids = append(ids, id)
		}
		return ids
	case networkdevice.EdgeTenant:
		if id := m.tenant; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *NetworkDeviceMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedports != nil {
		edges = append(edges, networkdevice.EdgePorts)
	}
	if m.removedbackups != nil {
		edges = append(edges, networkdevice.EdgeBackups)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *NetworkDeviceMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case networkdevice.EdgePorts:
		ids := make([]ent.Value, 0, len(m.removedports))
		for id := range m.removedports {
			ids = append(ids, id)
		}
		return ids
	case networkdevice.EdgeBackups:
		ids := make([]ent.Value, 0, len(m.removedbackups))
		for id := range m.removedbackups {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *NetworkDeviceMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedports {
		edges = append(edges, networkdevice.EdgePorts)
	}
	if m.clearedbackups {
		edges = append(edges, networkdevice.EdgeBackups)
	}
	if m.clearedtenant {
		edges = append(edges, networkdevice.EdgeTenant)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *NetworkDeviceMutation) EdgeCleared(name string) bool {
	switch name {
	case networkdevice.EdgePorts:
		return m.clearedports
	case networkdevice.EdgeBackups:
		return m.clearedbackups
	case networkdevice.EdgeTenant:
		return m.clearedtenant
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *NetworkDeviceMutation) ClearEdge(name string) error {
	switch name {
	case networkdevice.EdgeTenant:
		m.ClearTenant()
		return nil
	}
	return fmt.Errorf("unknown NetworkDevice unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *NetworkDeviceMutation) ResetEdge(name string) error {
	switch name {
	case networkdevice.EdgePorts:
		m.ResetPorts()
		return nil
	case networkdevice.EdgeBackups:
		m.ResetBackups()
		return nil
	case networkdevice.EdgeTenant:
		m.ResetTenant()
		return nil
	}
	return fmt.Errorf("unknown NetworkDevice edge %s", name)
}

// NetworkLinkMutation represents an operation that mutates the NetworkLink nodes in the graph.
type NetworkLinkMutation struct {
	config
	op                 Op
	typ                string
	id                 *int
	protocol           *string
	last_seen          *time.Time
	clearedFields      map[string]struct{}
	source_port        *int
	clearedsource_port bool
	target_port        *int
	clearedtarget_port bool
	tenant             *int
	clearedtenant      bool
	done               bool
	oldValue           func(context.Context) (*NetworkLink, error)
	predicates         []predicate.NetworkLink
}

var _ ent.Mutation = (*NetworkLinkMutation)(nil)

// networklinkOption allows management of the mutation configuration using functional options.
type networklinkOption func(*NetworkLinkMutation)

// newNetworkLinkMutation creates new mutation for the NetworkLink entity.
func newNetworkLinkMutation(c config, op Op, opts ...networklinkOption) *NetworkLinkMutation {
	m := &NetworkLinkMutation{
		config:        c,
		op:            op,
		typ:           TypeNetworkLink,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withNetworkLinkID sets the ID field of the mutation.
func withNetworkLinkID(id int) networklinkOption {
	return func(m *NetworkLinkMutation) {
		var (
			err   error
			once  sync.Once
			value *NetworkLink
		)
		m.oldValue = func(ctx context.Context) (*NetworkLink, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().NetworkLink.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withNetworkLink sets the old NetworkLink of the mutation.
func withNetworkLink(node *NetworkLink) networklinkOption {
	return func(m *NetworkLinkMutation) {
		m.oldValue = func(context.Context) (*NetworkLink, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m NetworkLinkMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m NetworkLinkMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *NetworkLinkMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *NetworkLinkMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().NetworkLink.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetProtocol sets the "protocol" field.
func (m *NetworkLinkMutation) SetProtocol(s string) {
	m.protocol = &s
}

// Protocol returns the value of the "protocol" field in the mutation.
func (m *NetworkLinkMutation) Protocol() (r string, exists bool) {
	v := m.protocol
	if v == nil {
		return
	}
	return *v, true
}

// OldProtocol returns the old "protocol" field's value of the NetworkLink entity.
// If the NetworkLink object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NetworkLinkMutation) OldProtocol(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProtocol is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProtocol requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProtocol: %w", err)
	}
	return oldValue.Protocol, nil
}

// ResetProtocol resets all changes to the "protocol" field.
func (m *NetworkLinkMutation) ResetProtocol() {
	m.protocol = nil
}

// SetLastSeen sets the "last_seen" field.
func (m *NetworkLinkMutation) SetLastSeen(t time.Time) {
	m.last_seen = &t
}

// LastSeen returns the value of the "last_seen" field in the mutation.
func (m *NetworkLinkMutation) LastSeen() (r time.Time, exists bool) {
	v := m.last_seen
	if v == nil {
		return
	}
	return *v, true
}

// OldLastSeen returns the old "last_seen" field's value of the NetworkLink entity.
// If the NetworkLink object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NetworkLinkMutation) OldLastSeen(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastSeen is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastSeen requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastSeen: %w", err)
	}
	return oldValue.LastSeen, nil
}

// ResetLastSeen resets all changes to the "last_seen" field.
func (m *NetworkLinkMutation) ResetLastSeen() {
	m.last_seen = nil
}

// SetSourcePortID sets the "source_port" edge to the NetworkPort entity by id.
func (m *NetworkLinkMutation) SetSourcePortID(id int) {
	m.source_port = &id
}

// ClearSourcePort clears the "source_port" edge to the NetworkPort entity.
func (m *NetworkLinkMutation) ClearSourcePort() {
	m.clearedsource_port = true
}

// SourcePortCleared reports if the "source_port" edge to the NetworkPort entity was cleared.
func (m *NetworkLinkMutation) SourcePortCleared() bool {
	return m.clearedsource_port
}

// SourcePortID returns the "source_port" edge ID in the mutation.
func (m *NetworkLinkMutation) SourcePortID() (id int, exists bool) {
	if m.source_port != nil {
		return *m.source_port, true
	}
	return
}

// SourcePortIDs returns the "source_port" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SourcePortID instead. It exists only for internal usage by the builders.
func (m *NetworkLinkMutation) SourcePortIDs() (ids []int) {
	if id := m.source_port; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSourcePort resets all changes to the "source_port" edge.
func (m *NetworkLinkMutation) ResetSourcePort() {
	m.source_port = nil
	m.clearedsource_port = false
}

// SetTargetPortID sets the "target_port" edge to the NetworkPort entity by id.
func (m *NetworkLinkMutation) SetTargetPortID(id int) {
	m.target_port = &id
}

// ClearTargetPort clears the "target_port" edge to the NetworkPort entity.
func (m *NetworkLinkMutation) ClearTargetPort() {
	m.clearedtarget_port = true
}

// TargetPortCleared reports if the "target_port" edge to the NetworkPort entity was cleared.
func (m *NetworkLinkMutation) TargetPortCleared() bool {
	return m.clearedtarget_port
}

// TargetPortID returns the "target_port" edge ID in the mutation.
func (m *NetworkLinkMutation) TargetPortID() (id int, exists bool) {
	if m.target_port != nil {
		return *m.target_port, true
	}
	return
}

// TargetPortIDs returns the "target_port" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TargetPortID instead. It exists only for internal usage by the builders.
func (m *NetworkLinkMutation) TargetPortIDs() (ids []int) {
	if id := m.target_port; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTargetPort resets all changes to the "target_port" edge.
func (m *NetworkLinkMutation) ResetTargetPort() {
	m.target_port = nil
	m.clearedtarget_port = false
}

// SetTenantID sets the "tenant" edge to the Tenant entity by id.
func (m *NetworkLinkMutation) SetTenantID(id int) {
	m.tenant = &id
}

// ClearTenant clears the "tenant" edge to the Tenant entity.
func (m *NetworkLinkMutation) ClearTenant() {
	m.clearedtenant = true
}

// TenantCleared reports if the "tenant" edge to the Tenant entity was cleared.
func (m *NetworkLinkMutation) TenantCleared() bool {
	return m.clearedtenant
}

// TenantID returns the "tenant" edge ID in the mutation.
func (m *NetworkLinkMutation) TenantID() (id int, exists bool) {
	if m.tenant != nil {
		return *m.tenant, true
	}
	return
}

// TenantIDs returns the "tenant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TenantID instead. It exists only for internal usage by the builders.
func (m *NetworkLinkMutation) TenantIDs() (ids []int) {
	if id := m.tenant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTenant resets all changes to the "tenant" edge.
func (m *NetworkLinkMutation) ResetTenant() {
	m.tenant = nil
	m.clearedtenant = false
}

// Where appends a list predicates to the NetworkLinkMutation builder.
func (m *NetworkLinkMutation) Where(ps ...predicate.NetworkLink) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the NetworkLinkMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *NetworkLinkMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.NetworkLink, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *NetworkLinkMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *NetworkLinkMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (NetworkLink).
func (m *NetworkLinkMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *NetworkLinkMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.protocol != nil {
		fields = append(fields, networklink.FieldProtocol)
	}
	if m.last_seen != nil {
		fields = append(fields, networklink.FieldLastSeen)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *NetworkLinkMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case networklink.FieldProtocol:
		return m.Protocol()
	case networklink.FieldLastSeen:
		return m.LastSeen()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *NetworkLinkMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case networklink.FieldProtocol:
		return m.OldProtocol(ctx)
	case networklink.FieldLastSeen:
		return m.OldLastSeen(ctx)
	}
	return nil, fmt.Errorf("unknown NetworkLink field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NetworkLinkMutation) SetField(name string, value ent.Value) error {
	switch name {
	case networklink.FieldProtocol:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProtocol(v)
		return nil
	case networklink.FieldLastSeen:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastSeen(v)
		return nil
	}
	return fmt.Errorf("unknown NetworkLink field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *NetworkLinkMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *NetworkLinkMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NetworkLinkMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown NetworkLink numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *NetworkLinkMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *NetworkLinkMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *NetworkLinkMutation) ClearField(name string) error {
	return fmt.Errorf("unknown NetworkLink nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *NetworkLinkMutation) ResetField(name string) error {
	switch name {
	case networklink.FieldProtocol:
		m.ResetProtocol()
		return nil
	case networklink.FieldLastSeen:
		m.ResetLastSeen()
		return nil
	}
	return fmt.Errorf("unknown NetworkLink field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *NetworkLinkMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.source_port != nil {
		edges = append(edges, networklink.EdgeSourcePort)
	}
	if m.target_port != nil {
		edges = append(edges, networklink.EdgeTargetPort)
	}
	if m.tenant != nil {
		edges = append(edges, networklink.EdgeTenant)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *NetworkLinkMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case networklink.EdgeSourcePort:
		if id := m.source_port; id != nil {
			return []ent.Value{*id}
		}
	case networklink.EdgeTargetPort:
		if id := m.target_port; id != nil {
			return []ent.Value{*id}
		}
	case networklink.EdgeTenant:
		if id := m.tenant; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *NetworkLinkMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *NetworkLinkMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *NetworkLinkMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedsource_port {
		edges = append(edges, networklink.EdgeSourcePort)
	}
	if m.clearedtarget_port {
		edges = append(edges, networklink.EdgeTargetPort)
	}
	if m.clearedtenant {
		edges = append(edges, networklink.EdgeTenant)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *NetworkLinkMutation) EdgeCleared(name string) bool {
	switch name {
	case networklink.EdgeSourcePort:
		return m.clearedsource_port
	case networklink.EdgeTargetPort:
		return m.clearedtarget_port
	case networklink.EdgeTenant:
		return m.clearedtenant
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *NetworkLinkMutation) ClearEdge(name string) error {
	switch name {
	case networklink.EdgeSourcePort:
		m.ClearSourcePort()
		return nil
	case networklink.EdgeTargetPort:
		m.ClearTargetPort()
		return nil
	case networklink.EdgeTenant:
		m.ClearTenant()
		return nil
	}
	return fmt.Errorf("unknown NetworkLink unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *NetworkLinkMutation) ResetEdge(name string) error {
	switch name {
	case networklink.EdgeSourcePort:
		m.ResetSourcePort()
		return nil
	case networklink.EdgeTargetPort:
		m.ResetTargetPort()
		return nil
	case networklink.EdgeTenant:
		m.ResetTenant()
		return nil
	}
	return fmt.Errorf("unknown NetworkLink edge %s", name)
}

// NetworkPortMutation represents an operation that mutates the NetworkPort nodes in the graph.
type NetworkPortMutation struct {
	config
	op                  Op
	typ                 string
	id                  *int
	name                *string
	_type               *string
	status              *string
	vlan                *int
	addvlan             *int
	mac_address         *string
	poe_enabled         *bool
	poe_wattage         *float64
	addpoe_wattage      *float64
	description         *string
	clearedFields       map[string]struct{}
	device              *int
	cleareddevice       bool
	connected_to        map[int]struct{}
	removedconnected_to map[int]struct{}
	clearedconnected_to bool
	tenant              *int
	clearedtenant       bool
	done                bool
	oldValue            func(context.Context) (*NetworkPort, error)
	predicates          []predicate.NetworkPort
}

var _ ent.Mutation = (*NetworkPortMutation)(nil)

// networkportOption allows management of the mutation configuration using functional options.
type networkportOption func(*NetworkPortMutation)

// newNetworkPortMutation creates new mutation for the NetworkPort entity.
func newNetworkPortMutation(c config, op Op, opts ...networkportOption) *NetworkPortMutation {
	m := &NetworkPortMutation{
		config:        c,
		op:            op,
		typ:           TypeNetworkPort,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withNetworkPortID sets the ID field of the mutation.
func withNetworkPortID(id int) networkportOption {
	return func(m *NetworkPortMutation) {
		var (
			err   error
			once  sync.Once
			value *NetworkPort
		)
		m.oldValue = func(ctx context.Context) (*NetworkPort, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().NetworkPort.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withNetworkPort sets the old NetworkPort of the mutation.
func withNetworkPort(node *NetworkPort) networkportOption {
	return func(m *NetworkPortMutation) {
		m.oldValue = func(context.Context) (*NetworkPort, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m NetworkPortMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m NetworkPortMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *NetworkPortMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *NetworkPortMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().NetworkPort.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *NetworkPortMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *NetworkPortMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the NetworkPort entity.
// If the NetworkPort object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NetworkPortMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *NetworkPortMutation) ResetName() {
	m.name = nil
}

// SetType sets the "type" field.
func (m *NetworkPortMutation) SetType(s string) {
	m._type = &s
}

// GetType returns the value of the "type" field in the mutation.
func (m *NetworkPortMutation) GetType() (r string, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the NetworkPort entity.
// If the NetworkPort object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NetworkPortMutation) OldType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *NetworkPortMutation) ResetType() {
	m._type = nil
}

// SetStatus sets the "status" field.
func (m *NetworkPortMutation) SetStatus(s string) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *NetworkPortMutation) Status() (r string, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the NetworkPort entity.
// If the NetworkPort object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NetworkPortMutation) OldStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *NetworkPortMutation) ResetStatus() {
	m.status = nil
}

// SetVlan sets the "vlan" field.
func (m *NetworkPortMutation) SetVlan(i int) {
	m.vlan = &i
	m.addvlan = nil
}

// Vlan returns the value of the "vlan" field in the mutation.
func (m *NetworkPortMutation) Vlan() (r int, exists bool) {
	v := m.vlan
	if v == nil {
		return
	}
	return *v, true
}

// OldVlan returns the old "vlan" field's value of the NetworkPort entity.
// If the NetworkPort object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NetworkPortMutation) OldVlan(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVlan is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVlan requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVlan: %w", err)
	}
	return oldValue.Vlan, nil
}

// AddVlan adds i to the "vlan" field.
func (m *NetworkPortMutation) AddVlan(i int) {
	if m.addvlan != nil {
		*m.addvlan += i
	} else {
		m.addvlan = &i
	}
}

// AddedVlan returns the value that was added to the "vlan" field in this mutation.
func (m *NetworkPortMutation) AddedVlan() (r int, exists bool) {
	v := m.addvlan
	if v == nil {
		return
	}
	return *v, true
}

// ResetVlan resets all changes to the "vlan" field.
func (m *NetworkPortMutation) ResetVlan() {
	m.vlan = nil
	m.addvlan = nil
}

// SetMACAddress sets the "mac_address" field.
func (m *NetworkPortMutation) SetMACAddress(s string) {
	m.mac_address = &s
}

// MACAddress returns the value of the "mac_address" field in the mutation.
func (m *NetworkPortMutation) MACAddress() (r string, exists bool) {
	v := m.mac_address
	if v == nil {
		return
	}
	return *v, true
}

// OldMACAddress returns the old "mac_address" field's value of the NetworkPort entity.
// If the NetworkPort object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NetworkPortMutation) OldMACAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMACAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMACAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMACAddress: %w", err)
	}
	return oldValue.MACAddress, nil
}

// ClearMACAddress clears the value of the "mac_address" field.
func (m *NetworkPortMutation) ClearMACAddress() {
	m.mac_address = nil
	m.clearedFields[networkport.FieldMACAddress] = struct{}{}
}

// MACAddressCleared returns if the "mac_address" field was cleared in this mutation.
func (m *NetworkPortMutation) MACAddressCleared() bool {
	_, ok := m.clearedFields[networkport.FieldMACAddress]
	return ok
}

// ResetMACAddress resets all changes to the "mac_address" field.
func (m *NetworkPortMutation) ResetMACAddress() {
	m.mac_address = nil
	delete(m.clearedFields, networkport.FieldMACAddress)
}

// SetPoeEnabled sets the "poe_enabled" field.
func (m *NetworkPortMutation) SetPoeEnabled(b bool) {
	m.poe_enabled = &b
}

// PoeEnabled returns the value of the "poe_enabled" field in the mutation.
func (m *NetworkPortMutation) PoeEnabled() (r bool, exists bool) {
	v := m.poe_enabled
	if v == nil {
		return
	}
	return *v, true
}

// OldPoeEnabled returns the old "poe_enabled" field's value of the NetworkPort entity.
// If the NetworkPort object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NetworkPortMutation) OldPoeEnabled(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPoeEnabled is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPoeEnabled requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPoeEnabled: %w", err)
	}
	return oldValue.PoeEnabled, nil
}

// ResetPoeEnabled resets all changes to the "poe_enabled" field.
func (m *NetworkPortMutation) ResetPoeEnabled() {
	m.poe_enabled = nil
}

// SetPoeWattage sets the "poe_wattage" field.
func (m *NetworkPortMutation) SetPoeWattage(f float64) {
	m.poe_wattage = &f
	m.addpoe_wattage = nil
}

// PoeWattage returns the value of the "poe_wattage" field in the mutation.
func (m *NetworkPortMutation) PoeWattage() (r float64, exists bool) {
	v := m.poe_wattage
	if v == nil {
		return
	}
	return *v, true
}

// OldPoeWattage returns the old "poe_wattage" field's value of the NetworkPort entity.
// If the NetworkPort object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NetworkPortMutation) OldPoeWattage(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPoeWattage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPoeWattage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPoeWattage: %w", err)
	}
	return oldValue.PoeWattage, nil
}

// AddPoeWattage adds f to the "poe_wattage" field.
func (m *NetworkPortMutation) AddPoeWattage(f float64) {
	if m.addpoe_wattage != nil {
		*m.addpoe_wattage += f
	} else {
		m.addpoe_wattage = &f
	}
}

// AddedPoeWattage returns the value that was added to the "poe_wattage" field in this mutation.
func (m *NetworkPortMutation) AddedPoeWattage() (r float64, exists bool) {
	v := m.addpoe_wattage
	if v == nil {
		return
	}
	return *v, true
}

// ResetPoeWattage resets all changes to the "poe_wattage" field.
func (m *NetworkPortMutation) ResetPoeWattage() {
	m.poe_wattage = nil
	m.addpoe_wattage = nil
}

// SetDescription sets the "description" field.
func (m *NetworkPortMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *NetworkPortMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the NetworkPort entity.
// If the NetworkPort object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NetworkPortMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *NetworkPortMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[networkport.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *NetworkPortMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[networkport.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *NetworkPortMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, networkport.FieldDescription)
}

// SetDeviceID sets the "device" edge to the NetworkDevice entity by id.
func (m *NetworkPortMutation) SetDeviceID(id int) {
	m.device = &id
}

// ClearDevice clears the "device" edge to the NetworkDevice entity.
func (m *NetworkPortMutation) ClearDevice() {
	m.cleareddevice = true
}

// DeviceCleared reports if the "device" edge to the NetworkDevice entity was cleared.
func (m *NetworkPortMutation) DeviceCleared() bool {
	return m.cleareddevice
}

// DeviceID returns the "device" edge ID in the mutation.
func (m *NetworkPortMutation) DeviceID() (id int, exists bool) {
	if m.device != nil {
		return *m.device, true
	}
	return
}

// DeviceIDs returns the "device" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// DeviceID instead. It exists only for internal usage by the builders.
func (m *NetworkPortMutation) DeviceIDs() (ids []int) {
	if id := m.device; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDevice resets all changes to the "device" edge.
func (m *NetworkPortMutation) ResetDevice() {
	m.device = nil
	m.cleareddevice = false
}

// AddConnectedToIDs adds the "connected_to" edge to the NetworkLink entity by ids.
func (m *NetworkPortMutation) AddConnectedToIDs(ids ...int) {
	if m.connected_to == nil {
		m.connected_to = make(map[int]struct{})
	}
	for i := range ids {
		m.connected_to[ids[i]] = struct{}{}
	}
}

// ClearConnectedTo clears the "connected_to" edge to the NetworkLink entity.
func (m *NetworkPortMutation) ClearConnectedTo() {
	m.clearedconnected_to = true
}

// ConnectedToCleared reports if the "connected_to" edge to the NetworkLink entity was cleared.
func (m *NetworkPortMutation) ConnectedToCleared() bool {
	return m.clearedconnected_to
}

// RemoveConnectedToIDs removes the "connected_to" edge to the NetworkLink entity by IDs.
func (m *NetworkPortMutation) RemoveConnectedToIDs(ids ...int) {
	if m.removedconnected_to == nil {
		m.removedconnected_to = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.connected_to, ids[i])
		m.removedconnected_to[ids[i]] = struct{}{}
	}
}

// RemovedConnectedTo returns the removed IDs of the "connected_to" edge to the NetworkLink entity.
func (m *NetworkPortMutation) RemovedConnectedToIDs() (ids []int) {
	for id := range m.removedconnected_to {
		ids = append(ids, id)
	}
	return
}

// ConnectedToIDs returns the "connected_to" edge IDs in the mutation.
func (m *NetworkPortMutation) ConnectedToIDs() (ids []int) {
	for id := range m.connected_to {
		ids = append(ids, id)
	}
	return
}

// ResetConnectedTo resets all changes to the "connected_to" edge.
func (m *NetworkPortMutation) ResetConnectedTo() {
	m.connected_to = nil
	m.clearedconnected_to = false
	m.removedconnected_to = nil
}

// SetTenantID sets the "tenant" edge to the Tenant entity by id.
func (m *NetworkPortMutation) SetTenantID(id int) {
	m.tenant = &id
}

// ClearTenant clears the "tenant" edge to the Tenant entity.
func (m *NetworkPortMutation) ClearTenant() {
	m.clearedtenant = true
}

// TenantCleared reports if the "tenant" edge to the Tenant entity was cleared.
func (m *NetworkPortMutation) TenantCleared() bool {
	return m.clearedtenant
}

// TenantID returns the "tenant" edge ID in the mutation.
func (m *NetworkPortMutation) TenantID() (id int, exists bool) {
	if m.tenant != nil {
		return *m.tenant, true
	}
	return
}

// TenantIDs returns the "tenant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TenantID instead. It exists only for internal usage by the builders.
func (m *NetworkPortMutation) TenantIDs() (ids []int) {
	if id := m.tenant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTenant resets all changes to the "tenant" edge.
func (m *NetworkPortMutation) ResetTenant() {
	m.tenant = nil
	m.clearedtenant = false
}

// Where appends a list predicates to the NetworkPortMutation builder.
func (m *NetworkPortMutation) Where(ps ...predicate.NetworkPort) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the NetworkPortMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *NetworkPortMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.NetworkPort, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *NetworkPortMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *NetworkPortMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (NetworkPort).
func (m *NetworkPortMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *NetworkPortMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.name != nil {
		fields = append(fields, networkport.FieldName)
	}
	if m._type != nil {
		fields = append(fields, networkport.FieldType)
	}
	if m.status != nil {
		fields = append(fields, networkport.FieldStatus)
	}
	if m.vlan != nil {
		fields = append(fields, networkport.FieldVlan)
	}
	if m.mac_address != nil {
		fields = append(fields, networkport.FieldMACAddress)
	}
	if m.poe_enabled != nil {
		fields = append(fields, networkport.FieldPoeEnabled)
	}
	if m.poe_wattage != nil {
		fields = append(fields, networkport.FieldPoeWattage)
	}
	if m.description != nil {
		fields = append(fields, networkport.FieldDescription)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *NetworkPortMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case networkport.FieldName:
		return m.Name()
	case networkport.FieldType:
		return m.GetType()
	case networkport.FieldStatus:
		return m.Status()
	case networkport.FieldVlan:
		return m.Vlan()
	case networkport.FieldMACAddress:
		return m.MACAddress()
	case networkport.FieldPoeEnabled:
		return m.PoeEnabled()
	case networkport.FieldPoeWattage:
		return m.PoeWattage()
	case networkport.FieldDescription:
		return m.Description()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *NetworkPortMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case networkport.FieldName:
		return m.OldName(ctx)
	case networkport.FieldType:
		return m.OldType(ctx)
	case networkport.FieldStatus:
		return m.OldStatus(ctx)
	case networkport.FieldVlan:
		return m.OldVlan(ctx)
	case networkport.FieldMACAddress:
		return m.OldMACAddress(ctx)
	case networkport.FieldPoeEnabled:
		return m.OldPoeEnabled(ctx)
	case networkport.FieldPoeWattage:
		return m.OldPoeWattage(ctx)
	case networkport.FieldDescription:
		return m.OldDescription(ctx)
	}
	return nil, fmt.Errorf("unknown NetworkPort field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NetworkPortMutation) SetField(name string, value ent.Value) error {
	switch name {
	case networkport.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case networkport.FieldType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case networkport.FieldStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case networkport.FieldVlan:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVlan(v)
		return nil
	case networkport.FieldMACAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMACAddress(v)
		return nil
	case networkport.FieldPoeEnabled:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPoeEnabled(v)
		return nil
	case networkport.FieldPoeWattage:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPoeWattage(v)
		return nil
	case networkport.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	}
	return fmt.Errorf("unknown NetworkPort field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *NetworkPortMutation) AddedFields() []string {
	var fields []string
	if m.addvlan != nil {
		fields = append(fields, networkport.FieldVlan)
	}
	if m.addpoe_wattage != nil {
		fields = append(fields, networkport.FieldPoeWattage)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *NetworkPortMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case networkport.FieldVlan:
		return m.AddedVlan()
	case networkport.FieldPoeWattage:
		return m.AddedPoeWattage()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NetworkPortMutation) AddField(name string, value ent.Value) error {
	switch name {
	case networkport.FieldVlan:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddVlan(v)
		return nil
	case networkport.FieldPoeWattage:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPoeWattage(v)
		return nil
	}
	return fmt.Errorf("unknown NetworkPort numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *NetworkPortMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(networkport.FieldMACAddress) {
		fields = append(fields, networkport.FieldMACAddress)
	}
	if m.FieldCleared(networkport.FieldDescription) {
		fields = append(fields, networkport.FieldDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *NetworkPortMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *NetworkPortMutation) ClearField(name string) error {
	switch name {
	case networkport.FieldMACAddress:
		m.ClearMACAddress()
		return nil
	case networkport.FieldDescription:
		m.ClearDescription()
		return nil
	}
	return fmt.Errorf("unknown NetworkPort nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *NetworkPortMutation) ResetField(name string) error {
	switch name {
	case networkport.FieldName:
		m.ResetName()
		return nil
	case networkport.FieldType:
		m.ResetType()
		return nil
	case networkport.FieldStatus:
		m.ResetStatus()
		return nil
	case networkport.FieldVlan:
		m.ResetVlan()
		return nil
	case networkport.FieldMACAddress:
		m.ResetMACAddress()
		return nil
	case networkport.FieldPoeEnabled:
		m.ResetPoeEnabled()
		return nil
	case networkport.FieldPoeWattage:
		m.ResetPoeWattage()
		return nil
	case networkport.FieldDescription:
		m.ResetDescription()
		return nil
	}
	return fmt.Errorf("unknown NetworkPort field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *NetworkPortMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.device != nil {
		edges = append(edges, networkport.EdgeDevice)
	}
	if m.connected_to != nil {
		edges = append(edges, networkport.EdgeConnectedTo)
	}
	if m.tenant != nil {
		edges = append(edges, networkport.EdgeTenant)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *NetworkPortMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case networkport.EdgeDevice:
		if id := m.device; id != nil {
			return []ent.Value{*id}
		}
	case networkport.EdgeConnectedTo:
		ids := make([]ent.Value, 0, len(m.connected_to))
		for id := range m.connected_to {
			ids = append(ids, id)
		}
		return ids
	case networkport.EdgeTenant:
		if id := m.tenant; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *NetworkPortMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedconnected_to != nil {
		edges = append(edges, networkport.EdgeConnectedTo)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *NetworkPortMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case networkport.EdgeConnectedTo:
		ids := make([]ent.Value, 0, len(m.removedconnected_to))
		for id := range m.removedconnected_to {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *NetworkPortMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.cleareddevice {
		edges = append(edges, networkport.EdgeDevice)
	}
	if m.clearedconnected_to {
		edges = append(edges, networkport.EdgeConnectedTo)
	}
	if m.clearedtenant {
		edges = append(edges, networkport.EdgeTenant)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *NetworkPortMutation) EdgeCleared(name string) bool {
	switch name {
	case networkport.EdgeDevice:
		return m.cleareddevice
	case networkport.EdgeConnectedTo:
		return m.clearedconnected_to
	case networkport.EdgeTenant:
		return m.clearedtenant
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *NetworkPortMutation) ClearEdge(name string) error {
	switch name {
	case networkport.EdgeDevice:
		m.ClearDevice()
		return nil
	case networkport.EdgeTenant:
		m.ClearTenant()
		return nil
	}
	return fmt.Errorf("unknown NetworkPort unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *NetworkPortMutation) ResetEdge(name string) error {
	switch name {
	case networkport.EdgeDevice:
		m.ResetDevice()
		return nil
	case networkport.EdgeConnectedTo:
		m.ResetConnectedTo()
		return nil
	case networkport.EdgeTenant:
		m.ResetTenant()
		return nil
	}
	return fmt.Errorf("unknown NetworkPort edge %s", name)
}

// NexusAuditMutation represents an operation that mutates the NexusAudit nodes in the graph.
type NexusAuditMutation struct {
	config
	op            Op
	typ           string
	id            *int
	action        *string
	actor_id      *string
	credential_id *string
	reason_code   *string
	ticket_id     *string
	timestamp     *time.Time
	metadata      *map[string]interface{}
	clearedFields map[string]struct{}
	tenant        *int
	clearedtenant bool
	done          bool
	oldValue      func(context.Context) (*NexusAudit, error)
	predicates    []predicate.NexusAudit
}

var _ ent.Mutation = (*NexusAuditMutation)(nil)

// nexusauditOption allows management of the mutation configuration using functional options.
type nexusauditOption func(*NexusAuditMutation)

// newNexusAuditMutation creates new mutation for the NexusAudit entity.
func newNexusAuditMutation(c config, op Op, opts ...nexusauditOption) *NexusAuditMutation {
	m := &NexusAuditMutation{
		config:        c,
		op:            op,
		typ:           TypeNexusAudit,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withNexusAuditID sets the ID field of the mutation.
func withNexusAuditID(id int) nexusauditOption {
	return func(m *NexusAuditMutation) {
		var (
			err   error
			once  sync.Once
			value *NexusAudit
		)
		m.oldValue = func(ctx context.Context) (*NexusAudit, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().NexusAudit.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withNexusAudit sets the old NexusAudit of the mutation.
func withNexusAudit(node *NexusAudit) nexusauditOption {
	return func(m *NexusAuditMutation) {
		m.oldValue = func(context.Context) (*NexusAudit, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m NexusAuditMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m NexusAuditMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *NexusAuditMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *NexusAuditMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().NexusAudit.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetAction sets the "action" field.
func (m *NexusAuditMutation) SetAction(s string) {
	m.action = &s
}

// Action returns the value of the "action" field in the mutation.
func (m *NexusAuditMutation) Action() (r string, exists bool) {
	v := m.action
	if v == nil {
		return
	}
	return *v, true
}

// OldAction returns the old "action" field's value of the NexusAudit entity.
// If the NexusAudit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NexusAuditMutation) OldAction(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAction is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAction requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAction: %w", err)
	}
	return oldValue.Action, nil
}

// ResetAction resets all changes to the "action" field.
func (m *NexusAuditMutation) ResetAction() {
	m.action = nil
}

// SetActorID sets the "actor_id" field.
func (m *NexusAuditMutation) SetActorID(s string) {
	m.actor_id = &s
}

// ActorID returns the value of the "actor_id" field in the mutation.
func (m *NexusAuditMutation) ActorID() (r string, exists bool) {
	v := m.actor_id
	if v == nil {
		return
	}
	return *v, true
}

// OldActorID returns the old "actor_id" field's value of the NexusAudit entity.
// If the NexusAudit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NexusAuditMutation) OldActorID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldActorID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldActorID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldActorID: %w", err)
	}
	return oldValue.ActorID, nil
}

// ResetActorID resets all changes to the "actor_id" field.
func (m *NexusAuditMutation) ResetActorID() {
	m.actor_id = nil
}

// SetCredentialID sets the "credential_id" field.
func (m *NexusAuditMutation) SetCredentialID(s string) {
	m.credential_id = &s
}

// CredentialID returns the value of the "credential_id" field in the mutation.
func (m *NexusAuditMutation) CredentialID() (r string, exists bool) {
	v := m.credential_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCredentialID returns the old "credential_id" field's value of the NexusAudit entity.
// If the NexusAudit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NexusAuditMutation) OldCredentialID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCredentialID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCredentialID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCredentialID: %w", err)
	}
	return oldValue.CredentialID, nil
}

// ClearCredentialID clears the value of the "credential_id" field.
func (m *NexusAuditMutation) ClearCredentialID() {
	m.credential_id = nil
	m.clearedFields[nexusaudit.FieldCredentialID] = struct{}{}
}

// CredentialIDCleared returns if the "credential_id" field was cleared in this mutation.
func (m *NexusAuditMutation) CredentialIDCleared() bool {
	_, ok := m.clearedFields[nexusaudit.FieldCredentialID]
	return ok
}

// ResetCredentialID resets all changes to the "credential_id" field.
func (m *NexusAuditMutation) ResetCredentialID() {
	m.credential_id = nil
	delete(m.clearedFields, nexusaudit.FieldCredentialID)
}

// SetReasonCode sets the "reason_code" field.
func (m *NexusAuditMutation) SetReasonCode(s string) {
	m.reason_code = &s
}

// ReasonCode returns the value of the "reason_code" field in the mutation.
func (m *NexusAuditMutation) ReasonCode() (r string, exists bool) {
	v := m.reason_code
	if v == nil {
		return
	}
	return *v, true
}

// OldReasonCode returns the old "reason_code" field's value of the NexusAudit entity.
// If the NexusAudit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NexusAuditMutation) OldReasonCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReasonCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReasonCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReasonCode: %w", err)
	}
	return oldValue.ReasonCode, nil
}

// ClearReasonCode clears the value of the "reason_code" field.
func (m *NexusAuditMutation) ClearReasonCode() {
	m.reason_code = nil
	m.clearedFields[nexusaudit.FieldReasonCode] = struct{}{}
}

// ReasonCodeCleared returns if the "reason_code" field was cleared in this mutation.
func (m *NexusAuditMutation) ReasonCodeCleared() bool {
	_, ok := m.clearedFields[nexusaudit.FieldReasonCode]
	return ok
}

// ResetReasonCode resets all changes to the "reason_code" field.
func (m *NexusAuditMutation) ResetReasonCode() {
	m.reason_code = nil
	delete(m.clearedFields, nexusaudit.FieldReasonCode)
}

// SetTicketID sets the "ticket_id" field.
func (m *NexusAuditMutation) SetTicketID(s string) {
	m.ticket_id = &s
}

// TicketID returns the value of the "ticket_id" field in the mutation.
func (m *NexusAuditMutation) TicketID() (r string, exists bool) {
	v := m.ticket_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTicketID returns the old "ticket_id" field's value of the NexusAudit entity.
// If the NexusAudit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NexusAuditMutation) OldTicketID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTicketID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTicketID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTicketID: %w", err)
	}
	return oldValue.TicketID, nil
}

// ClearTicketID clears the value of the "ticket_id" field.
func (m *NexusAuditMutation) ClearTicketID() {
	m.ticket_id = nil
	m.clearedFields[nexusaudit.FieldTicketID] = struct{}{}
}

// TicketIDCleared returns if the "ticket_id" field was cleared in this mutation.
func (m *NexusAuditMutation) TicketIDCleared() bool {
	_, ok := m.clearedFields[nexusaudit.FieldTicketID]
	return ok
}

// ResetTicketID resets all changes to the "ticket_id" field.
func (m *NexusAuditMutation) ResetTicketID() {
	m.ticket_id = nil
	delete(m.clearedFields, nexusaudit.FieldTicketID)
}

// SetTimestamp sets the "timestamp" field.
func (m *NexusAuditMutation) SetTimestamp(t time.Time) {
	m.timestamp = &t
}

// Timestamp returns the value of the "timestamp" field in the mutation.
func (m *NexusAuditMutation) Timestamp() (r time.Time, exists bool) {
	v := m.timestamp
	if v == nil {
		return
	}
	return *v, true
}

// OldTimestamp returns the old "timestamp" field's value of the NexusAudit entity.
// If the NexusAudit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NexusAuditMutation) OldTimestamp(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTimestamp is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTimestamp requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTimestamp: %w", err)
	}
	return oldValue.Timestamp, nil
}

// ResetTimestamp resets all changes to the "timestamp" field.
func (m *NexusAuditMutation) ResetTimestamp() {
	m.timestamp = nil
}

// SetMetadata sets the "metadata" field.
func (m *NexusAuditMutation) SetMetadata(value map[string]interface{}) {
	m.metadata = &value
}

// Metadata returns the value of the "metadata" field in the mutation.
func (m *NexusAuditMutation) Metadata() (r map[string]interface{}, exists bool) {
	v := m.metadata
	if v == nil {
		return
	}
	return *v, true
}

// OldMetadata returns the old "metadata" field's value of the NexusAudit entity.
// If the NexusAudit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NexusAuditMutation) OldMetadata(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMetadata is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMetadata requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetadata: %w", err)
	}
	return oldValue.Metadata, nil
}

// ClearMetadata clears the value of the "metadata" field.
func (m *NexusAuditMutation) ClearMetadata() {
	m.metadata = nil
	m.clearedFields[nexusaudit.FieldMetadata] = struct{}{}
}

// MetadataCleared returns if the "metadata" field was cleared in this mutation.
func (m *NexusAuditMutation) MetadataCleared() bool {
	_, ok := m.clearedFields[nexusaudit.FieldMetadata]
	return ok
}

// ResetMetadata resets all changes to the "metadata" field.
func (m *NexusAuditMutation) ResetMetadata() {
	m.metadata = nil
	delete(m.clearedFields, nexusaudit.FieldMetadata)
}

// SetTenantID sets the "tenant" edge to the Tenant entity by id.
func (m *NexusAuditMutation) SetTenantID(id int) {
	m.tenant = &id
}

// ClearTenant clears the "tenant" edge to the Tenant entity.
func (m *NexusAuditMutation) ClearTenant() {
	m.clearedtenant = true
}

// TenantCleared reports if the "tenant" edge to the Tenant entity was cleared.
func (m *NexusAuditMutation) TenantCleared() bool {
	return m.clearedtenant
}

// TenantID returns the "tenant" edge ID in the mutation.
func (m *NexusAuditMutation) TenantID() (id int, exists bool) {
	if m.tenant != nil {
		return *m.tenant, true
	}
	return
}

// TenantIDs returns the "tenant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TenantID instead. It exists only for internal usage by the builders.
func (m *NexusAuditMutation) TenantIDs() (ids []int) {
	if id := m.tenant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTenant resets all changes to the "tenant" edge.
func (m *NexusAuditMutation) ResetTenant() {
	m.tenant = nil
	m.clearedtenant = false
}

// Where appends a list predicates to the NexusAuditMutation builder.
func (m *NexusAuditMutation) Where(ps ...predicate.NexusAudit) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the NexusAuditMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *NexusAuditMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.NexusAudit, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *NexusAuditMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *NexusAuditMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (NexusAudit).
func (m *NexusAuditMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *NexusAuditMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.action != nil {
		fields = append(fields, nexusaudit.FieldAction)
	}
	if m.actor_id != nil {
		fields = append(fields, nexusaudit.FieldActorID)
	}
	if m.credential_id != nil {
		fields = append(fields, nexusaudit.FieldCredentialID)
	}
	if m.reason_code != nil {
		fields = append(fields, nexusaudit.FieldReasonCode)
	}
	if m.ticket_id != nil {
		fields = append(fields, nexusaudit.FieldTicketID)
	}
	if m.timestamp != nil {
		fields = append(fields, nexusaudit.FieldTimestamp)
	}
	if m.metadata != nil {
		fields = append(fields, nexusaudit.FieldMetadata)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *NexusAuditMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case nexusaudit.FieldAction:
		return m.Action()
	case nexusaudit.FieldActorID:
		return m.ActorID()
	case nexusaudit.FieldCredentialID:
		return m.CredentialID()
	case nexusaudit.FieldReasonCode:
		return m.ReasonCode()
	case nexusaudit.FieldTicketID:
		return m.TicketID()
	case nexusaudit.FieldTimestamp:
		return m.Timestamp()
	case nexusaudit.FieldMetadata:
		return m.Metadata()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *NexusAuditMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case nexusaudit.FieldAction:
		return m.OldAction(ctx)
	case nexusaudit.FieldActorID:
		return m.OldActorID(ctx)
	case nexusaudit.FieldCredentialID:
		return m.OldCredentialID(ctx)
	case nexusaudit.FieldReasonCode:
		return m.OldReasonCode(ctx)
	case nexusaudit.FieldTicketID:
		return m.OldTicketID(ctx)
	case nexusaudit.FieldTimestamp:
		return m.OldTimestamp(ctx)
	case nexusaudit.FieldMetadata:
		return m.OldMetadata(ctx)
	}
	return nil, fmt.Errorf("unknown NexusAudit field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NexusAuditMutation) SetField(name string, value ent.Value) error {
	switch name {
	case nexusaudit.FieldAction:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAction(v)
		return nil
	case nexusaudit.FieldActorID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetActorID(v)
		return nil
	case nexusaudit.FieldCredentialID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCredentialID(v)
		return nil
	case nexusaudit.FieldReasonCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReasonCode(v)
		return nil
	case nexusaudit.FieldTicketID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTicketID(v)
		return nil
	case nexusaudit.FieldTimestamp:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTimestamp(v)
		return nil
	case nexusaudit.FieldMetadata:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetadata(v)
		return nil
	}
	return fmt.Errorf("unknown NexusAudit field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *NexusAuditMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *NexusAuditMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NexusAuditMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown NexusAudit numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *NexusAuditMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(nexusaudit.FieldCredentialID) {
		fields = append(fields, nexusaudit.FieldCredentialID)
	}
	if m.FieldCleared(nexusaudit.FieldReasonCode) {
		fields = append(fields, nexusaudit.FieldReasonCode)
	}
	if m.FieldCleared(nexusaudit.FieldTicketID) {
		fields = append(fields, nexusaudit.FieldTicketID)
	}
	if m.FieldCleared(nexusaudit.FieldMetadata) {
		fields = append(fields, nexusaudit.FieldMetadata)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *NexusAuditMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *NexusAuditMutation) ClearField(name string) error {
	switch name {
	case nexusaudit.FieldCredentialID:
		m.ClearCredentialID()
		return nil
	case nexusaudit.FieldReasonCode:
		m.ClearReasonCode()
		return nil
	case nexusaudit.FieldTicketID:
		m.ClearTicketID()
		return nil
	case nexusaudit.FieldMetadata:
		m.ClearMetadata()
		return nil
	}
	return fmt.Errorf("unknown NexusAudit nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *NexusAuditMutation) ResetField(name string) error {
	switch name {
	case nexusaudit.FieldAction:
		m.ResetAction()
		return nil
	case nexusaudit.FieldActorID:
		m.ResetActorID()
		return nil
	case nexusaudit.FieldCredentialID:
		m.ResetCredentialID()
		return nil
	case nexusaudit.FieldReasonCode:
		m.ResetReasonCode()
		return nil
	case nexusaudit.FieldTicketID:
		m.ResetTicketID()
		return nil
	case nexusaudit.FieldTimestamp:
		m.ResetTimestamp()
		return nil
	case nexusaudit.FieldMetadata:
		m.ResetMetadata()
		return nil
	}
	return fmt.Errorf("unknown NexusAudit field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *NexusAuditMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.tenant != nil {
		edges = append(edges, nexusaudit.EdgeTenant)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *NexusAuditMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case nexusaudit.EdgeTenant:
		if id := m.tenant; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *NexusAuditMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *NexusAuditMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *NexusAuditMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedtenant {
		edges = append(edges, nexusaudit.EdgeTenant)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *NexusAuditMutation) EdgeCleared(name string) bool {
	switch name {
	case nexusaudit.EdgeTenant:
		return m.clearedtenant
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *NexusAuditMutation) ClearEdge(name string) error {
	switch name {
	case nexusaudit.EdgeTenant:
		m.ClearTenant()
		return nil
	}
	return fmt.Errorf("unknown NexusAudit unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *NexusAuditMutation) ResetEdge(name string) error {
	switch name {
	case nexusaudit.EdgeTenant:
		m.ResetTenant()
		return nil
	}
	return fmt.Errorf("unknown NexusAudit edge %s", name)
}

// OneTimeLinkMutation represents an operation that mutates the OneTimeLink nodes in the graph.
type OneTimeLinkMutation struct {
	config
	op                Op
	typ               string
	id                *int
	token             *string
	expires_at        *time.Time
	consumed          *bool
	created_at        *time.Time
	clearedFields     map[string]struct{}
	credential        *int
	clearedcredential bool
	tenant            *int
	clearedtenant     bool
	done              bool
	oldValue          func(context.Context) (*OneTimeLink, error)
	predicates        []predicate.OneTimeLink
}

var _ ent.Mutation = (*OneTimeLinkMutation)(nil)

// onetimelinkOption allows management of the mutation configuration using functional options.
type onetimelinkOption func(*OneTimeLinkMutation)

// newOneTimeLinkMutation creates new mutation for the OneTimeLink entity.
func newOneTimeLinkMutation(c config, op Op, opts ...onetimelinkOption) *OneTimeLinkMutation {
	m := &OneTimeLinkMutation{
		config:        c,
		op:            op,
		typ:           TypeOneTimeLink,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOneTimeLinkID sets the ID field of the mutation.
func withOneTimeLinkID(id int) onetimelinkOption {
	return func(m *OneTimeLinkMutation) {
		var (
			err   error
			once  sync.Once
			value *OneTimeLink
		)
		m.oldValue = func(ctx context.Context) (*OneTimeLink, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().OneTimeLink.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOneTimeLink sets the old OneTimeLink of the mutation.
func withOneTimeLink(node *OneTimeLink) onetimelinkOption {
	return func(m *OneTimeLinkMutation) {
		m.oldValue = func(context.Context) (*OneTimeLink, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m OneTimeLinkMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m OneTimeLinkMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *OneTimeLinkMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *OneTimeLinkMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().OneTimeLink.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTenantID sets the "tenant_id" field.
func (m *OneTimeLinkMutation) SetTenantID(i int) {
	m.tenant = &i
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *OneTimeLinkMutation) TenantID() (r int, exists bool) {
	v := m.tenant
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the OneTimeLink entity.
// If the OneTimeLink object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OneTimeLinkMutation) OldTenantID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *OneTimeLinkMutation) ResetTenantID() {
	m.tenant = nil
}

// SetCredentialID sets the "credential_id" field.
func (m *OneTimeLinkMutation) SetCredentialID(i int) {
	m.credential = &i
}

// CredentialID returns the value of the "credential_id" field in the mutation.
func (m *OneTimeLinkMutation) CredentialID() (r int, exists bool) {
	v := m.credential
	if v == nil {
		return
	}
	return *v, true
}

// OldCredentialID returns the old "credential_id" field's value of the OneTimeLink entity.
// If the OneTimeLink object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OneTimeLinkMutation) OldCredentialID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCredentialID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCredentialID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCredentialID: %w", err)
	}
	return oldValue.CredentialID, nil
}

// ResetCredentialID resets all changes to the "credential_id" field.
func (m *OneTimeLinkMutation) ResetCredentialID() {
	m.credential = nil
}

// SetToken sets the "token" field.
func (m *OneTimeLinkMutation) SetToken(s string) {
	m.token = &s
}

// Token returns the value of the "token" field in the mutation.
func (m *OneTimeLinkMutation) Token() (r string, exists bool) {
	v := m.token
	if v == nil {
		return
	}
	return *v, true
}

// OldToken returns the old "token" field's value of the OneTimeLink entity.
// If the OneTimeLink object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OneTimeLinkMutation) OldToken(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldToken is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldToken requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldToken: %w", err)
	}
	return oldValue.Token, nil
}

// ResetToken resets all changes to the "token" field.
func (m *OneTimeLinkMutation) ResetToken() {
	m.token = nil
}

// SetExpiresAt sets the "expires_at" field.
func (m *OneTimeLinkMutation) SetExpiresAt(t time.Time) {
	m.expires_at = &t
}

// ExpiresAt returns the value of the "expires_at" field in the mutation.
func (m *OneTimeLinkMutation) ExpiresAt() (r time.Time, exists bool) {
	v := m.expires_at
	if v == nil {
		return
	}
	return *v, true
}

// OldExpiresAt returns the old "expires_at" field's value of the OneTimeLink entity.
// If the OneTimeLink object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OneTimeLinkMutation) OldExpiresAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpiresAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpiresAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpiresAt: %w", err)
	}
	return oldValue.ExpiresAt, nil
}

// ResetExpiresAt resets all changes to the "expires_at" field.
func (m *OneTimeLinkMutation) ResetExpiresAt() {
	m.expires_at = nil
}

// SetConsumed sets the "consumed" field.
func (m *OneTimeLinkMutation) SetConsumed(b bool) {
	m.consumed = &b
}

// Consumed returns the value of the "consumed" field in the mutation.
func (m *OneTimeLinkMutation) Consumed() (r bool, exists bool) {
	v := m.consumed
	if v == nil {
		return
	}
	return *v, true
}

// OldConsumed returns the old "consumed" field's value of the OneTimeLink entity.
// If the OneTimeLink object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OneTimeLinkMutation) OldConsumed(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldConsumed is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldConsumed requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldConsumed: %w", err)
	}
	return oldValue.Consumed, nil
}

// ResetConsumed resets all changes to the "consumed" field.
func (m *OneTimeLinkMutation) ResetConsumed() {
	m.consumed = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *OneTimeLinkMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *OneTimeLinkMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the OneTimeLink entity.
// If the OneTimeLink object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OneTimeLinkMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *OneTimeLinkMutation) ResetCreatedAt() {
	m.created_at = nil
}

// ClearCredential clears the "credential" edge to the Credential entity.
func (m *OneTimeLinkMutation) ClearCredential() {
	m.clearedcredential = true
	m.clearedFields[onetimelink.FieldCredentialID] = struct{}{}
}

// CredentialCleared reports if the "credential" edge to the Credential entity was cleared.
func (m *OneTimeLinkMutation) CredentialCleared() bool {
	return m.clearedcredential
}

// CredentialIDs returns the "credential" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CredentialID instead. It exists only for internal usage by the builders.
func (m *OneTimeLinkMutation) CredentialIDs() (ids []int) {
	if id := m.credential; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCredential resets all changes to the "credential" edge.
func (m *OneTimeLinkMutation) ResetCredential() {
	m.credential = nil
	m.clearedcredential = false
}

// ClearTenant clears the "tenant" edge to the Tenant entity.
func (m *OneTimeLinkMutation) ClearTenant() {
	m.clearedtenant = true
	m.clearedFields[onetimelink.FieldTenantID] = struct{}{}
}

// TenantCleared reports if the "tenant" edge to the Tenant entity was cleared.
func (m *OneTimeLinkMutation) TenantCleared() bool {
	return m.clearedtenant
}

// TenantIDs returns the "tenant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TenantID instead. It exists only for internal usage by the builders.
func (m *OneTimeLinkMutation) TenantIDs() (ids []int) {
	if id := m.tenant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTenant resets all changes to the "tenant" edge.
func (m *OneTimeLinkMutation) ResetTenant() {
	m.tenant = nil
	m.clearedtenant = false
}

// Where appends a list predicates to the OneTimeLinkMutation builder.
func (m *OneTimeLinkMutation) Where(ps ...predicate.OneTimeLink) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the OneTimeLinkMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *OneTimeLinkMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.OneTimeLink, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *OneTimeLinkMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *OneTimeLinkMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (OneTimeLink).
func (m *OneTimeLinkMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *OneTimeLinkMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.tenant != nil {
		fields = append(fields, onetimelink.FieldTenantID)
	}
	if m.credential != nil {
		fields = append(fields, onetimelink.FieldCredentialID)
	}
	if m.token != nil {
		fields = append(fields, onetimelink.FieldToken)
	}
	if m.expires_at != nil {
		fields = append(fields, onetimelink.FieldExpiresAt)
	}
	if m.consumed != nil {
		fields = append(fields, onetimelink.FieldConsumed)
	}
	if m.created_at != nil {
		fields = append(fields, onetimelink.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *OneTimeLinkMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case onetimelink.FieldTenantID:
		return m.TenantID()
	case onetimelink.FieldCredentialID:
		return m.CredentialID()
	case onetimelink.FieldToken:
		return m.Token()
	case onetimelink.FieldExpiresAt:
		return m.ExpiresAt()
	case onetimelink.FieldConsumed:
		return m.Consumed()
	case onetimelink.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *OneTimeLinkMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case onetimelink.FieldTenantID:
		return m.OldTenantID(ctx)
	case onetimelink.FieldCredentialID:
		return m.OldCredentialID(ctx)
	case onetimelink.FieldToken:
		return m.OldToken(ctx)
	case onetimelink.FieldExpiresAt:
		return m.OldExpiresAt(ctx)
	case onetimelink.FieldConsumed:
		return m.OldConsumed(ctx)
	case onetimelink.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown OneTimeLink field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OneTimeLinkMutation) SetField(name string, value ent.Value) error {
	switch name {
	case onetimelink.FieldTenantID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case onetimelink.FieldCredentialID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCredentialID(v)
		return nil
	case onetimelink.FieldToken:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetToken(v)
		return nil
	case onetimelink.FieldExpiresAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpiresAt(v)
		return nil
	case onetimelink.FieldConsumed:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetConsumed(v)
		return nil
	case onetimelink.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown OneTimeLink field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *OneTimeLinkMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *OneTimeLinkMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OneTimeLinkMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown OneTimeLink numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *OneTimeLinkMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *OneTimeLinkMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *OneTimeLinkMutation) ClearField(name string) error {
	return fmt.Errorf("unknown OneTimeLink nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *OneTimeLinkMutation) ResetField(name string) error {
	switch name {
	case onetimelink.FieldTenantID:
		m.ResetTenantID()
		return nil
	case onetimelink.FieldCredentialID:
		m.ResetCredentialID()
		return nil
	case onetimelink.FieldToken:
		m.ResetToken()
		return nil
	case onetimelink.FieldExpiresAt:
		m.ResetExpiresAt()
		return nil
	case onetimelink.FieldConsumed:
		m.ResetConsumed()
		return nil
	case onetimelink.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown OneTimeLink field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *OneTimeLinkMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.credential != nil {
		edges = append(edges, onetimelink.EdgeCredential)
	}
	if m.tenant != nil {
		edges = append(edges, onetimelink.EdgeTenant)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *OneTimeLinkMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case onetimelink.EdgeCredential:
		if id := m.credential; id != nil {
			return []ent.Value{*id}
		}
	case onetimelink.EdgeTenant:
		if id := m.tenant; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *OneTimeLinkMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *OneTimeLinkMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *OneTimeLinkMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedcredential {
		edges = append(edges, onetimelink.EdgeCredential)
	}
	if m.clearedtenant {
		edges = append(edges, onetimelink.EdgeTenant)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *OneTimeLinkMutation) EdgeCleared(name string) bool {
	switch name {
	case onetimelink.EdgeCredential:
		return m.clearedcredential
	case onetimelink.EdgeTenant:
		return m.clearedtenant
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *OneTimeLinkMutation) ClearEdge(name string) error {
	switch name {
	case onetimelink.EdgeCredential:
		m.ClearCredential()
		return nil
	case onetimelink.EdgeTenant:
		m.ClearTenant()
		return nil
	}
	return fmt.Errorf("unknown OneTimeLink unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *OneTimeLinkMutation) ResetEdge(name string) error {
	switch name {
	case onetimelink.EdgeCredential:
		m.ResetCredential()
		return nil
	case onetimelink.EdgeTenant:
		m.ResetTenant()
		return nil
	}
	return fmt.Errorf("unknown OneTimeLink edge %s", name)
}

// PerformanceReviewMutation represents an operation that mutates the PerformanceReview nodes in the graph.
type PerformanceReviewMutation struct {
	config
	op                    Op
	typ                   string
	id                    *int
	overall_rating        *performancereview.OverallRating
	review_type           *performancereview.ReviewType
	strengths             *string
	areas_for_improvement *string
	manager_comments      *string
	goals_assessment      *map[string]interface{}
	survey_responses      *map[string]interface{}
	status                *performancereview.Status
	submitted_at          *time.Time
	acknowledged_at       *time.Time
	created_at            *time.Time
	updated_at            *time.Time
	clearedFields         map[string]struct{}
	tenant                *int
	clearedtenant         bool
	employee              *int
	clearedemployee       bool
	reviewer              *int
	clearedreviewer       bool
	cycle                 *int
	clearedcycle          bool
	done                  bool
	oldValue              func(context.Context) (*PerformanceReview, error)
	predicates            []predicate.PerformanceReview
}

var _ ent.Mutation = (*PerformanceReviewMutation)(nil)

// performancereviewOption allows management of the mutation configuration using functional options.
type performancereviewOption func(*PerformanceReviewMutation)

// newPerformanceReviewMutation creates new mutation for the PerformanceReview entity.
func newPerformanceReviewMutation(c config, op Op, opts ...performancereviewOption) *PerformanceReviewMutation {
	m := &PerformanceReviewMutation{
		config:        c,
		op:            op,
		typ:           TypePerformanceReview,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPerformanceReviewID sets the ID field of the mutation.
func withPerformanceReviewID(id int) performancereviewOption {
	return func(m *PerformanceReviewMutation) {
		var (
			err   error
			once  sync.Once
			value *PerformanceReview
		)
		m.oldValue = func(ctx context.Context) (*PerformanceReview, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().PerformanceReview.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPerformanceReview sets the old PerformanceReview of the mutation.
func withPerformanceReview(node *PerformanceReview) performancereviewOption {
	return func(m *PerformanceReviewMutation) {
		m.oldValue = func(context.Context) (*PerformanceReview, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PerformanceReviewMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PerformanceReviewMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PerformanceReviewMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PerformanceReviewMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().PerformanceReview.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetOverallRating sets the "overall_rating" field.
func (m *PerformanceReviewMutation) SetOverallRating(pr performancereview.OverallRating) {
	m.overall_rating = &pr
}

// OverallRating returns the value of the "overall_rating" field in the mutation.
func (m *PerformanceReviewMutation) OverallRating() (r performancereview.OverallRating, exists bool) {
	v := m.overall_rating
	if v == nil {
		return
	}
	return *v, true
}

// OldOverallRating returns the old "overall_rating" field's value of the PerformanceReview entity.
// If the PerformanceReview object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PerformanceReviewMutation) OldOverallRating(ctx context.Context) (v performancereview.OverallRating, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOverallRating is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOverallRating requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOverallRating: %w", err)
	}
	return oldValue.OverallRating, nil
}

// ClearOverallRating clears the value of the "overall_rating" field.
func (m *PerformanceReviewMutation) ClearOverallRating() {
	m.overall_rating = nil
	m.clearedFields[performancereview.FieldOverallRating] = struct{}{}
}

// OverallRatingCleared returns if the "overall_rating" field was cleared in this mutation.
func (m *PerformanceReviewMutation) OverallRatingCleared() bool {
	_, ok := m.clearedFields[performancereview.FieldOverallRating]
	return ok
}

// ResetOverallRating resets all changes to the "overall_rating" field.
func (m *PerformanceReviewMutation) ResetOverallRating() {
	m.overall_rating = nil
	delete(m.clearedFields, performancereview.FieldOverallRating)
}

// SetReviewType sets the "review_type" field.
func (m *PerformanceReviewMutation) SetReviewType(pt performancereview.ReviewType) {
	m.review_type = &pt
}

// ReviewType returns the value of the "review_type" field in the mutation.
func (m *PerformanceReviewMutation) ReviewType() (r performancereview.ReviewType, exists bool) {
	v := m.review_type
	if v == nil {
		return
	}
	return *v, true
}

// OldReviewType returns the old "review_type" field's value of the PerformanceReview entity.
// If the PerformanceReview object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PerformanceReviewMutation) OldReviewType(ctx context.Context) (v performancereview.ReviewType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReviewType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReviewType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReviewType: %w", err)
	}
	return oldValue.ReviewType, nil
}

// ResetReviewType resets all changes to the "review_type" field.
func (m *PerformanceReviewMutation) ResetReviewType() {
	m.review_type = nil
}

// SetStrengths sets the "strengths" field.
func (m *PerformanceReviewMutation) SetStrengths(s string) {
	m.strengths = &s
}

// Strengths returns the value of the "strengths" field in the mutation.
func (m *PerformanceReviewMutation) Strengths() (r string, exists bool) {
	v := m.strengths
	if v == nil {
		return
	}
	return *v, true
}

// OldStrengths returns the old "strengths" field's value of the PerformanceReview entity.
// If the PerformanceReview object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PerformanceReviewMutation) OldStrengths(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStrengths is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStrengths requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStrengths: %w", err)
	}
	return oldValue.Strengths, nil
}

// ClearStrengths clears the value of the "strengths" field.
func (m *PerformanceReviewMutation) ClearStrengths() {
	m.strengths = nil
	m.clearedFields[performancereview.FieldStrengths] = struct{}{}
}

// StrengthsCleared returns if the "strengths" field was cleared in this mutation.
func (m *PerformanceReviewMutation) StrengthsCleared() bool {
	_, ok := m.clearedFields[performancereview.FieldStrengths]
	return ok
}

// ResetStrengths resets all changes to the "strengths" field.
func (m *PerformanceReviewMutation) ResetStrengths() {
	m.strengths = nil
	delete(m.clearedFields, performancereview.FieldStrengths)
}

// SetAreasForImprovement sets the "areas_for_improvement" field.
func (m *PerformanceReviewMutation) SetAreasForImprovement(s string) {
	m.areas_for_improvement = &s
}

// AreasForImprovement returns the value of the "areas_for_improvement" field in the mutation.
func (m *PerformanceReviewMutation) AreasForImprovement() (r string, exists bool) {
	v := m.areas_for_improvement
	if v == nil {
		return
	}
	return *v, true
}

// OldAreasForImprovement returns the old "areas_for_improvement" field's value of the PerformanceReview entity.
// If the PerformanceReview object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PerformanceReviewMutation) OldAreasForImprovement(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAreasForImprovement is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAreasForImprovement requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAreasForImprovement: %w", err)
	}
	return oldValue.AreasForImprovement, nil
}

// ClearAreasForImprovement clears the value of the "areas_for_improvement" field.
func (m *PerformanceReviewMutation) ClearAreasForImprovement() {
	m.areas_for_improvement = nil
	m.clearedFields[performancereview.FieldAreasForImprovement] = struct{}{}
}

// AreasForImprovementCleared returns if the "areas_for_improvement" field was cleared in this mutation.
func (m *PerformanceReviewMutation) AreasForImprovementCleared() bool {
	_, ok := m.clearedFields[performancereview.FieldAreasForImprovement]
	return ok
}

// ResetAreasForImprovement resets all changes to the "areas_for_improvement" field.
func (m *PerformanceReviewMutation) ResetAreasForImprovement() {
	m.areas_for_improvement = nil
	delete(m.clearedFields, performancereview.FieldAreasForImprovement)
}

// SetManagerComments sets the "manager_comments" field.
func (m *PerformanceReviewMutation) SetManagerComments(s string) {
	m.manager_comments = &s
}

// ManagerComments returns the value of the "manager_comments" field in the mutation.
func (m *PerformanceReviewMutation) ManagerComments() (r string, exists bool) {
	v := m.manager_comments
	if v == nil {
		return
	}
	return *v, true
}

// OldManagerComments returns the old "manager_comments" field's value of the PerformanceReview entity.
// If the PerformanceReview object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PerformanceReviewMutation) OldManagerComments(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldManagerComments is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldManagerComments requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldManagerComments: %w", err)
	}
	return oldValue.ManagerComments, nil
}

// ClearManagerComments clears the value of the "manager_comments" field.
func (m *PerformanceReviewMutation) ClearManagerComments() {
	m.manager_comments = nil
	m.clearedFields[performancereview.FieldManagerComments] = struct{}{}
}

// ManagerCommentsCleared returns if the "manager_comments" field was cleared in this mutation.
func (m *PerformanceReviewMutation) ManagerCommentsCleared() bool {
	_, ok := m.clearedFields[performancereview.FieldManagerComments]
	return ok
}

// ResetManagerComments resets all changes to the "manager_comments" field.
func (m *PerformanceReviewMutation) ResetManagerComments() {
	m.manager_comments = nil
	delete(m.clearedFields, performancereview.FieldManagerComments)
}

// SetGoalsAssessment sets the "goals_assessment" field.
func (m *PerformanceReviewMutation) SetGoalsAssessment(value map[string]interface{}) {
	m.goals_assessment = &value
}

// GoalsAssessment returns the value of the "goals_assessment" field in the mutation.
func (m *PerformanceReviewMutation) GoalsAssessment() (r map[string]interface{}, exists bool) {
	v := m.goals_assessment
	if v == nil {
		return
	}
	return *v, true
}

// OldGoalsAssessment returns the old "goals_assessment" field's value of the PerformanceReview entity.
// If the PerformanceReview object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PerformanceReviewMutation) OldGoalsAssessment(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGoalsAssessment is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGoalsAssessment requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGoalsAssessment: %w", err)
	}
	return oldValue.GoalsAssessment, nil
}

// ClearGoalsAssessment clears the value of the "goals_assessment" field.
func (m *PerformanceReviewMutation) ClearGoalsAssessment() {
	m.goals_assessment = nil
	m.clearedFields[performancereview.FieldGoalsAssessment] = struct{}{}
}

// GoalsAssessmentCleared returns if the "goals_assessment" field was cleared in this mutation.
func (m *PerformanceReviewMutation) GoalsAssessmentCleared() bool {
	_, ok := m.clearedFields[performancereview.FieldGoalsAssessment]
	return ok
}

// ResetGoalsAssessment resets all changes to the "goals_assessment" field.
func (m *PerformanceReviewMutation) ResetGoalsAssessment() {
	m.goals_assessment = nil
	delete(m.clearedFields, performancereview.FieldGoalsAssessment)
}

// SetSurveyResponses sets the "survey_responses" field.
func (m *PerformanceReviewMutation) SetSurveyResponses(value map[string]interface{}) {
	m.survey_responses = &value
}

// SurveyResponses returns the value of the "survey_responses" field in the mutation.
func (m *PerformanceReviewMutation) SurveyResponses() (r map[string]interface{}, exists bool) {
	v := m.survey_responses
	if v == nil {
		return
	}
	return *v, true
}

// OldSurveyResponses returns the old "survey_responses" field's value of the PerformanceReview entity.
// If the PerformanceReview object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PerformanceReviewMutation) OldSurveyResponses(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSurveyResponses is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSurveyResponses requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSurveyResponses: %w", err)
	}
	return oldValue.SurveyResponses, nil
}

// ClearSurveyResponses clears the value of the "survey_responses" field.
func (m *PerformanceReviewMutation) ClearSurveyResponses() {
	m.survey_responses = nil
	m.clearedFields[performancereview.FieldSurveyResponses] = struct{}{}
}

// SurveyResponsesCleared returns if the "survey_responses" field was cleared in this mutation.
func (m *PerformanceReviewMutation) SurveyResponsesCleared() bool {
	_, ok := m.clearedFields[performancereview.FieldSurveyResponses]
	return ok
}

// ResetSurveyResponses resets all changes to the "survey_responses" field.
func (m *PerformanceReviewMutation) ResetSurveyResponses() {
	m.survey_responses = nil
	delete(m.clearedFields, performancereview.FieldSurveyResponses)
}

// SetStatus sets the "status" field.
func (m *PerformanceReviewMutation) SetStatus(pe performancereview.Status) {
	m.status = &pe
}

// Status returns the value of the "status" field in the mutation.
func (m *PerformanceReviewMutation) Status() (r performancereview.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the PerformanceReview entity.
// If the PerformanceReview object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PerformanceReviewMutation) OldStatus(ctx context.Context) (v performancereview.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *PerformanceReviewMutation) ResetStatus() {
	m.status = nil
}

// SetSubmittedAt sets the "submitted_at" field.
func (m *PerformanceReviewMutation) SetSubmittedAt(t time.Time) {
	m.submitted_at = &t
}

// SubmittedAt returns the value of the "submitted_at" field in the mutation.
func (m *PerformanceReviewMutation) SubmittedAt() (r time.Time, exists bool) {
	v := m.submitted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldSubmittedAt returns the old "submitted_at" field's value of the PerformanceReview entity.
// If the PerformanceReview object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PerformanceReviewMutation) OldSubmittedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSubmittedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSubmittedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSubmittedAt: %w", err)
	}
	return oldValue.SubmittedAt, nil
}

// ClearSubmittedAt clears the value of the "submitted_at" field.
func (m *PerformanceReviewMutation) ClearSubmittedAt() {
	m.submitted_at = nil
	m.clearedFields[performancereview.FieldSubmittedAt] = struct{}{}
}

// SubmittedAtCleared returns if the "submitted_at" field was cleared in this mutation.
func (m *PerformanceReviewMutation) SubmittedAtCleared() bool {
	_, ok := m.clearedFields[performancereview.FieldSubmittedAt]
	return ok
}

// ResetSubmittedAt resets all changes to the "submitted_at" field.
func (m *PerformanceReviewMutation) ResetSubmittedAt() {
	m.submitted_at = nil
	delete(m.clearedFields, performancereview.FieldSubmittedAt)
}

// SetAcknowledgedAt sets the "acknowledged_at" field.
func (m *PerformanceReviewMutation) SetAcknowledgedAt(t time.Time) {
	m.acknowledged_at = &t
}

// AcknowledgedAt returns the value of the "acknowledged_at" field in the mutation.
func (m *PerformanceReviewMutation) AcknowledgedAt() (r time.Time, exists bool) {
	v := m.acknowledged_at
	if v == nil {
		return
	}
	return *v, true
}

// OldAcknowledgedAt returns the old "acknowledged_at" field's value of the PerformanceReview entity.
// If the PerformanceReview object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PerformanceReviewMutation) OldAcknowledgedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAcknowledgedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAcknowledgedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAcknowledgedAt: %w", err)
	}
	return oldValue.AcknowledgedAt, nil
}

// ClearAcknowledgedAt clears the value of the "acknowledged_at" field.
func (m *PerformanceReviewMutation) ClearAcknowledgedAt() {
	m.acknowledged_at = nil
	m.clearedFields[performancereview.FieldAcknowledgedAt] = struct{}{}
}

// AcknowledgedAtCleared returns if the "acknowledged_at" field was cleared in this mutation.
func (m *PerformanceReviewMutation) AcknowledgedAtCleared() bool {
	_, ok := m.clearedFields[performancereview.FieldAcknowledgedAt]
	return ok
}

// ResetAcknowledgedAt resets all changes to the "acknowledged_at" field.
func (m *PerformanceReviewMutation) ResetAcknowledgedAt() {
	m.acknowledged_at = nil
	delete(m.clearedFields, performancereview.FieldAcknowledgedAt)
}

// SetCreatedAt sets the "created_at" field.
func (m *PerformanceReviewMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *PerformanceReviewMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the PerformanceReview entity.
// If the PerformanceReview object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PerformanceReviewMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *PerformanceReviewMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *PerformanceReviewMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *PerformanceReviewMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the PerformanceReview entity.
// If the PerformanceReview object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PerformanceReviewMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *PerformanceReviewMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetTenantID sets the "tenant" edge to the Tenant entity by id.
func (m *PerformanceReviewMutation) SetTenantID(id int) {
	m.tenant = &id
}

// ClearTenant clears the "tenant" edge to the Tenant entity.
func (m *PerformanceReviewMutation) ClearTenant() {
	m.clearedtenant = true
}

// TenantCleared reports if the "tenant" edge to the Tenant entity was cleared.
func (m *PerformanceReviewMutation) TenantCleared() bool {
	return m.clearedtenant
}

// TenantID returns the "tenant" edge ID in the mutation.
func (m *PerformanceReviewMutation) TenantID() (id int, exists bool) {
	if m.tenant != nil {
		return *m.tenant, true
	}
	return
}

// TenantIDs returns the "tenant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TenantID instead. It exists only for internal usage by the builders.
func (m *PerformanceReviewMutation) TenantIDs() (ids []int) {
	if id := m.tenant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTenant resets all changes to the "tenant" edge.
func (m *PerformanceReviewMutation) ResetTenant() {
	m.tenant = nil
	m.clearedtenant = false
}

// SetEmployeeID sets the "employee" edge to the Employee entity by id.
func (m *PerformanceReviewMutation) SetEmployeeID(id int) {
	m.employee = &id
}

// ClearEmployee clears the "employee" edge to the Employee entity.
func (m *PerformanceReviewMutation) ClearEmployee() {
	m.clearedemployee = true
}

// EmployeeCleared reports if the "employee" edge to the Employee entity was cleared.
func (m *PerformanceReviewMutation) EmployeeCleared() bool {
	return m.clearedemployee
}

// EmployeeID returns the "employee" edge ID in the mutation.
func (m *PerformanceReviewMutation) EmployeeID() (id int, exists bool) {
	if m.employee != nil {
		return *m.employee, true
	}
	return
}

// EmployeeIDs returns the "employee" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// EmployeeID instead. It exists only for internal usage by the builders.
func (m *PerformanceReviewMutation) EmployeeIDs() (ids []int) {
	if id := m.employee; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEmployee resets all changes to the "employee" edge.
func (m *PerformanceReviewMutation) ResetEmployee() {
	m.employee = nil
	m.clearedemployee = false
}

// SetReviewerID sets the "reviewer" edge to the Employee entity by id.
func (m *PerformanceReviewMutation) SetReviewerID(id int) {
	m.reviewer = &id
}

// ClearReviewer clears the "reviewer" edge to the Employee entity.
func (m *PerformanceReviewMutation) ClearReviewer() {
	m.clearedreviewer = true
}

// ReviewerCleared reports if the "reviewer" edge to the Employee entity was cleared.
func (m *PerformanceReviewMutation) ReviewerCleared() bool {
	return m.clearedreviewer
}

// ReviewerID returns the "reviewer" edge ID in the mutation.
func (m *PerformanceReviewMutation) ReviewerID() (id int, exists bool) {
	if m.reviewer != nil {
		return *m.reviewer, true
	}
	return
}

// ReviewerIDs returns the "reviewer" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ReviewerID instead. It exists only for internal usage by the builders.
func (m *PerformanceReviewMutation) ReviewerIDs() (ids []int) {
	if id := m.reviewer; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetReviewer resets all changes to the "reviewer" edge.
func (m *PerformanceReviewMutation) ResetReviewer() {
	m.reviewer = nil
	m.clearedreviewer = false
}

// SetCycleID sets the "cycle" edge to the ReviewCycle entity by id.
func (m *PerformanceReviewMutation) SetCycleID(id int) {
	m.cycle = &id
}

// ClearCycle clears the "cycle" edge to the ReviewCycle entity.
func (m *PerformanceReviewMutation) ClearCycle() {
	m.clearedcycle = true
}

// CycleCleared reports if the "cycle" edge to the ReviewCycle entity was cleared.
func (m *PerformanceReviewMutation) CycleCleared() bool {
	return m.clearedcycle
}

// CycleID returns the "cycle" edge ID in the mutation.
func (m *PerformanceReviewMutation) CycleID() (id int, exists bool) {
	if m.cycle != nil {
		return *m.cycle, true
	}
	return
}

// CycleIDs returns the "cycle" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CycleID instead. It exists only for internal usage by the builders.
func (m *PerformanceReviewMutation) CycleIDs() (ids []int) {
	if id := m.cycle; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCycle resets all changes to the "cycle" edge.
func (m *PerformanceReviewMutation) ResetCycle() {
	m.cycle = nil
	m.clearedcycle = false
}

// Where appends a list predicates to the PerformanceReviewMutation builder.
func (m *PerformanceReviewMutation) Where(ps ...predicate.PerformanceReview) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PerformanceReviewMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PerformanceReviewMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.PerformanceReview, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PerformanceReviewMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PerformanceReviewMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (PerformanceReview).
func (m *PerformanceReviewMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PerformanceReviewMutation) Fields() []string {
	fields := make([]string, 0, 12)
	if m.overall_rating != nil {
		fields = append(fields, performancereview.FieldOverallRating)
	}
	if m.review_type != nil {
		fields = append(fields, performancereview.FieldReviewType)
	}
	if m.strengths != nil {
		fields = append(fields, performancereview.FieldStrengths)
	}
	if m.areas_for_improvement != nil {
		fields = append(fields, performancereview.FieldAreasForImprovement)
	}
	if m.manager_comments != nil {
		fields = append(fields, performancereview.FieldManagerComments)
	}
	if m.goals_assessment != nil {
		fields = append(fields, performancereview.FieldGoalsAssessment)
	}
	if m.survey_responses != nil {
		fields = append(fields, performancereview.FieldSurveyResponses)
	}
	if m.status != nil {
		fields = append(fields, performancereview.FieldStatus)
	}
	if m.submitted_at != nil {
		fields = append(fields, performancereview.FieldSubmittedAt)
	}
	if m.acknowledged_at != nil {
		fields = append(fields, performancereview.FieldAcknowledgedAt)
	}
	if m.created_at != nil {
		fields = append(fields, performancereview.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, performancereview.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PerformanceReviewMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case performancereview.FieldOverallRating:
		return m.OverallRating()
	case performancereview.FieldReviewType:
		return m.ReviewType()
	case performancereview.FieldStrengths:
		return m.Strengths()
	case performancereview.FieldAreasForImprovement:
		return m.AreasForImprovement()
	case performancereview.FieldManagerComments:
		return m.ManagerComments()
	case performancereview.FieldGoalsAssessment:
		return m.GoalsAssessment()
	case performancereview.FieldSurveyResponses:
		return m.SurveyResponses()
	case performancereview.FieldStatus:
		return m.Status()
	case performancereview.FieldSubmittedAt:
		return m.SubmittedAt()
	case performancereview.FieldAcknowledgedAt:
		return m.AcknowledgedAt()
	case performancereview.FieldCreatedAt:
		return m.CreatedAt()
	case performancereview.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PerformanceReviewMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case performancereview.FieldOverallRating:
		return m.OldOverallRating(ctx)
	case performancereview.FieldReviewType:
		return m.OldReviewType(ctx)
	case performancereview.FieldStrengths:
		return m.OldStrengths(ctx)
	case performancereview.FieldAreasForImprovement:
		return m.OldAreasForImprovement(ctx)
	case performancereview.FieldManagerComments:
		return m.OldManagerComments(ctx)
	case performancereview.FieldGoalsAssessment:
		return m.OldGoalsAssessment(ctx)
	case performancereview.FieldSurveyResponses:
		return m.OldSurveyResponses(ctx)
	case performancereview.FieldStatus:
		return m.OldStatus(ctx)
	case performancereview.FieldSubmittedAt:
		return m.OldSubmittedAt(ctx)
	case performancereview.FieldAcknowledgedAt:
		return m.OldAcknowledgedAt(ctx)
	case performancereview.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case performancereview.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown PerformanceReview field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PerformanceReviewMutation) SetField(name string, value ent.Value) error {
	switch name {
	case performancereview.FieldOverallRating:
		v, ok := value.(performancereview.OverallRating)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOverallRating(v)
		return nil
	case performancereview.FieldReviewType:
		v, ok := value.(performancereview.ReviewType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReviewType(v)
		return nil
	case performancereview.FieldStrengths:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStrengths(v)
		return nil
	case performancereview.FieldAreasForImprovement:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAreasForImprovement(v)
		return nil
	case performancereview.FieldManagerComments:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetManagerComments(v)
		return nil
	case performancereview.FieldGoalsAssessment:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGoalsAssessment(v)
		return nil
	case performancereview.FieldSurveyResponses:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSurveyResponses(v)
		return nil
	case performancereview.FieldStatus:
		v, ok := value.(performancereview.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case performancereview.FieldSubmittedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSubmittedAt(v)
		return nil
	case performancereview.FieldAcknowledgedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAcknowledgedAt(v)
		return nil
	case performancereview.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case performancereview.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown PerformanceReview field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PerformanceReviewMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PerformanceReviewMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PerformanceReviewMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown PerformanceReview numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PerformanceReviewMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(performancereview.FieldOverallRating) {
		fields = append(fields, performancereview.FieldOverallRating)
	}
	if m.FieldCleared(performancereview.FieldStrengths) {
		fields = append(fields, performancereview.FieldStrengths)
	}
	if m.FieldCleared(performancereview.FieldAreasForImprovement) {
		fields = append(fields, performancereview.FieldAreasForImprovement)
	}
	if m.FieldCleared(performancereview.FieldManagerComments) {
		fields = append(fields, performancereview.FieldManagerComments)
	}
	if m.FieldCleared(performancereview.FieldGoalsAssessment) {
		fields = append(fields, performancereview.FieldGoalsAssessment)
	}
	if m.FieldCleared(performancereview.FieldSurveyResponses) {
		fields = append(fields, performancereview.FieldSurveyResponses)
	}
	if m.FieldCleared(performancereview.FieldSubmittedAt) {
		fields = append(fields, performancereview.FieldSubmittedAt)
	}
	if m.FieldCleared(performancereview.FieldAcknowledgedAt) {
		fields = append(fields, performancereview.FieldAcknowledgedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PerformanceReviewMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PerformanceReviewMutation) ClearField(name string) error {
	switch name {
	case performancereview.FieldOverallRating:
		m.ClearOverallRating()
		return nil
	case performancereview.FieldStrengths:
		m.ClearStrengths()
		return nil
	case performancereview.FieldAreasForImprovement:
		m.ClearAreasForImprovement()
		return nil
	case performancereview.FieldManagerComments:
		m.ClearManagerComments()
		return nil
	case performancereview.FieldGoalsAssessment:
		m.ClearGoalsAssessment()
		return nil
	case performancereview.FieldSurveyResponses:
		m.ClearSurveyResponses()
		return nil
	case performancereview.FieldSubmittedAt:
		m.ClearSubmittedAt()
		return nil
	case performancereview.FieldAcknowledgedAt:
		m.ClearAcknowledgedAt()
		return nil
	}
	return fmt.Errorf("unknown PerformanceReview nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PerformanceReviewMutation) ResetField(name string) error {
	switch name {
	case performancereview.FieldOverallRating:
		m.ResetOverallRating()
		return nil
	case performancereview.FieldReviewType:
		m.ResetReviewType()
		return nil
	case performancereview.FieldStrengths:
		m.ResetStrengths()
		return nil
	case performancereview.FieldAreasForImprovement:
		m.ResetAreasForImprovement()
		return nil
	case performancereview.FieldManagerComments:
		m.ResetManagerComments()
		return nil
	case performancereview.FieldGoalsAssessment:
		m.ResetGoalsAssessment()
		return nil
	case performancereview.FieldSurveyResponses:
		m.ResetSurveyResponses()
		return nil
	case performancereview.FieldStatus:
		m.ResetStatus()
		return nil
	case performancereview.FieldSubmittedAt:
		m.ResetSubmittedAt()
		return nil
	case performancereview.FieldAcknowledgedAt:
		m.ResetAcknowledgedAt()
		return nil
	case performancereview.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case performancereview.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown PerformanceReview field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PerformanceReviewMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.tenant != nil {
		edges = append(edges, performancereview.EdgeTenant)
	}
	if m.employee != nil {
		edges = append(edges, performancereview.EdgeEmployee)
	}
	if m.reviewer != nil {
		edges = append(edges, performancereview.EdgeReviewer)
	}
	if m.cycle != nil {
		edges = append(edges, performancereview.EdgeCycle)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PerformanceReviewMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case performancereview.EdgeTenant:
		if id := m.tenant; id != nil {
			return []ent.Value{*id}
		}
	case performancereview.EdgeEmployee:
		if id := m.employee; id != nil {
			return []ent.Value{*id}
		}
	case performancereview.EdgeReviewer:
		if id := m.reviewer; id != nil {
			return []ent.Value{*id}
		}
	case performancereview.EdgeCycle:
		if id := m.cycle; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PerformanceReviewMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PerformanceReviewMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PerformanceReviewMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedtenant {
		edges = append(edges, performancereview.EdgeTenant)
	}
	if m.clearedemployee {
		edges = append(edges, performancereview.EdgeEmployee)
	}
	if m.clearedreviewer {
		edges = append(edges, performancereview.EdgeReviewer)
	}
	if m.clearedcycle {
		edges = append(edges, performancereview.EdgeCycle)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PerformanceReviewMutation) EdgeCleared(name string) bool {
	switch name {
	case performancereview.EdgeTenant:
		return m.clearedtenant
	case performancereview.EdgeEmployee:
		return m.clearedemployee
	case performancereview.EdgeReviewer:
		return m.clearedreviewer
	case performancereview.EdgeCycle:
		return m.clearedcycle
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PerformanceReviewMutation) ClearEdge(name string) error {
	switch name {
	case performancereview.EdgeTenant:
		m.ClearTenant()
		return nil
	case performancereview.EdgeEmployee:
		m.ClearEmployee()
		return nil
	case performancereview.EdgeReviewer:
		m.ClearReviewer()
		return nil
	case performancereview.EdgeCycle:
		m.ClearCycle()
		return nil
	}
	return fmt.Errorf("unknown PerformanceReview unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PerformanceReviewMutation) ResetEdge(name string) error {
	switch name {
	case performancereview.EdgeTenant:
		m.ResetTenant()
		return nil
	case performancereview.EdgeEmployee:
		m.ResetEmployee()
		return nil
	case performancereview.EdgeReviewer:
		m.ResetReviewer()
		return nil
	case performancereview.EdgeCycle:
		m.ResetCycle()
		return nil
	}
	return fmt.Errorf("unknown PerformanceReview edge %s", name)
}

// PermissionMutation represents an operation that mutates the Permission nodes in the graph.
type PermissionMutation struct {
	config
	op            Op
	typ           string
	id            *int
	name          *string
	code          *string
	clearedFields map[string]struct{}
	users         map[int]struct{}
	removedusers  map[int]struct{}
	clearedusers  bool
	tenant        *int
	clearedtenant bool
	done          bool
	oldValue      func(context.Context) (*Permission, error)
	predicates    []predicate.Permission
}

var _ ent.Mutation = (*PermissionMutation)(nil)

// permissionOption allows management of the mutation configuration using functional options.
type permissionOption func(*PermissionMutation)

// newPermissionMutation creates new mutation for the Permission entity.
func newPermissionMutation(c config, op Op, opts ...permissionOption) *PermissionMutation {
	m := &PermissionMutation{
		config:        c,
		op:            op,
		typ:           TypePermission,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPermissionID sets the ID field of the mutation.
func withPermissionID(id int) permissionOption {
	return func(m *PermissionMutation) {
		var (
			err   error
			once  sync.Once
			value *Permission
		)
		m.oldValue = func(ctx context.Context) (*Permission, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Permission.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPermission sets the old Permission of the mutation.
func withPermission(node *Permission) permissionOption {
	return func(m *PermissionMutation) {
		m.oldValue = func(context.Context) (*Permission, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PermissionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PermissionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PermissionMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PermissionMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Permission.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *PermissionMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *PermissionMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Permission entity.
// If the Permission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PermissionMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *PermissionMutation) ResetName() {
	m.name = nil
}

// SetCode sets the "code" field.
func (m *PermissionMutation) SetCode(s string) {
	m.code = &s
}

// Code returns the value of the "code" field in the mutation.
func (m *PermissionMutation) Code() (r string, exists bool) {
	v := m.code
	if v == nil {
		return
	}
	return *v, true
}

// OldCode returns the old "code" field's value of the Permission entity.
// If the Permission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PermissionMutation) OldCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCode: %w", err)
	}
	return oldValue.Code, nil
}

// ResetCode resets all changes to the "code" field.
func (m *PermissionMutation) ResetCode() {
	m.code = nil
}

// AddUserIDs adds the "users" edge to the User entity by ids.
func (m *PermissionMutation) AddUserIDs(ids ...int) {
	if m.users == nil {
		m.users = make(map[int]struct{})
	}
	for i := range ids {
		m.users[ids[i]] = struct{}{}
	}
}

// ClearUsers clears the "users" edge to the User entity.
func (m *PermissionMutation) ClearUsers() {
	m.clearedusers = true
}

// UsersCleared reports if the "users" edge to the User entity was cleared.
func (m *PermissionMutation) UsersCleared() bool {
	return m.clearedusers
}

// RemoveUserIDs removes the "users" edge to the User entity by IDs.
func (m *PermissionMutation) RemoveUserIDs(ids ...int) {
	if m.removedusers == nil {
		m.removedusers = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.users, ids[i])
		m.removedusers[ids[i]] = struct{}{}
	}
}

// RemovedUsers returns the removed IDs of the "users" edge to the User entity.
func (m *PermissionMutation) RemovedUsersIDs() (ids []int) {
	for id := range m.removedusers {
		ids = append(ids, id)
	}
	return
}

// UsersIDs returns the "users" edge IDs in the mutation.
func (m *PermissionMutation) UsersIDs() (ids []int) {
	for id := range m.users {
		ids = append(ids, id)
	}
	return
}

// ResetUsers resets all changes to the "users" edge.
func (m *PermissionMutation) ResetUsers() {
	m.users = nil
	m.clearedusers = false
	m.removedusers = nil
}

// SetTenantID sets the "tenant" edge to the Tenant entity by id.
func (m *PermissionMutation) SetTenantID(id int) {
	m.tenant = &id
}

// ClearTenant clears the "tenant" edge to the Tenant entity.
func (m *PermissionMutation) ClearTenant() {
	m.clearedtenant = true
}

// TenantCleared reports if the "tenant" edge to the Tenant entity was cleared.
func (m *PermissionMutation) TenantCleared() bool {
	return m.clearedtenant
}

// TenantID returns the "tenant" edge ID in the mutation.
func (m *PermissionMutation) TenantID() (id int, exists bool) {
	if m.tenant != nil {
		return *m.tenant, true
	}
	return
}

// TenantIDs returns the "tenant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TenantID instead. It exists only for internal usage by the builders.
func (m *PermissionMutation) TenantIDs() (ids []int) {
	if id := m.tenant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTenant resets all changes to the "tenant" edge.
func (m *PermissionMutation) ResetTenant() {
	m.tenant = nil
	m.clearedtenant = false
}

// Where appends a list predicates to the PermissionMutation builder.
func (m *PermissionMutation) Where(ps ...predicate.Permission) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PermissionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PermissionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Permission, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PermissionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PermissionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Permission).
func (m *PermissionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PermissionMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.name != nil {
		fields = append(fields, permission.FieldName)
	}
	if m.code != nil {
		fields = append(fields, permission.FieldCode)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PermissionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case permission.FieldName:
		return m.Name()
	case permission.FieldCode:
		return m.Code()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PermissionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case permission.FieldName:
		return m.OldName(ctx)
	case permission.FieldCode:
		return m.OldCode(ctx)
	}
	return nil, fmt.Errorf("unknown Permission field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PermissionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case permission.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case permission.FieldCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCode(v)
		return nil
	}
	return fmt.Errorf("unknown Permission field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PermissionMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PermissionMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PermissionMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Permission numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PermissionMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PermissionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PermissionMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Permission nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PermissionMutation) ResetField(name string) error {
	switch name {
	case permission.FieldName:
		m.ResetName()
		return nil
	case permission.FieldCode:
		m.ResetCode()
		return nil
	}
	return fmt.Errorf("unknown Permission field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PermissionMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.users != nil {
		edges = append(edges, permission.EdgeUsers)
	}
	if m.tenant != nil {
		edges = append(edges, permission.EdgeTenant)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PermissionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case permission.EdgeUsers:
		ids := make([]ent.Value, 0, len(m.users))
		for id := range m.users {
			ids = append(ids, id)
		}
		return ids
	case permission.EdgeTenant:
		if id := m.tenant; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PermissionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedusers != nil {
		edges = append(edges, permission.EdgeUsers)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PermissionMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case permission.EdgeUsers:
		ids := make([]ent.Value, 0, len(m.removedusers))
		for id := range m.removedusers {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PermissionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedusers {
		edges = append(edges, permission.EdgeUsers)
	}
	if m.clearedtenant {
		edges = append(edges, permission.EdgeTenant)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PermissionMutation) EdgeCleared(name string) bool {
	switch name {
	case permission.EdgeUsers:
		return m.clearedusers
	case permission.EdgeTenant:
		return m.clearedtenant
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PermissionMutation) ClearEdge(name string) error {
	switch name {
	case permission.EdgeTenant:
		m.ClearTenant()
		return nil
	}
	return fmt.Errorf("unknown Permission unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PermissionMutation) ResetEdge(name string) error {
	switch name {
	case permission.EdgeUsers:
		m.ResetUsers()
		return nil
	case permission.EdgeTenant:
		m.ResetTenant()
		return nil
	}
	return fmt.Errorf("unknown Permission edge %s", name)
}

// ProductMutation represents an operation that mutates the Product nodes in the graph.
type ProductMutation struct {
	config
	op                           Op
	typ                          string
	id                           *int
	sku                          *string
	name                         *string
	description                  *string
	unit_cost                    *decimal.Decimal
	quantity                     *decimal.Decimal
	attributes                   *map[string]interface{}
	created_at                   *time.Time
	updated_at                   *time.Time
	min_stock_level              *int
	addmin_stock_level           *int
	max_stock_level              *int
	addmax_stock_level           *int
	barcode                      *string
	location                     *string
	is_variant_parent            *bool
	serial_number                *string
	purchase_date                *time.Time
	purchase_price               *decimal.Decimal
	useful_life_months           *int
	adduseful_life_months        *int
	warranty_expires_at          *time.Time
	disposal_date                *time.Time
	disposal_reason              *string
	is_disposed                  *bool
	clearedFields                map[string]struct{}
	tenant                       *int
	clearedtenant                bool
	movements                    map[int]struct{}
	removedmovements             map[int]struct{}
	clearedmovements             bool
	reservations                 map[int]struct{}
	removedreservations          map[int]struct{}
	clearedreservations          bool
	vendor                       *int
	clearedvendor                bool
	supplier                     *int
	clearedsupplier              bool
	category                     *int
	clearedcategory              bool
	warehouse                    *int
	clearedwarehouse             bool
	assignments                  map[int]struct{}
	removedassignments           map[int]struct{}
	clearedassignments           bool
	variants                     map[int]struct{}
	removedvariants              map[int]struct{}
	clearedvariants              bool
	maintenance_schedules        map[int]struct{}
	removedmaintenance_schedules map[int]struct{}
	clearedmaintenance_schedules bool
	alerts                       map[int]struct{}
	removedalerts                map[int]struct{}
	clearedalerts                bool
	purchase_order_lines         map[int]struct{}
	removedpurchase_order_lines  map[int]struct{}
	clearedpurchase_order_lines  bool
	inventory_counts             map[int]struct{}
	removedinventory_counts      map[int]struct{}
	clearedinventory_counts      bool
	done                         bool
	oldValue                     func(context.Context) (*Product, error)
	predicates                   []predicate.Product
}

var _ ent.Mutation = (*ProductMutation)(nil)

// productOption allows management of the mutation configuration using functional options.
type productOption func(*ProductMutation)

// newProductMutation creates new mutation for the Product entity.
func newProductMutation(c config, op Op, opts ...productOption) *ProductMutation {
	m := &ProductMutation{
		config:        c,
		op:            op,
		typ:           TypeProduct,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withProductID sets the ID field of the mutation.
func withProductID(id int) productOption {
	return func(m *ProductMutation) {
		var (
			err   error
			once  sync.Once
			value *Product
		)
		m.oldValue = func(ctx context.Context) (*Product, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Product.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProduct sets the old Product of the mutation.
func withProduct(node *Product) productOption {
	return func(m *ProductMutation) {
		m.oldValue = func(context.Context) (*Product, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProductMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProductMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ProductMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ProductMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Product.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetSku sets the "sku" field.
func (m *ProductMutation) SetSku(s string) {
	m.sku = &s
}

// Sku returns the value of the "sku" field in the mutation.
func (m *ProductMutation) Sku() (r string, exists bool) {
	v := m.sku
	if v == nil {
		return
	}
	return *v, true
}

// OldSku returns the old "sku" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldSku(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSku is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSku requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSku: %w", err)
	}
	return oldValue.Sku, nil
}

// ResetSku resets all changes to the "sku" field.
func (m *ProductMutation) ResetSku() {
	m.sku = nil
}

// SetName sets the "name" field.
func (m *ProductMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ProductMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ProductMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *ProductMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *ProductMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *ProductMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[product.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *ProductMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[product.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *ProductMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, product.FieldDescription)
}

// SetUnitCost sets the "unit_cost" field.
func (m *ProductMutation) SetUnitCost(d decimal.Decimal) {
	m.unit_cost = &d
}

// UnitCost returns the value of the "unit_cost" field in the mutation.
func (m *ProductMutation) UnitCost() (r decimal.Decimal, exists bool) {
	v := m.unit_cost
	if v == nil {
		return
	}
	return *v, true
}

// OldUnitCost returns the old "unit_cost" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldUnitCost(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUnitCost is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUnitCost requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUnitCost: %w", err)
	}
	return oldValue.UnitCost, nil
}

// ResetUnitCost resets all changes to the "unit_cost" field.
func (m *ProductMutation) ResetUnitCost() {
	m.unit_cost = nil
}

// SetQuantity sets the "quantity" field.
func (m *ProductMutation) SetQuantity(d decimal.Decimal) {
	m.quantity = &d
}

// Quantity returns the value of the "quantity" field in the mutation.
func (m *ProductMutation) Quantity() (r decimal.Decimal, exists bool) {
	v := m.quantity
	if v == nil {
		return
	}
	return *v, true
}

// OldQuantity returns the old "quantity" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldQuantity(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldQuantity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldQuantity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldQuantity: %w", err)
	}
	return oldValue.Quantity, nil
}

// ResetQuantity resets all changes to the "quantity" field.
func (m *ProductMutation) ResetQuantity() {
	m.quantity = nil
}

// SetAttributes sets the "attributes" field.
func (m *ProductMutation) SetAttributes(value map[string]interface{}) {
	m.attributes = &value
}

// Attributes returns the value of the "attributes" field in the mutation.
func (m *ProductMutation) Attributes() (r map[string]interface{}, exists bool) {
	v := m.attributes
	if v == nil {
		return
	}
	return *v, true
}

// OldAttributes returns the old "attributes" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldAttributes(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAttributes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAttributes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAttributes: %w", err)
	}
	return oldValue.Attributes, nil
}

// ClearAttributes clears the value of the "attributes" field.
func (m *ProductMutation) ClearAttributes() {
	m.attributes = nil
	m.clearedFields[product.FieldAttributes] = struct{}{}
}

// AttributesCleared returns if the "attributes" field was cleared in this mutation.
func (m *ProductMutation) AttributesCleared() bool {
	_, ok := m.clearedFields[product.FieldAttributes]
	return ok
}

// ResetAttributes resets all changes to the "attributes" field.
func (m *ProductMutation) ResetAttributes() {
	m.attributes = nil
	delete(m.clearedFields, product.FieldAttributes)
}

// SetCreatedAt sets the "created_at" field.
func (m *ProductMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ProductMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ProductMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ProductMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ProductMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ProductMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetMinStockLevel sets the "min_stock_level" field.
func (m *ProductMutation) SetMinStockLevel(i int) {
	m.min_stock_level = &i
	m.addmin_stock_level = nil
}

// MinStockLevel returns the value of the "min_stock_level" field in the mutation.
func (m *ProductMutation) MinStockLevel() (r int, exists bool) {
	v := m.min_stock_level
	if v == nil {
		return
	}
	return *v, true
}

// OldMinStockLevel returns the old "min_stock_level" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldMinStockLevel(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMinStockLevel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMinStockLevel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMinStockLevel: %w", err)
	}
	return oldValue.MinStockLevel, nil
}

// AddMinStockLevel adds i to the "min_stock_level" field.
func (m *ProductMutation) AddMinStockLevel(i int) {
	if m.addmin_stock_level != nil {
		*m.addmin_stock_level += i
	} else {
		m.addmin_stock_level = &i
	}
}

// AddedMinStockLevel returns the value that was added to the "min_stock_level" field in this mutation.
func (m *ProductMutation) AddedMinStockLevel() (r int, exists bool) {
	v := m.addmin_stock_level
	if v == nil {
		return
	}
	return *v, true
}

// ResetMinStockLevel resets all changes to the "min_stock_level" field.
func (m *ProductMutation) ResetMinStockLevel() {
	m.min_stock_level = nil
	m.addmin_stock_level = nil
}

// SetMaxStockLevel sets the "max_stock_level" field.
func (m *ProductMutation) SetMaxStockLevel(i int) {
	m.max_stock_level = &i
	m.addmax_stock_level = nil
}

// MaxStockLevel returns the value of the "max_stock_level" field in the mutation.
func (m *ProductMutation) MaxStockLevel() (r int, exists bool) {
	v := m.max_stock_level
	if v == nil {
		return
	}
	return *v, true
}

// OldMaxStockLevel returns the old "max_stock_level" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldMaxStockLevel(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMaxStockLevel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMaxStockLevel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMaxStockLevel: %w", err)
	}
	return oldValue.MaxStockLevel, nil
}

// AddMaxStockLevel adds i to the "max_stock_level" field.
func (m *ProductMutation) AddMaxStockLevel(i int) {
	if m.addmax_stock_level != nil {
		*m.addmax_stock_level += i
	} else {
		m.addmax_stock_level = &i
	}
}

// AddedMaxStockLevel returns the value that was added to the "max_stock_level" field in this mutation.
func (m *ProductMutation) AddedMaxStockLevel() (r int, exists bool) {
	v := m.addmax_stock_level
	if v == nil {
		return
	}
	return *v, true
}

// ResetMaxStockLevel resets all changes to the "max_stock_level" field.
func (m *ProductMutation) ResetMaxStockLevel() {
	m.max_stock_level = nil
	m.addmax_stock_level = nil
}

// SetBarcode sets the "barcode" field.
func (m *ProductMutation) SetBarcode(s string) {
	m.barcode = &s
}

// Barcode returns the value of the "barcode" field in the mutation.
func (m *ProductMutation) Barcode() (r string, exists bool) {
	v := m.barcode
	if v == nil {
		return
	}
	return *v, true
}

// OldBarcode returns the old "barcode" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldBarcode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBarcode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBarcode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBarcode: %w", err)
	}
	return oldValue.Barcode, nil
}

// ClearBarcode clears the value of the "barcode" field.
func (m *ProductMutation) ClearBarcode() {
	m.barcode = nil
	m.clearedFields[product.FieldBarcode] = struct{}{}
}

// BarcodeCleared returns if the "barcode" field was cleared in this mutation.
func (m *ProductMutation) BarcodeCleared() bool {
	_, ok := m.clearedFields[product.FieldBarcode]
	return ok
}

// ResetBarcode resets all changes to the "barcode" field.
func (m *ProductMutation) ResetBarcode() {
	m.barcode = nil
	delete(m.clearedFields, product.FieldBarcode)
}

// SetLocation sets the "location" field.
func (m *ProductMutation) SetLocation(s string) {
	m.location = &s
}

// Location returns the value of the "location" field in the mutation.
func (m *ProductMutation) Location() (r string, exists bool) {
	v := m.location
	if v == nil {
		return
	}
	return *v, true
}

// OldLocation returns the old "location" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldLocation(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLocation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLocation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLocation: %w", err)
	}
	return oldValue.Location, nil
}

// ClearLocation clears the value of the "location" field.
func (m *ProductMutation) ClearLocation() {
	m.location = nil
	m.clearedFields[product.FieldLocation] = struct{}{}
}

// LocationCleared returns if the "location" field was cleared in this mutation.
func (m *ProductMutation) LocationCleared() bool {
	_, ok := m.clearedFields[product.FieldLocation]
	return ok
}

// ResetLocation resets all changes to the "location" field.
func (m *ProductMutation) ResetLocation() {
	m.location = nil
	delete(m.clearedFields, product.FieldLocation)
}

// SetIsVariantParent sets the "is_variant_parent" field.
func (m *ProductMutation) SetIsVariantParent(b bool) {
	m.is_variant_parent = &b
}

// IsVariantParent returns the value of the "is_variant_parent" field in the mutation.
func (m *ProductMutation) IsVariantParent() (r bool, exists bool) {
	v := m.is_variant_parent
	if v == nil {
		return
	}
	return *v, true
}

// OldIsVariantParent returns the old "is_variant_parent" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldIsVariantParent(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsVariantParent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsVariantParent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsVariantParent: %w", err)
	}
	return oldValue.IsVariantParent, nil
}

// ResetIsVariantParent resets all changes to the "is_variant_parent" field.
func (m *ProductMutation) ResetIsVariantParent() {
	m.is_variant_parent = nil
}

// SetSerialNumber sets the "serial_number" field.
func (m *ProductMutation) SetSerialNumber(s string) {
	m.serial_number = &s
}

// SerialNumber returns the value of the "serial_number" field in the mutation.
func (m *ProductMutation) SerialNumber() (r string, exists bool) {
	v := m.serial_number
	if v == nil {
		return
	}
	return *v, true
}

// OldSerialNumber returns the old "serial_number" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldSerialNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSerialNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSerialNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSerialNumber: %w", err)
	}
	return oldValue.SerialNumber, nil
}

// ClearSerialNumber clears the value of the "serial_number" field.
func (m *ProductMutation) ClearSerialNumber() {
	m.serial_number = nil
	m.clearedFields[product.FieldSerialNumber] = struct{}{}
}

// SerialNumberCleared returns if the "serial_number" field was cleared in this mutation.
func (m *ProductMutation) SerialNumberCleared() bool {
	_, ok := m.clearedFields[product.FieldSerialNumber]
	return ok
}

// ResetSerialNumber resets all changes to the "serial_number" field.
func (m *ProductMutation) ResetSerialNumber() {
	m.serial_number = nil
	delete(m.clearedFields, product.FieldSerialNumber)
}

// SetPurchaseDate sets the "purchase_date" field.
func (m *ProductMutation) SetPurchaseDate(t time.Time) {
	m.purchase_date = &t
}

// PurchaseDate returns the value of the "purchase_date" field in the mutation.
func (m *ProductMutation) PurchaseDate() (r time.Time, exists bool) {
	v := m.purchase_date
	if v == nil {
		return
	}
	return *v, true
}

// OldPurchaseDate returns the old "purchase_date" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldPurchaseDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPurchaseDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPurchaseDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPurchaseDate: %w", err)
	}
	return oldValue.PurchaseDate, nil
}

// ClearPurchaseDate clears the value of the "purchase_date" field.
func (m *ProductMutation) ClearPurchaseDate() {
	m.purchase_date = nil
	m.clearedFields[product.FieldPurchaseDate] = struct{}{}
}

// PurchaseDateCleared returns if the "purchase_date" field was cleared in this mutation.
func (m *ProductMutation) PurchaseDateCleared() bool {
	_, ok := m.clearedFields[product.FieldPurchaseDate]
	return ok
}

// ResetPurchaseDate resets all changes to the "purchase_date" field.
func (m *ProductMutation) ResetPurchaseDate() {
	m.purchase_date = nil
	delete(m.clearedFields, product.FieldPurchaseDate)
}

// SetPurchasePrice sets the "purchase_price" field.
func (m *ProductMutation) SetPurchasePrice(d decimal.Decimal) {
	m.purchase_price = &d
}

// PurchasePrice returns the value of the "purchase_price" field in the mutation.
func (m *ProductMutation) PurchasePrice() (r decimal.Decimal, exists bool) {
	v := m.purchase_price
	if v == nil {
		return
	}
	return *v, true
}

// OldPurchasePrice returns the old "purchase_price" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldPurchasePrice(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPurchasePrice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPurchasePrice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPurchasePrice: %w", err)
	}
	return oldValue.PurchasePrice, nil
}

// ClearPurchasePrice clears the value of the "purchase_price" field.
func (m *ProductMutation) ClearPurchasePrice() {
	m.purchase_price = nil
	m.clearedFields[product.FieldPurchasePrice] = struct{}{}
}

// PurchasePriceCleared returns if the "purchase_price" field was cleared in this mutation.
func (m *ProductMutation) PurchasePriceCleared() bool {
	_, ok := m.clearedFields[product.FieldPurchasePrice]
	return ok
}

// ResetPurchasePrice resets all changes to the "purchase_price" field.
func (m *ProductMutation) ResetPurchasePrice() {
	m.purchase_price = nil
	delete(m.clearedFields, product.FieldPurchasePrice)
}

// SetUsefulLifeMonths sets the "useful_life_months" field.
func (m *ProductMutation) SetUsefulLifeMonths(i int) {
	m.useful_life_months = &i
	m.adduseful_life_months = nil
}

// UsefulLifeMonths returns the value of the "useful_life_months" field in the mutation.
func (m *ProductMutation) UsefulLifeMonths() (r int, exists bool) {
	v := m.useful_life_months
	if v == nil {
		return
	}
	return *v, true
}

// OldUsefulLifeMonths returns the old "useful_life_months" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldUsefulLifeMonths(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsefulLifeMonths is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsefulLifeMonths requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsefulLifeMonths: %w", err)
	}
	return oldValue.UsefulLifeMonths, nil
}

// AddUsefulLifeMonths adds i to the "useful_life_months" field.
func (m *ProductMutation) AddUsefulLifeMonths(i int) {
	if m.adduseful_life_months != nil {
		*m.adduseful_life_months += i
	} else {
		m.adduseful_life_months = &i
	}
}

// AddedUsefulLifeMonths returns the value that was added to the "useful_life_months" field in this mutation.
func (m *ProductMutation) AddedUsefulLifeMonths() (r int, exists bool) {
	v := m.adduseful_life_months
	if v == nil {
		return
	}
	return *v, true
}

// ClearUsefulLifeMonths clears the value of the "useful_life_months" field.
func (m *ProductMutation) ClearUsefulLifeMonths() {
	m.useful_life_months = nil
	m.adduseful_life_months = nil
	m.clearedFields[product.FieldUsefulLifeMonths] = struct{}{}
}

// UsefulLifeMonthsCleared returns if the "useful_life_months" field was cleared in this mutation.
func (m *ProductMutation) UsefulLifeMonthsCleared() bool {
	_, ok := m.clearedFields[product.FieldUsefulLifeMonths]
	return ok
}

// ResetUsefulLifeMonths resets all changes to the "useful_life_months" field.
func (m *ProductMutation) ResetUsefulLifeMonths() {
	m.useful_life_months = nil
	m.adduseful_life_months = nil
	delete(m.clearedFields, product.FieldUsefulLifeMonths)
}

// SetWarrantyExpiresAt sets the "warranty_expires_at" field.
func (m *ProductMutation) SetWarrantyExpiresAt(t time.Time) {
	m.warranty_expires_at = &t
}

// WarrantyExpiresAt returns the value of the "warranty_expires_at" field in the mutation.
func (m *ProductMutation) WarrantyExpiresAt() (r time.Time, exists bool) {
	v := m.warranty_expires_at
	if v == nil {
		return
	}
	return *v, true
}

// OldWarrantyExpiresAt returns the old "warranty_expires_at" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldWarrantyExpiresAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWarrantyExpiresAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWarrantyExpiresAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWarrantyExpiresAt: %w", err)
	}
	return oldValue.WarrantyExpiresAt, nil
}

// ClearWarrantyExpiresAt clears the value of the "warranty_expires_at" field.
func (m *ProductMutation) ClearWarrantyExpiresAt() {
	m.warranty_expires_at = nil
	m.clearedFields[product.FieldWarrantyExpiresAt] = struct{}{}
}

// WarrantyExpiresAtCleared returns if the "warranty_expires_at" field was cleared in this mutation.
func (m *ProductMutation) WarrantyExpiresAtCleared() bool {
	_, ok := m.clearedFields[product.FieldWarrantyExpiresAt]
	return ok
}

// ResetWarrantyExpiresAt resets all changes to the "warranty_expires_at" field.
func (m *ProductMutation) ResetWarrantyExpiresAt() {
	m.warranty_expires_at = nil
	delete(m.clearedFields, product.FieldWarrantyExpiresAt)
}

// SetDisposalDate sets the "disposal_date" field.
func (m *ProductMutation) SetDisposalDate(t time.Time) {
	m.disposal_date = &t
}

// DisposalDate returns the value of the "disposal_date" field in the mutation.
func (m *ProductMutation) DisposalDate() (r time.Time, exists bool) {
	v := m.disposal_date
	if v == nil {
		return
	}
	return *v, true
}

// OldDisposalDate returns the old "disposal_date" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldDisposalDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisposalDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisposalDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisposalDate: %w", err)
	}
	return oldValue.DisposalDate, nil
}

// ClearDisposalDate clears the value of the "disposal_date" field.
func (m *ProductMutation) ClearDisposalDate() {
	m.disposal_date = nil
	m.clearedFields[product.FieldDisposalDate] = struct{}{}
}

// DisposalDateCleared returns if the "disposal_date" field was cleared in this mutation.
func (m *ProductMutation) DisposalDateCleared() bool {
	_, ok := m.clearedFields[product.FieldDisposalDate]
	return ok
}

// ResetDisposalDate resets all changes to the "disposal_date" field.
func (m *ProductMutation) ResetDisposalDate() {
	m.disposal_date = nil
	delete(m.clearedFields, product.FieldDisposalDate)
}

// SetDisposalReason sets the "disposal_reason" field.
func (m *ProductMutation) SetDisposalReason(s string) {
	m.disposal_reason = &s
}

// DisposalReason returns the value of the "disposal_reason" field in the mutation.
func (m *ProductMutation) DisposalReason() (r string, exists bool) {
	v := m.disposal_reason
	if v == nil {
		return
	}
	return *v, true
}

// OldDisposalReason returns the old "disposal_reason" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldDisposalReason(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisposalReason is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisposalReason requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisposalReason: %w", err)
	}
	return oldValue.DisposalReason, nil
}

// ClearDisposalReason clears the value of the "disposal_reason" field.
func (m *ProductMutation) ClearDisposalReason() {
	m.disposal_reason = nil
	m.clearedFields[product.FieldDisposalReason] = struct{}{}
}

// DisposalReasonCleared returns if the "disposal_reason" field was cleared in this mutation.
func (m *ProductMutation) DisposalReasonCleared() bool {
	_, ok := m.clearedFields[product.FieldDisposalReason]
	return ok
}

// ResetDisposalReason resets all changes to the "disposal_reason" field.
func (m *ProductMutation) ResetDisposalReason() {
	m.disposal_reason = nil
	delete(m.clearedFields, product.FieldDisposalReason)
}

// SetIsDisposed sets the "is_disposed" field.
func (m *ProductMutation) SetIsDisposed(b bool) {
	m.is_disposed = &b
}

// IsDisposed returns the value of the "is_disposed" field in the mutation.
func (m *ProductMutation) IsDisposed() (r bool, exists bool) {
	v := m.is_disposed
	if v == nil {
		return
	}
	return *v, true
}

// OldIsDisposed returns the old "is_disposed" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldIsDisposed(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsDisposed is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsDisposed requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsDisposed: %w", err)
	}
	return oldValue.IsDisposed, nil
}

// ResetIsDisposed resets all changes to the "is_disposed" field.
func (m *ProductMutation) ResetIsDisposed() {
	m.is_disposed = nil
}

// SetTenantID sets the "tenant" edge to the Tenant entity by id.
func (m *ProductMutation) SetTenantID(id int) {
	m.tenant = &id
}

// ClearTenant clears the "tenant" edge to the Tenant entity.
func (m *ProductMutation) ClearTenant() {
	m.clearedtenant = true
}

// TenantCleared reports if the "tenant" edge to the Tenant entity was cleared.
func (m *ProductMutation) TenantCleared() bool {
	return m.clearedtenant
}

// TenantID returns the "tenant" edge ID in the mutation.
func (m *ProductMutation) TenantID() (id int, exists bool) {
	if m.tenant != nil {
		return *m.tenant, true
	}
	return
}

// TenantIDs returns the "tenant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TenantID instead. It exists only for internal usage by the builders.
func (m *ProductMutation) TenantIDs() (ids []int) {
	if id := m.tenant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTenant resets all changes to the "tenant" edge.
func (m *ProductMutation) ResetTenant() {
	m.tenant = nil
	m.clearedtenant = false
}

// AddMovementIDs adds the "movements" edge to the StockMovement entity by ids.
func (m *ProductMutation) AddMovementIDs(ids ...int) {
	if m.movements == nil {
		m.movements = make(map[int]struct{})
	}
	for i := range ids {
		m.movements[ids[i]] = struct{}{}
	}
}

// ClearMovements clears the "movements" edge to the StockMovement entity.
func (m *ProductMutation) ClearMovements() {
	m.clearedmovements = true
}

// MovementsCleared reports if the "movements" edge to the StockMovement entity was cleared.
func (m *ProductMutation) MovementsCleared() bool {
	return m.clearedmovements
}

// RemoveMovementIDs removes the "movements" edge to the StockMovement entity by IDs.
func (m *ProductMutation) RemoveMovementIDs(ids ...int) {
	if m.removedmovements == nil {
		m.removedmovements = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.movements, ids[i])
		m.removedmovements[ids[i]] = struct{}{}
	}
}

// RemovedMovements returns the removed IDs of the "movements" edge to the StockMovement entity.
func (m *ProductMutation) RemovedMovementsIDs() (ids []int) {
	for id := range m.removedmovements {
		ids = append(ids, id)
	}
	return
}

// MovementsIDs returns the "movements" edge IDs in the mutation.
func (m *ProductMutation) MovementsIDs() (ids []int) {
	for id := range m.movements {
		ids = append(ids, id)
	}
	return
}

// ResetMovements resets all changes to the "movements" edge.
func (m *ProductMutation) ResetMovements() {
	m.movements = nil
	m.clearedmovements = false
	m.removedmovements = nil
}

// AddReservationIDs adds the "reservations" edge to the InventoryReservation entity by ids.
func (m *ProductMutation) AddReservationIDs(ids ...int) {
	if m.reservations == nil {
		m.reservations = make(map[int]struct{})
	}
	for i := range ids {
		m.reservations[ids[i]] = struct{}{}
	}
}

// ClearReservations clears the "reservations" edge to the InventoryReservation entity.
func (m *ProductMutation) ClearReservations() {
	m.clearedreservations = true
}

// ReservationsCleared reports if the "reservations" edge to the InventoryReservation entity was cleared.
func (m *ProductMutation) ReservationsCleared() bool {
	return m.clearedreservations
}

// RemoveReservationIDs removes the "reservations" edge to the InventoryReservation entity by IDs.
func (m *ProductMutation) RemoveReservationIDs(ids ...int) {
	if m.removedreservations == nil {
		m.removedreservations = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.reservations, ids[i])
		m.removedreservations[ids[i]] = struct{}{}
	}
}

// RemovedReservations returns the removed IDs of the "reservations" edge to the InventoryReservation entity.
func (m *ProductMutation) RemovedReservationsIDs() (ids []int) {
	for id := range m.removedreservations {
		ids = append(ids, id)
	}
	return
}

// ReservationsIDs returns the "reservations" edge IDs in the mutation.
func (m *ProductMutation) ReservationsIDs() (ids []int) {
	for id := range m.reservations {
		ids = append(ids, id)
	}
	return
}

// ResetReservations resets all changes to the "reservations" edge.
func (m *ProductMutation) ResetReservations() {
	m.reservations = nil
	m.clearedreservations = false
	m.removedreservations = nil
}

// SetVendorID sets the "vendor" edge to the Account entity by id.
func (m *ProductMutation) SetVendorID(id int) {
	m.vendor = &id
}

// ClearVendor clears the "vendor" edge to the Account entity.
func (m *ProductMutation) ClearVendor() {
	m.clearedvendor = true
}

// VendorCleared reports if the "vendor" edge to the Account entity was cleared.
func (m *ProductMutation) VendorCleared() bool {
	return m.clearedvendor
}

// VendorID returns the "vendor" edge ID in the mutation.
func (m *ProductMutation) VendorID() (id int, exists bool) {
	if m.vendor != nil {
		return *m.vendor, true
	}
	return
}

// VendorIDs returns the "vendor" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// VendorID instead. It exists only for internal usage by the builders.
func (m *ProductMutation) VendorIDs() (ids []int) {
	if id := m.vendor; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetVendor resets all changes to the "vendor" edge.
func (m *ProductMutation) ResetVendor() {
	m.vendor = nil
	m.clearedvendor = false
}

// SetSupplierID sets the "supplier" edge to the Supplier entity by id.
func (m *ProductMutation) SetSupplierID(id int) {
	m.supplier = &id
}

// ClearSupplier clears the "supplier" edge to the Supplier entity.
func (m *ProductMutation) ClearSupplier() {
	m.clearedsupplier = true
}

// SupplierCleared reports if the "supplier" edge to the Supplier entity was cleared.
func (m *ProductMutation) SupplierCleared() bool {
	return m.clearedsupplier
}

// SupplierID returns the "supplier" edge ID in the mutation.
func (m *ProductMutation) SupplierID() (id int, exists bool) {
	if m.supplier != nil {
		return *m.supplier, true
	}
	return
}

// SupplierIDs returns the "supplier" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SupplierID instead. It exists only for internal usage by the builders.
func (m *ProductMutation) SupplierIDs() (ids []int) {
	if id := m.supplier; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSupplier resets all changes to the "supplier" edge.
func (m *ProductMutation) ResetSupplier() {
	m.supplier = nil
	m.clearedsupplier = false
}

// SetCategoryID sets the "category" edge to the Category entity by id.
func (m *ProductMutation) SetCategoryID(id int) {
	m.category = &id
}

// ClearCategory clears the "category" edge to the Category entity.
func (m *ProductMutation) ClearCategory() {
	m.clearedcategory = true
}

// CategoryCleared reports if the "category" edge to the Category entity was cleared.
func (m *ProductMutation) CategoryCleared() bool {
	return m.clearedcategory
}

// CategoryID returns the "category" edge ID in the mutation.
func (m *ProductMutation) CategoryID() (id int, exists bool) {
	if m.category != nil {
		return *m.category, true
	}
	return
}

// CategoryIDs returns the "category" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CategoryID instead. It exists only for internal usage by the builders.
func (m *ProductMutation) CategoryIDs() (ids []int) {
	if id := m.category; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCategory resets all changes to the "category" edge.
func (m *ProductMutation) ResetCategory() {
	m.category = nil
	m.clearedcategory = false
}

// SetWarehouseID sets the "warehouse" edge to the Warehouse entity by id.
func (m *ProductMutation) SetWarehouseID(id int) {
	m.warehouse = &id
}

// ClearWarehouse clears the "warehouse" edge to the Warehouse entity.
func (m *ProductMutation) ClearWarehouse() {
	m.clearedwarehouse = true
}

// WarehouseCleared reports if the "warehouse" edge to the Warehouse entity was cleared.
func (m *ProductMutation) WarehouseCleared() bool {
	return m.clearedwarehouse
}

// WarehouseID returns the "warehouse" edge ID in the mutation.
func (m *ProductMutation) WarehouseID() (id int, exists bool) {
	if m.warehouse != nil {
		return *m.warehouse, true
	}
	return
}

// WarehouseIDs returns the "warehouse" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// WarehouseID instead. It exists only for internal usage by the builders.
func (m *ProductMutation) WarehouseIDs() (ids []int) {
	if id := m.warehouse; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetWarehouse resets all changes to the "warehouse" edge.
func (m *ProductMutation) ResetWarehouse() {
	m.warehouse = nil
	m.clearedwarehouse = false
}

// AddAssignmentIDs adds the "assignments" edge to the AssetAssignment entity by ids.
func (m *ProductMutation) AddAssignmentIDs(ids ...int) {
	if m.assignments == nil {
		m.assignments = make(map[int]struct{})
	}
	for i := range ids {
		m.assignments[ids[i]] = struct{}{}
	}
}

// ClearAssignments clears the "assignments" edge to the AssetAssignment entity.
func (m *ProductMutation) ClearAssignments() {
	m.clearedassignments = true
}

// AssignmentsCleared reports if the "assignments" edge to the AssetAssignment entity was cleared.
func (m *ProductMutation) AssignmentsCleared() bool {
	return m.clearedassignments
}

// RemoveAssignmentIDs removes the "assignments" edge to the AssetAssignment entity by IDs.
func (m *ProductMutation) RemoveAssignmentIDs(ids ...int) {
	if m.removedassignments == nil {
		m.removedassignments = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.assignments, ids[i])
		m.removedassignments[ids[i]] = struct{}{}
	}
}

// RemovedAssignments returns the removed IDs of the "assignments" edge to the AssetAssignment entity.
func (m *ProductMutation) RemovedAssignmentsIDs() (ids []int) {
	for id := range m.removedassignments {
		ids = append(ids, id)
	}
	return
}

// AssignmentsIDs returns the "assignments" edge IDs in the mutation.
func (m *ProductMutation) AssignmentsIDs() (ids []int) {
	for id := range m.assignments {
		ids = append(ids, id)
	}
	return
}

// ResetAssignments resets all changes to the "assignments" edge.
func (m *ProductMutation) ResetAssignments() {
	m.assignments = nil
	m.clearedassignments = false
	m.removedassignments = nil
}

// AddVariantIDs adds the "variants" edge to the ProductVariant entity by ids.
func (m *ProductMutation) AddVariantIDs(ids ...int) {
	if m.variants == nil {
		m.variants = make(map[int]struct{})
	}
	for i := range ids {
		m.variants[ids[i]] = struct{}{}
	}
}

// ClearVariants clears the "variants" edge to the ProductVariant entity.
func (m *ProductMutation) ClearVariants() {
	m.clearedvariants = true
}

// VariantsCleared reports if the "variants" edge to the ProductVariant entity was cleared.
func (m *ProductMutation) VariantsCleared() bool {
	return m.clearedvariants
}

// RemoveVariantIDs removes the "variants" edge to the ProductVariant entity by IDs.
func (m *ProductMutation) RemoveVariantIDs(ids ...int) {
	if m.removedvariants == nil {
		m.removedvariants = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.variants, ids[i])
		m.removedvariants[ids[i]] = struct{}{}
	}
}

// RemovedVariants returns the removed IDs of the "variants" edge to the ProductVariant entity.
func (m *ProductMutation) RemovedVariantsIDs() (ids []int) {
	for id := range m.removedvariants {
		ids = append(ids, id)
	}
	return
}

// VariantsIDs returns the "variants" edge IDs in the mutation.
func (m *ProductMutation) VariantsIDs() (ids []int) {
	for id := range m.variants {
		ids = append(ids, id)
	}
	return
}

// ResetVariants resets all changes to the "variants" edge.
func (m *ProductMutation) ResetVariants() {
	m.variants = nil
	m.clearedvariants = false
	m.removedvariants = nil
}

// AddMaintenanceScheduleIDs adds the "maintenance_schedules" edge to the MaintenanceSchedule entity by ids.
func (m *ProductMutation) AddMaintenanceScheduleIDs(ids ...int) {
	if m.maintenance_schedules == nil {
		m.maintenance_schedules = make(map[int]struct{})
	}
	for i := range ids {
		m.maintenance_schedules[ids[i]] = struct{}{}
	}
}

// ClearMaintenanceSchedules clears the "maintenance_schedules" edge to the MaintenanceSchedule entity.
func (m *ProductMutation) ClearMaintenanceSchedules() {
	m.clearedmaintenance_schedules = true
}

// MaintenanceSchedulesCleared reports if the "maintenance_schedules" edge to the MaintenanceSchedule entity was cleared.
func (m *ProductMutation) MaintenanceSchedulesCleared() bool {
	return m.clearedmaintenance_schedules
}

// RemoveMaintenanceScheduleIDs removes the "maintenance_schedules" edge to the MaintenanceSchedule entity by IDs.
func (m *ProductMutation) RemoveMaintenanceScheduleIDs(ids ...int) {
	if m.removedmaintenance_schedules == nil {
		m.removedmaintenance_schedules = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.maintenance_schedules, ids[i])
		m.removedmaintenance_schedules[ids[i]] = struct{}{}
	}
}

// RemovedMaintenanceSchedules returns the removed IDs of the "maintenance_schedules" edge to the MaintenanceSchedule entity.
func (m *ProductMutation) RemovedMaintenanceSchedulesIDs() (ids []int) {
	for id := range m.removedmaintenance_schedules {
		ids = append(ids, id)
	}
	return
}

// MaintenanceSchedulesIDs returns the "maintenance_schedules" edge IDs in the mutation.
func (m *ProductMutation) MaintenanceSchedulesIDs() (ids []int) {
	for id := range m.maintenance_schedules {
		ids = append(ids, id)
	}
	return
}

// ResetMaintenanceSchedules resets all changes to the "maintenance_schedules" edge.
func (m *ProductMutation) ResetMaintenanceSchedules() {
	m.maintenance_schedules = nil
	m.clearedmaintenance_schedules = false
	m.removedmaintenance_schedules = nil
}

// AddAlertIDs adds the "alerts" edge to the StockAlert entity by ids.
func (m *ProductMutation) AddAlertIDs(ids ...int) {
	if m.alerts == nil {
		m.alerts = make(map[int]struct{})
	}
	for i := range ids {
		m.alerts[ids[i]] = struct{}{}
	}
}

// ClearAlerts clears the "alerts" edge to the StockAlert entity.
func (m *ProductMutation) ClearAlerts() {
	m.clearedalerts = true
}

// AlertsCleared reports if the "alerts" edge to the StockAlert entity was cleared.
func (m *ProductMutation) AlertsCleared() bool {
	return m.clearedalerts
}

// RemoveAlertIDs removes the "alerts" edge to the StockAlert entity by IDs.
func (m *ProductMutation) RemoveAlertIDs(ids ...int) {
	if m.removedalerts == nil {
		m.removedalerts = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.alerts, ids[i])
		m.removedalerts[ids[i]] = struct{}{}
	}
}

// RemovedAlerts returns the removed IDs of the "alerts" edge to the StockAlert entity.
func (m *ProductMutation) RemovedAlertsIDs() (ids []int) {
	for id := range m.removedalerts {
		ids = append(ids, id)
	}
	return
}

// AlertsIDs returns the "alerts" edge IDs in the mutation.
func (m *ProductMutation) AlertsIDs() (ids []int) {
	for id := range m.alerts {
		ids = append(ids, id)
	}
	return
}

// ResetAlerts resets all changes to the "alerts" edge.
func (m *ProductMutation) ResetAlerts() {
	m.alerts = nil
	m.clearedalerts = false
	m.removedalerts = nil
}

// AddPurchaseOrderLineIDs adds the "purchase_order_lines" edge to the PurchaseOrderLine entity by ids.
func (m *ProductMutation) AddPurchaseOrderLineIDs(ids ...int) {
	if m.purchase_order_lines == nil {
		m.purchase_order_lines = make(map[int]struct{})
	}
	for i := range ids {
		m.purchase_order_lines[ids[i]] = struct{}{}
	}
}

// ClearPurchaseOrderLines clears the "purchase_order_lines" edge to the PurchaseOrderLine entity.
func (m *ProductMutation) ClearPurchaseOrderLines() {
	m.clearedpurchase_order_lines = true
}

// PurchaseOrderLinesCleared reports if the "purchase_order_lines" edge to the PurchaseOrderLine entity was cleared.
func (m *ProductMutation) PurchaseOrderLinesCleared() bool {
	return m.clearedpurchase_order_lines
}

// RemovePurchaseOrderLineIDs removes the "purchase_order_lines" edge to the PurchaseOrderLine entity by IDs.
func (m *ProductMutation) RemovePurchaseOrderLineIDs(ids ...int) {
	if m.removedpurchase_order_lines == nil {
		m.removedpurchase_order_lines = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.purchase_order_lines, ids[i])
		m.removedpurchase_order_lines[ids[i]] = struct{}{}
	}
}

// RemovedPurchaseOrderLines returns the removed IDs of the "purchase_order_lines" edge to the PurchaseOrderLine entity.
func (m *ProductMutation) RemovedPurchaseOrderLinesIDs() (ids []int) {
	for id := range m.removedpurchase_order_lines {
		ids = append(ids, id)
	}
	return
}

// PurchaseOrderLinesIDs returns the "purchase_order_lines" edge IDs in the mutation.
func (m *ProductMutation) PurchaseOrderLinesIDs() (ids []int) {
	for id := range m.purchase_order_lines {
		ids = append(ids, id)
	}
	return
}

// ResetPurchaseOrderLines resets all changes to the "purchase_order_lines" edge.
func (m *ProductMutation) ResetPurchaseOrderLines() {
	m.purchase_order_lines = nil
	m.clearedpurchase_order_lines = false
	m.removedpurchase_order_lines = nil
}

// AddInventoryCountIDs adds the "inventory_counts" edge to the InventoryCount entity by ids.
func (m *ProductMutation) AddInventoryCountIDs(ids ...int) {
	if m.inventory_counts == nil {
		m.inventory_counts = make(map[int]struct{})
	}
	for i := range ids {
		m.inventory_counts[ids[i]] = struct{}{}
	}
}

// ClearInventoryCounts clears the "inventory_counts" edge to the InventoryCount entity.
func (m *ProductMutation) ClearInventoryCounts() {
	m.clearedinventory_counts = true
}

// InventoryCountsCleared reports if the "inventory_counts" edge to the InventoryCount entity was cleared.
func (m *ProductMutation) InventoryCountsCleared() bool {
	return m.clearedinventory_counts
}

// RemoveInventoryCountIDs removes the "inventory_counts" edge to the InventoryCount entity by IDs.
func (m *ProductMutation) RemoveInventoryCountIDs(ids ...int) {
	if m.removedinventory_counts == nil {
		m.removedinventory_counts = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.inventory_counts, ids[i])
		m.removedinventory_counts[ids[i]] = struct{}{}
	}
}

// RemovedInventoryCounts returns the removed IDs of the "inventory_counts" edge to the InventoryCount entity.
func (m *ProductMutation) RemovedInventoryCountsIDs() (ids []int) {
	for id := range m.removedinventory_counts {
		ids = append(ids, id)
	}
	return
}

// InventoryCountsIDs returns the "inventory_counts" edge IDs in the mutation.
func (m *ProductMutation) InventoryCountsIDs() (ids []int) {
	for id := range m.inventory_counts {
		ids = append(ids, id)
	}
	return
}

// ResetInventoryCounts resets all changes to the "inventory_counts" edge.
func (m *ProductMutation) ResetInventoryCounts() {
	m.inventory_counts = nil
	m.clearedinventory_counts = false
	m.removedinventory_counts = nil
}

// Where appends a list predicates to the ProductMutation builder.
func (m *ProductMutation) Where(ps ...predicate.Product) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ProductMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ProductMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Product, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ProductMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ProductMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Product).
func (m *ProductMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ProductMutation) Fields() []string {
	fields := make([]string, 0, 21)
	if m.sku != nil {
		fields = append(fields, product.FieldSku)
	}
	if m.name != nil {
		fields = append(fields, product.FieldName)
	}
	if m.description != nil {
		fields = append(fields, product.FieldDescription)
	}
	if m.unit_cost != nil {
		fields = append(fields, product.FieldUnitCost)
	}
	if m.quantity != nil {
		fields = append(fields, product.FieldQuantity)
	}
	if m.attributes != nil {
		fields = append(fields, product.FieldAttributes)
	}
	if m.created_at != nil {
		fields = append(fields, product.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, product.FieldUpdatedAt)
	}
	if m.min_stock_level != nil {
		fields = append(fields, product.FieldMinStockLevel)
	}
	if m.max_stock_level != nil {
		fields = append(fields, product.FieldMaxStockLevel)
	}
	if m.barcode != nil {
		fields = append(fields, product.FieldBarcode)
	}
	if m.location != nil {
		fields = append(fields, product.FieldLocation)
	}
	if m.is_variant_parent != nil {
		fields = append(fields, product.FieldIsVariantParent)
	}
	if m.serial_number != nil {
		fields = append(fields, product.FieldSerialNumber)
	}
	if m.purchase_date != nil {
		fields = append(fields, product.FieldPurchaseDate)
	}
	if m.purchase_price != nil {
		fields = append(fields, product.FieldPurchasePrice)
	}
	if m.useful_life_months != nil {
		fields = append(fields, product.FieldUsefulLifeMonths)
	}
	if m.warranty_expires_at != nil {
		fields = append(fields, product.FieldWarrantyExpiresAt)
	}
	if m.disposal_date != nil {
		fields = append(fields, product.FieldDisposalDate)
	}
	if m.disposal_reason != nil {
		fields = append(fields, product.FieldDisposalReason)
	}
	if m.is_disposed != nil {
		fields = append(fields, product.FieldIsDisposed)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ProductMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case product.FieldSku:
		return m.Sku()
	case product.FieldName:
		return m.Name()
	case product.FieldDescription:
		return m.Description()
	case product.FieldUnitCost:
		return m.UnitCost()
	case product.FieldQuantity:
		return m.Quantity()
	case product.FieldAttributes:
		return m.Attributes()
	case product.FieldCreatedAt:
		return m.CreatedAt()
	case product.FieldUpdatedAt:
		return m.UpdatedAt()
	case product.FieldMinStockLevel:
		return m.MinStockLevel()
	case product.FieldMaxStockLevel:
		return m.MaxStockLevel()
	case product.FieldBarcode:
		return m.Barcode()
	case product.FieldLocation:
		return m.Location()
	case product.FieldIsVariantParent:
		return m.IsVariantParent()
	case product.FieldSerialNumber:
		return m.SerialNumber()
	case product.FieldPurchaseDate:
		return m.PurchaseDate()
	case product.FieldPurchasePrice:
		return m.PurchasePrice()
	case product.FieldUsefulLifeMonths:
		return m.UsefulLifeMonths()
	case product.FieldWarrantyExpiresAt:
		return m.WarrantyExpiresAt()
	case product.FieldDisposalDate:
		return m.DisposalDate()
	case product.FieldDisposalReason:
		return m.DisposalReason()
	case product.FieldIsDisposed:
		return m.IsDisposed()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ProductMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case product.FieldSku:
		return m.OldSku(ctx)
	case product.FieldName:
		return m.OldName(ctx)
	case product.FieldDescription:
		return m.OldDescription(ctx)
	case product.FieldUnitCost:
		return m.OldUnitCost(ctx)
	case product.FieldQuantity:
		return m.OldQuantity(ctx)
	case product.FieldAttributes:
		return m.OldAttributes(ctx)
	case product.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case product.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case product.FieldMinStockLevel:
		return m.OldMinStockLevel(ctx)
	case product.FieldMaxStockLevel:
		return m.OldMaxStockLevel(ctx)
	case product.FieldBarcode:
		return m.OldBarcode(ctx)
	case product.FieldLocation:
		return m.OldLocation(ctx)
	case product.FieldIsVariantParent:
		return m.OldIsVariantParent(ctx)
	case product.FieldSerialNumber:
		return m.OldSerialNumber(ctx)
	case product.FieldPurchaseDate:
		return m.OldPurchaseDate(ctx)
	case product.FieldPurchasePrice:
		return m.OldPurchasePrice(ctx)
	case product.FieldUsefulLifeMonths:
		return m.OldUsefulLifeMonths(ctx)
	case product.FieldWarrantyExpiresAt:
		return m.OldWarrantyExpiresAt(ctx)
	case product.FieldDisposalDate:
		return m.OldDisposalDate(ctx)
	case product.FieldDisposalReason:
		return m.OldDisposalReason(ctx)
	case product.FieldIsDisposed:
		return m.OldIsDisposed(ctx)
	}
	return nil, fmt.Errorf("unknown Product field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProductMutation) SetField(name string, value ent.Value) error {
	switch name {
	case product.FieldSku:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSku(v)
		return nil
	case product.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case product.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case product.FieldUnitCost:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUnitCost(v)
		return nil
	case product.FieldQuantity:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetQuantity(v)
		return nil
	case product.FieldAttributes:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAttributes(v)
		return nil
	case product.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case product.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case product.FieldMinStockLevel:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMinStockLevel(v)
		return nil
	case product.FieldMaxStockLevel:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMaxStockLevel(v)
		return nil
	case product.FieldBarcode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBarcode(v)
		return nil
	case product.FieldLocation:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLocation(v)
		return nil
	case product.FieldIsVariantParent:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsVariantParent(v)
		return nil
	case product.FieldSerialNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSerialNumber(v)
		return nil
	case product.FieldPurchaseDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPurchaseDate(v)
		return nil
	case product.FieldPurchasePrice:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPurchasePrice(v)
		return nil
	case product.FieldUsefulLifeMonths:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsefulLifeMonths(v)
		return nil
	case product.FieldWarrantyExpiresAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWarrantyExpiresAt(v)
		return nil
	case product.FieldDisposalDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisposalDate(v)
		return nil
	case product.FieldDisposalReason:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisposalReason(v)
		return nil
	case product.FieldIsDisposed:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsDisposed(v)
		return nil
	}
	return fmt.Errorf("unknown Product field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ProductMutation) AddedFields() []string {
	var fields []string
	if m.addmin_stock_level != nil {
		fields = append(fields, product.FieldMinStockLevel)
	}
	if m.addmax_stock_level != nil {
		fields = append(fields, product.FieldMaxStockLevel)
	}
	if m.adduseful_life_months != nil {
		fields = append(fields, product.FieldUsefulLifeMonths)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ProductMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case product.FieldMinStockLevel:
		return m.AddedMinStockLevel()
	case product.FieldMaxStockLevel:
		return m.AddedMaxStockLevel()
	case product.FieldUsefulLifeMonths:
		return m.AddedUsefulLifeMonths()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProductMutation) AddField(name string, value ent.Value) error {
	switch name {
	case product.FieldMinStockLevel:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMinStockLevel(v)
		return nil
	case product.FieldMaxStockLevel:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMaxStockLevel(v)
		return nil
	case product.FieldUsefulLifeMonths:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUsefulLifeMonths(v)
		return nil
	}
	return fmt.Errorf("unknown Product numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ProductMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(product.FieldDescription) {
		fields = append(fields, product.FieldDescription)
	}
	if m.FieldCleared(product.FieldAttributes) {
		fields = append(fields, product.FieldAttributes)
	}
	if m.FieldCleared(product.FieldBarcode) {
		fields = append(fields, product.FieldBarcode)
	}
	if m.FieldCleared(product.FieldLocation) {
		fields = append(fields, product.FieldLocation)
	}
	if m.FieldCleared(product.FieldSerialNumber) {
		fields = append(fields, product.FieldSerialNumber)
	}
	if m.FieldCleared(product.FieldPurchaseDate) {
		fields = append(fields, product.FieldPurchaseDate)
	}
	if m.FieldCleared(product.FieldPurchasePrice) {
		fields = append(fields, product.FieldPurchasePrice)
	}
	if m.FieldCleared(product.FieldUsefulLifeMonths) {
		fields = append(fields, product.FieldUsefulLifeMonths)
	}
	if m.FieldCleared(product.FieldWarrantyExpiresAt) {
		fields = append(fields, product.FieldWarrantyExpiresAt)
	}
	if m.FieldCleared(product.FieldDisposalDate) {
		fields = append(fields, product.FieldDisposalDate)
	}
	if m.FieldCleared(product.FieldDisposalReason) {
		fields = append(fields, product.FieldDisposalReason)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ProductMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProductMutation) ClearField(name string) error {
	switch name {
	case product.FieldDescription:
		m.ClearDescription()
		return nil
	case product.FieldAttributes:
		m.ClearAttributes()
		return nil
	case product.FieldBarcode:
		m.ClearBarcode()
		return nil
	case product.FieldLocation:
		m.ClearLocation()
		return nil
	case product.FieldSerialNumber:
		m.ClearSerialNumber()
		return nil
	case product.FieldPurchaseDate:
		m.ClearPurchaseDate()
		return nil
	case product.FieldPurchasePrice:
		m.ClearPurchasePrice()
		return nil
	case product.FieldUsefulLifeMonths:
		m.ClearUsefulLifeMonths()
		return nil
	case product.FieldWarrantyExpiresAt:
		m.ClearWarrantyExpiresAt()
		return nil
	case product.FieldDisposalDate:
		m.ClearDisposalDate()
		return nil
	case product.FieldDisposalReason:
		m.ClearDisposalReason()
		return nil
	}
	return fmt.Errorf("unknown Product nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ProductMutation) ResetField(name string) error {
	switch name {
	case product.FieldSku:
		m.ResetSku()
		return nil
	case product.FieldName:
		m.ResetName()
		return nil
	case product.FieldDescription:
		m.ResetDescription()
		return nil
	case product.FieldUnitCost:
		m.ResetUnitCost()
		return nil
	case product.FieldQuantity:
		m.ResetQuantity()
		return nil
	case product.FieldAttributes:
		m.ResetAttributes()
		return nil
	case product.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case product.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case product.FieldMinStockLevel:
		m.ResetMinStockLevel()
		return nil
	case product.FieldMaxStockLevel:
		m.ResetMaxStockLevel()
		return nil
	case product.FieldBarcode:
		m.ResetBarcode()
		return nil
	case product.FieldLocation:
		m.ResetLocation()
		return nil
	case product.FieldIsVariantParent:
		m.ResetIsVariantParent()
		return nil
	case product.FieldSerialNumber:
		m.ResetSerialNumber()
		return nil
	case product.FieldPurchaseDate:
		m.ResetPurchaseDate()
		return nil
	case product.FieldPurchasePrice:
		m.ResetPurchasePrice()
		return nil
	case product.FieldUsefulLifeMonths:
		m.ResetUsefulLifeMonths()
		return nil
	case product.FieldWarrantyExpiresAt:
		m.ResetWarrantyExpiresAt()
		return nil
	case product.FieldDisposalDate:
		m.ResetDisposalDate()
		return nil
	case product.FieldDisposalReason:
		m.ResetDisposalReason()
		return nil
	case product.FieldIsDisposed:
		m.ResetIsDisposed()
		return nil
	}
	return fmt.Errorf("unknown Product field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ProductMutation) AddedEdges() []string {
	edges := make([]string, 0, 13)
	if m.tenant != nil {
		edges = append(edges, product.EdgeTenant)
	}
	if m.movements != nil {
		edges = append(edges, product.EdgeMovements)
	}
	if m.reservations != nil {
		edges = append(edges, product.EdgeReservations)
	}
	if m.vendor != nil {
		edges = append(edges, product.EdgeVendor)
	}
	if m.supplier != nil {
		edges = append(edges, product.EdgeSupplier)
	}
	if m.category != nil {
		edges = append(edges, product.EdgeCategory)
	}
	if m.warehouse != nil {
		edges = append(edges, product.EdgeWarehouse)
	}
	if m.assignments != nil {
		edges = append(edges, product.EdgeAssignments)
	}
	if m.variants != nil {
		edges = append(edges, product.EdgeVariants)
	}
	if m.maintenance_schedules != nil {
		edges = append(edges, product.EdgeMaintenanceSchedules)
	}
	if m.alerts != nil {
		edges = append(edges, product.EdgeAlerts)
	}
	if m.purchase_order_lines != nil {
		edges = append(edges, product.EdgePurchaseOrderLines)
	}
	if m.inventory_counts != nil {
		edges = append(edges, product.EdgeInventoryCounts)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ProductMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case product.EdgeTenant:
		if id := m.tenant; id != nil {
			return []ent.Value{*id}
		}
	case product.EdgeMovements:
		ids := make([]ent.Value, 0, len(m.movements))
		for id := range m.movements {
			ids = append(ids, id)
		}
		return ids
	case product.EdgeReservations:
		ids := make([]ent.Value, 0, len(m.reservations))
		for id := range m.reservations {
			ids = append(ids, id)
		}
		return ids
	case product.EdgeVendor:
		if id := m.vendor; id != nil {
			return []ent.Value{*id}
		}
	case product.EdgeSupplier:
		if id := m.supplier; id != nil {
			return []ent.Value{*id}
		}
	case product.EdgeCategory:
		if id := m.category; id != nil {
			return []ent.Value{*id}
		}
	case product.EdgeWarehouse:
		if id := m.warehouse; id != nil {
			return []ent.Value{*id}
		}
	case product.EdgeAssignments:
		ids := make([]ent.Value, 0, len(m.assignments))
		for id := range m.assignments {
			ids = append(ids, id)
		}
		return ids
	case product.EdgeVariants:
		ids := make([]ent.Value, 0, len(m.variants))
		for id := range m.variants {
			ids = append(ids, id)
		}
		return ids
	case product.EdgeMaintenanceSchedules:
		ids := make([]ent.Value, 0, len(m.maintenance_schedules))
		for id := range m.maintenance_schedules {
			ids = append(ids, id)
		}
		return ids
	case product.EdgeAlerts:
		ids := make([]ent.Value, 0, len(m.alerts))
		for id := range m.alerts {
			ids = append(ids, id)
		}
		return ids
	case product.EdgePurchaseOrderLines:
		ids := make([]ent.Value, 0, len(m.purchase_order_lines))
		for id := range m.purchase_order_lines {
			ids = append(ids, id)
		}
		return ids
	case product.EdgeInventoryCounts:
		ids := make([]ent.Value, 0, len(m.inventory_counts))
		for id := range m.inventory_counts {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ProductMutation) RemovedEdges() []string {
	edges := make([]string, 0, 13)
	if m.removedmovements != nil {
		edges = append(edges, product.EdgeMovements)
	}
	if m.removedreservations != nil {
		edges = append(edges, product.EdgeReservations)
	}
	if m.removedassignments != nil {
		edges = append(edges, product.EdgeAssignments)
	}
	if m.removedvariants != nil {
		edges = append(edges, product.EdgeVariants)
	}
	if m.removedmaintenance_schedules != nil {
		edges = append(edges, product.EdgeMaintenanceSchedules)
	}
	if m.removedalerts != nil {
		edges = append(edges, product.EdgeAlerts)
	}
	if m.removedpurchase_order_lines != nil {
		edges = append(edges, product.EdgePurchaseOrderLines)
	}
	if m.removedinventory_counts != nil {
		edges = append(edges, product.EdgeInventoryCounts)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ProductMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case product.EdgeMovements:
		ids := make([]ent.Value, 0, len(m.removedmovements))
		for id := range m.removedmovements {
			ids = append(ids, id)
		}
		return ids
	case product.EdgeReservations:
		ids := make([]ent.Value, 0, len(m.removedreservations))
		for id := range m.removedreservations {
			ids = append(ids, id)
		}
		return ids
	case product.EdgeAssignments:
		ids := make([]ent.Value, 0, len(m.removedassignments))
		for id := range m.removedassignments {
			ids = append(ids, id)
		}
		return ids
	case product.EdgeVariants:
		ids := make([]ent.Value, 0, len(m.removedvariants))
		for id := range m.removedvariants {
			ids = append(ids, id)
		}
		return ids
	case product.EdgeMaintenanceSchedules:
		ids := make([]ent.Value, 0, len(m.removedmaintenance_schedules))
		for id := range m.removedmaintenance_schedules {
			ids = append(ids, id)
		}
		return ids
	case product.EdgeAlerts:
		ids := make([]ent.Value, 0, len(m.removedalerts))
		for id := range m.removedalerts {
			ids = append(ids, id)
		}
		return ids
	case product.EdgePurchaseOrderLines:
		ids := make([]ent.Value, 0, len(m.removedpurchase_order_lines))
		for id := range m.removedpurchase_order_lines {
			ids = append(ids, id)
		}
		return ids
	case product.EdgeInventoryCounts:
		ids := make([]ent.Value, 0, len(m.removedinventory_counts))
		for id := range m.removedinventory_counts {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ProductMutation) ClearedEdges() []string {
	edges := make([]string, 0, 13)
	if m.clearedtenant {
		edges = append(edges, product.EdgeTenant)
	}
	if m.clearedmovements {
		edges = append(edges, product.EdgeMovements)
	}
	if m.clearedreservations {
		edges = append(edges, product.EdgeReservations)
	}
	if m.clearedvendor {
		edges = append(edges, product.EdgeVendor)
	}
	if m.clearedsupplier {
		edges = append(edges, product.EdgeSupplier)
	}
	if m.clearedcategory {
		edges = append(edges, product.EdgeCategory)
	}
	if m.clearedwarehouse {
		edges = append(edges, product.EdgeWarehouse)
	}
	if m.clearedassignments {
		edges = append(edges, product.EdgeAssignments)
	}
	if m.clearedvariants {
		edges = append(edges, product.EdgeVariants)
	}
	if m.clearedmaintenance_schedules {
		edges = append(edges, product.EdgeMaintenanceSchedules)
	}
	if m.clearedalerts {
		edges = append(edges, product.EdgeAlerts)
	}
	if m.clearedpurchase_order_lines {
		edges = append(edges, product.EdgePurchaseOrderLines)
	}
	if m.clearedinventory_counts {
		edges = append(edges, product.EdgeInventoryCounts)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ProductMutation) EdgeCleared(name string) bool {
	switch name {
	case product.EdgeTenant:
		return m.clearedtenant
	case product.EdgeMovements:
		return m.clearedmovements
	case product.EdgeReservations:
		return m.clearedreservations
	case product.EdgeVendor:
		return m.clearedvendor
	case product.EdgeSupplier:
		return m.clearedsupplier
	case product.EdgeCategory:
		return m.clearedcategory
	case product.EdgeWarehouse:
		return m.clearedwarehouse
	case product.EdgeAssignments:
		return m.clearedassignments
	case product.EdgeVariants:
		return m.clearedvariants
	case product.EdgeMaintenanceSchedules:
		return m.clearedmaintenance_schedules
	case product.EdgeAlerts:
		return m.clearedalerts
	case product.EdgePurchaseOrderLines:
		return m.clearedpurchase_order_lines
	case product.EdgeInventoryCounts:
		return m.clearedinventory_counts
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ProductMutation) ClearEdge(name string) error {
	switch name {
	case product.EdgeTenant:
		m.ClearTenant()
		return nil
	case product.EdgeVendor:
		m.ClearVendor()
		return nil
	case product.EdgeSupplier:
		m.ClearSupplier()
		return nil
	case product.EdgeCategory:
		m.ClearCategory()
		return nil
	case product.EdgeWarehouse:
		m.ClearWarehouse()
		return nil
	}
	return fmt.Errorf("unknown Product unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ProductMutation) ResetEdge(name string) error {
	switch name {
	case product.EdgeTenant:
		m.ResetTenant()
		return nil
	case product.EdgeMovements:
		m.ResetMovements()
		return nil
	case product.EdgeReservations:
		m.ResetReservations()
		return nil
	case product.EdgeVendor:
		m.ResetVendor()
		return nil
	case product.EdgeSupplier:
		m.ResetSupplier()
		return nil
	case product.EdgeCategory:
		m.ResetCategory()
		return nil
	case product.EdgeWarehouse:
		m.ResetWarehouse()
		return nil
	case product.EdgeAssignments:
		m.ResetAssignments()
		return nil
	case product.EdgeVariants:
		m.ResetVariants()
		return nil
	case product.EdgeMaintenanceSchedules:
		m.ResetMaintenanceSchedules()
		return nil
	case product.EdgeAlerts:
		m.ResetAlerts()
		return nil
	case product.EdgePurchaseOrderLines:
		m.ResetPurchaseOrderLines()
		return nil
	case product.EdgeInventoryCounts:
		m.ResetInventoryCounts()
		return nil
	}
	return fmt.Errorf("unknown Product edge %s", name)
}

// ProductVariantMutation represents an operation that mutates the ProductVariant nodes in the graph.
type ProductVariantMutation struct {
	config
	op                  Op
	typ                 string
	id                  *int
	name                *string
	sku                 *string
	price_adjustment    *float64
	addprice_adjustment *float64
	stock               *int
	addstock            *int
	clearedFields       map[string]struct{}
	product             *int
	clearedproduct      bool
	done                bool
	oldValue            func(context.Context) (*ProductVariant, error)
	predicates          []predicate.ProductVariant
}

var _ ent.Mutation = (*ProductVariantMutation)(nil)

// productvariantOption allows management of the mutation configuration using functional options.
type productvariantOption func(*ProductVariantMutation)

// newProductVariantMutation creates new mutation for the ProductVariant entity.
func newProductVariantMutation(c config, op Op, opts ...productvariantOption) *ProductVariantMutation {
	m := &ProductVariantMutation{
		config:        c,
		op:            op,
		typ:           TypeProductVariant,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withProductVariantID sets the ID field of the mutation.
func withProductVariantID(id int) productvariantOption {
	return func(m *ProductVariantMutation) {
		var (
			err   error
			once  sync.Once
			value *ProductVariant
		)
		m.oldValue = func(ctx context.Context) (*ProductVariant, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ProductVariant.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProductVariant sets the old ProductVariant of the mutation.
func withProductVariant(node *ProductVariant) productvariantOption {
	return func(m *ProductVariantMutation) {
		m.oldValue = func(context.Context) (*ProductVariant, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProductVariantMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProductVariantMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ProductVariantMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ProductVariantMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ProductVariant.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *ProductVariantMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ProductVariantMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the ProductVariant entity.
// If the ProductVariant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductVariantMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ProductVariantMutation) ResetName() {
	m.name = nil
}

// SetSku sets the "sku" field.
func (m *ProductVariantMutation) SetSku(s string) {
	m.sku = &s
}

// Sku returns the value of the "sku" field in the mutation.
func (m *ProductVariantMutation) Sku() (r string, exists bool) {
	v := m.sku
	if v == nil {
		return
	}
	return *v, true
}

// OldSku returns the old "sku" field's value of the ProductVariant entity.
// If the ProductVariant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductVariantMutation) OldSku(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSku is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSku requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSku: %w", err)
	}
	return oldValue.Sku, nil
}

// ResetSku resets all changes to the "sku" field.
func (m *ProductVariantMutation) ResetSku() {
	m.sku = nil
}

// SetPriceAdjustment sets the "price_adjustment" field.
func (m *ProductVariantMutation) SetPriceAdjustment(f float64) {
	m.price_adjustment = &f
	m.addprice_adjustment = nil
}

// PriceAdjustment returns the value of the "price_adjustment" field in the mutation.
func (m *ProductVariantMutation) PriceAdjustment() (r float64, exists bool) {
	v := m.price_adjustment
	if v == nil {
		return
	}
	return *v, true
}

// OldPriceAdjustment returns the old "price_adjustment" field's value of the ProductVariant entity.
// If the ProductVariant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductVariantMutation) OldPriceAdjustment(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPriceAdjustment is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPriceAdjustment requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPriceAdjustment: %w", err)
	}
	return oldValue.PriceAdjustment, nil
}

// AddPriceAdjustment adds f to the "price_adjustment" field.
func (m *ProductVariantMutation) AddPriceAdjustment(f float64) {
	if m.addprice_adjustment != nil {
		*m.addprice_adjustment += f
	} else {
		m.addprice_adjustment = &f
	}
}

// AddedPriceAdjustment returns the value that was added to the "price_adjustment" field in this mutation.
func (m *ProductVariantMutation) AddedPriceAdjustment() (r float64, exists bool) {
	v := m.addprice_adjustment
	if v == nil {
		return
	}
	return *v, true
}

// ResetPriceAdjustment resets all changes to the "price_adjustment" field.
func (m *ProductVariantMutation) ResetPriceAdjustment() {
	m.price_adjustment = nil
	m.addprice_adjustment = nil
}

// SetStock sets the "stock" field.
func (m *ProductVariantMutation) SetStock(i int) {
	m.stock = &i
	m.addstock = nil
}

// Stock returns the value of the "stock" field in the mutation.
func (m *ProductVariantMutation) Stock() (r int, exists bool) {
	v := m.stock
	if v == nil {
		return
	}
	return *v, true
}

// OldStock returns the old "stock" field's value of the ProductVariant entity.
// If the ProductVariant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductVariantMutation) OldStock(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStock is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStock requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStock: %w", err)
	}
	return oldValue.Stock, nil
}

// AddStock adds i to the "stock" field.
func (m *ProductVariantMutation) AddStock(i int) {
	if m.addstock != nil {
		*m.addstock += i
	} else {
		m.addstock = &i
	}
}

// AddedStock returns the value that was added to the "stock" field in this mutation.
func (m *ProductVariantMutation) AddedStock() (r int, exists bool) {
	v := m.addstock
	if v == nil {
		return
	}
	return *v, true
}

// ResetStock resets all changes to the "stock" field.
func (m *ProductVariantMutation) ResetStock() {
	m.stock = nil
	m.addstock = nil
}

// SetProductID sets the "product" edge to the Product entity by id.
func (m *ProductVariantMutation) SetProductID(id int) {
	m.product = &id
}

// ClearProduct clears the "product" edge to the Product entity.
func (m *ProductVariantMutation) ClearProduct() {
	m.clearedproduct = true
}

// ProductCleared reports if the "product" edge to the Product entity was cleared.
func (m *ProductVariantMutation) ProductCleared() bool {
	return m.clearedproduct
}

// ProductID returns the "product" edge ID in the mutation.
func (m *ProductVariantMutation) ProductID() (id int, exists bool) {
	if m.product != nil {
		return *m.product, true
	}
	return
}

// ProductIDs returns the "product" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProductID instead. It exists only for internal usage by the builders.
func (m *ProductVariantMutation) ProductIDs() (ids []int) {
	if id := m.product; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProduct resets all changes to the "product" edge.
func (m *ProductVariantMutation) ResetProduct() {
	m.product = nil
	m.clearedproduct = false
}

// Where appends a list predicates to the ProductVariantMutation builder.
func (m *ProductVariantMutation) Where(ps ...predicate.ProductVariant) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ProductVariantMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ProductVariantMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ProductVariant, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ProductVariantMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ProductVariantMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ProductVariant).
func (m *ProductVariantMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ProductVariantMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.name != nil {
		fields = append(fields, productvariant.FieldName)
	}
	if m.sku != nil {
		fields = append(fields, productvariant.FieldSku)
	}
	if m.price_adjustment != nil {
		fields = append(fields, productvariant.FieldPriceAdjustment)
	}
	if m.stock != nil {
		fields = append(fields, productvariant.FieldStock)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ProductVariantMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case productvariant.FieldName:
		return m.Name()
	case productvariant.FieldSku:
		return m.Sku()
	case productvariant.FieldPriceAdjustment:
		return m.PriceAdjustment()
	case productvariant.FieldStock:
		return m.Stock()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ProductVariantMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case productvariant.FieldName:
		return m.OldName(ctx)
	case productvariant.FieldSku:
		return m.OldSku(ctx)
	case productvariant.FieldPriceAdjustment:
		return m.OldPriceAdjustment(ctx)
	case productvariant.FieldStock:
		return m.OldStock(ctx)
	}
	return nil, fmt.Errorf("unknown ProductVariant field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProductVariantMutation) SetField(name string, value ent.Value) error {
	switch name {
	case productvariant.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case productvariant.FieldSku:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSku(v)
		return nil
	case productvariant.FieldPriceAdjustment:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPriceAdjustment(v)
		return nil
	case productvariant.FieldStock:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStock(v)
		return nil
	}
	return fmt.Errorf("unknown ProductVariant field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ProductVariantMutation) AddedFields() []string {
	var fields []string
	if m.addprice_adjustment != nil {
		fields = append(fields, productvariant.FieldPriceAdjustment)
	}
	if m.addstock != nil {
		fields = append(fields, productvariant.FieldStock)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ProductVariantMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case productvariant.FieldPriceAdjustment:
		return m.AddedPriceAdjustment()
	case productvariant.FieldStock:
		return m.AddedStock()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProductVariantMutation) AddField(name string, value ent.Value) error {
	switch name {
	case productvariant.FieldPriceAdjustment:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPriceAdjustment(v)
		return nil
	case productvariant.FieldStock:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStock(v)
		return nil
	}
	return fmt.Errorf("unknown ProductVariant numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ProductVariantMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ProductVariantMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProductVariantMutation) ClearField(name string) error {
	return fmt.Errorf("unknown ProductVariant nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ProductVariantMutation) ResetField(name string) error {
	switch name {
	case productvariant.FieldName:
		m.ResetName()
		return nil
	case productvariant.FieldSku:
		m.ResetSku()
		return nil
	case productvariant.FieldPriceAdjustment:
		m.ResetPriceAdjustment()
		return nil
	case productvariant.FieldStock:
		m.ResetStock()
		return nil
	}
	return fmt.Errorf("unknown ProductVariant field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ProductVariantMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.product != nil {
		edges = append(edges, productvariant.EdgeProduct)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ProductVariantMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case productvariant.EdgeProduct:
		if id := m.product; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ProductVariantMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ProductVariantMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ProductVariantMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedproduct {
		edges = append(edges, productvariant.EdgeProduct)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ProductVariantMutation) EdgeCleared(name string) bool {
	switch name {
	case productvariant.EdgeProduct:
		return m.clearedproduct
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ProductVariantMutation) ClearEdge(name string) error {
	switch name {
	case productvariant.EdgeProduct:
		m.ClearProduct()
		return nil
	}
	return fmt.Errorf("unknown ProductVariant unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ProductVariantMutation) ResetEdge(name string) error {
	switch name {
	case productvariant.EdgeProduct:
		m.ResetProduct()
		return nil
	}
	return fmt.Errorf("unknown ProductVariant edge %s", name)
}

// PurchaseOrderMutation represents an operation that mutates the PurchaseOrder nodes in the graph.
type PurchaseOrderMutation struct {
	config
	op              Op
	typ             string
	id              *int
	po_number       *string
	status          *purchaseorder.Status
	order_date      *time.Time
	expected_date   *time.Time
	total_amount    *decimal.Decimal
	notes           *string
	created_at      *time.Time
	updated_at      *time.Time
	clearedFields   map[string]struct{}
	tenant          *int
	clearedtenant   bool
	supplier        *int
	clearedsupplier bool
	lines           map[int]struct{}
	removedlines    map[int]struct{}
	clearedlines    bool
	done            bool
	oldValue        func(context.Context) (*PurchaseOrder, error)
	predicates      []predicate.PurchaseOrder
}

var _ ent.Mutation = (*PurchaseOrderMutation)(nil)

// purchaseorderOption allows management of the mutation configuration using functional options.
type purchaseorderOption func(*PurchaseOrderMutation)

// newPurchaseOrderMutation creates new mutation for the PurchaseOrder entity.
func newPurchaseOrderMutation(c config, op Op, opts ...purchaseorderOption) *PurchaseOrderMutation {
	m := &PurchaseOrderMutation{
		config:        c,
		op:            op,
		typ:           TypePurchaseOrder,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPurchaseOrderID sets the ID field of the mutation.
func withPurchaseOrderID(id int) purchaseorderOption {
	return func(m *PurchaseOrderMutation) {
		var (
			err   error
			once  sync.Once
			value *PurchaseOrder
		)
		m.oldValue = func(ctx context.Context) (*PurchaseOrder, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().PurchaseOrder.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPurchaseOrder sets the old PurchaseOrder of the mutation.
func withPurchaseOrder(node *PurchaseOrder) purchaseorderOption {
	return func(m *PurchaseOrderMutation) {
		m.oldValue = func(context.Context) (*PurchaseOrder, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PurchaseOrderMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PurchaseOrderMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PurchaseOrderMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PurchaseOrderMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().PurchaseOrder.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetPoNumber sets the "po_number" field.
func (m *PurchaseOrderMutation) SetPoNumber(s string) {
	m.po_number = &s
}

// PoNumber returns the value of the "po_number" field in the mutation.
func (m *PurchaseOrderMutation) PoNumber() (r string, exists bool) {
	v := m.po_number
	if v == nil {
		return
	}
	return *v, true
}

// OldPoNumber returns the old "po_number" field's value of the PurchaseOrder entity.
// If the PurchaseOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PurchaseOrderMutation) OldPoNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPoNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPoNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPoNumber: %w", err)
	}
	return oldValue.PoNumber, nil
}

// ResetPoNumber resets all changes to the "po_number" field.
func (m *PurchaseOrderMutation) ResetPoNumber() {
	m.po_number = nil
}

// SetStatus sets the "status" field.
func (m *PurchaseOrderMutation) SetStatus(pu purchaseorder.Status) {
	m.status = &pu
}

// Status returns the value of the "status" field in the mutation.
func (m *PurchaseOrderMutation) Status() (r purchaseorder.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the PurchaseOrder entity.
// If the PurchaseOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PurchaseOrderMutation) OldStatus(ctx context.Context) (v purchaseorder.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *PurchaseOrderMutation) ResetStatus() {
	m.status = nil
}

// SetOrderDate sets the "order_date" field.
func (m *PurchaseOrderMutation) SetOrderDate(t time.Time) {
	m.order_date = &t
}

// OrderDate returns the value of the "order_date" field in the mutation.
func (m *PurchaseOrderMutation) OrderDate() (r time.Time, exists bool) {
	v := m.order_date
	if v == nil {
		return
	}
	return *v, true
}

// OldOrderDate returns the old "order_date" field's value of the PurchaseOrder entity.
// If the PurchaseOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PurchaseOrderMutation) OldOrderDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrderDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrderDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrderDate: %w", err)
	}
	return oldValue.OrderDate, nil
}

// ResetOrderDate resets all changes to the "order_date" field.
func (m *PurchaseOrderMutation) ResetOrderDate() {
	m.order_date = nil
}

// SetExpectedDate sets the "expected_date" field.
func (m *PurchaseOrderMutation) SetExpectedDate(t time.Time) {
	m.expected_date = &t
}

// ExpectedDate returns the value of the "expected_date" field in the mutation.
func (m *PurchaseOrderMutation) ExpectedDate() (r time.Time, exists bool) {
	v := m.expected_date
	if v == nil {
		return
	}
	return *v, true
}

// OldExpectedDate returns the old "expected_date" field's value of the PurchaseOrder entity.
// If the PurchaseOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PurchaseOrderMutation) OldExpectedDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpectedDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpectedDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpectedDate: %w", err)
	}
	return oldValue.ExpectedDate, nil
}

// ClearExpectedDate clears the value of the "expected_date" field.
func (m *PurchaseOrderMutation) ClearExpectedDate() {
	m.expected_date = nil
	m.clearedFields[purchaseorder.FieldExpectedDate] = struct{}{}
}

// ExpectedDateCleared returns if the "expected_date" field was cleared in this mutation.
func (m *PurchaseOrderMutation) ExpectedDateCleared() bool {
	_, ok := m.clearedFields[purchaseorder.FieldExpectedDate]
	return ok
}

// ResetExpectedDate resets all changes to the "expected_date" field.
func (m *PurchaseOrderMutation) ResetExpectedDate() {
	m.expected_date = nil
	delete(m.clearedFields, purchaseorder.FieldExpectedDate)
}

// SetTotalAmount sets the "total_amount" field.
func (m *PurchaseOrderMutation) SetTotalAmount(d decimal.Decimal) {
	m.total_amount = &d
}

// TotalAmount returns the value of the "total_amount" field in the mutation.
func (m *PurchaseOrderMutation) TotalAmount() (r decimal.Decimal, exists bool) {
	v := m.total_amount
	if v == nil {
		return
	}
	return *v, true
}

// OldTotalAmount returns the old "total_amount" field's value of the PurchaseOrder entity.
// If the PurchaseOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PurchaseOrderMutation) OldTotalAmount(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTotalAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTotalAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTotalAmount: %w", err)
	}
	return oldValue.TotalAmount, nil
}

// ResetTotalAmount resets all changes to the "total_amount" field.
func (m *PurchaseOrderMutation) ResetTotalAmount() {
	m.total_amount = nil
}

// SetNotes sets the "notes" field.
func (m *PurchaseOrderMutation) SetNotes(s string) {
	m.notes = &s
}

// Notes returns the value of the "notes" field in the mutation.
func (m *PurchaseOrderMutation) Notes() (r string, exists bool) {
	v := m.notes
	if v == nil {
		return
	}
	return *v, true
}

// OldNotes returns the old "notes" field's value of the PurchaseOrder entity.
// If the PurchaseOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PurchaseOrderMutation) OldNotes(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNotes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNotes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNotes: %w", err)
	}
	return oldValue.Notes, nil
}

// ClearNotes clears the value of the "notes" field.
func (m *PurchaseOrderMutation) ClearNotes() {
	m.notes = nil
	m.clearedFields[purchaseorder.FieldNotes] = struct{}{}
}

// NotesCleared returns if the "notes" field was cleared in this mutation.
func (m *PurchaseOrderMutation) NotesCleared() bool {
	_, ok := m.clearedFields[purchaseorder.FieldNotes]
	return ok
}

// ResetNotes resets all changes to the "notes" field.
func (m *PurchaseOrderMutation) ResetNotes() {
	m.notes = nil
	delete(m.clearedFields, purchaseorder.FieldNotes)
}

// SetCreatedAt sets the "created_at" field.
func (m *PurchaseOrderMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *PurchaseOrderMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the PurchaseOrder entity.
// If the PurchaseOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PurchaseOrderMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *PurchaseOrderMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *PurchaseOrderMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *PurchaseOrderMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the PurchaseOrder entity.
// If the PurchaseOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PurchaseOrderMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *PurchaseOrderMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetTenantID sets the "tenant" edge to the Tenant entity by id.
func (m *PurchaseOrderMutation) SetTenantID(id int) {
	m.tenant = &id
}

// ClearTenant clears the "tenant" edge to the Tenant entity.
func (m *PurchaseOrderMutation) ClearTenant() {
	m.clearedtenant = true
}

// TenantCleared reports if the "tenant" edge to the Tenant entity was cleared.
func (m *PurchaseOrderMutation) TenantCleared() bool {
	return m.clearedtenant
}

// TenantID returns the "tenant" edge ID in the mutation.
func (m *PurchaseOrderMutation) TenantID() (id int, exists bool) {
	if m.tenant != nil {
		return *m.tenant, true
	}
	return
}

// TenantIDs returns the "tenant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TenantID instead. It exists only for internal usage by the builders.
func (m *PurchaseOrderMutation) TenantIDs() (ids []int) {
	if id := m.tenant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTenant resets all changes to the "tenant" edge.
func (m *PurchaseOrderMutation) ResetTenant() {
	m.tenant = nil
	m.clearedtenant = false
}

// SetSupplierID sets the "supplier" edge to the Supplier entity by id.
func (m *PurchaseOrderMutation) SetSupplierID(id int) {
	m.supplier = &id
}

// ClearSupplier clears the "supplier" edge to the Supplier entity.
func (m *PurchaseOrderMutation) ClearSupplier() {
	m.clearedsupplier = true
}

// SupplierCleared reports if the "supplier" edge to the Supplier entity was cleared.
func (m *PurchaseOrderMutation) SupplierCleared() bool {
	return m.clearedsupplier
}

// SupplierID returns the "supplier" edge ID in the mutation.
func (m *PurchaseOrderMutation) SupplierID() (id int, exists bool) {
	if m.supplier != nil {
		return *m.supplier, true
	}
	return
}

// SupplierIDs returns the "supplier" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SupplierID instead. It exists only for internal usage by the builders.
func (m *PurchaseOrderMutation) SupplierIDs() (ids []int) {
	if id := m.supplier; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSupplier resets all changes to the "supplier" edge.
func (m *PurchaseOrderMutation) ResetSupplier() {
	m.supplier = nil
	m.clearedsupplier = false
}

// AddLineIDs adds the "lines" edge to the PurchaseOrderLine entity by ids.
func (m *PurchaseOrderMutation) AddLineIDs(ids ...int) {
	if m.lines == nil {
		m.lines = make(map[int]struct{})
	}
	for i := range ids {
		m.lines[ids[i]] = struct{}{}
	}
}

// ClearLines clears the "lines" edge to the PurchaseOrderLine entity.
func (m *PurchaseOrderMutation) ClearLines() {
	m.clearedlines = true
}

// LinesCleared reports if the "lines" edge to the PurchaseOrderLine entity was cleared.
func (m *PurchaseOrderMutation) LinesCleared() bool {
	return m.clearedlines
}

// RemoveLineIDs removes the "lines" edge to the PurchaseOrderLine entity by IDs.
func (m *PurchaseOrderMutation) RemoveLineIDs(ids ...int) {
	if m.removedlines == nil {
		m.removedlines = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.lines, ids[i])
		m.removedlines[ids[i]] = struct{}{}
	}
}

// RemovedLines returns the removed IDs of the "lines" edge to the PurchaseOrderLine entity.
func (m *PurchaseOrderMutation) RemovedLinesIDs() (ids []int) {
	for id := range m.removedlines {
		ids = append(ids, id)
	}
	return
}

// LinesIDs returns the "lines" edge IDs in the mutation.
func (m *PurchaseOrderMutation) LinesIDs() (ids []int) {
	for id := range m.lines {
		ids = append(ids, id)
	}
	return
}

// ResetLines resets all changes to the "lines" edge.
func (m *PurchaseOrderMutation) ResetLines() {
	m.lines = nil
	m.clearedlines = false
	m.removedlines = nil
}

// Where appends a list predicates to the PurchaseOrderMutation builder.
func (m *PurchaseOrderMutation) Where(ps ...predicate.PurchaseOrder) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PurchaseOrderMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PurchaseOrderMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.PurchaseOrder, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PurchaseOrderMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PurchaseOrderMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (PurchaseOrder).
func (m *PurchaseOrderMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PurchaseOrderMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.po_number != nil {
		fields = append(fields, purchaseorder.FieldPoNumber)
	}
	if m.status != nil {
		fields = append(fields, purchaseorder.FieldStatus)
	}
	if m.order_date != nil {
		fields = append(fields, purchaseorder.FieldOrderDate)
	}
	if m.expected_date != nil {
		fields = append(fields, purchaseorder.FieldExpectedDate)
	}
	if m.total_amount != nil {
		fields = append(fields, purchaseorder.FieldTotalAmount)
	}
	if m.notes != nil {
		fields = append(fields, purchaseorder.FieldNotes)
	}
	if m.created_at != nil {
		fields = append(fields, purchaseorder.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, purchaseorder.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PurchaseOrderMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case purchaseorder.FieldPoNumber:
		return m.PoNumber()
	case purchaseorder.FieldStatus:
		return m.Status()
	case purchaseorder.FieldOrderDate:
		return m.OrderDate()
	case purchaseorder.FieldExpectedDate:
		return m.ExpectedDate()
	case purchaseorder.FieldTotalAmount:
		return m.TotalAmount()
	case purchaseorder.FieldNotes:
		return m.Notes()
	case purchaseorder.FieldCreatedAt:
		return m.CreatedAt()
	case purchaseorder.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PurchaseOrderMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case purchaseorder.FieldPoNumber:
		return m.OldPoNumber(ctx)
	case purchaseorder.FieldStatus:
		return m.OldStatus(ctx)
	case purchaseorder.FieldOrderDate:
		return m.OldOrderDate(ctx)
	case purchaseorder.FieldExpectedDate:
		return m.OldExpectedDate(ctx)
	case purchaseorder.FieldTotalAmount:
		return m.OldTotalAmount(ctx)
	case purchaseorder.FieldNotes:
		return m.OldNotes(ctx)
	case purchaseorder.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case purchaseorder.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown PurchaseOrder field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PurchaseOrderMutation) SetField(name string, value ent.Value) error {
	switch name {
	case purchaseorder.FieldPoNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPoNumber(v)
		return nil
	case purchaseorder.FieldStatus:
		v, ok := value.(purchaseorder.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case purchaseorder.FieldOrderDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrderDate(v)
		return nil
	case purchaseorder.FieldExpectedDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpectedDate(v)
		return nil
	case purchaseorder.FieldTotalAmount:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTotalAmount(v)
		return nil
	case purchaseorder.FieldNotes:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNotes(v)
		return nil
	case purchaseorder.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case purchaseorder.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown PurchaseOrder field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PurchaseOrderMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PurchaseOrderMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PurchaseOrderMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown PurchaseOrder numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PurchaseOrderMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(purchaseorder.FieldExpectedDate) {
		fields = append(fields, purchaseorder.FieldExpectedDate)
	}
	if m.FieldCleared(purchaseorder.FieldNotes) {
		fields = append(fields, purchaseorder.FieldNotes)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PurchaseOrderMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PurchaseOrderMutation) ClearField(name string) error {
	switch name {
	case purchaseorder.FieldExpectedDate:
		m.ClearExpectedDate()
		return nil
	case purchaseorder.FieldNotes:
		m.ClearNotes()
		return nil
	}
	return fmt.Errorf("unknown PurchaseOrder nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PurchaseOrderMutation) ResetField(name string) error {
	switch name {
	case purchaseorder.FieldPoNumber:
		m.ResetPoNumber()
		return nil
	case purchaseorder.FieldStatus:
		m.ResetStatus()
		return nil
	case purchaseorder.FieldOrderDate:
		m.ResetOrderDate()
		return nil
	case purchaseorder.FieldExpectedDate:
		m.ResetExpectedDate()
		return nil
	case purchaseorder.FieldTotalAmount:
		m.ResetTotalAmount()
		return nil
	case purchaseorder.FieldNotes:
		m.ResetNotes()
		return nil
	case purchaseorder.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case purchaseorder.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown PurchaseOrder field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PurchaseOrderMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.tenant != nil {
		edges = append(edges, purchaseorder.EdgeTenant)
	}
	if m.supplier != nil {
		edges = append(edges, purchaseorder.EdgeSupplier)
	}
	if m.lines != nil {
		edges = append(edges, purchaseorder.EdgeLines)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PurchaseOrderMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case purchaseorder.EdgeTenant:
		if id := m.tenant; id != nil {
			return []ent.Value{*id}
		}
	case purchaseorder.EdgeSupplier:
		if id := m.supplier; id != nil {
			return []ent.Value{*id}
		}
	case purchaseorder.EdgeLines:
		ids := make([]ent.Value, 0, len(m.lines))
		for id := range m.lines {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PurchaseOrderMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedlines != nil {
		edges = append(edges, purchaseorder.EdgeLines)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PurchaseOrderMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case purchaseorder.EdgeLines:
		ids := make([]ent.Value, 0, len(m.removedlines))
		for id := range m.removedlines {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PurchaseOrderMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedtenant {
		edges = append(edges, purchaseorder.EdgeTenant)
	}
	if m.clearedsupplier {
		edges = append(edges, purchaseorder.EdgeSupplier)
	}
	if m.clearedlines {
		edges = append(edges, purchaseorder.EdgeLines)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PurchaseOrderMutation) EdgeCleared(name string) bool {
	switch name {
	case purchaseorder.EdgeTenant:
		return m.clearedtenant
	case purchaseorder.EdgeSupplier:
		return m.clearedsupplier
	case purchaseorder.EdgeLines:
		return m.clearedlines
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PurchaseOrderMutation) ClearEdge(name string) error {
	switch name {
	case purchaseorder.EdgeTenant:
		m.ClearTenant()
		return nil
	case purchaseorder.EdgeSupplier:
		m.ClearSupplier()
		return nil
	}
	return fmt.Errorf("unknown PurchaseOrder unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PurchaseOrderMutation) ResetEdge(name string) error {
	switch name {
	case purchaseorder.EdgeTenant:
		m.ResetTenant()
		return nil
	case purchaseorder.EdgeSupplier:
		m.ResetSupplier()
		return nil
	case purchaseorder.EdgeLines:
		m.ResetLines()
		return nil
	}
	return fmt.Errorf("unknown PurchaseOrder edge %s", name)
}

// PurchaseOrderLineMutation represents an operation that mutates the PurchaseOrderLine nodes in the graph.
type PurchaseOrderLineMutation struct {
	config
	op                    Op
	typ                   string
	id                    *int
	quantity              *int
	addquantity           *int
	unit_cost             *decimal.Decimal
	received_qty          *int
	addreceived_qty       *int
	clearedFields         map[string]struct{}
	purchase_order        *int
	clearedpurchase_order bool
	product               *int
	clearedproduct        bool
	done                  bool
	oldValue              func(context.Context) (*PurchaseOrderLine, error)
	predicates            []predicate.PurchaseOrderLine
}

var _ ent.Mutation = (*PurchaseOrderLineMutation)(nil)

// purchaseorderlineOption allows management of the mutation configuration using functional options.
type purchaseorderlineOption func(*PurchaseOrderLineMutation)

// newPurchaseOrderLineMutation creates new mutation for the PurchaseOrderLine entity.
func newPurchaseOrderLineMutation(c config, op Op, opts ...purchaseorderlineOption) *PurchaseOrderLineMutation {
	m := &PurchaseOrderLineMutation{
		config:        c,
		op:            op,
		typ:           TypePurchaseOrderLine,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPurchaseOrderLineID sets the ID field of the mutation.
func withPurchaseOrderLineID(id int) purchaseorderlineOption {
	return func(m *PurchaseOrderLineMutation) {
		var (
			err   error
			once  sync.Once
			value *PurchaseOrderLine
		)
		m.oldValue = func(ctx context.Context) (*PurchaseOrderLine, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().PurchaseOrderLine.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPurchaseOrderLine sets the old PurchaseOrderLine of the mutation.
func withPurchaseOrderLine(node *PurchaseOrderLine) purchaseorderlineOption {
	return func(m *PurchaseOrderLineMutation) {
		m.oldValue = func(context.Context) (*PurchaseOrderLine, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PurchaseOrderLineMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PurchaseOrderLineMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PurchaseOrderLineMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PurchaseOrderLineMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().PurchaseOrderLine.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetQuantity sets the "quantity" field.
func (m *PurchaseOrderLineMutation) SetQuantity(i int) {
	m.quantity = &i
	m.addquantity = nil
}

// Quantity returns the value of the "quantity" field in the mutation.
func (m *PurchaseOrderLineMutation) Quantity() (r int, exists bool) {
	v := m.quantity
	if v == nil {
		return
	}
	return *v, true
}

// OldQuantity returns the old "quantity" field's value of the PurchaseOrderLine entity.
// If the PurchaseOrderLine object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PurchaseOrderLineMutation) OldQuantity(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldQuantity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldQuantity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldQuantity: %w", err)
	}
	return oldValue.Quantity, nil
}

// AddQuantity adds i to the "quantity" field.
func (m *PurchaseOrderLineMutation) AddQuantity(i int) {
	if m.addquantity != nil {
		*m.addquantity += i
	} else {
		m.addquantity = &i
	}
}

// AddedQuantity returns the value that was added to the "quantity" field in this mutation.
func (m *PurchaseOrderLineMutation) AddedQuantity() (r int, exists bool) {
	v := m.addquantity
	if v == nil {
		return
	}
	return *v, true
}

// ResetQuantity resets all changes to the "quantity" field.
func (m *PurchaseOrderLineMutation) ResetQuantity() {
	m.quantity = nil
	m.addquantity = nil
}

// SetUnitCost sets the "unit_cost" field.
func (m *PurchaseOrderLineMutation) SetUnitCost(d decimal.Decimal) {
	m.unit_cost = &d
}

// UnitCost returns the value of the "unit_cost" field in the mutation.
func (m *PurchaseOrderLineMutation) UnitCost() (r decimal.Decimal, exists bool) {
	v := m.unit_cost
	if v == nil {
		return
	}
	return *v, true
}

// OldUnitCost returns the old "unit_cost" field's value of the PurchaseOrderLine entity.
// If the PurchaseOrderLine object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PurchaseOrderLineMutation) OldUnitCost(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUnitCost is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUnitCost requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUnitCost: %w", err)
	}
	return oldValue.UnitCost, nil
}

// ResetUnitCost resets all changes to the "unit_cost" field.
func (m *PurchaseOrderLineMutation) ResetUnitCost() {
	m.unit_cost = nil
}

// SetReceivedQty sets the "received_qty" field.
func (m *PurchaseOrderLineMutation) SetReceivedQty(i int) {
	m.received_qty = &i
	m.addreceived_qty = nil
}

// ReceivedQty returns the value of the "received_qty" field in the mutation.
func (m *PurchaseOrderLineMutation) ReceivedQty() (r int, exists bool) {
	v := m.received_qty
	if v == nil {
		return
	}
	return *v, true
}

// OldReceivedQty returns the old "received_qty" field's value of the PurchaseOrderLine entity.
// If the PurchaseOrderLine object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PurchaseOrderLineMutation) OldReceivedQty(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReceivedQty is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReceivedQty requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReceivedQty: %w", err)
	}
	return oldValue.ReceivedQty, nil
}

// AddReceivedQty adds i to the "received_qty" field.
func (m *PurchaseOrderLineMutation) AddReceivedQty(i int) {
	if m.addreceived_qty != nil {
		*m.addreceived_qty += i
	} else {
		m.addreceived_qty = &i
	}
}

// AddedReceivedQty returns the value that was added to the "received_qty" field in this mutation.
func (m *PurchaseOrderLineMutation) AddedReceivedQty() (r int, exists bool) {
	v := m.addreceived_qty
	if v == nil {
		return
	}
	return *v, true
}

// ResetReceivedQty resets all changes to the "received_qty" field.
func (m *PurchaseOrderLineMutation) ResetReceivedQty() {
	m.received_qty = nil
	m.addreceived_qty = nil
}

// SetPurchaseOrderID sets the "purchase_order" edge to the PurchaseOrder entity by id.
func (m *PurchaseOrderLineMutation) SetPurchaseOrderID(id int) {
	m.purchase_order = &id
}

// ClearPurchaseOrder clears the "purchase_order" edge to the PurchaseOrder entity.
func (m *PurchaseOrderLineMutation) ClearPurchaseOrder() {
	m.clearedpurchase_order = true
}

// PurchaseOrderCleared reports if the "purchase_order" edge to the PurchaseOrder entity was cleared.
func (m *PurchaseOrderLineMutation) PurchaseOrderCleared() bool {
	return m.clearedpurchase_order
}

// PurchaseOrderID returns the "purchase_order" edge ID in the mutation.
func (m *PurchaseOrderLineMutation) PurchaseOrderID() (id int, exists bool) {
	if m.purchase_order != nil {
		return *m.purchase_order, true
	}
	return
}

// PurchaseOrderIDs returns the "purchase_order" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PurchaseOrderID instead. It exists only for internal usage by the builders.
func (m *PurchaseOrderLineMutation) PurchaseOrderIDs() (ids []int) {
	if id := m.purchase_order; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPurchaseOrder resets all changes to the "purchase_order" edge.
func (m *PurchaseOrderLineMutation) ResetPurchaseOrder() {
	m.purchase_order = nil
	m.clearedpurchase_order = false
}

// SetProductID sets the "product" edge to the Product entity by id.
func (m *PurchaseOrderLineMutation) SetProductID(id int) {
	m.product = &id
}

// ClearProduct clears the "product" edge to the Product entity.
func (m *PurchaseOrderLineMutation) ClearProduct() {
	m.clearedproduct = true
}

// ProductCleared reports if the "product" edge to the Product entity was cleared.
func (m *PurchaseOrderLineMutation) ProductCleared() bool {
	return m.clearedproduct
}

// ProductID returns the "product" edge ID in the mutation.
func (m *PurchaseOrderLineMutation) ProductID() (id int, exists bool) {
	if m.product != nil {
		return *m.product, true
	}
	return
}

// ProductIDs returns the "product" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProductID instead. It exists only for internal usage by the builders.
func (m *PurchaseOrderLineMutation) ProductIDs() (ids []int) {
	if id := m.product; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProduct resets all changes to the "product" edge.
func (m *PurchaseOrderLineMutation) ResetProduct() {
	m.product = nil
	m.clearedproduct = false
}

// Where appends a list predicates to the PurchaseOrderLineMutation builder.
func (m *PurchaseOrderLineMutation) Where(ps ...predicate.PurchaseOrderLine) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PurchaseOrderLineMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PurchaseOrderLineMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.PurchaseOrderLine, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PurchaseOrderLineMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PurchaseOrderLineMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (PurchaseOrderLine).
func (m *PurchaseOrderLineMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PurchaseOrderLineMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.quantity != nil {
		fields = append(fields, purchaseorderline.FieldQuantity)
	}
	if m.unit_cost != nil {
		fields = append(fields, purchaseorderline.FieldUnitCost)
	}
	if m.received_qty != nil {
		fields = append(fields, purchaseorderline.FieldReceivedQty)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PurchaseOrderLineMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case purchaseorderline.FieldQuantity:
		return m.Quantity()
	case purchaseorderline.FieldUnitCost:
		return m.UnitCost()
	case purchaseorderline.FieldReceivedQty:
		return m.ReceivedQty()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PurchaseOrderLineMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case purchaseorderline.FieldQuantity:
		return m.OldQuantity(ctx)
	case purchaseorderline.FieldUnitCost:
		return m.OldUnitCost(ctx)
	case purchaseorderline.FieldReceivedQty:
		return m.OldReceivedQty(ctx)
	}
	return nil, fmt.Errorf("unknown PurchaseOrderLine field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PurchaseOrderLineMutation) SetField(name string, value ent.Value) error {
	switch name {
	case purchaseorderline.FieldQuantity:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetQuantity(v)
		return nil
	case purchaseorderline.FieldUnitCost:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUnitCost(v)
		return nil
	case purchaseorderline.FieldReceivedQty:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReceivedQty(v)
		return nil
	}
	return fmt.Errorf("unknown PurchaseOrderLine field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PurchaseOrderLineMutation) AddedFields() []string {
	var fields []string
	if m.addquantity != nil {
		fields = append(fields, purchaseorderline.FieldQuantity)
	}
	if m.addreceived_qty != nil {
		fields = append(fields, purchaseorderline.FieldReceivedQty)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PurchaseOrderLineMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case purchaseorderline.FieldQuantity:
		return m.AddedQuantity()
	case purchaseorderline.FieldReceivedQty:
		return m.AddedReceivedQty()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PurchaseOrderLineMutation) AddField(name string, value ent.Value) error {
	switch name {
	case purchaseorderline.FieldQuantity:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddQuantity(v)
		return nil
	case purchaseorderline.FieldReceivedQty:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddReceivedQty(v)
		return nil
	}
	return fmt.Errorf("unknown PurchaseOrderLine numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PurchaseOrderLineMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PurchaseOrderLineMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PurchaseOrderLineMutation) ClearField(name string) error {
	return fmt.Errorf("unknown PurchaseOrderLine nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PurchaseOrderLineMutation) ResetField(name string) error {
	switch name {
	case purchaseorderline.FieldQuantity:
		m.ResetQuantity()
		return nil
	case purchaseorderline.FieldUnitCost:
		m.ResetUnitCost()
		return nil
	case purchaseorderline.FieldReceivedQty:
		m.ResetReceivedQty()
		return nil
	}
	return fmt.Errorf("unknown PurchaseOrderLine field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PurchaseOrderLineMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.purchase_order != nil {
		edges = append(edges, purchaseorderline.EdgePurchaseOrder)
	}
	if m.product != nil {
		edges = append(edges, purchaseorderline.EdgeProduct)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PurchaseOrderLineMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case purchaseorderline.EdgePurchaseOrder:
		if id := m.purchase_order; id != nil {
			return []ent.Value{*id}
		}
	case purchaseorderline.EdgeProduct:
		if id := m.product; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PurchaseOrderLineMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PurchaseOrderLineMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PurchaseOrderLineMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedpurchase_order {
		edges = append(edges, purchaseorderline.EdgePurchaseOrder)
	}
	if m.clearedproduct {
		edges = append(edges, purchaseorderline.EdgeProduct)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PurchaseOrderLineMutation) EdgeCleared(name string) bool {
	switch name {
	case purchaseorderline.EdgePurchaseOrder:
		return m.clearedpurchase_order
	case purchaseorderline.EdgeProduct:
		return m.clearedproduct
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PurchaseOrderLineMutation) ClearEdge(name string) error {
	switch name {
	case purchaseorderline.EdgePurchaseOrder:
		m.ClearPurchaseOrder()
		return nil
	case purchaseorderline.EdgeProduct:
		m.ClearProduct()
		return nil
	}
	return fmt.Errorf("unknown PurchaseOrderLine unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PurchaseOrderLineMutation) ResetEdge(name string) error {
	switch name {
	case purchaseorderline.EdgePurchaseOrder:
		m.ResetPurchaseOrder()
		return nil
	case purchaseorderline.EdgeProduct:
		m.ResetProduct()
		return nil
	}
	return fmt.Errorf("unknown PurchaseOrderLine edge %s", name)
}

// RecordingMutation represents an operation that mutates the Recording nodes in the graph.
type RecordingMutation struct {
	config
	op            Op
	typ           string
	id            *int
	_path         *string
	start_time    *time.Time
	end_time      *time.Time
	size_bytes    *float64
	addsize_bytes *float64
	_type         *string
	clearedFields map[string]struct{}
	camera        *int
	clearedcamera bool
	tenant        *int
	clearedtenant bool
	done          bool
	oldValue      func(context.Context) (*Recording, error)
	predicates    []predicate.Recording
}

var _ ent.Mutation = (*RecordingMutation)(nil)

// recordingOption allows management of the mutation configuration using functional options.
type recordingOption func(*RecordingMutation)

// newRecordingMutation creates new mutation for the Recording entity.
func newRecordingMutation(c config, op Op, opts ...recordingOption) *RecordingMutation {
	m := &RecordingMutation{
		config:        c,
		op:            op,
		typ:           TypeRecording,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRecordingID sets the ID field of the mutation.
func withRecordingID(id int) recordingOption {
	return func(m *RecordingMutation) {
		var (
			err   error
			once  sync.Once
			value *Recording
		)
		m.oldValue = func(ctx context.Context) (*Recording, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Recording.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRecording sets the old Recording of the mutation.
func withRecording(node *Recording) recordingOption {
	return func(m *RecordingMutation) {
		m.oldValue = func(context.Context) (*Recording, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RecordingMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RecordingMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *RecordingMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *RecordingMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Recording.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetPath sets the "path" field.
func (m *RecordingMutation) SetPath(s string) {
	m._path = &s
}

// Path returns the value of the "path" field in the mutation.
func (m *RecordingMutation) Path() (r string, exists bool) {
	v := m._path
	if v == nil {
		return
	}
	return *v, true
}

// OldPath returns the old "path" field's value of the Recording entity.
// If the Recording object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RecordingMutation) OldPath(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPath is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPath requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPath: %w", err)
	}
	return oldValue.Path, nil
}

// ResetPath resets all changes to the "path" field.
func (m *RecordingMutation) ResetPath() {
	m._path = nil
}

// SetStartTime sets the "start_time" field.
func (m *RecordingMutation) SetStartTime(t time.Time) {
	m.start_time = &t
}

// StartTime returns the value of the "start_time" field in the mutation.
func (m *RecordingMutation) StartTime() (r time.Time, exists bool) {
	v := m.start_time
	if v == nil {
		return
	}
	return *v, true
}

// OldStartTime returns the old "start_time" field's value of the Recording entity.
// If the Recording object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RecordingMutation) OldStartTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartTime: %w", err)
	}
	return oldValue.StartTime, nil
}

// ResetStartTime resets all changes to the "start_time" field.
func (m *RecordingMutation) ResetStartTime() {
	m.start_time = nil
}

// SetEndTime sets the "end_time" field.
func (m *RecordingMutation) SetEndTime(t time.Time) {
	m.end_time = &t
}

// EndTime returns the value of the "end_time" field in the mutation.
func (m *RecordingMutation) EndTime() (r time.Time, exists bool) {
	v := m.end_time
	if v == nil {
		return
	}
	return *v, true
}

// OldEndTime returns the old "end_time" field's value of the Recording entity.
// If the Recording object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RecordingMutation) OldEndTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEndTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEndTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndTime: %w", err)
	}
	return oldValue.EndTime, nil
}

// ClearEndTime clears the value of the "end_time" field.
func (m *RecordingMutation) ClearEndTime() {
	m.end_time = nil
	m.clearedFields[recording.FieldEndTime] = struct{}{}
}

// EndTimeCleared returns if the "end_time" field was cleared in this mutation.
func (m *RecordingMutation) EndTimeCleared() bool {
	_, ok := m.clearedFields[recording.FieldEndTime]
	return ok
}

// ResetEndTime resets all changes to the "end_time" field.
func (m *RecordingMutation) ResetEndTime() {
	m.end_time = nil
	delete(m.clearedFields, recording.FieldEndTime)
}

// SetSizeBytes sets the "size_bytes" field.
func (m *RecordingMutation) SetSizeBytes(f float64) {
	m.size_bytes = &f
	m.addsize_bytes = nil
}

// SizeBytes returns the value of the "size_bytes" field in the mutation.
func (m *RecordingMutation) SizeBytes() (r float64, exists bool) {
	v := m.size_bytes
	if v == nil {
		return
	}
	return *v, true
}

// OldSizeBytes returns the old "size_bytes" field's value of the Recording entity.
// If the Recording object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RecordingMutation) OldSizeBytes(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSizeBytes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSizeBytes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSizeBytes: %w", err)
	}
	return oldValue.SizeBytes, nil
}

// AddSizeBytes adds f to the "size_bytes" field.
func (m *RecordingMutation) AddSizeBytes(f float64) {
	if m.addsize_bytes != nil {
		*m.addsize_bytes += f
	} else {
		m.addsize_bytes = &f
	}
}

// AddedSizeBytes returns the value that was added to the "size_bytes" field in this mutation.
func (m *RecordingMutation) AddedSizeBytes() (r float64, exists bool) {
	v := m.addsize_bytes
	if v == nil {
		return
	}
	return *v, true
}

// ClearSizeBytes clears the value of the "size_bytes" field.
func (m *RecordingMutation) ClearSizeBytes() {
	m.size_bytes = nil
	m.addsize_bytes = nil
	m.clearedFields[recording.FieldSizeBytes] = struct{}{}
}

// SizeBytesCleared returns if the "size_bytes" field was cleared in this mutation.
func (m *RecordingMutation) SizeBytesCleared() bool {
	_, ok := m.clearedFields[recording.FieldSizeBytes]
	return ok
}

// ResetSizeBytes resets all changes to the "size_bytes" field.
func (m *RecordingMutation) ResetSizeBytes() {
	m.size_bytes = nil
	m.addsize_bytes = nil
	delete(m.clearedFields, recording.FieldSizeBytes)
}

// SetType sets the "type" field.
func (m *RecordingMutation) SetType(s string) {
	m._type = &s
}

// GetType returns the value of the "type" field in the mutation.
func (m *RecordingMutation) GetType() (r string, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Recording entity.
// If the Recording object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RecordingMutation) OldType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *RecordingMutation) ResetType() {
	m._type = nil
}

// SetCameraID sets the "camera" edge to the Camera entity by id.
func (m *RecordingMutation) SetCameraID(id int) {
	m.camera = &id
}

// ClearCamera clears the "camera" edge to the Camera entity.
func (m *RecordingMutation) ClearCamera() {
	m.clearedcamera = true
}

// CameraCleared reports if the "camera" edge to the Camera entity was cleared.
func (m *RecordingMutation) CameraCleared() bool {
	return m.clearedcamera
}

// CameraID returns the "camera" edge ID in the mutation.
func (m *RecordingMutation) CameraID() (id int, exists bool) {
	if m.camera != nil {
		return *m.camera, true
	}
	return
}

// CameraIDs returns the "camera" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CameraID instead. It exists only for internal usage by the builders.
func (m *RecordingMutation) CameraIDs() (ids []int) {
	if id := m.camera; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCamera resets all changes to the "camera" edge.
func (m *RecordingMutation) ResetCamera() {
	m.camera = nil
	m.clearedcamera = false
}

// SetTenantID sets the "tenant" edge to the Tenant entity by id.
func (m *RecordingMutation) SetTenantID(id int) {
	m.tenant = &id
}

// ClearTenant clears the "tenant" edge to the Tenant entity.
func (m *RecordingMutation) ClearTenant() {
	m.clearedtenant = true
}

// TenantCleared reports if the "tenant" edge to the Tenant entity was cleared.
func (m *RecordingMutation) TenantCleared() bool {
	return m.clearedtenant
}

// TenantID returns the "tenant" edge ID in the mutation.
func (m *RecordingMutation) TenantID() (id int, exists bool) {
	if m.tenant != nil {
		return *m.tenant, true
	}
	return
}

// TenantIDs returns the "tenant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TenantID instead. It exists only for internal usage by the builders.
func (m *RecordingMutation) TenantIDs() (ids []int) {
	if id := m.tenant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTenant resets all changes to the "tenant" edge.
func (m *RecordingMutation) ResetTenant() {
	m.tenant = nil
	m.clearedtenant = false
}

// Where appends a list predicates to the RecordingMutation builder.
func (m *RecordingMutation) Where(ps ...predicate.Recording) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the RecordingMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *RecordingMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Recording, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *RecordingMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *RecordingMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Recording).
func (m *RecordingMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *RecordingMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m._path != nil {
		fields = append(fields, recording.FieldPath)
	}
	if m.start_time != nil {
		fields = append(fields, recording.FieldStartTime)
	}
	if m.end_time != nil {
		fields = append(fields, recording.FieldEndTime)
	}
	if m.size_bytes != nil {
		fields = append(fields, recording.FieldSizeBytes)
	}
	if m._type != nil {
		fields = append(fields, recording.FieldType)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *RecordingMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case recording.FieldPath:
		return m.Path()
	case recording.FieldStartTime:
		return m.StartTime()
	case recording.FieldEndTime:
		return m.EndTime()
	case recording.FieldSizeBytes:
		return m.SizeBytes()
	case recording.FieldType:
		return m.GetType()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *RecordingMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case recording.FieldPath:
		return m.OldPath(ctx)
	case recording.FieldStartTime:
		return m.OldStartTime(ctx)
	case recording.FieldEndTime:
		return m.OldEndTime(ctx)
	case recording.FieldSizeBytes:
		return m.OldSizeBytes(ctx)
	case recording.FieldType:
		return m.OldType(ctx)
	}
	return nil, fmt.Errorf("unknown Recording field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RecordingMutation) SetField(name string, value ent.Value) error {
	switch name {
	case recording.FieldPath:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPath(v)
		return nil
	case recording.FieldStartTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartTime(v)
		return nil
	case recording.FieldEndTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndTime(v)
		return nil
	case recording.FieldSizeBytes:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSizeBytes(v)
		return nil
	case recording.FieldType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	}
	return fmt.Errorf("unknown Recording field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *RecordingMutation) AddedFields() []string {
	var fields []string
	if m.addsize_bytes != nil {
		fields = append(fields, recording.FieldSizeBytes)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *RecordingMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case recording.FieldSizeBytes:
		return m.AddedSizeBytes()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RecordingMutation) AddField(name string, value ent.Value) error {
	switch name {
	case recording.FieldSizeBytes:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSizeBytes(v)
		return nil
	}
	return fmt.Errorf("unknown Recording numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *RecordingMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(recording.FieldEndTime) {
		fields = append(fields, recording.FieldEndTime)
	}
	if m.FieldCleared(recording.FieldSizeBytes) {
		fields = append(fields, recording.FieldSizeBytes)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *RecordingMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *RecordingMutation) ClearField(name string) error {
	switch name {
	case recording.FieldEndTime:
		m.ClearEndTime()
		return nil
	case recording.FieldSizeBytes:
		m.ClearSizeBytes()
		return nil
	}
	return fmt.Errorf("unknown Recording nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *RecordingMutation) ResetField(name string) error {
	switch name {
	case recording.FieldPath:
		m.ResetPath()
		return nil
	case recording.FieldStartTime:
		m.ResetStartTime()
		return nil
	case recording.FieldEndTime:
		m.ResetEndTime()
		return nil
	case recording.FieldSizeBytes:
		m.ResetSizeBytes()
		return nil
	case recording.FieldType:
		m.ResetType()
		return nil
	}
	return fmt.Errorf("unknown Recording field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *RecordingMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.camera != nil {
		edges = append(edges, recording.EdgeCamera)
	}
	if m.tenant != nil {
		edges = append(edges, recording.EdgeTenant)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *RecordingMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case recording.EdgeCamera:
		if id := m.camera; id != nil {
			return []ent.Value{*id}
		}
	case recording.EdgeTenant:
		if id := m.tenant; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *RecordingMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *RecordingMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *RecordingMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedcamera {
		edges = append(edges, recording.EdgeCamera)
	}
	if m.clearedtenant {
		edges = append(edges, recording.EdgeTenant)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *RecordingMutation) EdgeCleared(name string) bool {
	switch name {
	case recording.EdgeCamera:
		return m.clearedcamera
	case recording.EdgeTenant:
		return m.clearedtenant
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *RecordingMutation) ClearEdge(name string) error {
	switch name {
	case recording.EdgeCamera:
		m.ClearCamera()
		return nil
	case recording.EdgeTenant:
		m.ClearTenant()
		return nil
	}
	return fmt.Errorf("unknown Recording unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *RecordingMutation) ResetEdge(name string) error {
	switch name {
	case recording.EdgeCamera:
		m.ResetCamera()
		return nil
	case recording.EdgeTenant:
		m.ResetTenant()
		return nil
	}
	return fmt.Errorf("unknown Recording edge %s", name)
}

// RecurringInvoiceMutation represents an operation that mutates the RecurringInvoice nodes in the graph.
type RecurringInvoiceMutation struct {
	config
	op             Op
	typ            string
	id             *int
	description    *string
	amount         *decimal.Decimal
	currency       *string
	frequency      *string
	next_run_date  *time.Time
	last_run_date  *time.Time
	is_active      *bool
	created_at     *time.Time
	clearedFields  map[string]struct{}
	tenant         *int
	clearedtenant  bool
	account        *int
	clearedaccount bool
	done           bool
	oldValue       func(context.Context) (*RecurringInvoice, error)
	predicates     []predicate.RecurringInvoice
}

var _ ent.Mutation = (*RecurringInvoiceMutation)(nil)

// recurringinvoiceOption allows management of the mutation configuration using functional options.
type recurringinvoiceOption func(*RecurringInvoiceMutation)

// newRecurringInvoiceMutation creates new mutation for the RecurringInvoice entity.
func newRecurringInvoiceMutation(c config, op Op, opts ...recurringinvoiceOption) *RecurringInvoiceMutation {
	m := &RecurringInvoiceMutation{
		config:        c,
		op:            op,
		typ:           TypeRecurringInvoice,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRecurringInvoiceID sets the ID field of the mutation.
func withRecurringInvoiceID(id int) recurringinvoiceOption {
	return func(m *RecurringInvoiceMutation) {
		var (
			err   error
			once  sync.Once
			value *RecurringInvoice
		)
		m.oldValue = func(ctx context.Context) (*RecurringInvoice, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().RecurringInvoice.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRecurringInvoice sets the old RecurringInvoice of the mutation.
func withRecurringInvoice(node *RecurringInvoice) recurringinvoiceOption {
	return func(m *RecurringInvoiceMutation) {
		m.oldValue = func(context.Context) (*RecurringInvoice, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RecurringInvoiceMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RecurringInvoiceMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *RecurringInvoiceMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *RecurringInvoiceMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().RecurringInvoice.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetDescription sets the "description" field.
func (m *RecurringInvoiceMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *RecurringInvoiceMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the RecurringInvoice entity.
// If the RecurringInvoice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RecurringInvoiceMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *RecurringInvoiceMutation) ResetDescription() {
	m.description = nil
}

// SetAmount sets the "amount" field.
func (m *RecurringInvoiceMutation) SetAmount(d decimal.Decimal) {
	m.amount = &d
}

// Amount returns the value of the "amount" field in the mutation.
func (m *RecurringInvoiceMutation) Amount() (r decimal.Decimal, exists bool) {
	v := m.amount
	if v == nil {
		return
	}
	return *v, true
}

// OldAmount returns the old "amount" field's value of the RecurringInvoice entity.
// If the RecurringInvoice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RecurringInvoiceMutation) OldAmount(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAmount: %w", err)
	}
	return oldValue.Amount, nil
}

// ResetAmount resets all changes to the "amount" field.
func (m *RecurringInvoiceMutation) ResetAmount() {
	m.amount = nil
}

// SetCurrency sets the "currency" field.
func (m *RecurringInvoiceMutation) SetCurrency(s string) {
	m.currency = &s
}

// Currency returns the value of the "currency" field in the mutation.
func (m *RecurringInvoiceMutation) Currency() (r string, exists bool) {
	v := m.currency
	if v == nil {
		return
	}
	return *v, true
}

// OldCurrency returns the old "currency" field's value of the RecurringInvoice entity.
// If the RecurringInvoice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RecurringInvoiceMutation) OldCurrency(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCurrency is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCurrency requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCurrency: %w", err)
	}
	return oldValue.Currency, nil
}

// ResetCurrency resets all changes to the "currency" field.
func (m *RecurringInvoiceMutation) ResetCurrency() {
	m.currency = nil
}

// SetFrequency sets the "frequency" field.
func (m *RecurringInvoiceMutation) SetFrequency(s string) {
	m.frequency = &s
}

// Frequency returns the value of the "frequency" field in the mutation.
func (m *RecurringInvoiceMutation) Frequency() (r string, exists bool) {
	v := m.frequency
	if v == nil {
		return
	}
	return *v, true
}

// OldFrequency returns the old "frequency" field's value of the RecurringInvoice entity.
// If the RecurringInvoice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RecurringInvoiceMutation) OldFrequency(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFrequency is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFrequency requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFrequency: %w", err)
	}
	return oldValue.Frequency, nil
}

// ResetFrequency resets all changes to the "frequency" field.
func (m *RecurringInvoiceMutation) ResetFrequency() {
	m.frequency = nil
}

// SetNextRunDate sets the "next_run_date" field.
func (m *RecurringInvoiceMutation) SetNextRunDate(t time.Time) {
	m.next_run_date = &t
}

// NextRunDate returns the value of the "next_run_date" field in the mutation.
func (m *RecurringInvoiceMutation) NextRunDate() (r time.Time, exists bool) {
	v := m.next_run_date
	if v == nil {
		return
	}
	return *v, true
}

// OldNextRunDate returns the old "next_run_date" field's value of the RecurringInvoice entity.
// If the RecurringInvoice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RecurringInvoiceMutation) OldNextRunDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNextRunDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNextRunDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNextRunDate: %w", err)
	}
	return oldValue.NextRunDate, nil
}

// ResetNextRunDate resets all changes to the "next_run_date" field.
func (m *RecurringInvoiceMutation) ResetNextRunDate() {
	m.next_run_date = nil
}

// SetLastRunDate sets the "last_run_date" field.
func (m *RecurringInvoiceMutation) SetLastRunDate(t time.Time) {
	m.last_run_date = &t
}

// LastRunDate returns the value of the "last_run_date" field in the mutation.
func (m *RecurringInvoiceMutation) LastRunDate() (r time.Time, exists bool) {
	v := m.last_run_date
	if v == nil {
		return
	}
	return *v, true
}

// OldLastRunDate returns the old "last_run_date" field's value of the RecurringInvoice entity.
// If the RecurringInvoice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RecurringInvoiceMutation) OldLastRunDate(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastRunDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastRunDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastRunDate: %w", err)
	}
	return oldValue.LastRunDate, nil
}

// ClearLastRunDate clears the value of the "last_run_date" field.
func (m *RecurringInvoiceMutation) ClearLastRunDate() {
	m.last_run_date = nil
	m.clearedFields[recurringinvoice.FieldLastRunDate] = struct{}{}
}

// LastRunDateCleared returns if the "last_run_date" field was cleared in this mutation.
func (m *RecurringInvoiceMutation) LastRunDateCleared() bool {
	_, ok := m.clearedFields[recurringinvoice.FieldLastRunDate]
	return ok
}

// ResetLastRunDate resets all changes to the "last_run_date" field.
func (m *RecurringInvoiceMutation) ResetLastRunDate() {
	m.last_run_date = nil
	delete(m.clearedFields, recurringinvoice.FieldLastRunDate)
}

// SetIsActive sets the "is_active" field.
func (m *RecurringInvoiceMutation) SetIsActive(b bool) {
	m.is_active = &b
}

// IsActive returns the value of the "is_active" field in the mutation.
func (m *RecurringInvoiceMutation) IsActive() (r bool, exists bool) {
	v := m.is_active
	if v == nil {
		return
	}
	return *v, true
}

// OldIsActive returns the old "is_active" field's value of the RecurringInvoice entity.
// If the RecurringInvoice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RecurringInvoiceMutation) OldIsActive(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsActive is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsActive requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsActive: %w", err)
	}
	return oldValue.IsActive, nil
}

// ResetIsActive resets all changes to the "is_active" field.
func (m *RecurringInvoiceMutation) ResetIsActive() {
	m.is_active = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *RecurringInvoiceMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *RecurringInvoiceMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the RecurringInvoice entity.
// If the RecurringInvoice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RecurringInvoiceMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *RecurringInvoiceMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetTenantID sets the "tenant" edge to the Tenant entity by id.
func (m *RecurringInvoiceMutation) SetTenantID(id int) {
	m.tenant = &id
}

// ClearTenant clears the "tenant" edge to the Tenant entity.
func (m *RecurringInvoiceMutation) ClearTenant() {
	m.clearedtenant = true
}

// TenantCleared reports if the "tenant" edge to the Tenant entity was cleared.
func (m *RecurringInvoiceMutation) TenantCleared() bool {
	return m.clearedtenant
}

// TenantID returns the "tenant" edge ID in the mutation.
func (m *RecurringInvoiceMutation) TenantID() (id int, exists bool) {
	if m.tenant != nil {
		return *m.tenant, true
	}
	return
}

// TenantIDs returns the "tenant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TenantID instead. It exists only for internal usage by the builders.
func (m *RecurringInvoiceMutation) TenantIDs() (ids []int) {
	if id := m.tenant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTenant resets all changes to the "tenant" edge.
func (m *RecurringInvoiceMutation) ResetTenant() {
	m.tenant = nil
	m.clearedtenant = false
}

// SetAccountID sets the "account" edge to the Account entity by id.
func (m *RecurringInvoiceMutation) SetAccountID(id int) {
	m.account = &id
}

// ClearAccount clears the "account" edge to the Account entity.
func (m *RecurringInvoiceMutation) ClearAccount() {
	m.clearedaccount = true
}

// AccountCleared reports if the "account" edge to the Account entity was cleared.
func (m *RecurringInvoiceMutation) AccountCleared() bool {
	return m.clearedaccount
}

// AccountID returns the "account" edge ID in the mutation.
func (m *RecurringInvoiceMutation) AccountID() (id int, exists bool) {
	if m.account != nil {
		return *m.account, true
	}
	return
}

// AccountIDs returns the "account" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AccountID instead. It exists only for internal usage by the builders.
func (m *RecurringInvoiceMutation) AccountIDs() (ids []int) {
	if id := m.account; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAccount resets all changes to the "account" edge.
func (m *RecurringInvoiceMutation) ResetAccount() {
	m.account = nil
	m.clearedaccount = false
}

// Where appends a list predicates to the RecurringInvoiceMutation builder.
func (m *RecurringInvoiceMutation) Where(ps ...predicate.RecurringInvoice) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the RecurringInvoiceMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *RecurringInvoiceMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.RecurringInvoice, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *RecurringInvoiceMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *RecurringInvoiceMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (RecurringInvoice).
func (m *RecurringInvoiceMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *RecurringInvoiceMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.description != nil {
		fields = append(fields, recurringinvoice.FieldDescription)
	}
	if m.amount != nil {
		fields = append(fields, recurringinvoice.FieldAmount)
	}
	if m.currency != nil {
		fields = append(fields, recurringinvoice.FieldCurrency)
	}
	if m.frequency != nil {
		fields = append(fields, recurringinvoice.FieldFrequency)
	}
	if m.next_run_date != nil {
		fields = append(fields, recurringinvoice.FieldNextRunDate)
	}
	if m.last_run_date != nil {
		fields = append(fields, recurringinvoice.FieldLastRunDate)
	}
	if m.is_active != nil {
		fields = append(fields, recurringinvoice.FieldIsActive)
	}
	if m.created_at != nil {
		fields = append(fields, recurringinvoice.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *RecurringInvoiceMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case recurringinvoice.FieldDescription:
		return m.Description()
	case recurringinvoice.FieldAmount:
		return m.Amount()
	case recurringinvoice.FieldCurrency:
		return m.Currency()
	case recurringinvoice.FieldFrequency:
		return m.Frequency()
	case recurringinvoice.FieldNextRunDate:
		return m.NextRunDate()
	case recurringinvoice.FieldLastRunDate:
		return m.LastRunDate()
	case recurringinvoice.FieldIsActive:
		return m.IsActive()
	case recurringinvoice.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *RecurringInvoiceMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case recurringinvoice.FieldDescription:
		return m.OldDescription(ctx)
	case recurringinvoice.FieldAmount:
		return m.OldAmount(ctx)
	case recurringinvoice.FieldCurrency:
		return m.OldCurrency(ctx)
	case recurringinvoice.FieldFrequency:
		return m.OldFrequency(ctx)
	case recurringinvoice.FieldNextRunDate:
		return m.OldNextRunDate(ctx)
	case recurringinvoice.FieldLastRunDate:
		return m.OldLastRunDate(ctx)
	case recurringinvoice.FieldIsActive:
		return m.OldIsActive(ctx)
	case recurringinvoice.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown RecurringInvoice field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RecurringInvoiceMutation) SetField(name string, value ent.Value) error {
	switch name {
	case recurringinvoice.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case recurringinvoice.FieldAmount:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAmount(v)
		return nil
	case recurringinvoice.FieldCurrency:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCurrency(v)
		return nil
	case recurringinvoice.FieldFrequency:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFrequency(v)
		return nil
	case recurringinvoice.FieldNextRunDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNextRunDate(v)
		return nil
	case recurringinvoice.FieldLastRunDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastRunDate(v)
		return nil
	case recurringinvoice.FieldIsActive:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsActive(v)
		return nil
	case recurringinvoice.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown RecurringInvoice field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *RecurringInvoiceMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *RecurringInvoiceMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RecurringInvoiceMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown RecurringInvoice numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *RecurringInvoiceMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(recurringinvoice.FieldLastRunDate) {
		fields = append(fields, recurringinvoice.FieldLastRunDate)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *RecurringInvoiceMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *RecurringInvoiceMutation) ClearField(name string) error {
	switch name {
	case recurringinvoice.FieldLastRunDate:
		m.ClearLastRunDate()
		return nil
	}
	return fmt.Errorf("unknown RecurringInvoice nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *RecurringInvoiceMutation) ResetField(name string) error {
	switch name {
	case recurringinvoice.FieldDescription:
		m.ResetDescription()
		return nil
	case recurringinvoice.FieldAmount:
		m.ResetAmount()
		return nil
	case recurringinvoice.FieldCurrency:
		m.ResetCurrency()
		return nil
	case recurringinvoice.FieldFrequency:
		m.ResetFrequency()
		return nil
	case recurringinvoice.FieldNextRunDate:
		m.ResetNextRunDate()
		return nil
	case recurringinvoice.FieldLastRunDate:
		m.ResetLastRunDate()
		return nil
	case recurringinvoice.FieldIsActive:
		m.ResetIsActive()
		return nil
	case recurringinvoice.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown RecurringInvoice field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *RecurringInvoiceMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.tenant != nil {
		edges = append(edges, recurringinvoice.EdgeTenant)
	}
	if m.account != nil {
		edges = append(edges, recurringinvoice.EdgeAccount)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *RecurringInvoiceMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case recurringinvoice.EdgeTenant:
		if id := m.tenant; id != nil {
			return []ent.Value{*id}
		}
	case recurringinvoice.EdgeAccount:
		if id := m.account; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *RecurringInvoiceMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *RecurringInvoiceMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *RecurringInvoiceMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedtenant {
		edges = append(edges, recurringinvoice.EdgeTenant)
	}
	if m.clearedaccount {
		edges = append(edges, recurringinvoice.EdgeAccount)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *RecurringInvoiceMutation) EdgeCleared(name string) bool {
	switch name {
	case recurringinvoice.EdgeTenant:
		return m.clearedtenant
	case recurringinvoice.EdgeAccount:
		return m.clearedaccount
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *RecurringInvoiceMutation) ClearEdge(name string) error {
	switch name {
	case recurringinvoice.EdgeTenant:
		m.ClearTenant()
		return nil
	case recurringinvoice.EdgeAccount:
		m.ClearAccount()
		return nil
	}
	return fmt.Errorf("unknown RecurringInvoice unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *RecurringInvoiceMutation) ResetEdge(name string) error {
	switch name {
	case recurringinvoice.EdgeTenant:
		m.ResetTenant()
		return nil
	case recurringinvoice.EdgeAccount:
		m.ResetAccount()
		return nil
	}
	return fmt.Errorf("unknown RecurringInvoice edge %s", name)
}

// RemediationStepMutation represents an operation that mutates the RemediationStep nodes in the graph.
type RemediationStepMutation struct {
	config
	op                Op
	typ               string
	id                *int
	action_name       *string
	sequence          *int
	addsequence       *int
	status            *remediationstep.Status
	output            *string
	execution_context *map[string]interface{}
	source_id         *string
	source_app        *string
	clearedFields     map[string]struct{}
	ticket            *int
	clearedticket     bool
	done              bool
	oldValue          func(context.Context) (*RemediationStep, error)
	predicates        []predicate.RemediationStep
}

var _ ent.Mutation = (*RemediationStepMutation)(nil)

// remediationstepOption allows management of the mutation configuration using functional options.
type remediationstepOption func(*RemediationStepMutation)

// newRemediationStepMutation creates new mutation for the RemediationStep entity.
func newRemediationStepMutation(c config, op Op, opts ...remediationstepOption) *RemediationStepMutation {
	m := &RemediationStepMutation{
		config:        c,
		op:            op,
		typ:           TypeRemediationStep,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRemediationStepID sets the ID field of the mutation.
func withRemediationStepID(id int) remediationstepOption {
	return func(m *RemediationStepMutation) {
		var (
			err   error
			once  sync.Once
			value *RemediationStep
		)
		m.oldValue = func(ctx context.Context) (*RemediationStep, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().RemediationStep.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRemediationStep sets the old RemediationStep of the mutation.
func withRemediationStep(node *RemediationStep) remediationstepOption {
	return func(m *RemediationStepMutation) {
		m.oldValue = func(context.Context) (*RemediationStep, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RemediationStepMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RemediationStepMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *RemediationStepMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *RemediationStepMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().RemediationStep.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetActionName sets the "action_name" field.
func (m *RemediationStepMutation) SetActionName(s string) {
	m.action_name = &s
}

// ActionName returns the value of the "action_name" field in the mutation.
func (m *RemediationStepMutation) ActionName() (r string, exists bool) {
	v := m.action_name
	if v == nil {
		return
	}
	return *v, true
}

// OldActionName returns the old "action_name" field's value of the RemediationStep entity.
// If the RemediationStep object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RemediationStepMutation) OldActionName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldActionName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldActionName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldActionName: %w", err)
	}
	return oldValue.ActionName, nil
}

// ResetActionName resets all changes to the "action_name" field.
func (m *RemediationStepMutation) ResetActionName() {
	m.action_name = nil
}

// SetSequence sets the "sequence" field.
func (m *RemediationStepMutation) SetSequence(i int) {
	m.sequence = &i
	m.addsequence = nil
}

// Sequence returns the value of the "sequence" field in the mutation.
func (m *RemediationStepMutation) Sequence() (r int, exists bool) {
	v := m.sequence
	if v == nil {
		return
	}
	return *v, true
}

// OldSequence returns the old "sequence" field's value of the RemediationStep entity.
// If the RemediationStep object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RemediationStepMutation) OldSequence(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSequence is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSequence requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSequence: %w", err)
	}
	return oldValue.Sequence, nil
}

// AddSequence adds i to the "sequence" field.
func (m *RemediationStepMutation) AddSequence(i int) {
	if m.addsequence != nil {
		*m.addsequence += i
	} else {
		m.addsequence = &i
	}
}

// AddedSequence returns the value that was added to the "sequence" field in this mutation.
func (m *RemediationStepMutation) AddedSequence() (r int, exists bool) {
	v := m.addsequence
	if v == nil {
		return
	}
	return *v, true
}

// ResetSequence resets all changes to the "sequence" field.
func (m *RemediationStepMutation) ResetSequence() {
	m.sequence = nil
	m.addsequence = nil
}

// SetStatus sets the "status" field.
func (m *RemediationStepMutation) SetStatus(r remediationstep.Status) {
	m.status = &r
}

// Status returns the value of the "status" field in the mutation.
func (m *RemediationStepMutation) Status() (r remediationstep.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the RemediationStep entity.
// If the RemediationStep object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RemediationStepMutation) OldStatus(ctx context.Context) (v remediationstep.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *RemediationStepMutation) ResetStatus() {
	m.status = nil
}

// SetOutput sets the "output" field.
func (m *RemediationStepMutation) SetOutput(s string) {
	m.output = &s
}

// Output returns the value of the "output" field in the mutation.
func (m *RemediationStepMutation) Output() (r string, exists bool) {
	v := m.output
	if v == nil {
		return
	}
	return *v, true
}

// OldOutput returns the old "output" field's value of the RemediationStep entity.
// If the RemediationStep object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RemediationStepMutation) OldOutput(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOutput is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOutput requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOutput: %w", err)
	}
	return oldValue.Output, nil
}

// ClearOutput clears the value of the "output" field.
func (m *RemediationStepMutation) ClearOutput() {
	m.output = nil
	m.clearedFields[remediationstep.FieldOutput] = struct{}{}
}

// OutputCleared returns if the "output" field was cleared in this mutation.
func (m *RemediationStepMutation) OutputCleared() bool {
	_, ok := m.clearedFields[remediationstep.FieldOutput]
	return ok
}

// ResetOutput resets all changes to the "output" field.
func (m *RemediationStepMutation) ResetOutput() {
	m.output = nil
	delete(m.clearedFields, remediationstep.FieldOutput)
}

// SetExecutionContext sets the "execution_context" field.
func (m *RemediationStepMutation) SetExecutionContext(value map[string]interface{}) {
	m.execution_context = &value
}

// ExecutionContext returns the value of the "execution_context" field in the mutation.
func (m *RemediationStepMutation) ExecutionContext() (r map[string]interface{}, exists bool) {
	v := m.execution_context
	if v == nil {
		return
	}
	return *v, true
}

// OldExecutionContext returns the old "execution_context" field's value of the RemediationStep entity.
// If the RemediationStep object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RemediationStepMutation) OldExecutionContext(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExecutionContext is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExecutionContext requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExecutionContext: %w", err)
	}
	return oldValue.ExecutionContext, nil
}

// ClearExecutionContext clears the value of the "execution_context" field.
func (m *RemediationStepMutation) ClearExecutionContext() {
	m.execution_context = nil
	m.clearedFields[remediationstep.FieldExecutionContext] = struct{}{}
}

// ExecutionContextCleared returns if the "execution_context" field was cleared in this mutation.
func (m *RemediationStepMutation) ExecutionContextCleared() bool {
	_, ok := m.clearedFields[remediationstep.FieldExecutionContext]
	return ok
}

// ResetExecutionContext resets all changes to the "execution_context" field.
func (m *RemediationStepMutation) ResetExecutionContext() {
	m.execution_context = nil
	delete(m.clearedFields, remediationstep.FieldExecutionContext)
}

// SetSourceID sets the "source_id" field.
func (m *RemediationStepMutation) SetSourceID(s string) {
	m.source_id = &s
}

// SourceID returns the value of the "source_id" field in the mutation.
func (m *RemediationStepMutation) SourceID() (r string, exists bool) {
	v := m.source_id
	if v == nil {
		return
	}
	return *v, true
}

// OldSourceID returns the old "source_id" field's value of the RemediationStep entity.
// If the RemediationStep object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RemediationStepMutation) OldSourceID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSourceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSourceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSourceID: %w", err)
	}
	return oldValue.SourceID, nil
}

// ClearSourceID clears the value of the "source_id" field.
func (m *RemediationStepMutation) ClearSourceID() {
	m.source_id = nil
	m.clearedFields[remediationstep.FieldSourceID] = struct{}{}
}

// SourceIDCleared returns if the "source_id" field was cleared in this mutation.
func (m *RemediationStepMutation) SourceIDCleared() bool {
	_, ok := m.clearedFields[remediationstep.FieldSourceID]
	return ok
}

// ResetSourceID resets all changes to the "source_id" field.
func (m *RemediationStepMutation) ResetSourceID() {
	m.source_id = nil
	delete(m.clearedFields, remediationstep.FieldSourceID)
}

// SetSourceApp sets the "source_app" field.
func (m *RemediationStepMutation) SetSourceApp(s string) {
	m.source_app = &s
}

// SourceApp returns the value of the "source_app" field in the mutation.
func (m *RemediationStepMutation) SourceApp() (r string, exists bool) {
	v := m.source_app
	if v == nil {
		return
	}
	return *v, true
}

// OldSourceApp returns the old "source_app" field's value of the RemediationStep entity.
// If the RemediationStep object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RemediationStepMutation) OldSourceApp(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSourceApp is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSourceApp requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSourceApp: %w", err)
	}
	return oldValue.SourceApp, nil
}

// ClearSourceApp clears the value of the "source_app" field.
func (m *RemediationStepMutation) ClearSourceApp() {
	m.source_app = nil
	m.clearedFields[remediationstep.FieldSourceApp] = struct{}{}
}

// SourceAppCleared returns if the "source_app" field was cleared in this mutation.
func (m *RemediationStepMutation) SourceAppCleared() bool {
	_, ok := m.clearedFields[remediationstep.FieldSourceApp]
	return ok
}

// ResetSourceApp resets all changes to the "source_app" field.
func (m *RemediationStepMutation) ResetSourceApp() {
	m.source_app = nil
	delete(m.clearedFields, remediationstep.FieldSourceApp)
}

// SetTicketID sets the "ticket" edge to the Ticket entity by id.
func (m *RemediationStepMutation) SetTicketID(id int) {
	m.ticket = &id
}

// ClearTicket clears the "ticket" edge to the Ticket entity.
func (m *RemediationStepMutation) ClearTicket() {
	m.clearedticket = true
}

// TicketCleared reports if the "ticket" edge to the Ticket entity was cleared.
func (m *RemediationStepMutation) TicketCleared() bool {
	return m.clearedticket
}

// TicketID returns the "ticket" edge ID in the mutation.
func (m *RemediationStepMutation) TicketID() (id int, exists bool) {
	if m.ticket != nil {
		return *m.ticket, true
	}
	return
}

// TicketIDs returns the "ticket" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TicketID instead. It exists only for internal usage by the builders.
func (m *RemediationStepMutation) TicketIDs() (ids []int) {
	if id := m.ticket; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTicket resets all changes to the "ticket" edge.
func (m *RemediationStepMutation) ResetTicket() {
	m.ticket = nil
	m.clearedticket = false
}

// Where appends a list predicates to the RemediationStepMutation builder.
func (m *RemediationStepMutation) Where(ps ...predicate.RemediationStep) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the RemediationStepMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *RemediationStepMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.RemediationStep, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *RemediationStepMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *RemediationStepMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (RemediationStep).
func (m *RemediationStepMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *RemediationStepMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.action_name != nil {
		fields = append(fields, remediationstep.FieldActionName)
	}
	if m.sequence != nil {
		fields = append(fields, remediationstep.FieldSequence)
	}
	if m.status != nil {
		fields = append(fields, remediationstep.FieldStatus)
	}
	if m.output != nil {
		fields = append(fields, remediationstep.FieldOutput)
	}
	if m.execution_context != nil {
		fields = append(fields, remediationstep.FieldExecutionContext)
	}
	if m.source_id != nil {
		fields = append(fields, remediationstep.FieldSourceID)
	}
	if m.source_app != nil {
		fields = append(fields, remediationstep.FieldSourceApp)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *RemediationStepMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case remediationstep.FieldActionName:
		return m.ActionName()
	case remediationstep.FieldSequence:
		return m.Sequence()
	case remediationstep.FieldStatus:
		return m.Status()
	case remediationstep.FieldOutput:
		return m.Output()
	case remediationstep.FieldExecutionContext:
		return m.ExecutionContext()
	case remediationstep.FieldSourceID:
		return m.SourceID()
	case remediationstep.FieldSourceApp:
		return m.SourceApp()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *RemediationStepMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case remediationstep.FieldActionName:
		return m.OldActionName(ctx)
	case remediationstep.FieldSequence:
		return m.OldSequence(ctx)
	case remediationstep.FieldStatus:
		return m.OldStatus(ctx)
	case remediationstep.FieldOutput:
		return m.OldOutput(ctx)
	case remediationstep.FieldExecutionContext:
		return m.OldExecutionContext(ctx)
	case remediationstep.FieldSourceID:
		return m.OldSourceID(ctx)
	case remediationstep.FieldSourceApp:
		return m.OldSourceApp(ctx)
	}
	return nil, fmt.Errorf("unknown RemediationStep field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RemediationStepMutation) SetField(name string, value ent.Value) error {
	switch name {
	case remediationstep.FieldActionName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetActionName(v)
		return nil
	case remediationstep.FieldSequence:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSequence(v)
		return nil
	case remediationstep.FieldStatus:
		v, ok := value.(remediationstep.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case remediationstep.FieldOutput:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOutput(v)
		return nil
	case remediationstep.FieldExecutionContext:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExecutionContext(v)
		return nil
	case remediationstep.FieldSourceID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSourceID(v)
		return nil
	case remediationstep.FieldSourceApp:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSourceApp(v)
		return nil
	}
	return fmt.Errorf("unknown RemediationStep field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *RemediationStepMutation) AddedFields() []string {
	var fields []string
	if m.addsequence != nil {
		fields = append(fields, remediationstep.FieldSequence)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *RemediationStepMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case remediationstep.FieldSequence:
		return m.AddedSequence()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RemediationStepMutation) AddField(name string, value ent.Value) error {
	switch name {
	case remediationstep.FieldSequence:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSequence(v)
		return nil
	}
	return fmt.Errorf("unknown RemediationStep numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *RemediationStepMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(remediationstep.FieldOutput) {
		fields = append(fields, remediationstep.FieldOutput)
	}
	if m.FieldCleared(remediationstep.FieldExecutionContext) {
		fields = append(fields, remediationstep.FieldExecutionContext)
	}
	if m.FieldCleared(remediationstep.FieldSourceID) {
		fields = append(fields, remediationstep.FieldSourceID)
	}
	if m.FieldCleared(remediationstep.FieldSourceApp) {
		fields = append(fields, remediationstep.FieldSourceApp)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *RemediationStepMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *RemediationStepMutation) ClearField(name string) error {
	switch name {
	case remediationstep.FieldOutput:
		m.ClearOutput()
		return nil
	case remediationstep.FieldExecutionContext:
		m.ClearExecutionContext()
		return nil
	case remediationstep.FieldSourceID:
		m.ClearSourceID()
		return nil
	case remediationstep.FieldSourceApp:
		m.ClearSourceApp()
		return nil
	}
	return fmt.Errorf("unknown RemediationStep nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *RemediationStepMutation) ResetField(name string) error {
	switch name {
	case remediationstep.FieldActionName:
		m.ResetActionName()
		return nil
	case remediationstep.FieldSequence:
		m.ResetSequence()
		return nil
	case remediationstep.FieldStatus:
		m.ResetStatus()
		return nil
	case remediationstep.FieldOutput:
		m.ResetOutput()
		return nil
	case remediationstep.FieldExecutionContext:
		m.ResetExecutionContext()
		return nil
	case remediationstep.FieldSourceID:
		m.ResetSourceID()
		return nil
	case remediationstep.FieldSourceApp:
		m.ResetSourceApp()
		return nil
	}
	return fmt.Errorf("unknown RemediationStep field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *RemediationStepMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.ticket != nil {
		edges = append(edges, remediationstep.EdgeTicket)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *RemediationStepMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case remediationstep.EdgeTicket:
		if id := m.ticket; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *RemediationStepMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *RemediationStepMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *RemediationStepMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedticket {
		edges = append(edges, remediationstep.EdgeTicket)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *RemediationStepMutation) EdgeCleared(name string) bool {
	switch name {
	case remediationstep.EdgeTicket:
		return m.clearedticket
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *RemediationStepMutation) ClearEdge(name string) error {
	switch name {
	case remediationstep.EdgeTicket:
		m.ClearTicket()
		return nil
	}
	return fmt.Errorf("unknown RemediationStep unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *RemediationStepMutation) ResetEdge(name string) error {
	switch name {
	case remediationstep.EdgeTicket:
		m.ResetTicket()
		return nil
	}
	return fmt.Errorf("unknown RemediationStep edge %s", name)
}

// RetentionPolicyMutation represents an operation that mutates the RetentionPolicy nodes in the graph.
type RetentionPolicyMutation struct {
	config
	op                Op
	typ               string
	id                *int
	name              *string
	description       *string
	retention_days    *int
	addretention_days *int
	action            *retentionpolicy.Action
	file_type_filter  *string
	active            *bool
	created_at        *time.Time
	clearedFields     map[string]struct{}
	tenant            *int
	clearedtenant     bool
	done              bool
	oldValue          func(context.Context) (*RetentionPolicy, error)
	predicates        []predicate.RetentionPolicy
}

var _ ent.Mutation = (*RetentionPolicyMutation)(nil)

// retentionpolicyOption allows management of the mutation configuration using functional options.
type retentionpolicyOption func(*RetentionPolicyMutation)

// newRetentionPolicyMutation creates new mutation for the RetentionPolicy entity.
func newRetentionPolicyMutation(c config, op Op, opts ...retentionpolicyOption) *RetentionPolicyMutation {
	m := &RetentionPolicyMutation{
		config:        c,
		op:            op,
		typ:           TypeRetentionPolicy,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRetentionPolicyID sets the ID field of the mutation.
func withRetentionPolicyID(id int) retentionpolicyOption {
	return func(m *RetentionPolicyMutation) {
		var (
			err   error
			once  sync.Once
			value *RetentionPolicy
		)
		m.oldValue = func(ctx context.Context) (*RetentionPolicy, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().RetentionPolicy.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRetentionPolicy sets the old RetentionPolicy of the mutation.
func withRetentionPolicy(node *RetentionPolicy) retentionpolicyOption {
	return func(m *RetentionPolicyMutation) {
		m.oldValue = func(context.Context) (*RetentionPolicy, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RetentionPolicyMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RetentionPolicyMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *RetentionPolicyMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *RetentionPolicyMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().RetentionPolicy.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *RetentionPolicyMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *RetentionPolicyMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the RetentionPolicy entity.
// If the RetentionPolicy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RetentionPolicyMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *RetentionPolicyMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *RetentionPolicyMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *RetentionPolicyMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the RetentionPolicy entity.
// If the RetentionPolicy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RetentionPolicyMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *RetentionPolicyMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[retentionpolicy.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *RetentionPolicyMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[retentionpolicy.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *RetentionPolicyMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, retentionpolicy.FieldDescription)
}

// SetRetentionDays sets the "retention_days" field.
func (m *RetentionPolicyMutation) SetRetentionDays(i int) {
	m.retention_days = &i
	m.addretention_days = nil
}

// RetentionDays returns the value of the "retention_days" field in the mutation.
func (m *RetentionPolicyMutation) RetentionDays() (r int, exists bool) {
	v := m.retention_days
	if v == nil {
		return
	}
	return *v, true
}

// OldRetentionDays returns the old "retention_days" field's value of the RetentionPolicy entity.
// If the RetentionPolicy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RetentionPolicyMutation) OldRetentionDays(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRetentionDays is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRetentionDays requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRetentionDays: %w", err)
	}
	return oldValue.RetentionDays, nil
}

// AddRetentionDays adds i to the "retention_days" field.
func (m *RetentionPolicyMutation) AddRetentionDays(i int) {
	if m.addretention_days != nil {
		*m.addretention_days += i
	} else {
		m.addretention_days = &i
	}
}

// AddedRetentionDays returns the value that was added to the "retention_days" field in this mutation.
func (m *RetentionPolicyMutation) AddedRetentionDays() (r int, exists bool) {
	v := m.addretention_days
	if v == nil {
		return
	}
	return *v, true
}

// ResetRetentionDays resets all changes to the "retention_days" field.
func (m *RetentionPolicyMutation) ResetRetentionDays() {
	m.retention_days = nil
	m.addretention_days = nil
}

// SetAction sets the "action" field.
func (m *RetentionPolicyMutation) SetAction(r retentionpolicy.Action) {
	m.action = &r
}

// Action returns the value of the "action" field in the mutation.
func (m *RetentionPolicyMutation) Action() (r retentionpolicy.Action, exists bool) {
	v := m.action
	if v == nil {
		return
	}
	return *v, true
}

// OldAction returns the old "action" field's value of the RetentionPolicy entity.
// If the RetentionPolicy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RetentionPolicyMutation) OldAction(ctx context.Context) (v retentionpolicy.Action, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAction is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAction requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAction: %w", err)
	}
	return oldValue.Action, nil
}

// ResetAction resets all changes to the "action" field.
func (m *RetentionPolicyMutation) ResetAction() {
	m.action = nil
}

// SetFileTypeFilter sets the "file_type_filter" field.
func (m *RetentionPolicyMutation) SetFileTypeFilter(s string) {
	m.file_type_filter = &s
}

// FileTypeFilter returns the value of the "file_type_filter" field in the mutation.
func (m *RetentionPolicyMutation) FileTypeFilter() (r string, exists bool) {
	v := m.file_type_filter
	if v == nil {
		return
	}
	return *v, true
}

// OldFileTypeFilter returns the old "file_type_filter" field's value of the RetentionPolicy entity.
// If the RetentionPolicy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RetentionPolicyMutation) OldFileTypeFilter(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFileTypeFilter is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFileTypeFilter requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFileTypeFilter: %w", err)
	}
	return oldValue.FileTypeFilter, nil
}

// ClearFileTypeFilter clears the value of the "file_type_filter" field.
func (m *RetentionPolicyMutation) ClearFileTypeFilter() {
	m.file_type_filter = nil
	m.clearedFields[retentionpolicy.FieldFileTypeFilter] = struct{}{}
}

// FileTypeFilterCleared returns if the "file_type_filter" field was cleared in this mutation.
func (m *RetentionPolicyMutation) FileTypeFilterCleared() bool {
	_, ok := m.clearedFields[retentionpolicy.FieldFileTypeFilter]
	return ok
}

// ResetFileTypeFilter resets all changes to the "file_type_filter" field.
func (m *RetentionPolicyMutation) ResetFileTypeFilter() {
	m.file_type_filter = nil
	delete(m.clearedFields, retentionpolicy.FieldFileTypeFilter)
}

// SetActive sets the "active" field.
func (m *RetentionPolicyMutation) SetActive(b bool) {
	m.active = &b
}

// Active returns the value of the "active" field in the mutation.
func (m *RetentionPolicyMutation) Active() (r bool, exists bool) {
	v := m.active
	if v == nil {
		return
	}
	return *v, true
}

// OldActive returns the old "active" field's value of the RetentionPolicy entity.
// If the RetentionPolicy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RetentionPolicyMutation) OldActive(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldActive is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldActive requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldActive: %w", err)
	}
	return oldValue.Active, nil
}

// ResetActive resets all changes to the "active" field.
func (m *RetentionPolicyMutation) ResetActive() {
	m.active = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *RetentionPolicyMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *RetentionPolicyMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the RetentionPolicy entity.
// If the RetentionPolicy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RetentionPolicyMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *RetentionPolicyMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetTenantID sets the "tenant" edge to the Tenant entity by id.
func (m *RetentionPolicyMutation) SetTenantID(id int) {
	m.tenant = &id
}

// ClearTenant clears the "tenant" edge to the Tenant entity.
func (m *RetentionPolicyMutation) ClearTenant() {
	m.clearedtenant = true
}

// TenantCleared reports if the "tenant" edge to the Tenant entity was cleared.
func (m *RetentionPolicyMutation) TenantCleared() bool {
	return m.clearedtenant
}

// TenantID returns the "tenant" edge ID in the mutation.
func (m *RetentionPolicyMutation) TenantID() (id int, exists bool) {
	if m.tenant != nil {
		return *m.tenant, true
	}
	return
}

// TenantIDs returns the "tenant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TenantID instead. It exists only for internal usage by the builders.
func (m *RetentionPolicyMutation) TenantIDs() (ids []int) {
	if id := m.tenant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTenant resets all changes to the "tenant" edge.
func (m *RetentionPolicyMutation) ResetTenant() {
	m.tenant = nil
	m.clearedtenant = false
}

// Where appends a list predicates to the RetentionPolicyMutation builder.
func (m *RetentionPolicyMutation) Where(ps ...predicate.RetentionPolicy) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the RetentionPolicyMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *RetentionPolicyMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.RetentionPolicy, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *RetentionPolicyMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *RetentionPolicyMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (RetentionPolicy).
func (m *RetentionPolicyMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *RetentionPolicyMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.name != nil {
		fields = append(fields, retentionpolicy.FieldName)
	}
	if m.description != nil {
		fields = append(fields, retentionpolicy.FieldDescription)
	}
	if m.retention_days != nil {
		fields = append(fields, retentionpolicy.FieldRetentionDays)
	}
	if m.action != nil {
		fields = append(fields, retentionpolicy.FieldAction)
	}
	if m.file_type_filter != nil {
		fields = append(fields, retentionpolicy.FieldFileTypeFilter)
	}
	if m.active != nil {
		fields = append(fields, retentionpolicy.FieldActive)
	}
	if m.created_at != nil {
		fields = append(fields, retentionpolicy.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *RetentionPolicyMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case retentionpolicy.FieldName:
		return m.Name()
	case retentionpolicy.FieldDescription:
		return m.Description()
	case retentionpolicy.FieldRetentionDays:
		return m.RetentionDays()
	case retentionpolicy.FieldAction:
		return m.Action()
	case retentionpolicy.FieldFileTypeFilter:
		return m.FileTypeFilter()
	case retentionpolicy.FieldActive:
		return m.Active()
	case retentionpolicy.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *RetentionPolicyMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case retentionpolicy.FieldName:
		return m.OldName(ctx)
	case retentionpolicy.FieldDescription:
		return m.OldDescription(ctx)
	case retentionpolicy.FieldRetentionDays:
		return m.OldRetentionDays(ctx)
	case retentionpolicy.FieldAction:
		return m.OldAction(ctx)
	case retentionpolicy.FieldFileTypeFilter:
		return m.OldFileTypeFilter(ctx)
	case retentionpolicy.FieldActive:
		return m.OldActive(ctx)
	case retentionpolicy.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown RetentionPolicy field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RetentionPolicyMutation) SetField(name string, value ent.Value) error {
	switch name {
	case retentionpolicy.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case retentionpolicy.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case retentionpolicy.FieldRetentionDays:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRetentionDays(v)
		return nil
	case retentionpolicy.FieldAction:
		v, ok := value.(retentionpolicy.Action)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAction(v)
		return nil
	case retentionpolicy.FieldFileTypeFilter:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFileTypeFilter(v)
		return nil
	case retentionpolicy.FieldActive:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetActive(v)
		return nil
	case retentionpolicy.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown RetentionPolicy field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *RetentionPolicyMutation) AddedFields() []string {
	var fields []string
	if m.addretention_days != nil {
		fields = append(fields, retentionpolicy.FieldRetentionDays)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *RetentionPolicyMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case retentionpolicy.FieldRetentionDays:
		return m.AddedRetentionDays()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RetentionPolicyMutation) AddField(name string, value ent.Value) error {
	switch name {
	case retentionpolicy.FieldRetentionDays:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRetentionDays(v)
		return nil
	}
	return fmt.Errorf("unknown RetentionPolicy numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *RetentionPolicyMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(retentionpolicy.FieldDescription) {
		fields = append(fields, retentionpolicy.FieldDescription)
	}
	if m.FieldCleared(retentionpolicy.FieldFileTypeFilter) {
		fields = append(fields, retentionpolicy.FieldFileTypeFilter)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *RetentionPolicyMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *RetentionPolicyMutation) ClearField(name string) error {
	switch name {
	case retentionpolicy.FieldDescription:
		m.ClearDescription()
		return nil
	case retentionpolicy.FieldFileTypeFilter:
		m.ClearFileTypeFilter()
		return nil
	}
	return fmt.Errorf("unknown RetentionPolicy nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *RetentionPolicyMutation) ResetField(name string) error {
	switch name {
	case retentionpolicy.FieldName:
		m.ResetName()
		return nil
	case retentionpolicy.FieldDescription:
		m.ResetDescription()
		return nil
	case retentionpolicy.FieldRetentionDays:
		m.ResetRetentionDays()
		return nil
	case retentionpolicy.FieldAction:
		m.ResetAction()
		return nil
	case retentionpolicy.FieldFileTypeFilter:
		m.ResetFileTypeFilter()
		return nil
	case retentionpolicy.FieldActive:
		m.ResetActive()
		return nil
	case retentionpolicy.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown RetentionPolicy field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *RetentionPolicyMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.tenant != nil {
		edges = append(edges, retentionpolicy.EdgeTenant)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *RetentionPolicyMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case retentionpolicy.EdgeTenant:
		if id := m.tenant; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *RetentionPolicyMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *RetentionPolicyMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *RetentionPolicyMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedtenant {
		edges = append(edges, retentionpolicy.EdgeTenant)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *RetentionPolicyMutation) EdgeCleared(name string) bool {
	switch name {
	case retentionpolicy.EdgeTenant:
		return m.clearedtenant
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *RetentionPolicyMutation) ClearEdge(name string) error {
	switch name {
	case retentionpolicy.EdgeTenant:
		m.ClearTenant()
		return nil
	}
	return fmt.Errorf("unknown RetentionPolicy unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *RetentionPolicyMutation) ResetEdge(name string) error {
	switch name {
	case retentionpolicy.EdgeTenant:
		m.ResetTenant()
		return nil
	}
	return fmt.Errorf("unknown RetentionPolicy edge %s", name)
}

// ReviewCycleMutation represents an operation that mutates the ReviewCycle nodes in the graph.
type ReviewCycleMutation struct {
	config
	op              Op
	typ             string
	id              *int
	name            *string
	description     *string
	cycle_type      *reviewcycle.CycleType
	status          *reviewcycle.Status
	start_date      *time.Time
	end_date        *time.Time
	review_deadline *time.Time
	created_at      *time.Time
	updated_at      *time.Time
	clearedFields   map[string]struct{}
	tenant          *int
	clearedtenant   bool
	reviews         map[int]struct{}
	removedreviews  map[int]struct{}
	clearedreviews  bool
	done            bool
	oldValue        func(context.Context) (*ReviewCycle, error)
	predicates      []predicate.ReviewCycle
}

var _ ent.Mutation = (*ReviewCycleMutation)(nil)

// reviewcycleOption allows management of the mutation configuration using functional options.
type reviewcycleOption func(*ReviewCycleMutation)

// newReviewCycleMutation creates new mutation for the ReviewCycle entity.
func newReviewCycleMutation(c config, op Op, opts ...reviewcycleOption) *ReviewCycleMutation {
	m := &ReviewCycleMutation{
		config:        c,
		op:            op,
		typ:           TypeReviewCycle,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withReviewCycleID sets the ID field of the mutation.
func withReviewCycleID(id int) reviewcycleOption {
	return func(m *ReviewCycleMutation) {
		var (
			err   error
			once  sync.Once
			value *ReviewCycle
		)
		m.oldValue = func(ctx context.Context) (*ReviewCycle, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ReviewCycle.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withReviewCycle sets the old ReviewCycle of the mutation.
func withReviewCycle(node *ReviewCycle) reviewcycleOption {
	return func(m *ReviewCycleMutation) {
		m.oldValue = func(context.Context) (*ReviewCycle, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ReviewCycleMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ReviewCycleMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ReviewCycleMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ReviewCycleMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ReviewCycle.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *ReviewCycleMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ReviewCycleMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the ReviewCycle entity.
// If the ReviewCycle object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReviewCycleMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ReviewCycleMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *ReviewCycleMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *ReviewCycleMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the ReviewCycle entity.
// If the ReviewCycle object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReviewCycleMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *ReviewCycleMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[reviewcycle.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *ReviewCycleMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[reviewcycle.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *ReviewCycleMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, reviewcycle.FieldDescription)
}

// SetCycleType sets the "cycle_type" field.
func (m *ReviewCycleMutation) SetCycleType(rt reviewcycle.CycleType) {
	m.cycle_type = &rt
}

// CycleType returns the value of the "cycle_type" field in the mutation.
func (m *ReviewCycleMutation) CycleType() (r reviewcycle.CycleType, exists bool) {
	v := m.cycle_type
	if v == nil {
		return
	}
	return *v, true
}

// OldCycleType returns the old "cycle_type" field's value of the ReviewCycle entity.
// If the ReviewCycle object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReviewCycleMutation) OldCycleType(ctx context.Context) (v reviewcycle.CycleType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCycleType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCycleType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCycleType: %w", err)
	}
	return oldValue.CycleType, nil
}

// ResetCycleType resets all changes to the "cycle_type" field.
func (m *ReviewCycleMutation) ResetCycleType() {
	m.cycle_type = nil
}

// SetStatus sets the "status" field.
func (m *ReviewCycleMutation) SetStatus(r reviewcycle.Status) {
	m.status = &r
}

// Status returns the value of the "status" field in the mutation.
func (m *ReviewCycleMutation) Status() (r reviewcycle.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the ReviewCycle entity.
// If the ReviewCycle object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReviewCycleMutation) OldStatus(ctx context.Context) (v reviewcycle.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *ReviewCycleMutation) ResetStatus() {
	m.status = nil
}

// SetStartDate sets the "start_date" field.
func (m *ReviewCycleMutation) SetStartDate(t time.Time) {
	m.start_date = &t
}

// StartDate returns the value of the "start_date" field in the mutation.
func (m *ReviewCycleMutation) StartDate() (r time.Time, exists bool) {
	v := m.start_date
	if v == nil {
		return
	}
	return *v, true
}

// OldStartDate returns the old "start_date" field's value of the ReviewCycle entity.
// If the ReviewCycle object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReviewCycleMutation) OldStartDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartDate: %w", err)
	}
	return oldValue.StartDate, nil
}

// ResetStartDate resets all changes to the "start_date" field.
func (m *ReviewCycleMutation) ResetStartDate() {
	m.start_date = nil
}

// SetEndDate sets the "end_date" field.
func (m *ReviewCycleMutation) SetEndDate(t time.Time) {
	m.end_date = &t
}

// EndDate returns the value of the "end_date" field in the mutation.
func (m *ReviewCycleMutation) EndDate() (r time.Time, exists bool) {
	v := m.end_date
	if v == nil {
		return
	}
	return *v, true
}

// OldEndDate returns the old "end_date" field's value of the ReviewCycle entity.
// If the ReviewCycle object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReviewCycleMutation) OldEndDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEndDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEndDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndDate: %w", err)
	}
	return oldValue.EndDate, nil
}

// ResetEndDate resets all changes to the "end_date" field.
func (m *ReviewCycleMutation) ResetEndDate() {
	m.end_date = nil
}

// SetReviewDeadline sets the "review_deadline" field.
func (m *ReviewCycleMutation) SetReviewDeadline(t time.Time) {
	m.review_deadline = &t
}

// ReviewDeadline returns the value of the "review_deadline" field in the mutation.
func (m *ReviewCycleMutation) ReviewDeadline() (r time.Time, exists bool) {
	v := m.review_deadline
	if v == nil {
		return
	}
	return *v, true
}

// OldReviewDeadline returns the old "review_deadline" field's value of the ReviewCycle entity.
// If the ReviewCycle object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReviewCycleMutation) OldReviewDeadline(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReviewDeadline is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReviewDeadline requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReviewDeadline: %w", err)
	}
	return oldValue.ReviewDeadline, nil
}

// ClearReviewDeadline clears the value of the "review_deadline" field.
func (m *ReviewCycleMutation) ClearReviewDeadline() {
	m.review_deadline = nil
	m.clearedFields[reviewcycle.FieldReviewDeadline] = struct{}{}
}

// ReviewDeadlineCleared returns if the "review_deadline" field was cleared in this mutation.
func (m *ReviewCycleMutation) ReviewDeadlineCleared() bool {
	_, ok := m.clearedFields[reviewcycle.FieldReviewDeadline]
	return ok
}

// ResetReviewDeadline resets all changes to the "review_deadline" field.
func (m *ReviewCycleMutation) ResetReviewDeadline() {
	m.review_deadline = nil
	delete(m.clearedFields, reviewcycle.FieldReviewDeadline)
}

// SetCreatedAt sets the "created_at" field.
func (m *ReviewCycleMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ReviewCycleMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ReviewCycle entity.
// If the ReviewCycle object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReviewCycleMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ReviewCycleMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ReviewCycleMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ReviewCycleMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ReviewCycle entity.
// If the ReviewCycle object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReviewCycleMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ReviewCycleMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetTenantID sets the "tenant" edge to the Tenant entity by id.
func (m *ReviewCycleMutation) SetTenantID(id int) {
	m.tenant = &id
}

// ClearTenant clears the "tenant" edge to the Tenant entity.
func (m *ReviewCycleMutation) ClearTenant() {
	m.clearedtenant = true
}

// TenantCleared reports if the "tenant" edge to the Tenant entity was cleared.
func (m *ReviewCycleMutation) TenantCleared() bool {
	return m.clearedtenant
}

// TenantID returns the "tenant" edge ID in the mutation.
func (m *ReviewCycleMutation) TenantID() (id int, exists bool) {
	if m.tenant != nil {
		return *m.tenant, true
	}
	return
}

// TenantIDs returns the "tenant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TenantID instead. It exists only for internal usage by the builders.
func (m *ReviewCycleMutation) TenantIDs() (ids []int) {
	if id := m.tenant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTenant resets all changes to the "tenant" edge.
func (m *ReviewCycleMutation) ResetTenant() {
	m.tenant = nil
	m.clearedtenant = false
}

// AddReviewIDs adds the "reviews" edge to the PerformanceReview entity by ids.
func (m *ReviewCycleMutation) AddReviewIDs(ids ...int) {
	if m.reviews == nil {
		m.reviews = make(map[int]struct{})
	}
	for i := range ids {
		m.reviews[ids[i]] = struct{}{}
	}
}

// ClearReviews clears the "reviews" edge to the PerformanceReview entity.
func (m *ReviewCycleMutation) ClearReviews() {
	m.clearedreviews = true
}

// ReviewsCleared reports if the "reviews" edge to the PerformanceReview entity was cleared.
func (m *ReviewCycleMutation) ReviewsCleared() bool {
	return m.clearedreviews
}

// RemoveReviewIDs removes the "reviews" edge to the PerformanceReview entity by IDs.
func (m *ReviewCycleMutation) RemoveReviewIDs(ids ...int) {
	if m.removedreviews == nil {
		m.removedreviews = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.reviews, ids[i])
		m.removedreviews[ids[i]] = struct{}{}
	}
}

// RemovedReviews returns the removed IDs of the "reviews" edge to the PerformanceReview entity.
func (m *ReviewCycleMutation) RemovedReviewsIDs() (ids []int) {
	for id := range m.removedreviews {
		ids = append(ids, id)
	}
	return
}

// ReviewsIDs returns the "reviews" edge IDs in the mutation.
func (m *ReviewCycleMutation) ReviewsIDs() (ids []int) {
	for id := range m.reviews {
		ids = append(ids, id)
	}
	return
}

// ResetReviews resets all changes to the "reviews" edge.
func (m *ReviewCycleMutation) ResetReviews() {
	m.reviews = nil
	m.clearedreviews = false
	m.removedreviews = nil
}

// Where appends a list predicates to the ReviewCycleMutation builder.
func (m *ReviewCycleMutation) Where(ps ...predicate.ReviewCycle) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ReviewCycleMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ReviewCycleMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ReviewCycle, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ReviewCycleMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ReviewCycleMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ReviewCycle).
func (m *ReviewCycleMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ReviewCycleMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.name != nil {
		fields = append(fields, reviewcycle.FieldName)
	}
	if m.description != nil {
		fields = append(fields, reviewcycle.FieldDescription)
	}
	if m.cycle_type != nil {
		fields = append(fields, reviewcycle.FieldCycleType)
	}
	if m.status != nil {
		fields = append(fields, reviewcycle.FieldStatus)
	}
	if m.start_date != nil {
		fields = append(fields, reviewcycle.FieldStartDate)
	}
	if m.end_date != nil {
		fields = append(fields, reviewcycle.FieldEndDate)
	}
	if m.review_deadline != nil {
		fields = append(fields, reviewcycle.FieldReviewDeadline)
	}
	if m.created_at != nil {
		fields = append(fields, reviewcycle.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, reviewcycle.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ReviewCycleMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case reviewcycle.FieldName:
		return m.Name()
	case reviewcycle.FieldDescription:
		return m.Description()
	case reviewcycle.FieldCycleType:
		return m.CycleType()
	case reviewcycle.FieldStatus:
		return m.Status()
	case reviewcycle.FieldStartDate:
		return m.StartDate()
	case reviewcycle.FieldEndDate:
		return m.EndDate()
	case reviewcycle.FieldReviewDeadline:
		return m.ReviewDeadline()
	case reviewcycle.FieldCreatedAt:
		return m.CreatedAt()
	case reviewcycle.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ReviewCycleMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case reviewcycle.FieldName:
		return m.OldName(ctx)
	case reviewcycle.FieldDescription:
		return m.OldDescription(ctx)
	case reviewcycle.FieldCycleType:
		return m.OldCycleType(ctx)
	case reviewcycle.FieldStatus:
		return m.OldStatus(ctx)
	case reviewcycle.FieldStartDate:
		return m.OldStartDate(ctx)
	case reviewcycle.FieldEndDate:
		return m.OldEndDate(ctx)
	case reviewcycle.FieldReviewDeadline:
		return m.OldReviewDeadline(ctx)
	case reviewcycle.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case reviewcycle.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown ReviewCycle field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ReviewCycleMutation) SetField(name string, value ent.Value) error {
	switch name {
	case reviewcycle.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case reviewcycle.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case reviewcycle.FieldCycleType:
		v, ok := value.(reviewcycle.CycleType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCycleType(v)
		return nil
	case reviewcycle.FieldStatus:
		v, ok := value.(reviewcycle.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case reviewcycle.FieldStartDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartDate(v)
		return nil
	case reviewcycle.FieldEndDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndDate(v)
		return nil
	case reviewcycle.FieldReviewDeadline:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReviewDeadline(v)
		return nil
	case reviewcycle.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case reviewcycle.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown ReviewCycle field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ReviewCycleMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ReviewCycleMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ReviewCycleMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ReviewCycle numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ReviewCycleMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(reviewcycle.FieldDescription) {
		fields = append(fields, reviewcycle.FieldDescription)
	}
	if m.FieldCleared(reviewcycle.FieldReviewDeadline) {
		fields = append(fields, reviewcycle.FieldReviewDeadline)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ReviewCycleMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ReviewCycleMutation) ClearField(name string) error {
	switch name {
	case reviewcycle.FieldDescription:
		m.ClearDescription()
		return nil
	case reviewcycle.FieldReviewDeadline:
		m.ClearReviewDeadline()
		return nil
	}
	return fmt.Errorf("unknown ReviewCycle nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ReviewCycleMutation) ResetField(name string) error {
	switch name {
	case reviewcycle.FieldName:
		m.ResetName()
		return nil
	case reviewcycle.FieldDescription:
		m.ResetDescription()
		return nil
	case reviewcycle.FieldCycleType:
		m.ResetCycleType()
		return nil
	case reviewcycle.FieldStatus:
		m.ResetStatus()
		return nil
	case reviewcycle.FieldStartDate:
		m.ResetStartDate()
		return nil
	case reviewcycle.FieldEndDate:
		m.ResetEndDate()
		return nil
	case reviewcycle.FieldReviewDeadline:
		m.ResetReviewDeadline()
		return nil
	case reviewcycle.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case reviewcycle.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown ReviewCycle field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ReviewCycleMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.tenant != nil {
		edges = append(edges, reviewcycle.EdgeTenant)
	}
	if m.reviews != nil {
		edges = append(edges, reviewcycle.EdgeReviews)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ReviewCycleMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case reviewcycle.EdgeTenant:
		if id := m.tenant; id != nil {
			return []ent.Value{*id}
		}
	case reviewcycle.EdgeReviews:
		ids := make([]ent.Value, 0, len(m.reviews))
		for id := range m.reviews {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ReviewCycleMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedreviews != nil {
		edges = append(edges, reviewcycle.EdgeReviews)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ReviewCycleMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case reviewcycle.EdgeReviews:
		ids := make([]ent.Value, 0, len(m.removedreviews))
		for id := range m.removedreviews {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ReviewCycleMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedtenant {
		edges = append(edges, reviewcycle.EdgeTenant)
	}
	if m.clearedreviews {
		edges = append(edges, reviewcycle.EdgeReviews)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ReviewCycleMutation) EdgeCleared(name string) bool {
	switch name {
	case reviewcycle.EdgeTenant:
		return m.clearedtenant
	case reviewcycle.EdgeReviews:
		return m.clearedreviews
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ReviewCycleMutation) ClearEdge(name string) error {
	switch name {
	case reviewcycle.EdgeTenant:
		m.ClearTenant()
		return nil
	}
	return fmt.Errorf("unknown ReviewCycle unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ReviewCycleMutation) ResetEdge(name string) error {
	switch name {
	case reviewcycle.EdgeTenant:
		m.ResetTenant()
		return nil
	case reviewcycle.EdgeReviews:
		m.ResetReviews()
		return nil
	}
	return fmt.Errorf("unknown ReviewCycle edge %s", name)
}

// SOPMutation represents an operation that mutates the SOP nodes in the graph.
type SOPMutation struct {
	config
	op            Op
	typ           string
	id            *int
	title         *string
	content       *map[string]interface{}
	version       *int
	addversion    *int
	created_at    *time.Time
	updated_at    *time.Time
	clearedFields map[string]struct{}
	tenant        *int
	clearedtenant bool
	asset         *int
	clearedasset  bool
	author        *int
	clearedauthor bool
	done          bool
	oldValue      func(context.Context) (*SOP, error)
	predicates    []predicate.SOP
}

var _ ent.Mutation = (*SOPMutation)(nil)

// sopOption allows management of the mutation configuration using functional options.
type sopOption func(*SOPMutation)

// newSOPMutation creates new mutation for the SOP entity.
func newSOPMutation(c config, op Op, opts ...sopOption) *SOPMutation {
	m := &SOPMutation{
		config:        c,
		op:            op,
		typ:           TypeSOP,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSOPID sets the ID field of the mutation.
func withSOPID(id int) sopOption {
	return func(m *SOPMutation) {
		var (
			err   error
			once  sync.Once
			value *SOP
		)
		m.oldValue = func(ctx context.Context) (*SOP, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().SOP.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSOP sets the old SOP of the mutation.
func withSOP(node *SOP) sopOption {
	return func(m *SOPMutation) {
		m.oldValue = func(context.Context) (*SOP, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SOPMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SOPMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SOPMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SOPMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().SOP.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTitle sets the "title" field.
func (m *SOPMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *SOPMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the SOP entity.
// If the SOP object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SOPMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *SOPMutation) ResetTitle() {
	m.title = nil
}

// SetContent sets the "content" field.
func (m *SOPMutation) SetContent(value map[string]interface{}) {
	m.content = &value
}

// Content returns the value of the "content" field in the mutation.
func (m *SOPMutation) Content() (r map[string]interface{}, exists bool) {
	v := m.content
	if v == nil {
		return
	}
	return *v, true
}

// OldContent returns the old "content" field's value of the SOP entity.
// If the SOP object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SOPMutation) OldContent(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContent: %w", err)
	}
	return oldValue.Content, nil
}

// ClearContent clears the value of the "content" field.
func (m *SOPMutation) ClearContent() {
	m.content = nil
	m.clearedFields[sop.FieldContent] = struct{}{}
}

// ContentCleared returns if the "content" field was cleared in this mutation.
func (m *SOPMutation) ContentCleared() bool {
	_, ok := m.clearedFields[sop.FieldContent]
	return ok
}

// ResetContent resets all changes to the "content" field.
func (m *SOPMutation) ResetContent() {
	m.content = nil
	delete(m.clearedFields, sop.FieldContent)
}

// SetVersion sets the "version" field.
func (m *SOPMutation) SetVersion(i int) {
	m.version = &i
	m.addversion = nil
}

// Version returns the value of the "version" field in the mutation.
func (m *SOPMutation) Version() (r int, exists bool) {
	v := m.version
	if v == nil {
		return
	}
	return *v, true
}

// OldVersion returns the old "version" field's value of the SOP entity.
// If the SOP object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SOPMutation) OldVersion(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVersion: %w", err)
	}
	return oldValue.Version, nil
}

// AddVersion adds i to the "version" field.
func (m *SOPMutation) AddVersion(i int) {
	if m.addversion != nil {
		*m.addversion += i
	} else {
		m.addversion = &i
	}
}

// AddedVersion returns the value that was added to the "version" field in this mutation.
func (m *SOPMutation) AddedVersion() (r int, exists bool) {
	v := m.addversion
	if v == nil {
		return
	}
	return *v, true
}

// ResetVersion resets all changes to the "version" field.
func (m *SOPMutation) ResetVersion() {
	m.version = nil
	m.addversion = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *SOPMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *SOPMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the SOP entity.
// If the SOP object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SOPMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *SOPMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *SOPMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *SOPMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the SOP entity.
// If the SOP object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SOPMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *SOPMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetTenantID sets the "tenant" edge to the Tenant entity by id.
func (m *SOPMutation) SetTenantID(id int) {
	m.tenant = &id
}

// ClearTenant clears the "tenant" edge to the Tenant entity.
func (m *SOPMutation) ClearTenant() {
	m.clearedtenant = true
}

// TenantCleared reports if the "tenant" edge to the Tenant entity was cleared.
func (m *SOPMutation) TenantCleared() bool {
	return m.clearedtenant
}

// TenantID returns the "tenant" edge ID in the mutation.
func (m *SOPMutation) TenantID() (id int, exists bool) {
	if m.tenant != nil {
		return *m.tenant, true
	}
	return
}

// TenantIDs returns the "tenant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TenantID instead. It exists only for internal usage by the builders.
func (m *SOPMutation) TenantIDs() (ids []int) {
	if id := m.tenant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTenant resets all changes to the "tenant" edge.
func (m *SOPMutation) ResetTenant() {
	m.tenant = nil
	m.clearedtenant = false
}

// SetAssetID sets the "asset" edge to the Asset entity by id.
func (m *SOPMutation) SetAssetID(id int) {
	m.asset = &id
}

// ClearAsset clears the "asset" edge to the Asset entity.
func (m *SOPMutation) ClearAsset() {
	m.clearedasset = true
}

// AssetCleared reports if the "asset" edge to the Asset entity was cleared.
func (m *SOPMutation) AssetCleared() bool {
	return m.clearedasset
}

// AssetID returns the "asset" edge ID in the mutation.
func (m *SOPMutation) AssetID() (id int, exists bool) {
	if m.asset != nil {
		return *m.asset, true
	}
	return
}

// AssetIDs returns the "asset" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AssetID instead. It exists only for internal usage by the builders.
func (m *SOPMutation) AssetIDs() (ids []int) {
	if id := m.asset; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAsset resets all changes to the "asset" edge.
func (m *SOPMutation) ResetAsset() {
	m.asset = nil
	m.clearedasset = false
}

// SetAuthorID sets the "author" edge to the User entity by id.
func (m *SOPMutation) SetAuthorID(id int) {
	m.author = &id
}

// ClearAuthor clears the "author" edge to the User entity.
func (m *SOPMutation) ClearAuthor() {
	m.clearedauthor = true
}

// AuthorCleared reports if the "author" edge to the User entity was cleared.
func (m *SOPMutation) AuthorCleared() bool {
	return m.clearedauthor
}

// AuthorID returns the "author" edge ID in the mutation.
func (m *SOPMutation) AuthorID() (id int, exists bool) {
	if m.author != nil {
		return *m.author, true
	}
	return
}

// AuthorIDs returns the "author" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AuthorID instead. It exists only for internal usage by the builders.
func (m *SOPMutation) AuthorIDs() (ids []int) {
	if id := m.author; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAuthor resets all changes to the "author" edge.
func (m *SOPMutation) ResetAuthor() {
	m.author = nil
	m.clearedauthor = false
}

// Where appends a list predicates to the SOPMutation builder.
func (m *SOPMutation) Where(ps ...predicate.SOP) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SOPMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SOPMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.SOP, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SOPMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SOPMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (SOP).
func (m *SOPMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SOPMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.title != nil {
		fields = append(fields, sop.FieldTitle)
	}
	if m.content != nil {
		fields = append(fields, sop.FieldContent)
	}
	if m.version != nil {
		fields = append(fields, sop.FieldVersion)
	}
	if m.created_at != nil {
		fields = append(fields, sop.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, sop.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SOPMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case sop.FieldTitle:
		return m.Title()
	case sop.FieldContent:
		return m.Content()
	case sop.FieldVersion:
		return m.Version()
	case sop.FieldCreatedAt:
		return m.CreatedAt()
	case sop.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SOPMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case sop.FieldTitle:
		return m.OldTitle(ctx)
	case sop.FieldContent:
		return m.OldContent(ctx)
	case sop.FieldVersion:
		return m.OldVersion(ctx)
	case sop.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case sop.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown SOP field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SOPMutation) SetField(name string, value ent.Value) error {
	switch name {
	case sop.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case sop.FieldContent:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContent(v)
		return nil
	case sop.FieldVersion:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVersion(v)
		return nil
	case sop.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case sop.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown SOP field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SOPMutation) AddedFields() []string {
	var fields []string
	if m.addversion != nil {
		fields = append(fields, sop.FieldVersion)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SOPMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case sop.FieldVersion:
		return m.AddedVersion()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SOPMutation) AddField(name string, value ent.Value) error {
	switch name {
	case sop.FieldVersion:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddVersion(v)
		return nil
	}
	return fmt.Errorf("unknown SOP numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SOPMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(sop.FieldContent) {
		fields = append(fields, sop.FieldContent)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SOPMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SOPMutation) ClearField(name string) error {
	switch name {
	case sop.FieldContent:
		m.ClearContent()
		return nil
	}
	return fmt.Errorf("unknown SOP nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SOPMutation) ResetField(name string) error {
	switch name {
	case sop.FieldTitle:
		m.ResetTitle()
		return nil
	case sop.FieldContent:
		m.ResetContent()
		return nil
	case sop.FieldVersion:
		m.ResetVersion()
		return nil
	case sop.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case sop.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown SOP field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SOPMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.tenant != nil {
		edges = append(edges, sop.EdgeTenant)
	}
	if m.asset != nil {
		edges = append(edges, sop.EdgeAsset)
	}
	if m.author != nil {
		edges = append(edges, sop.EdgeAuthor)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SOPMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case sop.EdgeTenant:
		if id := m.tenant; id != nil {
			return []ent.Value{*id}
		}
	case sop.EdgeAsset:
		if id := m.asset; id != nil {
			return []ent.Value{*id}
		}
	case sop.EdgeAuthor:
		if id := m.author; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SOPMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SOPMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SOPMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedtenant {
		edges = append(edges, sop.EdgeTenant)
	}
	if m.clearedasset {
		edges = append(edges, sop.EdgeAsset)
	}
	if m.clearedauthor {
		edges = append(edges, sop.EdgeAuthor)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SOPMutation) EdgeCleared(name string) bool {
	switch name {
	case sop.EdgeTenant:
		return m.clearedtenant
	case sop.EdgeAsset:
		return m.clearedasset
	case sop.EdgeAuthor:
		return m.clearedauthor
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SOPMutation) ClearEdge(name string) error {
	switch name {
	case sop.EdgeTenant:
		m.ClearTenant()
		return nil
	case sop.EdgeAsset:
		m.ClearAsset()
		return nil
	case sop.EdgeAuthor:
		m.ClearAuthor()
		return nil
	}
	return fmt.Errorf("unknown SOP unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SOPMutation) ResetEdge(name string) error {
	switch name {
	case sop.EdgeTenant:
		m.ResetTenant()
		return nil
	case sop.EdgeAsset:
		m.ResetAsset()
		return nil
	case sop.EdgeAuthor:
		m.ResetAuthor()
		return nil
	}
	return fmt.Errorf("unknown SOP edge %s", name)
}

// SaaSAppMutation represents an operation that mutates the SaaSApp nodes in the graph.
type SaaSAppMutation struct {
	config
	op                Op
	typ               string
	id                *int
	name              *string
	provider          *string
	category          *string
	url               *string
	is_managed        *bool
	_config           *map[string]interface{}
	monthly_price     *decimal.Decimal
	created_at        *time.Time
	updated_at        *time.Time
	clearedFields     map[string]struct{}
	identities        map[int]struct{}
	removedidentities map[int]struct{}
	clearedidentities bool
	filters           map[int]struct{}
	removedfilters    map[int]struct{}
	clearedfilters    bool
	tenant            *int
	clearedtenant     bool
	done              bool
	oldValue          func(context.Context) (*SaaSApp, error)
	predicates        []predicate.SaaSApp
}

var _ ent.Mutation = (*SaaSAppMutation)(nil)

// saasappOption allows management of the mutation configuration using functional options.
type saasappOption func(*SaaSAppMutation)

// newSaaSAppMutation creates new mutation for the SaaSApp entity.
func newSaaSAppMutation(c config, op Op, opts ...saasappOption) *SaaSAppMutation {
	m := &SaaSAppMutation{
		config:        c,
		op:            op,
		typ:           TypeSaaSApp,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSaaSAppID sets the ID field of the mutation.
func withSaaSAppID(id int) saasappOption {
	return func(m *SaaSAppMutation) {
		var (
			err   error
			once  sync.Once
			value *SaaSApp
		)
		m.oldValue = func(ctx context.Context) (*SaaSApp, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().SaaSApp.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSaaSApp sets the old SaaSApp of the mutation.
func withSaaSApp(node *SaaSApp) saasappOption {
	return func(m *SaaSAppMutation) {
		m.oldValue = func(context.Context) (*SaaSApp, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SaaSAppMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SaaSAppMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SaaSAppMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SaaSAppMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().SaaSApp.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *SaaSAppMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *SaaSAppMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the SaaSApp entity.
// If the SaaSApp object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SaaSAppMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *SaaSAppMutation) ResetName() {
	m.name = nil
}

// SetProvider sets the "provider" field.
func (m *SaaSAppMutation) SetProvider(s string) {
	m.provider = &s
}

// Provider returns the value of the "provider" field in the mutation.
func (m *SaaSAppMutation) Provider() (r string, exists bool) {
	v := m.provider
	if v == nil {
		return
	}
	return *v, true
}

// OldProvider returns the old "provider" field's value of the SaaSApp entity.
// If the SaaSApp object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SaaSAppMutation) OldProvider(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProvider is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProvider requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProvider: %w", err)
	}
	return oldValue.Provider, nil
}

// ResetProvider resets all changes to the "provider" field.
func (m *SaaSAppMutation) ResetProvider() {
	m.provider = nil
}

// SetCategory sets the "category" field.
func (m *SaaSAppMutation) SetCategory(s string) {
	m.category = &s
}

// Category returns the value of the "category" field in the mutation.
func (m *SaaSAppMutation) Category() (r string, exists bool) {
	v := m.category
	if v == nil {
		return
	}
	return *v, true
}

// OldCategory returns the old "category" field's value of the SaaSApp entity.
// If the SaaSApp object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SaaSAppMutation) OldCategory(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCategory is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCategory requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCategory: %w", err)
	}
	return oldValue.Category, nil
}

// ClearCategory clears the value of the "category" field.
func (m *SaaSAppMutation) ClearCategory() {
	m.category = nil
	m.clearedFields[saasapp.FieldCategory] = struct{}{}
}

// CategoryCleared returns if the "category" field was cleared in this mutation.
func (m *SaaSAppMutation) CategoryCleared() bool {
	_, ok := m.clearedFields[saasapp.FieldCategory]
	return ok
}

// ResetCategory resets all changes to the "category" field.
func (m *SaaSAppMutation) ResetCategory() {
	m.category = nil
	delete(m.clearedFields, saasapp.FieldCategory)
}

// SetURL sets the "url" field.
func (m *SaaSAppMutation) SetURL(s string) {
	m.url = &s
}

// URL returns the value of the "url" field in the mutation.
func (m *SaaSAppMutation) URL() (r string, exists bool) {
	v := m.url
	if v == nil {
		return
	}
	return *v, true
}

// OldURL returns the old "url" field's value of the SaaSApp entity.
// If the SaaSApp object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SaaSAppMutation) OldURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldURL: %w", err)
	}
	return oldValue.URL, nil
}

// ClearURL clears the value of the "url" field.
func (m *SaaSAppMutation) ClearURL() {
	m.url = nil
	m.clearedFields[saasapp.FieldURL] = struct{}{}
}

// URLCleared returns if the "url" field was cleared in this mutation.
func (m *SaaSAppMutation) URLCleared() bool {
	_, ok := m.clearedFields[saasapp.FieldURL]
	return ok
}

// ResetURL resets all changes to the "url" field.
func (m *SaaSAppMutation) ResetURL() {
	m.url = nil
	delete(m.clearedFields, saasapp.FieldURL)
}

// SetIsManaged sets the "is_managed" field.
func (m *SaaSAppMutation) SetIsManaged(b bool) {
	m.is_managed = &b
}

// IsManaged returns the value of the "is_managed" field in the mutation.
func (m *SaaSAppMutation) IsManaged() (r bool, exists bool) {
	v := m.is_managed
	if v == nil {
		return
	}
	return *v, true
}

// OldIsManaged returns the old "is_managed" field's value of the SaaSApp entity.
// If the SaaSApp object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SaaSAppMutation) OldIsManaged(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsManaged is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsManaged requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsManaged: %w", err)
	}
	return oldValue.IsManaged, nil
}

// ResetIsManaged resets all changes to the "is_managed" field.
func (m *SaaSAppMutation) ResetIsManaged() {
	m.is_managed = nil
}

// SetConfig sets the "config" field.
func (m *SaaSAppMutation) SetConfig(value map[string]interface{}) {
	m._config = &value
}

// Config returns the value of the "config" field in the mutation.
func (m *SaaSAppMutation) Config() (r map[string]interface{}, exists bool) {
	v := m._config
	if v == nil {
		return
	}
	return *v, true
}

// OldConfig returns the old "config" field's value of the SaaSApp entity.
// If the SaaSApp object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SaaSAppMutation) OldConfig(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldConfig is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldConfig requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldConfig: %w", err)
	}
	return oldValue.Config, nil
}

// ResetConfig resets all changes to the "config" field.
func (m *SaaSAppMutation) ResetConfig() {
	m._config = nil
}

// SetMonthlyPrice sets the "monthly_price" field.
func (m *SaaSAppMutation) SetMonthlyPrice(d decimal.Decimal) {
	m.monthly_price = &d
}

// MonthlyPrice returns the value of the "monthly_price" field in the mutation.
func (m *SaaSAppMutation) MonthlyPrice() (r decimal.Decimal, exists bool) {
	v := m.monthly_price
	if v == nil {
		return
	}
	return *v, true
}

// OldMonthlyPrice returns the old "monthly_price" field's value of the SaaSApp entity.
// If the SaaSApp object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SaaSAppMutation) OldMonthlyPrice(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMonthlyPrice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMonthlyPrice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMonthlyPrice: %w", err)
	}
	return oldValue.MonthlyPrice, nil
}

// ClearMonthlyPrice clears the value of the "monthly_price" field.
func (m *SaaSAppMutation) ClearMonthlyPrice() {
	m.monthly_price = nil
	m.clearedFields[saasapp.FieldMonthlyPrice] = struct{}{}
}

// MonthlyPriceCleared returns if the "monthly_price" field was cleared in this mutation.
func (m *SaaSAppMutation) MonthlyPriceCleared() bool {
	_, ok := m.clearedFields[saasapp.FieldMonthlyPrice]
	return ok
}

// ResetMonthlyPrice resets all changes to the "monthly_price" field.
func (m *SaaSAppMutation) ResetMonthlyPrice() {
	m.monthly_price = nil
	delete(m.clearedFields, saasapp.FieldMonthlyPrice)
}

// SetCreatedAt sets the "created_at" field.
func (m *SaaSAppMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *SaaSAppMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the SaaSApp entity.
// If the SaaSApp object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SaaSAppMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *SaaSAppMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *SaaSAppMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *SaaSAppMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the SaaSApp entity.
// If the SaaSApp object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SaaSAppMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *SaaSAppMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// AddIdentityIDs adds the "identities" edge to the SaaSIdentity entity by ids.
func (m *SaaSAppMutation) AddIdentityIDs(ids ...int) {
	if m.identities == nil {
		m.identities = make(map[int]struct{})
	}
	for i := range ids {
		m.identities[ids[i]] = struct{}{}
	}
}

// ClearIdentities clears the "identities" edge to the SaaSIdentity entity.
func (m *SaaSAppMutation) ClearIdentities() {
	m.clearedidentities = true
}

// IdentitiesCleared reports if the "identities" edge to the SaaSIdentity entity was cleared.
func (m *SaaSAppMutation) IdentitiesCleared() bool {
	return m.clearedidentities
}

// RemoveIdentityIDs removes the "identities" edge to the SaaSIdentity entity by IDs.
func (m *SaaSAppMutation) RemoveIdentityIDs(ids ...int) {
	if m.removedidentities == nil {
		m.removedidentities = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.identities, ids[i])
		m.removedidentities[ids[i]] = struct{}{}
	}
}

// RemovedIdentities returns the removed IDs of the "identities" edge to the SaaSIdentity entity.
func (m *SaaSAppMutation) RemovedIdentitiesIDs() (ids []int) {
	for id := range m.removedidentities {
		ids = append(ids, id)
	}
	return
}

// IdentitiesIDs returns the "identities" edge IDs in the mutation.
func (m *SaaSAppMutation) IdentitiesIDs() (ids []int) {
	for id := range m.identities {
		ids = append(ids, id)
	}
	return
}

// ResetIdentities resets all changes to the "identities" edge.
func (m *SaaSAppMutation) ResetIdentities() {
	m.identities = nil
	m.clearedidentities = false
	m.removedidentities = nil
}

// AddFilterIDs adds the "filters" edge to the SaaSFilter entity by ids.
func (m *SaaSAppMutation) AddFilterIDs(ids ...int) {
	if m.filters == nil {
		m.filters = make(map[int]struct{})
	}
	for i := range ids {
		m.filters[ids[i]] = struct{}{}
	}
}

// ClearFilters clears the "filters" edge to the SaaSFilter entity.
func (m *SaaSAppMutation) ClearFilters() {
	m.clearedfilters = true
}

// FiltersCleared reports if the "filters" edge to the SaaSFilter entity was cleared.
func (m *SaaSAppMutation) FiltersCleared() bool {
	return m.clearedfilters
}

// RemoveFilterIDs removes the "filters" edge to the SaaSFilter entity by IDs.
func (m *SaaSAppMutation) RemoveFilterIDs(ids ...int) {
	if m.removedfilters == nil {
		m.removedfilters = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.filters, ids[i])
		m.removedfilters[ids[i]] = struct{}{}
	}
}

// RemovedFilters returns the removed IDs of the "filters" edge to the SaaSFilter entity.
func (m *SaaSAppMutation) RemovedFiltersIDs() (ids []int) {
	for id := range m.removedfilters {
		ids = append(ids, id)
	}
	return
}

// FiltersIDs returns the "filters" edge IDs in the mutation.
func (m *SaaSAppMutation) FiltersIDs() (ids []int) {
	for id := range m.filters {
		ids = append(ids, id)
	}
	return
}

// ResetFilters resets all changes to the "filters" edge.
func (m *SaaSAppMutation) ResetFilters() {
	m.filters = nil
	m.clearedfilters = false
	m.removedfilters = nil
}

// SetTenantID sets the "tenant" edge to the Tenant entity by id.
func (m *SaaSAppMutation) SetTenantID(id int) {
	m.tenant = &id
}

// ClearTenant clears the "tenant" edge to the Tenant entity.
func (m *SaaSAppMutation) ClearTenant() {
	m.clearedtenant = true
}

// TenantCleared reports if the "tenant" edge to the Tenant entity was cleared.
func (m *SaaSAppMutation) TenantCleared() bool {
	return m.clearedtenant
}

// TenantID returns the "tenant" edge ID in the mutation.
func (m *SaaSAppMutation) TenantID() (id int, exists bool) {
	if m.tenant != nil {
		return *m.tenant, true
	}
	return
}

// TenantIDs returns the "tenant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TenantID instead. It exists only for internal usage by the builders.
func (m *SaaSAppMutation) TenantIDs() (ids []int) {
	if id := m.tenant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTenant resets all changes to the "tenant" edge.
func (m *SaaSAppMutation) ResetTenant() {
	m.tenant = nil
	m.clearedtenant = false
}

// Where appends a list predicates to the SaaSAppMutation builder.
func (m *SaaSAppMutation) Where(ps ...predicate.SaaSApp) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SaaSAppMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SaaSAppMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.SaaSApp, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SaaSAppMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SaaSAppMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (SaaSApp).
func (m *SaaSAppMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SaaSAppMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.name != nil {
		fields = append(fields, saasapp.FieldName)
	}
	if m.provider != nil {
		fields = append(fields, saasapp.FieldProvider)
	}
	if m.category != nil {
		fields = append(fields, saasapp.FieldCategory)
	}
	if m.url != nil {
		fields = append(fields, saasapp.FieldURL)
	}
	if m.is_managed != nil {
		fields = append(fields, saasapp.FieldIsManaged)
	}
	if m._config != nil {
		fields = append(fields, saasapp.FieldConfig)
	}
	if m.monthly_price != nil {
		fields = append(fields, saasapp.FieldMonthlyPrice)
	}
	if m.created_at != nil {
		fields = append(fields, saasapp.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, saasapp.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SaaSAppMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case saasapp.FieldName:
		return m.Name()
	case saasapp.FieldProvider:
		return m.Provider()
	case saasapp.FieldCategory:
		return m.Category()
	case saasapp.FieldURL:
		return m.URL()
	case saasapp.FieldIsManaged:
		return m.IsManaged()
	case saasapp.FieldConfig:
		return m.Config()
	case saasapp.FieldMonthlyPrice:
		return m.MonthlyPrice()
	case saasapp.FieldCreatedAt:
		return m.CreatedAt()
	case saasapp.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SaaSAppMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case saasapp.FieldName:
		return m.OldName(ctx)
	case saasapp.FieldProvider:
		return m.OldProvider(ctx)
	case saasapp.FieldCategory:
		return m.OldCategory(ctx)
	case saasapp.FieldURL:
		return m.OldURL(ctx)
	case saasapp.FieldIsManaged:
		return m.OldIsManaged(ctx)
	case saasapp.FieldConfig:
		return m.OldConfig(ctx)
	case saasapp.FieldMonthlyPrice:
		return m.OldMonthlyPrice(ctx)
	case saasapp.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case saasapp.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown SaaSApp field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SaaSAppMutation) SetField(name string, value ent.Value) error {
	switch name {
	case saasapp.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case saasapp.FieldProvider:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProvider(v)
		return nil
	case saasapp.FieldCategory:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCategory(v)
		return nil
	case saasapp.FieldURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetURL(v)
		return nil
	case saasapp.FieldIsManaged:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsManaged(v)
		return nil
	case saasapp.FieldConfig:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetConfig(v)
		return nil
	case saasapp.FieldMonthlyPrice:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMonthlyPrice(v)
		return nil
	case saasapp.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case saasapp.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown SaaSApp field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SaaSAppMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SaaSAppMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SaaSAppMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown SaaSApp numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SaaSAppMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(saasapp.FieldCategory) {
		fields = append(fields, saasapp.FieldCategory)
	}
	if m.FieldCleared(saasapp.FieldURL) {
		fields = append(fields, saasapp.FieldURL)
	}
	if m.FieldCleared(saasapp.FieldMonthlyPrice) {
		fields = append(fields, saasapp.FieldMonthlyPrice)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SaaSAppMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SaaSAppMutation) ClearField(name string) error {
	switch name {
	case saasapp.FieldCategory:
		m.ClearCategory()
		return nil
	case saasapp.FieldURL:
		m.ClearURL()
		return nil
	case saasapp.FieldMonthlyPrice:
		m.ClearMonthlyPrice()
		return nil
	}
	return fmt.Errorf("unknown SaaSApp nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SaaSAppMutation) ResetField(name string) error {
	switch name {
	case saasapp.FieldName:
		m.ResetName()
		return nil
	case saasapp.FieldProvider:
		m.ResetProvider()
		return nil
	case saasapp.FieldCategory:
		m.ResetCategory()
		return nil
	case saasapp.FieldURL:
		m.ResetURL()
		return nil
	case saasapp.FieldIsManaged:
		m.ResetIsManaged()
		return nil
	case saasapp.FieldConfig:
		m.ResetConfig()
		return nil
	case saasapp.FieldMonthlyPrice:
		m.ResetMonthlyPrice()
		return nil
	case saasapp.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case saasapp.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown SaaSApp field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SaaSAppMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.identities != nil {
		edges = append(edges, saasapp.EdgeIdentities)
	}
	if m.filters != nil {
		edges = append(edges, saasapp.EdgeFilters)
	}
	if m.tenant != nil {
		edges = append(edges, saasapp.EdgeTenant)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SaaSAppMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case saasapp.EdgeIdentities:
		ids := make([]ent.Value, 0, len(m.identities))
		for id := range m.identities {
			ids = append(ids, id)
		}
		return ids
	case saasapp.EdgeFilters:
		ids := make([]ent.Value, 0, len(m.filters))
		for id := range m.filters {
			ids = append(ids, id)
		}
		return ids
	case saasapp.EdgeTenant:
		if id := m.tenant; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SaaSAppMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedidentities != nil {
		edges = append(edges, saasapp.EdgeIdentities)
	}
	if m.removedfilters != nil {
		edges = append(edges, saasapp.EdgeFilters)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SaaSAppMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case saasapp.EdgeIdentities:
		ids := make([]ent.Value, 0, len(m.removedidentities))
		for id := range m.removedidentities {
			ids = append(ids, id)
		}
		return ids
	case saasapp.EdgeFilters:
		ids := make([]ent.Value, 0, len(m.removedfilters))
		for id := range m.removedfilters {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SaaSAppMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedidentities {
		edges = append(edges, saasapp.EdgeIdentities)
	}
	if m.clearedfilters {
		edges = append(edges, saasapp.EdgeFilters)
	}
	if m.clearedtenant {
		edges = append(edges, saasapp.EdgeTenant)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SaaSAppMutation) EdgeCleared(name string) bool {
	switch name {
	case saasapp.EdgeIdentities:
		return m.clearedidentities
	case saasapp.EdgeFilters:
		return m.clearedfilters
	case saasapp.EdgeTenant:
		return m.clearedtenant
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SaaSAppMutation) ClearEdge(name string) error {
	switch name {
	case saasapp.EdgeTenant:
		m.ClearTenant()
		return nil
	}
	return fmt.Errorf("unknown SaaSApp unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SaaSAppMutation) ResetEdge(name string) error {
	switch name {
	case saasapp.EdgeIdentities:
		m.ResetIdentities()
		return nil
	case saasapp.EdgeFilters:
		m.ResetFilters()
		return nil
	case saasapp.EdgeTenant:
		m.ResetTenant()
		return nil
	}
	return fmt.Errorf("unknown SaaSApp edge %s", name)
}

// SaaSFilterMutation represents an operation that mutates the SaaSFilter nodes in the graph.
type SaaSFilterMutation struct {
	config
	op             Op
	typ            string
	id             *int
	name           *string
	domain_pattern *string
	action         *saasfilter.Action
	reason         *string
	is_sni_based   *bool
	created_at     *time.Time
	updated_at     *time.Time
	clearedFields  map[string]struct{}
	app            *int
	clearedapp     bool
	tenant         *int
	clearedtenant  bool
	done           bool
	oldValue       func(context.Context) (*SaaSFilter, error)
	predicates     []predicate.SaaSFilter
}

var _ ent.Mutation = (*SaaSFilterMutation)(nil)

// saasfilterOption allows management of the mutation configuration using functional options.
type saasfilterOption func(*SaaSFilterMutation)

// newSaaSFilterMutation creates new mutation for the SaaSFilter entity.
func newSaaSFilterMutation(c config, op Op, opts ...saasfilterOption) *SaaSFilterMutation {
	m := &SaaSFilterMutation{
		config:        c,
		op:            op,
		typ:           TypeSaaSFilter,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSaaSFilterID sets the ID field of the mutation.
func withSaaSFilterID(id int) saasfilterOption {
	return func(m *SaaSFilterMutation) {
		var (
			err   error
			once  sync.Once
			value *SaaSFilter
		)
		m.oldValue = func(ctx context.Context) (*SaaSFilter, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().SaaSFilter.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSaaSFilter sets the old SaaSFilter of the mutation.
func withSaaSFilter(node *SaaSFilter) saasfilterOption {
	return func(m *SaaSFilterMutation) {
		m.oldValue = func(context.Context) (*SaaSFilter, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SaaSFilterMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SaaSFilterMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SaaSFilterMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SaaSFilterMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().SaaSFilter.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *SaaSFilterMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *SaaSFilterMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the SaaSFilter entity.
// If the SaaSFilter object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SaaSFilterMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *SaaSFilterMutation) ResetName() {
	m.name = nil
}

// SetDomainPattern sets the "domain_pattern" field.
func (m *SaaSFilterMutation) SetDomainPattern(s string) {
	m.domain_pattern = &s
}

// DomainPattern returns the value of the "domain_pattern" field in the mutation.
func (m *SaaSFilterMutation) DomainPattern() (r string, exists bool) {
	v := m.domain_pattern
	if v == nil {
		return
	}
	return *v, true
}

// OldDomainPattern returns the old "domain_pattern" field's value of the SaaSFilter entity.
// If the SaaSFilter object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SaaSFilterMutation) OldDomainPattern(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDomainPattern is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDomainPattern requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDomainPattern: %w", err)
	}
	return oldValue.DomainPattern, nil
}

// ResetDomainPattern resets all changes to the "domain_pattern" field.
func (m *SaaSFilterMutation) ResetDomainPattern() {
	m.domain_pattern = nil
}

// SetAction sets the "action" field.
func (m *SaaSFilterMutation) SetAction(s saasfilter.Action) {
	m.action = &s
}

// Action returns the value of the "action" field in the mutation.
func (m *SaaSFilterMutation) Action() (r saasfilter.Action, exists bool) {
	v := m.action
	if v == nil {
		return
	}
	return *v, true
}

// OldAction returns the old "action" field's value of the SaaSFilter entity.
// If the SaaSFilter object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SaaSFilterMutation) OldAction(ctx context.Context) (v saasfilter.Action, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAction is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAction requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAction: %w", err)
	}
	return oldValue.Action, nil
}

// ResetAction resets all changes to the "action" field.
func (m *SaaSFilterMutation) ResetAction() {
	m.action = nil
}

// SetReason sets the "reason" field.
func (m *SaaSFilterMutation) SetReason(s string) {
	m.reason = &s
}

// Reason returns the value of the "reason" field in the mutation.
func (m *SaaSFilterMutation) Reason() (r string, exists bool) {
	v := m.reason
	if v == nil {
		return
	}
	return *v, true
}

// OldReason returns the old "reason" field's value of the SaaSFilter entity.
// If the SaaSFilter object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SaaSFilterMutation) OldReason(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReason is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReason requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReason: %w", err)
	}
	return oldValue.Reason, nil
}

// ClearReason clears the value of the "reason" field.
func (m *SaaSFilterMutation) ClearReason() {
	m.reason = nil
	m.clearedFields[saasfilter.FieldReason] = struct{}{}
}

// ReasonCleared returns if the "reason" field was cleared in this mutation.
func (m *SaaSFilterMutation) ReasonCleared() bool {
	_, ok := m.clearedFields[saasfilter.FieldReason]
	return ok
}

// ResetReason resets all changes to the "reason" field.
func (m *SaaSFilterMutation) ResetReason() {
	m.reason = nil
	delete(m.clearedFields, saasfilter.FieldReason)
}

// SetIsSniBased sets the "is_sni_based" field.
func (m *SaaSFilterMutation) SetIsSniBased(b bool) {
	m.is_sni_based = &b
}

// IsSniBased returns the value of the "is_sni_based" field in the mutation.
func (m *SaaSFilterMutation) IsSniBased() (r bool, exists bool) {
	v := m.is_sni_based
	if v == nil {
		return
	}
	return *v, true
}

// OldIsSniBased returns the old "is_sni_based" field's value of the SaaSFilter entity.
// If the SaaSFilter object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SaaSFilterMutation) OldIsSniBased(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsSniBased is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsSniBased requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsSniBased: %w", err)
	}
	return oldValue.IsSniBased, nil
}

// ResetIsSniBased resets all changes to the "is_sni_based" field.
func (m *SaaSFilterMutation) ResetIsSniBased() {
	m.is_sni_based = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *SaaSFilterMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *SaaSFilterMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the SaaSFilter entity.
// If the SaaSFilter object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SaaSFilterMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *SaaSFilterMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *SaaSFilterMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *SaaSFilterMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the SaaSFilter entity.
// If the SaaSFilter object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SaaSFilterMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *SaaSFilterMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetAppID sets the "app" edge to the SaaSApp entity by id.
func (m *SaaSFilterMutation) SetAppID(id int) {
	m.app = &id
}

// ClearApp clears the "app" edge to the SaaSApp entity.
func (m *SaaSFilterMutation) ClearApp() {
	m.clearedapp = true
}

// AppCleared reports if the "app" edge to the SaaSApp entity was cleared.
func (m *SaaSFilterMutation) AppCleared() bool {
	return m.clearedapp
}

// AppID returns the "app" edge ID in the mutation.
func (m *SaaSFilterMutation) AppID() (id int, exists bool) {
	if m.app != nil {
		return *m.app, true
	}
	return
}

// AppIDs returns the "app" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AppID instead. It exists only for internal usage by the builders.
func (m *SaaSFilterMutation) AppIDs() (ids []int) {
	if id := m.app; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetApp resets all changes to the "app" edge.
func (m *SaaSFilterMutation) ResetApp() {
	m.app = nil
	m.clearedapp = false
}

// SetTenantID sets the "tenant" edge to the Tenant entity by id.
func (m *SaaSFilterMutation) SetTenantID(id int) {
	m.tenant = &id
}

// ClearTenant clears the "tenant" edge to the Tenant entity.
func (m *SaaSFilterMutation) ClearTenant() {
	m.clearedtenant = true
}

// TenantCleared reports if the "tenant" edge to the Tenant entity was cleared.
func (m *SaaSFilterMutation) TenantCleared() bool {
	return m.clearedtenant
}

// TenantID returns the "tenant" edge ID in the mutation.
func (m *SaaSFilterMutation) TenantID() (id int, exists bool) {
	if m.tenant != nil {
		return *m.tenant, true
	}
	return
}

// TenantIDs returns the "tenant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TenantID instead. It exists only for internal usage by the builders.
func (m *SaaSFilterMutation) TenantIDs() (ids []int) {
	if id := m.tenant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTenant resets all changes to the "tenant" edge.
func (m *SaaSFilterMutation) ResetTenant() {
	m.tenant = nil
	m.clearedtenant = false
}

// Where appends a list predicates to the SaaSFilterMutation builder.
func (m *SaaSFilterMutation) Where(ps ...predicate.SaaSFilter) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SaaSFilterMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SaaSFilterMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.SaaSFilter, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SaaSFilterMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SaaSFilterMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (SaaSFilter).
func (m *SaaSFilterMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SaaSFilterMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.name != nil {
		fields = append(fields, saasfilter.FieldName)
	}
	if m.domain_pattern != nil {
		fields = append(fields, saasfilter.FieldDomainPattern)
	}
	if m.action != nil {
		fields = append(fields, saasfilter.FieldAction)
	}
	if m.reason != nil {
		fields = append(fields, saasfilter.FieldReason)
	}
	if m.is_sni_based != nil {
		fields = append(fields, saasfilter.FieldIsSniBased)
	}
	if m.created_at != nil {
		fields = append(fields, saasfilter.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, saasfilter.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SaaSFilterMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case saasfilter.FieldName:
		return m.Name()
	case saasfilter.FieldDomainPattern:
		return m.DomainPattern()
	case saasfilter.FieldAction:
		return m.Action()
	case saasfilter.FieldReason:
		return m.Reason()
	case saasfilter.FieldIsSniBased:
		return m.IsSniBased()
	case saasfilter.FieldCreatedAt:
		return m.CreatedAt()
	case saasfilter.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SaaSFilterMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case saasfilter.FieldName:
		return m.OldName(ctx)
	case saasfilter.FieldDomainPattern:
		return m.OldDomainPattern(ctx)
	case saasfilter.FieldAction:
		return m.OldAction(ctx)
	case saasfilter.FieldReason:
		return m.OldReason(ctx)
	case saasfilter.FieldIsSniBased:
		return m.OldIsSniBased(ctx)
	case saasfilter.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case saasfilter.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown SaaSFilter field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SaaSFilterMutation) SetField(name string, value ent.Value) error {
	switch name {
	case saasfilter.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case saasfilter.FieldDomainPattern:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDomainPattern(v)
		return nil
	case saasfilter.FieldAction:
		v, ok := value.(saasfilter.Action)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAction(v)
		return nil
	case saasfilter.FieldReason:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReason(v)
		return nil
	case saasfilter.FieldIsSniBased:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsSniBased(v)
		return nil
	case saasfilter.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case saasfilter.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown SaaSFilter field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SaaSFilterMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SaaSFilterMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SaaSFilterMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown SaaSFilter numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SaaSFilterMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(saasfilter.FieldReason) {
		fields = append(fields, saasfilter.FieldReason)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SaaSFilterMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SaaSFilterMutation) ClearField(name string) error {
	switch name {
	case saasfilter.FieldReason:
		m.ClearReason()
		return nil
	}
	return fmt.Errorf("unknown SaaSFilter nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SaaSFilterMutation) ResetField(name string) error {
	switch name {
	case saasfilter.FieldName:
		m.ResetName()
		return nil
	case saasfilter.FieldDomainPattern:
		m.ResetDomainPattern()
		return nil
	case saasfilter.FieldAction:
		m.ResetAction()
		return nil
	case saasfilter.FieldReason:
		m.ResetReason()
		return nil
	case saasfilter.FieldIsSniBased:
		m.ResetIsSniBased()
		return nil
	case saasfilter.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case saasfilter.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown SaaSFilter field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SaaSFilterMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.app != nil {
		edges = append(edges, saasfilter.EdgeApp)
	}
	if m.tenant != nil {
		edges = append(edges, saasfilter.EdgeTenant)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SaaSFilterMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case saasfilter.EdgeApp:
		if id := m.app; id != nil {
			return []ent.Value{*id}
		}
	case saasfilter.EdgeTenant:
		if id := m.tenant; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SaaSFilterMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SaaSFilterMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SaaSFilterMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedapp {
		edges = append(edges, saasfilter.EdgeApp)
	}
	if m.clearedtenant {
		edges = append(edges, saasfilter.EdgeTenant)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SaaSFilterMutation) EdgeCleared(name string) bool {
	switch name {
	case saasfilter.EdgeApp:
		return m.clearedapp
	case saasfilter.EdgeTenant:
		return m.clearedtenant
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SaaSFilterMutation) ClearEdge(name string) error {
	switch name {
	case saasfilter.EdgeApp:
		m.ClearApp()
		return nil
	case saasfilter.EdgeTenant:
		m.ClearTenant()
		return nil
	}
	return fmt.Errorf("unknown SaaSFilter unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SaaSFilterMutation) ResetEdge(name string) error {
	switch name {
	case saasfilter.EdgeApp:
		m.ResetApp()
		return nil
	case saasfilter.EdgeTenant:
		m.ResetTenant()
		return nil
	}
	return fmt.Errorf("unknown SaaSFilter edge %s", name)
}

// SaaSIdentityMutation represents an operation that mutates the SaaSIdentity nodes in the graph.
type SaaSIdentityMutation struct {
	config
	op            Op
	typ           string
	id            *int
	external_id   *string
	email         *string
	display_name  *string
	current_plan  *string
	metadata      *map[string]interface{}
	mfa_enabled   *bool
	last_login    *time.Time
	created_at    *time.Time
	updated_at    *time.Time
	clearedFields map[string]struct{}
	user          *int
	cleareduser   bool
	app           *int
	clearedapp    bool
	usages        map[int]struct{}
	removedusages map[int]struct{}
	clearedusages bool
	tenant        *int
	clearedtenant bool
	done          bool
	oldValue      func(context.Context) (*SaaSIdentity, error)
	predicates    []predicate.SaaSIdentity
}

var _ ent.Mutation = (*SaaSIdentityMutation)(nil)

// saasidentityOption allows management of the mutation configuration using functional options.
type saasidentityOption func(*SaaSIdentityMutation)

// newSaaSIdentityMutation creates new mutation for the SaaSIdentity entity.
func newSaaSIdentityMutation(c config, op Op, opts ...saasidentityOption) *SaaSIdentityMutation {
	m := &SaaSIdentityMutation{
		config:        c,
		op:            op,
		typ:           TypeSaaSIdentity,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSaaSIdentityID sets the ID field of the mutation.
func withSaaSIdentityID(id int) saasidentityOption {
	return func(m *SaaSIdentityMutation) {
		var (
			err   error
			once  sync.Once
			value *SaaSIdentity
		)
		m.oldValue = func(ctx context.Context) (*SaaSIdentity, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().SaaSIdentity.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSaaSIdentity sets the old SaaSIdentity of the mutation.
func withSaaSIdentity(node *SaaSIdentity) saasidentityOption {
	return func(m *SaaSIdentityMutation) {
		m.oldValue = func(context.Context) (*SaaSIdentity, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SaaSIdentityMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SaaSIdentityMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SaaSIdentityMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SaaSIdentityMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().SaaSIdentity.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetExternalID sets the "external_id" field.
func (m *SaaSIdentityMutation) SetExternalID(s string) {
	m.external_id = &s
}

// ExternalID returns the value of the "external_id" field in the mutation.
func (m *SaaSIdentityMutation) ExternalID() (r string, exists bool) {
	v := m.external_id
	if v == nil {
		return
	}
	return *v, true
}

// OldExternalID returns the old "external_id" field's value of the SaaSIdentity entity.
// If the SaaSIdentity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SaaSIdentityMutation) OldExternalID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExternalID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExternalID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExternalID: %w", err)
	}
	return oldValue.ExternalID, nil
}

// ResetExternalID resets all changes to the "external_id" field.
func (m *SaaSIdentityMutation) ResetExternalID() {
	m.external_id = nil
}

// SetEmail sets the "email" field.
func (m *SaaSIdentityMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *SaaSIdentityMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the SaaSIdentity entity.
// If the SaaSIdentity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SaaSIdentityMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail resets all changes to the "email" field.
func (m *SaaSIdentityMutation) ResetEmail() {
	m.email = nil
}

// SetDisplayName sets the "display_name" field.
func (m *SaaSIdentityMutation) SetDisplayName(s string) {
	m.display_name = &s
}

// DisplayName returns the value of the "display_name" field in the mutation.
func (m *SaaSIdentityMutation) DisplayName() (r string, exists bool) {
	v := m.display_name
	if v == nil {
		return
	}
	return *v, true
}

// OldDisplayName returns the old "display_name" field's value of the SaaSIdentity entity.
// If the SaaSIdentity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SaaSIdentityMutation) OldDisplayName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisplayName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisplayName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisplayName: %w", err)
	}
	return oldValue.DisplayName, nil
}

// ClearDisplayName clears the value of the "display_name" field.
func (m *SaaSIdentityMutation) ClearDisplayName() {
	m.display_name = nil
	m.clearedFields[saasidentity.FieldDisplayName] = struct{}{}
}

// DisplayNameCleared returns if the "display_name" field was cleared in this mutation.
func (m *SaaSIdentityMutation) DisplayNameCleared() bool {
	_, ok := m.clearedFields[saasidentity.FieldDisplayName]
	return ok
}

// ResetDisplayName resets all changes to the "display_name" field.
func (m *SaaSIdentityMutation) ResetDisplayName() {
	m.display_name = nil
	delete(m.clearedFields, saasidentity.FieldDisplayName)
}

// SetCurrentPlan sets the "current_plan" field.
func (m *SaaSIdentityMutation) SetCurrentPlan(s string) {
	m.current_plan = &s
}

// CurrentPlan returns the value of the "current_plan" field in the mutation.
func (m *SaaSIdentityMutation) CurrentPlan() (r string, exists bool) {
	v := m.current_plan
	if v == nil {
		return
	}
	return *v, true
}

// OldCurrentPlan returns the old "current_plan" field's value of the SaaSIdentity entity.
// If the SaaSIdentity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SaaSIdentityMutation) OldCurrentPlan(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCurrentPlan is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCurrentPlan requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCurrentPlan: %w", err)
	}
	return oldValue.CurrentPlan, nil
}

// ClearCurrentPlan clears the value of the "current_plan" field.
func (m *SaaSIdentityMutation) ClearCurrentPlan() {
	m.current_plan = nil
	m.clearedFields[saasidentity.FieldCurrentPlan] = struct{}{}
}

// CurrentPlanCleared returns if the "current_plan" field was cleared in this mutation.
func (m *SaaSIdentityMutation) CurrentPlanCleared() bool {
	_, ok := m.clearedFields[saasidentity.FieldCurrentPlan]
	return ok
}

// ResetCurrentPlan resets all changes to the "current_plan" field.
func (m *SaaSIdentityMutation) ResetCurrentPlan() {
	m.current_plan = nil
	delete(m.clearedFields, saasidentity.FieldCurrentPlan)
}

// SetMetadata sets the "metadata" field.
func (m *SaaSIdentityMutation) SetMetadata(value map[string]interface{}) {
	m.metadata = &value
}

// Metadata returns the value of the "metadata" field in the mutation.
func (m *SaaSIdentityMutation) Metadata() (r map[string]interface{}, exists bool) {
	v := m.metadata
	if v == nil {
		return
	}
	return *v, true
}

// OldMetadata returns the old "metadata" field's value of the SaaSIdentity entity.
// If the SaaSIdentity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SaaSIdentityMutation) OldMetadata(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMetadata is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMetadata requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetadata: %w", err)
	}
	return oldValue.Metadata, nil
}

// ResetMetadata resets all changes to the "metadata" field.
func (m *SaaSIdentityMutation) ResetMetadata() {
	m.metadata = nil
}

// SetMfaEnabled sets the "mfa_enabled" field.
func (m *SaaSIdentityMutation) SetMfaEnabled(b bool) {
	m.mfa_enabled = &b
}

// MfaEnabled returns the value of the "mfa_enabled" field in the mutation.
func (m *SaaSIdentityMutation) MfaEnabled() (r bool, exists bool) {
	v := m.mfa_enabled
	if v == nil {
		return
	}
	return *v, true
}

// OldMfaEnabled returns the old "mfa_enabled" field's value of the SaaSIdentity entity.
// If the SaaSIdentity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SaaSIdentityMutation) OldMfaEnabled(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMfaEnabled is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMfaEnabled requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMfaEnabled: %w", err)
	}
	return oldValue.MfaEnabled, nil
}

// ResetMfaEnabled resets all changes to the "mfa_enabled" field.
func (m *SaaSIdentityMutation) ResetMfaEnabled() {
	m.mfa_enabled = nil
}

// SetLastLogin sets the "last_login" field.
func (m *SaaSIdentityMutation) SetLastLogin(t time.Time) {
	m.last_login = &t
}

// LastLogin returns the value of the "last_login" field in the mutation.
func (m *SaaSIdentityMutation) LastLogin() (r time.Time, exists bool) {
	v := m.last_login
	if v == nil {
		return
	}
	return *v, true
}

// OldLastLogin returns the old "last_login" field's value of the SaaSIdentity entity.
// If the SaaSIdentity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SaaSIdentityMutation) OldLastLogin(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastLogin is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastLogin requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastLogin: %w", err)
	}
	return oldValue.LastLogin, nil
}

// ClearLastLogin clears the value of the "last_login" field.
func (m *SaaSIdentityMutation) ClearLastLogin() {
	m.last_login = nil
	m.clearedFields[saasidentity.FieldLastLogin] = struct{}{}
}

// LastLoginCleared returns if the "last_login" field was cleared in this mutation.
func (m *SaaSIdentityMutation) LastLoginCleared() bool {
	_, ok := m.clearedFields[saasidentity.FieldLastLogin]
	return ok
}

// ResetLastLogin resets all changes to the "last_login" field.
func (m *SaaSIdentityMutation) ResetLastLogin() {
	m.last_login = nil
	delete(m.clearedFields, saasidentity.FieldLastLogin)
}

// SetCreatedAt sets the "created_at" field.
func (m *SaaSIdentityMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *SaaSIdentityMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the SaaSIdentity entity.
// If the SaaSIdentity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SaaSIdentityMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *SaaSIdentityMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *SaaSIdentityMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *SaaSIdentityMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the SaaSIdentity entity.
// If the SaaSIdentity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SaaSIdentityMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *SaaSIdentityMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetUserID sets the "user" edge to the User entity by id.
func (m *SaaSIdentityMutation) SetUserID(id int) {
	m.user = &id
}

// ClearUser clears the "user" edge to the User entity.
func (m *SaaSIdentityMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *SaaSIdentityMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *SaaSIdentityMutation) UserID() (id int, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *SaaSIdentityMutation) UserIDs() (ids []int) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *SaaSIdentityMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// SetAppID sets the "app" edge to the SaaSApp entity by id.
func (m *SaaSIdentityMutation) SetAppID(id int) {
	m.app = &id
}

// ClearApp clears the "app" edge to the SaaSApp entity.
func (m *SaaSIdentityMutation) ClearApp() {
	m.clearedapp = true
}

// AppCleared reports if the "app" edge to the SaaSApp entity was cleared.
func (m *SaaSIdentityMutation) AppCleared() bool {
	return m.clearedapp
}

// AppID returns the "app" edge ID in the mutation.
func (m *SaaSIdentityMutation) AppID() (id int, exists bool) {
	if m.app != nil {
		return *m.app, true
	}
	return
}

// AppIDs returns the "app" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AppID instead. It exists only for internal usage by the builders.
func (m *SaaSIdentityMutation) AppIDs() (ids []int) {
	if id := m.app; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetApp resets all changes to the "app" edge.
func (m *SaaSIdentityMutation) ResetApp() {
	m.app = nil
	m.clearedapp = false
}

// AddUsageIDs adds the "usages" edge to the SaaSUsage entity by ids.
func (m *SaaSIdentityMutation) AddUsageIDs(ids ...int) {
	if m.usages == nil {
		m.usages = make(map[int]struct{})
	}
	for i := range ids {
		m.usages[ids[i]] = struct{}{}
	}
}

// ClearUsages clears the "usages" edge to the SaaSUsage entity.
func (m *SaaSIdentityMutation) ClearUsages() {
	m.clearedusages = true
}

// UsagesCleared reports if the "usages" edge to the SaaSUsage entity was cleared.
func (m *SaaSIdentityMutation) UsagesCleared() bool {
	return m.clearedusages
}

// RemoveUsageIDs removes the "usages" edge to the SaaSUsage entity by IDs.
func (m *SaaSIdentityMutation) RemoveUsageIDs(ids ...int) {
	if m.removedusages == nil {
		m.removedusages = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.usages, ids[i])
		m.removedusages[ids[i]] = struct{}{}
	}
}

// RemovedUsages returns the removed IDs of the "usages" edge to the SaaSUsage entity.
func (m *SaaSIdentityMutation) RemovedUsagesIDs() (ids []int) {
	for id := range m.removedusages {
		ids = append(ids, id)
	}
	return
}

// UsagesIDs returns the "usages" edge IDs in the mutation.
func (m *SaaSIdentityMutation) UsagesIDs() (ids []int) {
	for id := range m.usages {
		ids = append(ids, id)
	}
	return
}

// ResetUsages resets all changes to the "usages" edge.
func (m *SaaSIdentityMutation) ResetUsages() {
	m.usages = nil
	m.clearedusages = false
	m.removedusages = nil
}

// SetTenantID sets the "tenant" edge to the Tenant entity by id.
func (m *SaaSIdentityMutation) SetTenantID(id int) {
	m.tenant = &id
}

// ClearTenant clears the "tenant" edge to the Tenant entity.
func (m *SaaSIdentityMutation) ClearTenant() {
	m.clearedtenant = true
}

// TenantCleared reports if the "tenant" edge to the Tenant entity was cleared.
func (m *SaaSIdentityMutation) TenantCleared() bool {
	return m.clearedtenant
}

// TenantID returns the "tenant" edge ID in the mutation.
func (m *SaaSIdentityMutation) TenantID() (id int, exists bool) {
	if m.tenant != nil {
		return *m.tenant, true
	}
	return
}

// TenantIDs returns the "tenant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TenantID instead. It exists only for internal usage by the builders.
func (m *SaaSIdentityMutation) TenantIDs() (ids []int) {
	if id := m.tenant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTenant resets all changes to the "tenant" edge.
func (m *SaaSIdentityMutation) ResetTenant() {
	m.tenant = nil
	m.clearedtenant = false
}

// Where appends a list predicates to the SaaSIdentityMutation builder.
func (m *SaaSIdentityMutation) Where(ps ...predicate.SaaSIdentity) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SaaSIdentityMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SaaSIdentityMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.SaaSIdentity, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SaaSIdentityMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SaaSIdentityMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (SaaSIdentity).
func (m *SaaSIdentityMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SaaSIdentityMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.external_id != nil {
		fields = append(fields, saasidentity.FieldExternalID)
	}
	if m.email != nil {
		fields = append(fields, saasidentity.FieldEmail)
	}
	if m.display_name != nil {
		fields = append(fields, saasidentity.FieldDisplayName)
	}
	if m.current_plan != nil {
		fields = append(fields, saasidentity.FieldCurrentPlan)
	}
	if m.metadata != nil {
		fields = append(fields, saasidentity.FieldMetadata)
	}
	if m.mfa_enabled != nil {
		fields = append(fields, saasidentity.FieldMfaEnabled)
	}
	if m.last_login != nil {
		fields = append(fields, saasidentity.FieldLastLogin)
	}
	if m.created_at != nil {
		fields = append(fields, saasidentity.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, saasidentity.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SaaSIdentityMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case saasidentity.FieldExternalID:
		return m.ExternalID()
	case saasidentity.FieldEmail:
		return m.Email()
	case saasidentity.FieldDisplayName:
		return m.DisplayName()
	case saasidentity.FieldCurrentPlan:
		return m.CurrentPlan()
	case saasidentity.FieldMetadata:
		return m.Metadata()
	case saasidentity.FieldMfaEnabled:
		return m.MfaEnabled()
	case saasidentity.FieldLastLogin:
		return m.LastLogin()
	case saasidentity.FieldCreatedAt:
		return m.CreatedAt()
	case saasidentity.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SaaSIdentityMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case saasidentity.FieldExternalID:
		return m.OldExternalID(ctx)
	case saasidentity.FieldEmail:
		return m.OldEmail(ctx)
	case saasidentity.FieldDisplayName:
		return m.OldDisplayName(ctx)
	case saasidentity.FieldCurrentPlan:
		return m.OldCurrentPlan(ctx)
	case saasidentity.FieldMetadata:
		return m.OldMetadata(ctx)
	case saasidentity.FieldMfaEnabled:
		return m.OldMfaEnabled(ctx)
	case saasidentity.FieldLastLogin:
		return m.OldLastLogin(ctx)
	case saasidentity.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case saasidentity.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown SaaSIdentity field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SaaSIdentityMutation) SetField(name string, value ent.Value) error {
	switch name {
	case saasidentity.FieldExternalID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExternalID(v)
		return nil
	case saasidentity.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case saasidentity.FieldDisplayName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisplayName(v)
		return nil
	case saasidentity.FieldCurrentPlan:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCurrentPlan(v)
		return nil
	case saasidentity.FieldMetadata:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetadata(v)
		return nil
	case saasidentity.FieldMfaEnabled:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMfaEnabled(v)
		return nil
	case saasidentity.FieldLastLogin:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastLogin(v)
		return nil
	case saasidentity.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case saasidentity.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown SaaSIdentity field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SaaSIdentityMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SaaSIdentityMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SaaSIdentityMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown SaaSIdentity numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SaaSIdentityMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(saasidentity.FieldDisplayName) {
		fields = append(fields, saasidentity.FieldDisplayName)
	}
	if m.FieldCleared(saasidentity.FieldCurrentPlan) {
		fields = append(fields, saasidentity.FieldCurrentPlan)
	}
	if m.FieldCleared(saasidentity.FieldLastLogin) {
		fields = append(fields, saasidentity.FieldLastLogin)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SaaSIdentityMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SaaSIdentityMutation) ClearField(name string) error {
	switch name {
	case saasidentity.FieldDisplayName:
		m.ClearDisplayName()
		return nil
	case saasidentity.FieldCurrentPlan:
		m.ClearCurrentPlan()
		return nil
	case saasidentity.FieldLastLogin:
		m.ClearLastLogin()
		return nil
	}
	return fmt.Errorf("unknown SaaSIdentity nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SaaSIdentityMutation) ResetField(name string) error {
	switch name {
	case saasidentity.FieldExternalID:
		m.ResetExternalID()
		return nil
	case saasidentity.FieldEmail:
		m.ResetEmail()
		return nil
	case saasidentity.FieldDisplayName:
		m.ResetDisplayName()
		return nil
	case saasidentity.FieldCurrentPlan:
		m.ResetCurrentPlan()
		return nil
	case saasidentity.FieldMetadata:
		m.ResetMetadata()
		return nil
	case saasidentity.FieldMfaEnabled:
		m.ResetMfaEnabled()
		return nil
	case saasidentity.FieldLastLogin:
		m.ResetLastLogin()
		return nil
	case saasidentity.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case saasidentity.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown SaaSIdentity field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SaaSIdentityMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.user != nil {
		edges = append(edges, saasidentity.EdgeUser)
	}
	if m.app != nil {
		edges = append(edges, saasidentity.EdgeApp)
	}
	if m.usages != nil {
		edges = append(edges, saasidentity.EdgeUsages)
	}
	if m.tenant != nil {
		edges = append(edges, saasidentity.EdgeTenant)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SaaSIdentityMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case saasidentity.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case saasidentity.EdgeApp:
		if id := m.app; id != nil {
			return []ent.Value{*id}
		}
	case saasidentity.EdgeUsages:
		ids := make([]ent.Value, 0, len(m.usages))
		for id := range m.usages {
			ids = append(ids, id)
		}
		return ids
	case saasidentity.EdgeTenant:
		if id := m.tenant; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SaaSIdentityMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedusages != nil {
		edges = append(edges, saasidentity.EdgeUsages)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SaaSIdentityMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case saasidentity.EdgeUsages:
		ids := make([]ent.Value, 0, len(m.removedusages))
		for id := range m.removedusages {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SaaSIdentityMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.cleareduser {
		edges = append(edges, saasidentity.EdgeUser)
	}
	if m.clearedapp {
		edges = append(edges, saasidentity.EdgeApp)
	}
	if m.clearedusages {
		edges = append(edges, saasidentity.EdgeUsages)
	}
	if m.clearedtenant {
		edges = append(edges, saasidentity.EdgeTenant)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SaaSIdentityMutation) EdgeCleared(name string) bool {
	switch name {
	case saasidentity.EdgeUser:
		return m.cleareduser
	case saasidentity.EdgeApp:
		return m.clearedapp
	case saasidentity.EdgeUsages:
		return m.clearedusages
	case saasidentity.EdgeTenant:
		return m.clearedtenant
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SaaSIdentityMutation) ClearEdge(name string) error {
	switch name {
	case saasidentity.EdgeUser:
		m.ClearUser()
		return nil
	case saasidentity.EdgeApp:
		m.ClearApp()
		return nil
	case saasidentity.EdgeTenant:
		m.ClearTenant()
		return nil
	}
	return fmt.Errorf("unknown SaaSIdentity unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SaaSIdentityMutation) ResetEdge(name string) error {
	switch name {
	case saasidentity.EdgeUser:
		m.ResetUser()
		return nil
	case saasidentity.EdgeApp:
		m.ResetApp()
		return nil
	case saasidentity.EdgeUsages:
		m.ResetUsages()
		return nil
	case saasidentity.EdgeTenant:
		m.ResetTenant()
		return nil
	}
	return fmt.Errorf("unknown SaaSIdentity edge %s", name)
}

// SaaSUsageMutation represents an operation that mutates the SaaSUsage nodes in the graph.
type SaaSUsageMutation struct {
	config
	op              Op
	typ             string
	id              *int
	timestamp       *time.Time
	feature_name    *string
	count           *int
	addcount        *int
	metadata        *map[string]interface{}
	clearedFields   map[string]struct{}
	identity        *int
	clearedidentity bool
	tenant          *int
	clearedtenant   bool
	done            bool
	oldValue        func(context.Context) (*SaaSUsage, error)
	predicates      []predicate.SaaSUsage
}

var _ ent.Mutation = (*SaaSUsageMutation)(nil)

// saasusageOption allows management of the mutation configuration using functional options.
type saasusageOption func(*SaaSUsageMutation)

// newSaaSUsageMutation creates new mutation for the SaaSUsage entity.
func newSaaSUsageMutation(c config, op Op, opts ...saasusageOption) *SaaSUsageMutation {
	m := &SaaSUsageMutation{
		config:        c,
		op:            op,
		typ:           TypeSaaSUsage,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSaaSUsageID sets the ID field of the mutation.
func withSaaSUsageID(id int) saasusageOption {
	return func(m *SaaSUsageMutation) {
		var (
			err   error
			once  sync.Once
			value *SaaSUsage
		)
		m.oldValue = func(ctx context.Context) (*SaaSUsage, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().SaaSUsage.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSaaSUsage sets the old SaaSUsage of the mutation.
func withSaaSUsage(node *SaaSUsage) saasusageOption {
	return func(m *SaaSUsageMutation) {
		m.oldValue = func(context.Context) (*SaaSUsage, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SaaSUsageMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SaaSUsageMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SaaSUsageMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SaaSUsageMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().SaaSUsage.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTimestamp sets the "timestamp" field.
func (m *SaaSUsageMutation) SetTimestamp(t time.Time) {
	m.timestamp = &t
}

// Timestamp returns the value of the "timestamp" field in the mutation.
func (m *SaaSUsageMutation) Timestamp() (r time.Time, exists bool) {
	v := m.timestamp
	if v == nil {
		return
	}
	return *v, true
}

// OldTimestamp returns the old "timestamp" field's value of the SaaSUsage entity.
// If the SaaSUsage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SaaSUsageMutation) OldTimestamp(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTimestamp is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTimestamp requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTimestamp: %w", err)
	}
	return oldValue.Timestamp, nil
}

// ResetTimestamp resets all changes to the "timestamp" field.
func (m *SaaSUsageMutation) ResetTimestamp() {
	m.timestamp = nil
}

// SetFeatureName sets the "feature_name" field.
func (m *SaaSUsageMutation) SetFeatureName(s string) {
	m.feature_name = &s
}

// FeatureName returns the value of the "feature_name" field in the mutation.
func (m *SaaSUsageMutation) FeatureName() (r string, exists bool) {
	v := m.feature_name
	if v == nil {
		return
	}
	return *v, true
}

// OldFeatureName returns the old "feature_name" field's value of the SaaSUsage entity.
// If the SaaSUsage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SaaSUsageMutation) OldFeatureName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFeatureName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFeatureName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFeatureName: %w", err)
	}
	return oldValue.FeatureName, nil
}

// ResetFeatureName resets all changes to the "feature_name" field.
func (m *SaaSUsageMutation) ResetFeatureName() {
	m.feature_name = nil
}

// SetCount sets the "count" field.
func (m *SaaSUsageMutation) SetCount(i int) {
	m.count = &i
	m.addcount = nil
}

// Count returns the value of the "count" field in the mutation.
func (m *SaaSUsageMutation) Count() (r int, exists bool) {
	v := m.count
	if v == nil {
		return
	}
	return *v, true
}

// OldCount returns the old "count" field's value of the SaaSUsage entity.
// If the SaaSUsage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SaaSUsageMutation) OldCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCount: %w", err)
	}
	return oldValue.Count, nil
}

// AddCount adds i to the "count" field.
func (m *SaaSUsageMutation) AddCount(i int) {
	if m.addcount != nil {
		*m.addcount += i
	} else {
		m.addcount = &i
	}
}

// AddedCount returns the value that was added to the "count" field in this mutation.
func (m *SaaSUsageMutation) AddedCount() (r int, exists bool) {
	v := m.addcount
	if v == nil {
		return
	}
	return *v, true
}

// ResetCount resets all changes to the "count" field.
func (m *SaaSUsageMutation) ResetCount() {
	m.count = nil
	m.addcount = nil
}

// SetMetadata sets the "metadata" field.
func (m *SaaSUsageMutation) SetMetadata(value map[string]interface{}) {
	m.metadata = &value
}

// Metadata returns the value of the "metadata" field in the mutation.
func (m *SaaSUsageMutation) Metadata() (r map[string]interface{}, exists bool) {
	v := m.metadata
	if v == nil {
		return
	}
	return *v, true
}

// OldMetadata returns the old "metadata" field's value of the SaaSUsage entity.
// If the SaaSUsage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SaaSUsageMutation) OldMetadata(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMetadata is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMetadata requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetadata: %w", err)
	}
	return oldValue.Metadata, nil
}

// ResetMetadata resets all changes to the "metadata" field.
func (m *SaaSUsageMutation) ResetMetadata() {
	m.metadata = nil
}

// SetIdentityID sets the "identity" edge to the SaaSIdentity entity by id.
func (m *SaaSUsageMutation) SetIdentityID(id int) {
	m.identity = &id
}

// ClearIdentity clears the "identity" edge to the SaaSIdentity entity.
func (m *SaaSUsageMutation) ClearIdentity() {
	m.clearedidentity = true
}

// IdentityCleared reports if the "identity" edge to the SaaSIdentity entity was cleared.
func (m *SaaSUsageMutation) IdentityCleared() bool {
	return m.clearedidentity
}

// IdentityID returns the "identity" edge ID in the mutation.
func (m *SaaSUsageMutation) IdentityID() (id int, exists bool) {
	if m.identity != nil {
		return *m.identity, true
	}
	return
}

// IdentityIDs returns the "identity" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// IdentityID instead. It exists only for internal usage by the builders.
func (m *SaaSUsageMutation) IdentityIDs() (ids []int) {
	if id := m.identity; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetIdentity resets all changes to the "identity" edge.
func (m *SaaSUsageMutation) ResetIdentity() {
	m.identity = nil
	m.clearedidentity = false
}

// SetTenantID sets the "tenant" edge to the Tenant entity by id.
func (m *SaaSUsageMutation) SetTenantID(id int) {
	m.tenant = &id
}

// ClearTenant clears the "tenant" edge to the Tenant entity.
func (m *SaaSUsageMutation) ClearTenant() {
	m.clearedtenant = true
}

// TenantCleared reports if the "tenant" edge to the Tenant entity was cleared.
func (m *SaaSUsageMutation) TenantCleared() bool {
	return m.clearedtenant
}

// TenantID returns the "tenant" edge ID in the mutation.
func (m *SaaSUsageMutation) TenantID() (id int, exists bool) {
	if m.tenant != nil {
		return *m.tenant, true
	}
	return
}

// TenantIDs returns the "tenant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TenantID instead. It exists only for internal usage by the builders.
func (m *SaaSUsageMutation) TenantIDs() (ids []int) {
	if id := m.tenant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTenant resets all changes to the "tenant" edge.
func (m *SaaSUsageMutation) ResetTenant() {
	m.tenant = nil
	m.clearedtenant = false
}

// Where appends a list predicates to the SaaSUsageMutation builder.
func (m *SaaSUsageMutation) Where(ps ...predicate.SaaSUsage) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SaaSUsageMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SaaSUsageMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.SaaSUsage, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SaaSUsageMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SaaSUsageMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (SaaSUsage).
func (m *SaaSUsageMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SaaSUsageMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.timestamp != nil {
		fields = append(fields, saasusage.FieldTimestamp)
	}
	if m.feature_name != nil {
		fields = append(fields, saasusage.FieldFeatureName)
	}
	if m.count != nil {
		fields = append(fields, saasusage.FieldCount)
	}
	if m.metadata != nil {
		fields = append(fields, saasusage.FieldMetadata)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SaaSUsageMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case saasusage.FieldTimestamp:
		return m.Timestamp()
	case saasusage.FieldFeatureName:
		return m.FeatureName()
	case saasusage.FieldCount:
		return m.Count()
	case saasusage.FieldMetadata:
		return m.Metadata()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SaaSUsageMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case saasusage.FieldTimestamp:
		return m.OldTimestamp(ctx)
	case saasusage.FieldFeatureName:
		return m.OldFeatureName(ctx)
	case saasusage.FieldCount:
		return m.OldCount(ctx)
	case saasusage.FieldMetadata:
		return m.OldMetadata(ctx)
	}
	return nil, fmt.Errorf("unknown SaaSUsage field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SaaSUsageMutation) SetField(name string, value ent.Value) error {
	switch name {
	case saasusage.FieldTimestamp:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTimestamp(v)
		return nil
	case saasusage.FieldFeatureName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFeatureName(v)
		return nil
	case saasusage.FieldCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCount(v)
		return nil
	case saasusage.FieldMetadata:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetadata(v)
		return nil
	}
	return fmt.Errorf("unknown SaaSUsage field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SaaSUsageMutation) AddedFields() []string {
	var fields []string
	if m.addcount != nil {
		fields = append(fields, saasusage.FieldCount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SaaSUsageMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case saasusage.FieldCount:
		return m.AddedCount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SaaSUsageMutation) AddField(name string, value ent.Value) error {
	switch name {
	case saasusage.FieldCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCount(v)
		return nil
	}
	return fmt.Errorf("unknown SaaSUsage numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SaaSUsageMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SaaSUsageMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SaaSUsageMutation) ClearField(name string) error {
	return fmt.Errorf("unknown SaaSUsage nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SaaSUsageMutation) ResetField(name string) error {
	switch name {
	case saasusage.FieldTimestamp:
		m.ResetTimestamp()
		return nil
	case saasusage.FieldFeatureName:
		m.ResetFeatureName()
		return nil
	case saasusage.FieldCount:
		m.ResetCount()
		return nil
	case saasusage.FieldMetadata:
		m.ResetMetadata()
		return nil
	}
	return fmt.Errorf("unknown SaaSUsage field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SaaSUsageMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.identity != nil {
		edges = append(edges, saasusage.EdgeIdentity)
	}
	if m.tenant != nil {
		edges = append(edges, saasusage.EdgeTenant)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SaaSUsageMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case saasusage.EdgeIdentity:
		if id := m.identity; id != nil {
			return []ent.Value{*id}
		}
	case saasusage.EdgeTenant:
		if id := m.tenant; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SaaSUsageMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SaaSUsageMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SaaSUsageMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedidentity {
		edges = append(edges, saasusage.EdgeIdentity)
	}
	if m.clearedtenant {
		edges = append(edges, saasusage.EdgeTenant)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SaaSUsageMutation) EdgeCleared(name string) bool {
	switch name {
	case saasusage.EdgeIdentity:
		return m.clearedidentity
	case saasusage.EdgeTenant:
		return m.clearedtenant
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SaaSUsageMutation) ClearEdge(name string) error {
	switch name {
	case saasusage.EdgeIdentity:
		m.ClearIdentity()
		return nil
	case saasusage.EdgeTenant:
		m.ClearTenant()
		return nil
	}
	return fmt.Errorf("unknown SaaSUsage unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SaaSUsageMutation) ResetEdge(name string) error {
	switch name {
	case saasusage.EdgeIdentity:
		m.ResetIdentity()
		return nil
	case saasusage.EdgeTenant:
		m.ResetTenant()
		return nil
	}
	return fmt.Errorf("unknown SaaSUsage edge %s", name)
}

// ScriptMutation represents an operation that mutates the Script nodes in the graph.
type ScriptMutation struct {
	config
	op               Op
	typ              string
	id               *int
	name             *string
	description      *string
	content          *string
	_type            *script.Type
	parameters       *[]string
	appendparameters []string
	created_at       *time.Time
	updated_at       *time.Time
	clearedFields    map[string]struct{}
	tenant           *int
	clearedtenant    bool
	jobs             map[int]struct{}
	removedjobs      map[int]struct{}
	clearedjobs      bool
	done             bool
	oldValue         func(context.Context) (*Script, error)
	predicates       []predicate.Script
}

var _ ent.Mutation = (*ScriptMutation)(nil)

// scriptOption allows management of the mutation configuration using functional options.
type scriptOption func(*ScriptMutation)

// newScriptMutation creates new mutation for the Script entity.
func newScriptMutation(c config, op Op, opts ...scriptOption) *ScriptMutation {
	m := &ScriptMutation{
		config:        c,
		op:            op,
		typ:           TypeScript,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withScriptID sets the ID field of the mutation.
func withScriptID(id int) scriptOption {
	return func(m *ScriptMutation) {
		var (
			err   error
			once  sync.Once
			value *Script
		)
		m.oldValue = func(ctx context.Context) (*Script, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Script.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withScript sets the old Script of the mutation.
func withScript(node *Script) scriptOption {
	return func(m *ScriptMutation) {
		m.oldValue = func(context.Context) (*Script, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ScriptMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ScriptMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ScriptMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ScriptMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Script.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *ScriptMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ScriptMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Script entity.
// If the Script object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScriptMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ScriptMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *ScriptMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *ScriptMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Script entity.
// If the Script object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScriptMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *ScriptMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[script.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *ScriptMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[script.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *ScriptMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, script.FieldDescription)
}

// SetContent sets the "content" field.
func (m *ScriptMutation) SetContent(s string) {
	m.content = &s
}

// Content returns the value of the "content" field in the mutation.
func (m *ScriptMutation) Content() (r string, exists bool) {
	v := m.content
	if v == nil {
		return
	}
	return *v, true
}

// OldContent returns the old "content" field's value of the Script entity.
// If the Script object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScriptMutation) OldContent(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContent: %w", err)
	}
	return oldValue.Content, nil
}

// ResetContent resets all changes to the "content" field.
func (m *ScriptMutation) ResetContent() {
	m.content = nil
}

// SetType sets the "type" field.
func (m *ScriptMutation) SetType(s script.Type) {
	m._type = &s
}

// GetType returns the value of the "type" field in the mutation.
func (m *ScriptMutation) GetType() (r script.Type, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Script entity.
// If the Script object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScriptMutation) OldType(ctx context.Context) (v script.Type, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *ScriptMutation) ResetType() {
	m._type = nil
}

// SetParameters sets the "parameters" field.
func (m *ScriptMutation) SetParameters(s []string) {
	m.parameters = &s
	m.appendparameters = nil
}

// Parameters returns the value of the "parameters" field in the mutation.
func (m *ScriptMutation) Parameters() (r []string, exists bool) {
	v := m.parameters
	if v == nil {
		return
	}
	return *v, true
}

// OldParameters returns the old "parameters" field's value of the Script entity.
// If the Script object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScriptMutation) OldParameters(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldParameters is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldParameters requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldParameters: %w", err)
	}
	return oldValue.Parameters, nil
}

// AppendParameters adds s to the "parameters" field.
func (m *ScriptMutation) AppendParameters(s []string) {
	m.appendparameters = append(m.appendparameters, s...)
}

// AppendedParameters returns the list of values that were appended to the "parameters" field in this mutation.
func (m *ScriptMutation) AppendedParameters() ([]string, bool) {
	if len(m.appendparameters) == 0 {
		return nil, false
	}
	return m.appendparameters, true
}

// ClearParameters clears the value of the "parameters" field.
func (m *ScriptMutation) ClearParameters() {
	m.parameters = nil
	m.appendparameters = nil
	m.clearedFields[script.FieldParameters] = struct{}{}
}

// ParametersCleared returns if the "parameters" field was cleared in this mutation.
func (m *ScriptMutation) ParametersCleared() bool {
	_, ok := m.clearedFields[script.FieldParameters]
	return ok
}

// ResetParameters resets all changes to the "parameters" field.
func (m *ScriptMutation) ResetParameters() {
	m.parameters = nil
	m.appendparameters = nil
	delete(m.clearedFields, script.FieldParameters)
}

// SetCreatedAt sets the "created_at" field.
func (m *ScriptMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ScriptMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Script entity.
// If the Script object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScriptMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ScriptMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ScriptMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ScriptMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Script entity.
// If the Script object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScriptMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ScriptMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetTenantID sets the "tenant" edge to the Tenant entity by id.
func (m *ScriptMutation) SetTenantID(id int) {
	m.tenant = &id
}

// ClearTenant clears the "tenant" edge to the Tenant entity.
func (m *ScriptMutation) ClearTenant() {
	m.clearedtenant = true
}

// TenantCleared reports if the "tenant" edge to the Tenant entity was cleared.
func (m *ScriptMutation) TenantCleared() bool {
	return m.clearedtenant
}

// TenantID returns the "tenant" edge ID in the mutation.
func (m *ScriptMutation) TenantID() (id int, exists bool) {
	if m.tenant != nil {
		return *m.tenant, true
	}
	return
}

// TenantIDs returns the "tenant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TenantID instead. It exists only for internal usage by the builders.
func (m *ScriptMutation) TenantIDs() (ids []int) {
	if id := m.tenant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTenant resets all changes to the "tenant" edge.
func (m *ScriptMutation) ResetTenant() {
	m.tenant = nil
	m.clearedtenant = false
}

// AddJobIDs adds the "jobs" edge to the Job entity by ids.
func (m *ScriptMutation) AddJobIDs(ids ...int) {
	if m.jobs == nil {
		m.jobs = make(map[int]struct{})
	}
	for i := range ids {
		m.jobs[ids[i]] = struct{}{}
	}
}

// ClearJobs clears the "jobs" edge to the Job entity.
func (m *ScriptMutation) ClearJobs() {
	m.clearedjobs = true
}

// JobsCleared reports if the "jobs" edge to the Job entity was cleared.
func (m *ScriptMutation) JobsCleared() bool {
	return m.clearedjobs
}

// RemoveJobIDs removes the "jobs" edge to the Job entity by IDs.
func (m *ScriptMutation) RemoveJobIDs(ids ...int) {
	if m.removedjobs == nil {
		m.removedjobs = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.jobs, ids[i])
		m.removedjobs[ids[i]] = struct{}{}
	}
}

// RemovedJobs returns the removed IDs of the "jobs" edge to the Job entity.
func (m *ScriptMutation) RemovedJobsIDs() (ids []int) {
	for id := range m.removedjobs {
		ids = append(ids, id)
	}
	return
}

// JobsIDs returns the "jobs" edge IDs in the mutation.
func (m *ScriptMutation) JobsIDs() (ids []int) {
	for id := range m.jobs {
		ids = append(ids, id)
	}
	return
}

// ResetJobs resets all changes to the "jobs" edge.
func (m *ScriptMutation) ResetJobs() {
	m.jobs = nil
	m.clearedjobs = false
	m.removedjobs = nil
}

// Where appends a list predicates to the ScriptMutation builder.
func (m *ScriptMutation) Where(ps ...predicate.Script) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ScriptMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ScriptMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Script, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ScriptMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ScriptMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Script).
func (m *ScriptMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ScriptMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.name != nil {
		fields = append(fields, script.FieldName)
	}
	if m.description != nil {
		fields = append(fields, script.FieldDescription)
	}
	if m.content != nil {
		fields = append(fields, script.FieldContent)
	}
	if m._type != nil {
		fields = append(fields, script.FieldType)
	}
	if m.parameters != nil {
		fields = append(fields, script.FieldParameters)
	}
	if m.created_at != nil {
		fields = append(fields, script.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, script.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ScriptMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case script.FieldName:
		return m.Name()
	case script.FieldDescription:
		return m.Description()
	case script.FieldContent:
		return m.Content()
	case script.FieldType:
		return m.GetType()
	case script.FieldParameters:
		return m.Parameters()
	case script.FieldCreatedAt:
		return m.CreatedAt()
	case script.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ScriptMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case script.FieldName:
		return m.OldName(ctx)
	case script.FieldDescription:
		return m.OldDescription(ctx)
	case script.FieldContent:
		return m.OldContent(ctx)
	case script.FieldType:
		return m.OldType(ctx)
	case script.FieldParameters:
		return m.OldParameters(ctx)
	case script.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case script.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Script field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ScriptMutation) SetField(name string, value ent.Value) error {
	switch name {
	case script.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case script.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case script.FieldContent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContent(v)
		return nil
	case script.FieldType:
		v, ok := value.(script.Type)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case script.FieldParameters:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetParameters(v)
		return nil
	case script.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case script.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Script field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ScriptMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ScriptMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ScriptMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Script numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ScriptMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(script.FieldDescription) {
		fields = append(fields, script.FieldDescription)
	}
	if m.FieldCleared(script.FieldParameters) {
		fields = append(fields, script.FieldParameters)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ScriptMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ScriptMutation) ClearField(name string) error {
	switch name {
	case script.FieldDescription:
		m.ClearDescription()
		return nil
	case script.FieldParameters:
		m.ClearParameters()
		return nil
	}
	return fmt.Errorf("unknown Script nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ScriptMutation) ResetField(name string) error {
	switch name {
	case script.FieldName:
		m.ResetName()
		return nil
	case script.FieldDescription:
		m.ResetDescription()
		return nil
	case script.FieldContent:
		m.ResetContent()
		return nil
	case script.FieldType:
		m.ResetType()
		return nil
	case script.FieldParameters:
		m.ResetParameters()
		return nil
	case script.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case script.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Script field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ScriptMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.tenant != nil {
		edges = append(edges, script.EdgeTenant)
	}
	if m.jobs != nil {
		edges = append(edges, script.EdgeJobs)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ScriptMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case script.EdgeTenant:
		if id := m.tenant; id != nil {
			return []ent.Value{*id}
		}
	case script.EdgeJobs:
		ids := make([]ent.Value, 0, len(m.jobs))
		for id := range m.jobs {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ScriptMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedjobs != nil {
		edges = append(edges, script.EdgeJobs)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ScriptMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case script.EdgeJobs:
		ids := make([]ent.Value, 0, len(m.removedjobs))
		for id := range m.removedjobs {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ScriptMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedtenant {
		edges = append(edges, script.EdgeTenant)
	}
	if m.clearedjobs {
		edges = append(edges, script.EdgeJobs)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ScriptMutation) EdgeCleared(name string) bool {
	switch name {
	case script.EdgeTenant:
		return m.clearedtenant
	case script.EdgeJobs:
		return m.clearedjobs
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ScriptMutation) ClearEdge(name string) error {
	switch name {
	case script.EdgeTenant:
		m.ClearTenant()
		return nil
	}
	return fmt.Errorf("unknown Script unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ScriptMutation) ResetEdge(name string) error {
	switch name {
	case script.EdgeTenant:
		m.ResetTenant()
		return nil
	case script.EdgeJobs:
		m.ResetJobs()
		return nil
	}
	return fmt.Errorf("unknown Script edge %s", name)
}

// ServiceRateMutation represents an operation that mutates the ServiceRate nodes in the graph.
type ServiceRateMutation struct {
	config
	op            Op
	typ           string
	id            *int
	work_type     *string
	rate          *decimal.Decimal
	description   *string
	clearedFields map[string]struct{}
	tenant        *int
	clearedtenant bool
	done          bool
	oldValue      func(context.Context) (*ServiceRate, error)
	predicates    []predicate.ServiceRate
}

var _ ent.Mutation = (*ServiceRateMutation)(nil)

// servicerateOption allows management of the mutation configuration using functional options.
type servicerateOption func(*ServiceRateMutation)

// newServiceRateMutation creates new mutation for the ServiceRate entity.
func newServiceRateMutation(c config, op Op, opts ...servicerateOption) *ServiceRateMutation {
	m := &ServiceRateMutation{
		config:        c,
		op:            op,
		typ:           TypeServiceRate,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withServiceRateID sets the ID field of the mutation.
func withServiceRateID(id int) servicerateOption {
	return func(m *ServiceRateMutation) {
		var (
			err   error
			once  sync.Once
			value *ServiceRate
		)
		m.oldValue = func(ctx context.Context) (*ServiceRate, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ServiceRate.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withServiceRate sets the old ServiceRate of the mutation.
func withServiceRate(node *ServiceRate) servicerateOption {
	return func(m *ServiceRateMutation) {
		m.oldValue = func(context.Context) (*ServiceRate, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ServiceRateMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ServiceRateMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ServiceRateMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ServiceRateMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ServiceRate.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetWorkType sets the "work_type" field.
func (m *ServiceRateMutation) SetWorkType(s string) {
	m.work_type = &s
}

// WorkType returns the value of the "work_type" field in the mutation.
func (m *ServiceRateMutation) WorkType() (r string, exists bool) {
	v := m.work_type
	if v == nil {
		return
	}
	return *v, true
}

// OldWorkType returns the old "work_type" field's value of the ServiceRate entity.
// If the ServiceRate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceRateMutation) OldWorkType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWorkType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWorkType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWorkType: %w", err)
	}
	return oldValue.WorkType, nil
}

// ResetWorkType resets all changes to the "work_type" field.
func (m *ServiceRateMutation) ResetWorkType() {
	m.work_type = nil
}

// SetRate sets the "rate" field.
func (m *ServiceRateMutation) SetRate(d decimal.Decimal) {
	m.rate = &d
}

// Rate returns the value of the "rate" field in the mutation.
func (m *ServiceRateMutation) Rate() (r decimal.Decimal, exists bool) {
	v := m.rate
	if v == nil {
		return
	}
	return *v, true
}

// OldRate returns the old "rate" field's value of the ServiceRate entity.
// If the ServiceRate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceRateMutation) OldRate(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRate: %w", err)
	}
	return oldValue.Rate, nil
}

// ResetRate resets all changes to the "rate" field.
func (m *ServiceRateMutation) ResetRate() {
	m.rate = nil
}

// SetDescription sets the "description" field.
func (m *ServiceRateMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *ServiceRateMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the ServiceRate entity.
// If the ServiceRate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceRateMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *ServiceRateMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[servicerate.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *ServiceRateMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[servicerate.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *ServiceRateMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, servicerate.FieldDescription)
}

// SetTenantID sets the "tenant" edge to the Tenant entity by id.
func (m *ServiceRateMutation) SetTenantID(id int) {
	m.tenant = &id
}

// ClearTenant clears the "tenant" edge to the Tenant entity.
func (m *ServiceRateMutation) ClearTenant() {
	m.clearedtenant = true
}

// TenantCleared reports if the "tenant" edge to the Tenant entity was cleared.
func (m *ServiceRateMutation) TenantCleared() bool {
	return m.clearedtenant
}

// TenantID returns the "tenant" edge ID in the mutation.
func (m *ServiceRateMutation) TenantID() (id int, exists bool) {
	if m.tenant != nil {
		return *m.tenant, true
	}
	return
}

// TenantIDs returns the "tenant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TenantID instead. It exists only for internal usage by the builders.
func (m *ServiceRateMutation) TenantIDs() (ids []int) {
	if id := m.tenant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTenant resets all changes to the "tenant" edge.
func (m *ServiceRateMutation) ResetTenant() {
	m.tenant = nil
	m.clearedtenant = false
}

// Where appends a list predicates to the ServiceRateMutation builder.
func (m *ServiceRateMutation) Where(ps ...predicate.ServiceRate) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ServiceRateMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ServiceRateMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ServiceRate, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ServiceRateMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ServiceRateMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ServiceRate).
func (m *ServiceRateMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ServiceRateMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.work_type != nil {
		fields = append(fields, servicerate.FieldWorkType)
	}
	if m.rate != nil {
		fields = append(fields, servicerate.FieldRate)
	}
	if m.description != nil {
		fields = append(fields, servicerate.FieldDescription)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ServiceRateMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case servicerate.FieldWorkType:
		return m.WorkType()
	case servicerate.FieldRate:
		return m.Rate()
	case servicerate.FieldDescription:
		return m.Description()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ServiceRateMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case servicerate.FieldWorkType:
		return m.OldWorkType(ctx)
	case servicerate.FieldRate:
		return m.OldRate(ctx)
	case servicerate.FieldDescription:
		return m.OldDescription(ctx)
	}
	return nil, fmt.Errorf("unknown ServiceRate field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ServiceRateMutation) SetField(name string, value ent.Value) error {
	switch name {
	case servicerate.FieldWorkType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWorkType(v)
		return nil
	case servicerate.FieldRate:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRate(v)
		return nil
	case servicerate.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	}
	return fmt.Errorf("unknown ServiceRate field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ServiceRateMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ServiceRateMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ServiceRateMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ServiceRate numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ServiceRateMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(servicerate.FieldDescription) {
		fields = append(fields, servicerate.FieldDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ServiceRateMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ServiceRateMutation) ClearField(name string) error {
	switch name {
	case servicerate.FieldDescription:
		m.ClearDescription()
		return nil
	}
	return fmt.Errorf("unknown ServiceRate nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ServiceRateMutation) ResetField(name string) error {
	switch name {
	case servicerate.FieldWorkType:
		m.ResetWorkType()
		return nil
	case servicerate.FieldRate:
		m.ResetRate()
		return nil
	case servicerate.FieldDescription:
		m.ResetDescription()
		return nil
	}
	return fmt.Errorf("unknown ServiceRate field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ServiceRateMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.tenant != nil {
		edges = append(edges, servicerate.EdgeTenant)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ServiceRateMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case servicerate.EdgeTenant:
		if id := m.tenant; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ServiceRateMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ServiceRateMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ServiceRateMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedtenant {
		edges = append(edges, servicerate.EdgeTenant)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ServiceRateMutation) EdgeCleared(name string) bool {
	switch name {
	case servicerate.EdgeTenant:
		return m.clearedtenant
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ServiceRateMutation) ClearEdge(name string) error {
	switch name {
	case servicerate.EdgeTenant:
		m.ClearTenant()
		return nil
	}
	return fmt.Errorf("unknown ServiceRate unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ServiceRateMutation) ResetEdge(name string) error {
	switch name {
	case servicerate.EdgeTenant:
		m.ResetTenant()
		return nil
	}
	return fmt.Errorf("unknown ServiceRate edge %s", name)
}

// StockAlertMutation represents an operation that mutates the StockAlert nodes in the graph.
type StockAlertMutation struct {
	config
	op             Op
	typ            string
	id             *int
	alert_type     *stockalert.AlertType
	message        *string
	is_read        *bool
	created_at     *time.Time
	clearedFields  map[string]struct{}
	tenant         *int
	clearedtenant  bool
	product        *int
	clearedproduct bool
	done           bool
	oldValue       func(context.Context) (*StockAlert, error)
	predicates     []predicate.StockAlert
}

var _ ent.Mutation = (*StockAlertMutation)(nil)

// stockalertOption allows management of the mutation configuration using functional options.
type stockalertOption func(*StockAlertMutation)

// newStockAlertMutation creates new mutation for the StockAlert entity.
func newStockAlertMutation(c config, op Op, opts ...stockalertOption) *StockAlertMutation {
	m := &StockAlertMutation{
		config:        c,
		op:            op,
		typ:           TypeStockAlert,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withStockAlertID sets the ID field of the mutation.
func withStockAlertID(id int) stockalertOption {
	return func(m *StockAlertMutation) {
		var (
			err   error
			once  sync.Once
			value *StockAlert
		)
		m.oldValue = func(ctx context.Context) (*StockAlert, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().StockAlert.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withStockAlert sets the old StockAlert of the mutation.
func withStockAlert(node *StockAlert) stockalertOption {
	return func(m *StockAlertMutation) {
		m.oldValue = func(context.Context) (*StockAlert, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m StockAlertMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m StockAlertMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *StockAlertMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *StockAlertMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().StockAlert.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetAlertType sets the "alert_type" field.
func (m *StockAlertMutation) SetAlertType(st stockalert.AlertType) {
	m.alert_type = &st
}

// AlertType returns the value of the "alert_type" field in the mutation.
func (m *StockAlertMutation) AlertType() (r stockalert.AlertType, exists bool) {
	v := m.alert_type
	if v == nil {
		return
	}
	return *v, true
}

// OldAlertType returns the old "alert_type" field's value of the StockAlert entity.
// If the StockAlert object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StockAlertMutation) OldAlertType(ctx context.Context) (v stockalert.AlertType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAlertType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAlertType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAlertType: %w", err)
	}
	return oldValue.AlertType, nil
}

// ResetAlertType resets all changes to the "alert_type" field.
func (m *StockAlertMutation) ResetAlertType() {
	m.alert_type = nil
}

// SetMessage sets the "message" field.
func (m *StockAlertMutation) SetMessage(s string) {
	m.message = &s
}

// Message returns the value of the "message" field in the mutation.
func (m *StockAlertMutation) Message() (r string, exists bool) {
	v := m.message
	if v == nil {
		return
	}
	return *v, true
}

// OldMessage returns the old "message" field's value of the StockAlert entity.
// If the StockAlert object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StockAlertMutation) OldMessage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMessage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMessage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMessage: %w", err)
	}
	return oldValue.Message, nil
}

// ResetMessage resets all changes to the "message" field.
func (m *StockAlertMutation) ResetMessage() {
	m.message = nil
}

// SetIsRead sets the "is_read" field.
func (m *StockAlertMutation) SetIsRead(b bool) {
	m.is_read = &b
}

// IsRead returns the value of the "is_read" field in the mutation.
func (m *StockAlertMutation) IsRead() (r bool, exists bool) {
	v := m.is_read
	if v == nil {
		return
	}
	return *v, true
}

// OldIsRead returns the old "is_read" field's value of the StockAlert entity.
// If the StockAlert object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StockAlertMutation) OldIsRead(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsRead is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsRead requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsRead: %w", err)
	}
	return oldValue.IsRead, nil
}

// ResetIsRead resets all changes to the "is_read" field.
func (m *StockAlertMutation) ResetIsRead() {
	m.is_read = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *StockAlertMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *StockAlertMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the StockAlert entity.
// If the StockAlert object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StockAlertMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *StockAlertMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetTenantID sets the "tenant" edge to the Tenant entity by id.
func (m *StockAlertMutation) SetTenantID(id int) {
	m.tenant = &id
}

// ClearTenant clears the "tenant" edge to the Tenant entity.
func (m *StockAlertMutation) ClearTenant() {
	m.clearedtenant = true
}

// TenantCleared reports if the "tenant" edge to the Tenant entity was cleared.
func (m *StockAlertMutation) TenantCleared() bool {
	return m.clearedtenant
}

// TenantID returns the "tenant" edge ID in the mutation.
func (m *StockAlertMutation) TenantID() (id int, exists bool) {
	if m.tenant != nil {
		return *m.tenant, true
	}
	return
}

// TenantIDs returns the "tenant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TenantID instead. It exists only for internal usage by the builders.
func (m *StockAlertMutation) TenantIDs() (ids []int) {
	if id := m.tenant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTenant resets all changes to the "tenant" edge.
func (m *StockAlertMutation) ResetTenant() {
	m.tenant = nil
	m.clearedtenant = false
}

// SetProductID sets the "product" edge to the Product entity by id.
func (m *StockAlertMutation) SetProductID(id int) {
	m.product = &id
}

// ClearProduct clears the "product" edge to the Product entity.
func (m *StockAlertMutation) ClearProduct() {
	m.clearedproduct = true
}

// ProductCleared reports if the "product" edge to the Product entity was cleared.
func (m *StockAlertMutation) ProductCleared() bool {
	return m.clearedproduct
}

// ProductID returns the "product" edge ID in the mutation.
func (m *StockAlertMutation) ProductID() (id int, exists bool) {
	if m.product != nil {
		return *m.product, true
	}
	return
}

// ProductIDs returns the "product" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProductID instead. It exists only for internal usage by the builders.
func (m *StockAlertMutation) ProductIDs() (ids []int) {
	if id := m.product; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProduct resets all changes to the "product" edge.
func (m *StockAlertMutation) ResetProduct() {
	m.product = nil
	m.clearedproduct = false
}

// Where appends a list predicates to the StockAlertMutation builder.
func (m *StockAlertMutation) Where(ps ...predicate.StockAlert) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the StockAlertMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *StockAlertMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.StockAlert, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *StockAlertMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *StockAlertMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (StockAlert).
func (m *StockAlertMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *StockAlertMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.alert_type != nil {
		fields = append(fields, stockalert.FieldAlertType)
	}
	if m.message != nil {
		fields = append(fields, stockalert.FieldMessage)
	}
	if m.is_read != nil {
		fields = append(fields, stockalert.FieldIsRead)
	}
	if m.created_at != nil {
		fields = append(fields, stockalert.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *StockAlertMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case stockalert.FieldAlertType:
		return m.AlertType()
	case stockalert.FieldMessage:
		return m.Message()
	case stockalert.FieldIsRead:
		return m.IsRead()
	case stockalert.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *StockAlertMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case stockalert.FieldAlertType:
		return m.OldAlertType(ctx)
	case stockalert.FieldMessage:
		return m.OldMessage(ctx)
	case stockalert.FieldIsRead:
		return m.OldIsRead(ctx)
	case stockalert.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown StockAlert field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *StockAlertMutation) SetField(name string, value ent.Value) error {
	switch name {
	case stockalert.FieldAlertType:
		v, ok := value.(stockalert.AlertType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAlertType(v)
		return nil
	case stockalert.FieldMessage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMessage(v)
		return nil
	case stockalert.FieldIsRead:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsRead(v)
		return nil
	case stockalert.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown StockAlert field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *StockAlertMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *StockAlertMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *StockAlertMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown StockAlert numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *StockAlertMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *StockAlertMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *StockAlertMutation) ClearField(name string) error {
	return fmt.Errorf("unknown StockAlert nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *StockAlertMutation) ResetField(name string) error {
	switch name {
	case stockalert.FieldAlertType:
		m.ResetAlertType()
		return nil
	case stockalert.FieldMessage:
		m.ResetMessage()
		return nil
	case stockalert.FieldIsRead:
		m.ResetIsRead()
		return nil
	case stockalert.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown StockAlert field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *StockAlertMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.tenant != nil {
		edges = append(edges, stockalert.EdgeTenant)
	}
	if m.product != nil {
		edges = append(edges, stockalert.EdgeProduct)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *StockAlertMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case stockalert.EdgeTenant:
		if id := m.tenant; id != nil {
			return []ent.Value{*id}
		}
	case stockalert.EdgeProduct:
		if id := m.product; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *StockAlertMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *StockAlertMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *StockAlertMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedtenant {
		edges = append(edges, stockalert.EdgeTenant)
	}
	if m.clearedproduct {
		edges = append(edges, stockalert.EdgeProduct)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *StockAlertMutation) EdgeCleared(name string) bool {
	switch name {
	case stockalert.EdgeTenant:
		return m.clearedtenant
	case stockalert.EdgeProduct:
		return m.clearedproduct
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *StockAlertMutation) ClearEdge(name string) error {
	switch name {
	case stockalert.EdgeTenant:
		m.ClearTenant()
		return nil
	case stockalert.EdgeProduct:
		m.ClearProduct()
		return nil
	}
	return fmt.Errorf("unknown StockAlert unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *StockAlertMutation) ResetEdge(name string) error {
	switch name {
	case stockalert.EdgeTenant:
		m.ResetTenant()
		return nil
	case stockalert.EdgeProduct:
		m.ResetProduct()
		return nil
	}
	return fmt.Errorf("unknown StockAlert edge %s", name)
}

// StockAuditLogMutation represents an operation that mutates the StockAuditLog nodes in the graph.
type StockAuditLogMutation struct {
	config
	op            Op
	typ           string
	id            *int
	action        *string
	entity_type   *string
	entity_id     *int
	addentity_id  *int
	user_id       *int
	adduser_id    *int
	user_name     *string
	details       *map[string]interface{}
	created_at    *time.Time
	clearedFields map[string]struct{}
	tenant        *int
	clearedtenant bool
	done          bool
	oldValue      func(context.Context) (*StockAuditLog, error)
	predicates    []predicate.StockAuditLog
}

var _ ent.Mutation = (*StockAuditLogMutation)(nil)

// stockauditlogOption allows management of the mutation configuration using functional options.
type stockauditlogOption func(*StockAuditLogMutation)

// newStockAuditLogMutation creates new mutation for the StockAuditLog entity.
func newStockAuditLogMutation(c config, op Op, opts ...stockauditlogOption) *StockAuditLogMutation {
	m := &StockAuditLogMutation{
		config:        c,
		op:            op,
		typ:           TypeStockAuditLog,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withStockAuditLogID sets the ID field of the mutation.
func withStockAuditLogID(id int) stockauditlogOption {
	return func(m *StockAuditLogMutation) {
		var (
			err   error
			once  sync.Once
			value *StockAuditLog
		)
		m.oldValue = func(ctx context.Context) (*StockAuditLog, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().StockAuditLog.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withStockAuditLog sets the old StockAuditLog of the mutation.
func withStockAuditLog(node *StockAuditLog) stockauditlogOption {
	return func(m *StockAuditLogMutation) {
		m.oldValue = func(context.Context) (*StockAuditLog, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m StockAuditLogMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m StockAuditLogMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *StockAuditLogMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *StockAuditLogMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().StockAuditLog.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetAction sets the "action" field.
func (m *StockAuditLogMutation) SetAction(s string) {
	m.action = &s
}

// Action returns the value of the "action" field in the mutation.
func (m *StockAuditLogMutation) Action() (r string, exists bool) {
	v := m.action
	if v == nil {
		return
	}
	return *v, true
}

// OldAction returns the old "action" field's value of the StockAuditLog entity.
// If the StockAuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StockAuditLogMutation) OldAction(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAction is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAction requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAction: %w", err)
	}
	return oldValue.Action, nil
}

// ResetAction resets all changes to the "action" field.
func (m *StockAuditLogMutation) ResetAction() {
	m.action = nil
}

// SetEntityType sets the "entity_type" field.
func (m *StockAuditLogMutation) SetEntityType(s string) {
	m.entity_type = &s
}

// EntityType returns the value of the "entity_type" field in the mutation.
func (m *StockAuditLogMutation) EntityType() (r string, exists bool) {
	v := m.entity_type
	if v == nil {
		return
	}
	return *v, true
}

// OldEntityType returns the old "entity_type" field's value of the StockAuditLog entity.
// If the StockAuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StockAuditLogMutation) OldEntityType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEntityType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEntityType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEntityType: %w", err)
	}
	return oldValue.EntityType, nil
}

// ResetEntityType resets all changes to the "entity_type" field.
func (m *StockAuditLogMutation) ResetEntityType() {
	m.entity_type = nil
}

// SetEntityID sets the "entity_id" field.
func (m *StockAuditLogMutation) SetEntityID(i int) {
	m.entity_id = &i
	m.addentity_id = nil
}

// EntityID returns the value of the "entity_id" field in the mutation.
func (m *StockAuditLogMutation) EntityID() (r int, exists bool) {
	v := m.entity_id
	if v == nil {
		return
	}
	return *v, true
}

// OldEntityID returns the old "entity_id" field's value of the StockAuditLog entity.
// If the StockAuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StockAuditLogMutation) OldEntityID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEntityID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEntityID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEntityID: %w", err)
	}
	return oldValue.EntityID, nil
}

// AddEntityID adds i to the "entity_id" field.
func (m *StockAuditLogMutation) AddEntityID(i int) {
	if m.addentity_id != nil {
		*m.addentity_id += i
	} else {
		m.addentity_id = &i
	}
}

// AddedEntityID returns the value that was added to the "entity_id" field in this mutation.
func (m *StockAuditLogMutation) AddedEntityID() (r int, exists bool) {
	v := m.addentity_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetEntityID resets all changes to the "entity_id" field.
func (m *StockAuditLogMutation) ResetEntityID() {
	m.entity_id = nil
	m.addentity_id = nil
}

// SetUserID sets the "user_id" field.
func (m *StockAuditLogMutation) SetUserID(i int) {
	m.user_id = &i
	m.adduser_id = nil
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *StockAuditLogMutation) UserID() (r int, exists bool) {
	v := m.user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the StockAuditLog entity.
// If the StockAuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StockAuditLogMutation) OldUserID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// AddUserID adds i to the "user_id" field.
func (m *StockAuditLogMutation) AddUserID(i int) {
	if m.adduser_id != nil {
		*m.adduser_id += i
	} else {
		m.adduser_id = &i
	}
}

// AddedUserID returns the value that was added to the "user_id" field in this mutation.
func (m *StockAuditLogMutation) AddedUserID() (r int, exists bool) {
	v := m.adduser_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearUserID clears the value of the "user_id" field.
func (m *StockAuditLogMutation) ClearUserID() {
	m.user_id = nil
	m.adduser_id = nil
	m.clearedFields[stockauditlog.FieldUserID] = struct{}{}
}

// UserIDCleared returns if the "user_id" field was cleared in this mutation.
func (m *StockAuditLogMutation) UserIDCleared() bool {
	_, ok := m.clearedFields[stockauditlog.FieldUserID]
	return ok
}

// ResetUserID resets all changes to the "user_id" field.
func (m *StockAuditLogMutation) ResetUserID() {
	m.user_id = nil
	m.adduser_id = nil
	delete(m.clearedFields, stockauditlog.FieldUserID)
}

// SetUserName sets the "user_name" field.
func (m *StockAuditLogMutation) SetUserName(s string) {
	m.user_name = &s
}

// UserName returns the value of the "user_name" field in the mutation.
func (m *StockAuditLogMutation) UserName() (r string, exists bool) {
	v := m.user_name
	if v == nil {
		return
	}
	return *v, true
}

// OldUserName returns the old "user_name" field's value of the StockAuditLog entity.
// If the StockAuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StockAuditLogMutation) OldUserName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserName: %w", err)
	}
	return oldValue.UserName, nil
}

// ClearUserName clears the value of the "user_name" field.
func (m *StockAuditLogMutation) ClearUserName() {
	m.user_name = nil
	m.clearedFields[stockauditlog.FieldUserName] = struct{}{}
}

// UserNameCleared returns if the "user_name" field was cleared in this mutation.
func (m *StockAuditLogMutation) UserNameCleared() bool {
	_, ok := m.clearedFields[stockauditlog.FieldUserName]
	return ok
}

// ResetUserName resets all changes to the "user_name" field.
func (m *StockAuditLogMutation) ResetUserName() {
	m.user_name = nil
	delete(m.clearedFields, stockauditlog.FieldUserName)
}

// SetDetails sets the "details" field.
func (m *StockAuditLogMutation) SetDetails(value map[string]interface{}) {
	m.details = &value
}

// Details returns the value of the "details" field in the mutation.
func (m *StockAuditLogMutation) Details() (r map[string]interface{}, exists bool) {
	v := m.details
	if v == nil {
		return
	}
	return *v, true
}

// OldDetails returns the old "details" field's value of the StockAuditLog entity.
// If the StockAuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StockAuditLogMutation) OldDetails(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDetails is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDetails requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDetails: %w", err)
	}
	return oldValue.Details, nil
}

// ClearDetails clears the value of the "details" field.
func (m *StockAuditLogMutation) ClearDetails() {
	m.details = nil
	m.clearedFields[stockauditlog.FieldDetails] = struct{}{}
}

// DetailsCleared returns if the "details" field was cleared in this mutation.
func (m *StockAuditLogMutation) DetailsCleared() bool {
	_, ok := m.clearedFields[stockauditlog.FieldDetails]
	return ok
}

// ResetDetails resets all changes to the "details" field.
func (m *StockAuditLogMutation) ResetDetails() {
	m.details = nil
	delete(m.clearedFields, stockauditlog.FieldDetails)
}

// SetCreatedAt sets the "created_at" field.
func (m *StockAuditLogMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *StockAuditLogMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the StockAuditLog entity.
// If the StockAuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StockAuditLogMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *StockAuditLogMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetTenantID sets the "tenant" edge to the Tenant entity by id.
func (m *StockAuditLogMutation) SetTenantID(id int) {
	m.tenant = &id
}

// ClearTenant clears the "tenant" edge to the Tenant entity.
func (m *StockAuditLogMutation) ClearTenant() {
	m.clearedtenant = true
}

// TenantCleared reports if the "tenant" edge to the Tenant entity was cleared.
func (m *StockAuditLogMutation) TenantCleared() bool {
	return m.clearedtenant
}

// TenantID returns the "tenant" edge ID in the mutation.
func (m *StockAuditLogMutation) TenantID() (id int, exists bool) {
	if m.tenant != nil {
		return *m.tenant, true
	}
	return
}

// TenantIDs returns the "tenant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TenantID instead. It exists only for internal usage by the builders.
func (m *StockAuditLogMutation) TenantIDs() (ids []int) {
	if id := m.tenant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTenant resets all changes to the "tenant" edge.
func (m *StockAuditLogMutation) ResetTenant() {
	m.tenant = nil
	m.clearedtenant = false
}

// Where appends a list predicates to the StockAuditLogMutation builder.
func (m *StockAuditLogMutation) Where(ps ...predicate.StockAuditLog) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the StockAuditLogMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *StockAuditLogMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.StockAuditLog, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *StockAuditLogMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *StockAuditLogMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (StockAuditLog).
func (m *StockAuditLogMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *StockAuditLogMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.action != nil {
		fields = append(fields, stockauditlog.FieldAction)
	}
	if m.entity_type != nil {
		fields = append(fields, stockauditlog.FieldEntityType)
	}
	if m.entity_id != nil {
		fields = append(fields, stockauditlog.FieldEntityID)
	}
	if m.user_id != nil {
		fields = append(fields, stockauditlog.FieldUserID)
	}
	if m.user_name != nil {
		fields = append(fields, stockauditlog.FieldUserName)
	}
	if m.details != nil {
		fields = append(fields, stockauditlog.FieldDetails)
	}
	if m.created_at != nil {
		fields = append(fields, stockauditlog.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *StockAuditLogMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case stockauditlog.FieldAction:
		return m.Action()
	case stockauditlog.FieldEntityType:
		return m.EntityType()
	case stockauditlog.FieldEntityID:
		return m.EntityID()
	case stockauditlog.FieldUserID:
		return m.UserID()
	case stockauditlog.FieldUserName:
		return m.UserName()
	case stockauditlog.FieldDetails:
		return m.Details()
	case stockauditlog.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *StockAuditLogMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case stockauditlog.FieldAction:
		return m.OldAction(ctx)
	case stockauditlog.FieldEntityType:
		return m.OldEntityType(ctx)
	case stockauditlog.FieldEntityID:
		return m.OldEntityID(ctx)
	case stockauditlog.FieldUserID:
		return m.OldUserID(ctx)
	case stockauditlog.FieldUserName:
		return m.OldUserName(ctx)
	case stockauditlog.FieldDetails:
		return m.OldDetails(ctx)
	case stockauditlog.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown StockAuditLog field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *StockAuditLogMutation) SetField(name string, value ent.Value) error {
	switch name {
	case stockauditlog.FieldAction:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAction(v)
		return nil
	case stockauditlog.FieldEntityType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEntityType(v)
		return nil
	case stockauditlog.FieldEntityID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEntityID(v)
		return nil
	case stockauditlog.FieldUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case stockauditlog.FieldUserName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserName(v)
		return nil
	case stockauditlog.FieldDetails:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDetails(v)
		return nil
	case stockauditlog.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown StockAuditLog field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *StockAuditLogMutation) AddedFields() []string {
	var fields []string
	if m.addentity_id != nil {
		fields = append(fields, stockauditlog.FieldEntityID)
	}
	if m.adduser_id != nil {
		fields = append(fields, stockauditlog.FieldUserID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *StockAuditLogMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case stockauditlog.FieldEntityID:
		return m.AddedEntityID()
	case stockauditlog.FieldUserID:
		return m.AddedUserID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *StockAuditLogMutation) AddField(name string, value ent.Value) error {
	switch name {
	case stockauditlog.FieldEntityID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddEntityID(v)
		return nil
	case stockauditlog.FieldUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUserID(v)
		return nil
	}
	return fmt.Errorf("unknown StockAuditLog numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *StockAuditLogMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(stockauditlog.FieldUserID) {
		fields = append(fields, stockauditlog.FieldUserID)
	}
	if m.FieldCleared(stockauditlog.FieldUserName) {
		fields = append(fields, stockauditlog.FieldUserName)
	}
	if m.FieldCleared(stockauditlog.FieldDetails) {
		fields = append(fields, stockauditlog.FieldDetails)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *StockAuditLogMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *StockAuditLogMutation) ClearField(name string) error {
	switch name {
	case stockauditlog.FieldUserID:
		m.ClearUserID()
		return nil
	case stockauditlog.FieldUserName:
		m.ClearUserName()
		return nil
	case stockauditlog.FieldDetails:
		m.ClearDetails()
		return nil
	}
	return fmt.Errorf("unknown StockAuditLog nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *StockAuditLogMutation) ResetField(name string) error {
	switch name {
	case stockauditlog.FieldAction:
		m.ResetAction()
		return nil
	case stockauditlog.FieldEntityType:
		m.ResetEntityType()
		return nil
	case stockauditlog.FieldEntityID:
		m.ResetEntityID()
		return nil
	case stockauditlog.FieldUserID:
		m.ResetUserID()
		return nil
	case stockauditlog.FieldUserName:
		m.ResetUserName()
		return nil
	case stockauditlog.FieldDetails:
		m.ResetDetails()
		return nil
	case stockauditlog.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown StockAuditLog field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *StockAuditLogMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.tenant != nil {
		edges = append(edges, stockauditlog.EdgeTenant)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *StockAuditLogMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case stockauditlog.EdgeTenant:
		if id := m.tenant; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *StockAuditLogMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *StockAuditLogMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *StockAuditLogMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedtenant {
		edges = append(edges, stockauditlog.EdgeTenant)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *StockAuditLogMutation) EdgeCleared(name string) bool {
	switch name {
	case stockauditlog.EdgeTenant:
		return m.clearedtenant
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *StockAuditLogMutation) ClearEdge(name string) error {
	switch name {
	case stockauditlog.EdgeTenant:
		m.ClearTenant()
		return nil
	}
	return fmt.Errorf("unknown StockAuditLog unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *StockAuditLogMutation) ResetEdge(name string) error {
	switch name {
	case stockauditlog.EdgeTenant:
		m.ResetTenant()
		return nil
	}
	return fmt.Errorf("unknown StockAuditLog edge %s", name)
}

// StockMovementMutation represents an operation that mutates the StockMovement nodes in the graph.
type StockMovementMutation struct {
	config
	op                 Op
	typ                string
	id                 *int
	quantity           *decimal.Decimal
	movement_type      *stockmovement.MovementType
	reason             *string
	unit_cost          *decimal.Decimal
	remaining_quantity *decimal.Decimal
	calculated_cogs    *decimal.Decimal
	metadata           *map[string]interface{}
	created_at         *time.Time
	clearedFields      map[string]struct{}
	product            *int
	clearedproduct     bool
	tenant             *int
	clearedtenant      bool
	done               bool
	oldValue           func(context.Context) (*StockMovement, error)
	predicates         []predicate.StockMovement
}

var _ ent.Mutation = (*StockMovementMutation)(nil)

// stockmovementOption allows management of the mutation configuration using functional options.
type stockmovementOption func(*StockMovementMutation)

// newStockMovementMutation creates new mutation for the StockMovement entity.
func newStockMovementMutation(c config, op Op, opts ...stockmovementOption) *StockMovementMutation {
	m := &StockMovementMutation{
		config:        c,
		op:            op,
		typ:           TypeStockMovement,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withStockMovementID sets the ID field of the mutation.
func withStockMovementID(id int) stockmovementOption {
	return func(m *StockMovementMutation) {
		var (
			err   error
			once  sync.Once
			value *StockMovement
		)
		m.oldValue = func(ctx context.Context) (*StockMovement, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().StockMovement.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withStockMovement sets the old StockMovement of the mutation.
func withStockMovement(node *StockMovement) stockmovementOption {
	return func(m *StockMovementMutation) {
		m.oldValue = func(context.Context) (*StockMovement, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m StockMovementMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m StockMovementMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *StockMovementMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *StockMovementMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().StockMovement.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetQuantity sets the "quantity" field.
func (m *StockMovementMutation) SetQuantity(d decimal.Decimal) {
	m.quantity = &d
}

// Quantity returns the value of the "quantity" field in the mutation.
func (m *StockMovementMutation) Quantity() (r decimal.Decimal, exists bool) {
	v := m.quantity
	if v == nil {
		return
	}
	return *v, true
}

// OldQuantity returns the old "quantity" field's value of the StockMovement entity.
// If the StockMovement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StockMovementMutation) OldQuantity(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldQuantity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldQuantity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldQuantity: %w", err)
	}
	return oldValue.Quantity, nil
}

// ResetQuantity resets all changes to the "quantity" field.
func (m *StockMovementMutation) ResetQuantity() {
	m.quantity = nil
}

// SetMovementType sets the "movement_type" field.
func (m *StockMovementMutation) SetMovementType(st stockmovement.MovementType) {
	m.movement_type = &st
}

// MovementType returns the value of the "movement_type" field in the mutation.
func (m *StockMovementMutation) MovementType() (r stockmovement.MovementType, exists bool) {
	v := m.movement_type
	if v == nil {
		return
	}
	return *v, true
}

// OldMovementType returns the old "movement_type" field's value of the StockMovement entity.
// If the StockMovement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StockMovementMutation) OldMovementType(ctx context.Context) (v stockmovement.MovementType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMovementType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMovementType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMovementType: %w", err)
	}
	return oldValue.MovementType, nil
}

// ResetMovementType resets all changes to the "movement_type" field.
func (m *StockMovementMutation) ResetMovementType() {
	m.movement_type = nil
}

// SetReason sets the "reason" field.
func (m *StockMovementMutation) SetReason(s string) {
	m.reason = &s
}

// Reason returns the value of the "reason" field in the mutation.
func (m *StockMovementMutation) Reason() (r string, exists bool) {
	v := m.reason
	if v == nil {
		return
	}
	return *v, true
}

// OldReason returns the old "reason" field's value of the StockMovement entity.
// If the StockMovement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StockMovementMutation) OldReason(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReason is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReason requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReason: %w", err)
	}
	return oldValue.Reason, nil
}

// ClearReason clears the value of the "reason" field.
func (m *StockMovementMutation) ClearReason() {
	m.reason = nil
	m.clearedFields[stockmovement.FieldReason] = struct{}{}
}

// ReasonCleared returns if the "reason" field was cleared in this mutation.
func (m *StockMovementMutation) ReasonCleared() bool {
	_, ok := m.clearedFields[stockmovement.FieldReason]
	return ok
}

// ResetReason resets all changes to the "reason" field.
func (m *StockMovementMutation) ResetReason() {
	m.reason = nil
	delete(m.clearedFields, stockmovement.FieldReason)
}

// SetUnitCost sets the "unit_cost" field.
func (m *StockMovementMutation) SetUnitCost(d decimal.Decimal) {
	m.unit_cost = &d
}

// UnitCost returns the value of the "unit_cost" field in the mutation.
func (m *StockMovementMutation) UnitCost() (r decimal.Decimal, exists bool) {
	v := m.unit_cost
	if v == nil {
		return
	}
	return *v, true
}

// OldUnitCost returns the old "unit_cost" field's value of the StockMovement entity.
// If the StockMovement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StockMovementMutation) OldUnitCost(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUnitCost is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUnitCost requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUnitCost: %w", err)
	}
	return oldValue.UnitCost, nil
}

// ClearUnitCost clears the value of the "unit_cost" field.
func (m *StockMovementMutation) ClearUnitCost() {
	m.unit_cost = nil
	m.clearedFields[stockmovement.FieldUnitCost] = struct{}{}
}

// UnitCostCleared returns if the "unit_cost" field was cleared in this mutation.
func (m *StockMovementMutation) UnitCostCleared() bool {
	_, ok := m.clearedFields[stockmovement.FieldUnitCost]
	return ok
}

// ResetUnitCost resets all changes to the "unit_cost" field.
func (m *StockMovementMutation) ResetUnitCost() {
	m.unit_cost = nil
	delete(m.clearedFields, stockmovement.FieldUnitCost)
}

// SetRemainingQuantity sets the "remaining_quantity" field.
func (m *StockMovementMutation) SetRemainingQuantity(d decimal.Decimal) {
	m.remaining_quantity = &d
}

// RemainingQuantity returns the value of the "remaining_quantity" field in the mutation.
func (m *StockMovementMutation) RemainingQuantity() (r decimal.Decimal, exists bool) {
	v := m.remaining_quantity
	if v == nil {
		return
	}
	return *v, true
}

// OldRemainingQuantity returns the old "remaining_quantity" field's value of the StockMovement entity.
// If the StockMovement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StockMovementMutation) OldRemainingQuantity(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRemainingQuantity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRemainingQuantity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemainingQuantity: %w", err)
	}
	return oldValue.RemainingQuantity, nil
}

// ClearRemainingQuantity clears the value of the "remaining_quantity" field.
func (m *StockMovementMutation) ClearRemainingQuantity() {
	m.remaining_quantity = nil
	m.clearedFields[stockmovement.FieldRemainingQuantity] = struct{}{}
}

// RemainingQuantityCleared returns if the "remaining_quantity" field was cleared in this mutation.
func (m *StockMovementMutation) RemainingQuantityCleared() bool {
	_, ok := m.clearedFields[stockmovement.FieldRemainingQuantity]
	return ok
}

// ResetRemainingQuantity resets all changes to the "remaining_quantity" field.
func (m *StockMovementMutation) ResetRemainingQuantity() {
	m.remaining_quantity = nil
	delete(m.clearedFields, stockmovement.FieldRemainingQuantity)
}

// SetCalculatedCogs sets the "calculated_cogs" field.
func (m *StockMovementMutation) SetCalculatedCogs(d decimal.Decimal) {
	m.calculated_cogs = &d
}

// CalculatedCogs returns the value of the "calculated_cogs" field in the mutation.
func (m *StockMovementMutation) CalculatedCogs() (r decimal.Decimal, exists bool) {
	v := m.calculated_cogs
	if v == nil {
		return
	}
	return *v, true
}

// OldCalculatedCogs returns the old "calculated_cogs" field's value of the StockMovement entity.
// If the StockMovement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StockMovementMutation) OldCalculatedCogs(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCalculatedCogs is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCalculatedCogs requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCalculatedCogs: %w", err)
	}
	return oldValue.CalculatedCogs, nil
}

// ClearCalculatedCogs clears the value of the "calculated_cogs" field.
func (m *StockMovementMutation) ClearCalculatedCogs() {
	m.calculated_cogs = nil
	m.clearedFields[stockmovement.FieldCalculatedCogs] = struct{}{}
}

// CalculatedCogsCleared returns if the "calculated_cogs" field was cleared in this mutation.
func (m *StockMovementMutation) CalculatedCogsCleared() bool {
	_, ok := m.clearedFields[stockmovement.FieldCalculatedCogs]
	return ok
}

// ResetCalculatedCogs resets all changes to the "calculated_cogs" field.
func (m *StockMovementMutation) ResetCalculatedCogs() {
	m.calculated_cogs = nil
	delete(m.clearedFields, stockmovement.FieldCalculatedCogs)
}

// SetMetadata sets the "metadata" field.
func (m *StockMovementMutation) SetMetadata(value map[string]interface{}) {
	m.metadata = &value
}

// Metadata returns the value of the "metadata" field in the mutation.
func (m *StockMovementMutation) Metadata() (r map[string]interface{}, exists bool) {
	v := m.metadata
	if v == nil {
		return
	}
	return *v, true
}

// OldMetadata returns the old "metadata" field's value of the StockMovement entity.
// If the StockMovement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StockMovementMutation) OldMetadata(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMetadata is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMetadata requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetadata: %w", err)
	}
	return oldValue.Metadata, nil
}

// ClearMetadata clears the value of the "metadata" field.
func (m *StockMovementMutation) ClearMetadata() {
	m.metadata = nil
	m.clearedFields[stockmovement.FieldMetadata] = struct{}{}
}

// MetadataCleared returns if the "metadata" field was cleared in this mutation.
func (m *StockMovementMutation) MetadataCleared() bool {
	_, ok := m.clearedFields[stockmovement.FieldMetadata]
	return ok
}

// ResetMetadata resets all changes to the "metadata" field.
func (m *StockMovementMutation) ResetMetadata() {
	m.metadata = nil
	delete(m.clearedFields, stockmovement.FieldMetadata)
}

// SetCreatedAt sets the "created_at" field.
func (m *StockMovementMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *StockMovementMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the StockMovement entity.
// If the StockMovement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StockMovementMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *StockMovementMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetProductID sets the "product" edge to the Product entity by id.
func (m *StockMovementMutation) SetProductID(id int) {
	m.product = &id
}

// ClearProduct clears the "product" edge to the Product entity.
func (m *StockMovementMutation) ClearProduct() {
	m.clearedproduct = true
}

// ProductCleared reports if the "product" edge to the Product entity was cleared.
func (m *StockMovementMutation) ProductCleared() bool {
	return m.clearedproduct
}

// ProductID returns the "product" edge ID in the mutation.
func (m *StockMovementMutation) ProductID() (id int, exists bool) {
	if m.product != nil {
		return *m.product, true
	}
	return
}

// ProductIDs returns the "product" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProductID instead. It exists only for internal usage by the builders.
func (m *StockMovementMutation) ProductIDs() (ids []int) {
	if id := m.product; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProduct resets all changes to the "product" edge.
func (m *StockMovementMutation) ResetProduct() {
	m.product = nil
	m.clearedproduct = false
}

// SetTenantID sets the "tenant" edge to the Tenant entity by id.
func (m *StockMovementMutation) SetTenantID(id int) {
	m.tenant = &id
}

// ClearTenant clears the "tenant" edge to the Tenant entity.
func (m *StockMovementMutation) ClearTenant() {
	m.clearedtenant = true
}

// TenantCleared reports if the "tenant" edge to the Tenant entity was cleared.
func (m *StockMovementMutation) TenantCleared() bool {
	return m.clearedtenant
}

// TenantID returns the "tenant" edge ID in the mutation.
func (m *StockMovementMutation) TenantID() (id int, exists bool) {
	if m.tenant != nil {
		return *m.tenant, true
	}
	return
}

// TenantIDs returns the "tenant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TenantID instead. It exists only for internal usage by the builders.
func (m *StockMovementMutation) TenantIDs() (ids []int) {
	if id := m.tenant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTenant resets all changes to the "tenant" edge.
func (m *StockMovementMutation) ResetTenant() {
	m.tenant = nil
	m.clearedtenant = false
}

// Where appends a list predicates to the StockMovementMutation builder.
func (m *StockMovementMutation) Where(ps ...predicate.StockMovement) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the StockMovementMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *StockMovementMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.StockMovement, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *StockMovementMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *StockMovementMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (StockMovement).
func (m *StockMovementMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *StockMovementMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.quantity != nil {
		fields = append(fields, stockmovement.FieldQuantity)
	}
	if m.movement_type != nil {
		fields = append(fields, stockmovement.FieldMovementType)
	}
	if m.reason != nil {
		fields = append(fields, stockmovement.FieldReason)
	}
	if m.unit_cost != nil {
		fields = append(fields, stockmovement.FieldUnitCost)
	}
	if m.remaining_quantity != nil {
		fields = append(fields, stockmovement.FieldRemainingQuantity)
	}
	if m.calculated_cogs != nil {
		fields = append(fields, stockmovement.FieldCalculatedCogs)
	}
	if m.metadata != nil {
		fields = append(fields, stockmovement.FieldMetadata)
	}
	if m.created_at != nil {
		fields = append(fields, stockmovement.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *StockMovementMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case stockmovement.FieldQuantity:
		return m.Quantity()
	case stockmovement.FieldMovementType:
		return m.MovementType()
	case stockmovement.FieldReason:
		return m.Reason()
	case stockmovement.FieldUnitCost:
		return m.UnitCost()
	case stockmovement.FieldRemainingQuantity:
		return m.RemainingQuantity()
	case stockmovement.FieldCalculatedCogs:
		return m.CalculatedCogs()
	case stockmovement.FieldMetadata:
		return m.Metadata()
	case stockmovement.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *StockMovementMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case stockmovement.FieldQuantity:
		return m.OldQuantity(ctx)
	case stockmovement.FieldMovementType:
		return m.OldMovementType(ctx)
	case stockmovement.FieldReason:
		return m.OldReason(ctx)
	case stockmovement.FieldUnitCost:
		return m.OldUnitCost(ctx)
	case stockmovement.FieldRemainingQuantity:
		return m.OldRemainingQuantity(ctx)
	case stockmovement.FieldCalculatedCogs:
		return m.OldCalculatedCogs(ctx)
	case stockmovement.FieldMetadata:
		return m.OldMetadata(ctx)
	case stockmovement.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown StockMovement field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *StockMovementMutation) SetField(name string, value ent.Value) error {
	switch name {
	case stockmovement.FieldQuantity:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetQuantity(v)
		return nil
	case stockmovement.FieldMovementType:
		v, ok := value.(stockmovement.MovementType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMovementType(v)
		return nil
	case stockmovement.FieldReason:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReason(v)
		return nil
	case stockmovement.FieldUnitCost:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUnitCost(v)
		return nil
	case stockmovement.FieldRemainingQuantity:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemainingQuantity(v)
		return nil
	case stockmovement.FieldCalculatedCogs:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCalculatedCogs(v)
		return nil
	case stockmovement.FieldMetadata:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetadata(v)
		return nil
	case stockmovement.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown StockMovement field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *StockMovementMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *StockMovementMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *StockMovementMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown StockMovement numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *StockMovementMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(stockmovement.FieldReason) {
		fields = append(fields, stockmovement.FieldReason)
	}
	if m.FieldCleared(stockmovement.FieldUnitCost) {
		fields = append(fields, stockmovement.FieldUnitCost)
	}
	if m.FieldCleared(stockmovement.FieldRemainingQuantity) {
		fields = append(fields, stockmovement.FieldRemainingQuantity)
	}
	if m.FieldCleared(stockmovement.FieldCalculatedCogs) {
		fields = append(fields, stockmovement.FieldCalculatedCogs)
	}
	if m.FieldCleared(stockmovement.FieldMetadata) {
		fields = append(fields, stockmovement.FieldMetadata)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *StockMovementMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *StockMovementMutation) ClearField(name string) error {
	switch name {
	case stockmovement.FieldReason:
		m.ClearReason()
		return nil
	case stockmovement.FieldUnitCost:
		m.ClearUnitCost()
		return nil
	case stockmovement.FieldRemainingQuantity:
		m.ClearRemainingQuantity()
		return nil
	case stockmovement.FieldCalculatedCogs:
		m.ClearCalculatedCogs()
		return nil
	case stockmovement.FieldMetadata:
		m.ClearMetadata()
		return nil
	}
	return fmt.Errorf("unknown StockMovement nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *StockMovementMutation) ResetField(name string) error {
	switch name {
	case stockmovement.FieldQuantity:
		m.ResetQuantity()
		return nil
	case stockmovement.FieldMovementType:
		m.ResetMovementType()
		return nil
	case stockmovement.FieldReason:
		m.ResetReason()
		return nil
	case stockmovement.FieldUnitCost:
		m.ResetUnitCost()
		return nil
	case stockmovement.FieldRemainingQuantity:
		m.ResetRemainingQuantity()
		return nil
	case stockmovement.FieldCalculatedCogs:
		m.ResetCalculatedCogs()
		return nil
	case stockmovement.FieldMetadata:
		m.ResetMetadata()
		return nil
	case stockmovement.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown StockMovement field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *StockMovementMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.product != nil {
		edges = append(edges, stockmovement.EdgeProduct)
	}
	if m.tenant != nil {
		edges = append(edges, stockmovement.EdgeTenant)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *StockMovementMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case stockmovement.EdgeProduct:
		if id := m.product; id != nil {
			return []ent.Value{*id}
		}
	case stockmovement.EdgeTenant:
		if id := m.tenant; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *StockMovementMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *StockMovementMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *StockMovementMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedproduct {
		edges = append(edges, stockmovement.EdgeProduct)
	}
	if m.clearedtenant {
		edges = append(edges, stockmovement.EdgeTenant)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *StockMovementMutation) EdgeCleared(name string) bool {
	switch name {
	case stockmovement.EdgeProduct:
		return m.clearedproduct
	case stockmovement.EdgeTenant:
		return m.clearedtenant
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *StockMovementMutation) ClearEdge(name string) error {
	switch name {
	case stockmovement.EdgeProduct:
		m.ClearProduct()
		return nil
	case stockmovement.EdgeTenant:
		m.ClearTenant()
		return nil
	}
	return fmt.Errorf("unknown StockMovement unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *StockMovementMutation) ResetEdge(name string) error {
	switch name {
	case stockmovement.EdgeProduct:
		m.ResetProduct()
		return nil
	case stockmovement.EdgeTenant:
		m.ResetTenant()
		return nil
	}
	return fmt.Errorf("unknown StockMovement edge %s", name)
}

// StrategicRoadmapMutation represents an operation that mutates the StrategicRoadmap nodes in the graph.
type StrategicRoadmapMutation struct {
	config
	op                   Op
	typ                  string
	id                   *int
	project_name         *string
	description          *string
	priority             *strategicroadmap.Priority
	status               *strategicroadmap.Status
	estimated_cost       *decimal.Decimal
	target_date          *time.Time
	strategic_commentary *string
	created_at           *time.Time
	updated_at           *time.Time
	clearedFields        map[string]struct{}
	tenant               *int
	clearedtenant        bool
	done                 bool
	oldValue             func(context.Context) (*StrategicRoadmap, error)
	predicates           []predicate.StrategicRoadmap
}

var _ ent.Mutation = (*StrategicRoadmapMutation)(nil)

// strategicroadmapOption allows management of the mutation configuration using functional options.
type strategicroadmapOption func(*StrategicRoadmapMutation)

// newStrategicRoadmapMutation creates new mutation for the StrategicRoadmap entity.
func newStrategicRoadmapMutation(c config, op Op, opts ...strategicroadmapOption) *StrategicRoadmapMutation {
	m := &StrategicRoadmapMutation{
		config:        c,
		op:            op,
		typ:           TypeStrategicRoadmap,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withStrategicRoadmapID sets the ID field of the mutation.
func withStrategicRoadmapID(id int) strategicroadmapOption {
	return func(m *StrategicRoadmapMutation) {
		var (
			err   error
			once  sync.Once
			value *StrategicRoadmap
		)
		m.oldValue = func(ctx context.Context) (*StrategicRoadmap, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().StrategicRoadmap.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withStrategicRoadmap sets the old StrategicRoadmap of the mutation.
func withStrategicRoadmap(node *StrategicRoadmap) strategicroadmapOption {
	return func(m *StrategicRoadmapMutation) {
		m.oldValue = func(context.Context) (*StrategicRoadmap, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m StrategicRoadmapMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m StrategicRoadmapMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *StrategicRoadmapMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *StrategicRoadmapMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().StrategicRoadmap.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetProjectName sets the "project_name" field.
func (m *StrategicRoadmapMutation) SetProjectName(s string) {
	m.project_name = &s
}

// ProjectName returns the value of the "project_name" field in the mutation.
func (m *StrategicRoadmapMutation) ProjectName() (r string, exists bool) {
	v := m.project_name
	if v == nil {
		return
	}
	return *v, true
}

// OldProjectName returns the old "project_name" field's value of the StrategicRoadmap entity.
// If the StrategicRoadmap object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StrategicRoadmapMutation) OldProjectName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProjectName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProjectName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProjectName: %w", err)
	}
	return oldValue.ProjectName, nil
}

// ResetProjectName resets all changes to the "project_name" field.
func (m *StrategicRoadmapMutation) ResetProjectName() {
	m.project_name = nil
}

// SetDescription sets the "description" field.
func (m *StrategicRoadmapMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *StrategicRoadmapMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the StrategicRoadmap entity.
// If the StrategicRoadmap object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StrategicRoadmapMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *StrategicRoadmapMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[strategicroadmap.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *StrategicRoadmapMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[strategicroadmap.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *StrategicRoadmapMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, strategicroadmap.FieldDescription)
}

// SetPriority sets the "priority" field.
func (m *StrategicRoadmapMutation) SetPriority(s strategicroadmap.Priority) {
	m.priority = &s
}

// Priority returns the value of the "priority" field in the mutation.
func (m *StrategicRoadmapMutation) Priority() (r strategicroadmap.Priority, exists bool) {
	v := m.priority
	if v == nil {
		return
	}
	return *v, true
}

// OldPriority returns the old "priority" field's value of the StrategicRoadmap entity.
// If the StrategicRoadmap object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StrategicRoadmapMutation) OldPriority(ctx context.Context) (v strategicroadmap.Priority, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPriority is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPriority requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPriority: %w", err)
	}
	return oldValue.Priority, nil
}

// ResetPriority resets all changes to the "priority" field.
func (m *StrategicRoadmapMutation) ResetPriority() {
	m.priority = nil
}

// SetStatus sets the "status" field.
func (m *StrategicRoadmapMutation) SetStatus(s strategicroadmap.Status) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *StrategicRoadmapMutation) Status() (r strategicroadmap.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the StrategicRoadmap entity.
// If the StrategicRoadmap object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StrategicRoadmapMutation) OldStatus(ctx context.Context) (v strategicroadmap.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *StrategicRoadmapMutation) ResetStatus() {
	m.status = nil
}

// SetEstimatedCost sets the "estimated_cost" field.
func (m *StrategicRoadmapMutation) SetEstimatedCost(d decimal.Decimal) {
	m.estimated_cost = &d
}

// EstimatedCost returns the value of the "estimated_cost" field in the mutation.
func (m *StrategicRoadmapMutation) EstimatedCost() (r decimal.Decimal, exists bool) {
	v := m.estimated_cost
	if v == nil {
		return
	}
	return *v, true
}

// OldEstimatedCost returns the old "estimated_cost" field's value of the StrategicRoadmap entity.
// If the StrategicRoadmap object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StrategicRoadmapMutation) OldEstimatedCost(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEstimatedCost is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEstimatedCost requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEstimatedCost: %w", err)
	}
	return oldValue.EstimatedCost, nil
}

// ResetEstimatedCost resets all changes to the "estimated_cost" field.
func (m *StrategicRoadmapMutation) ResetEstimatedCost() {
	m.estimated_cost = nil
}

// SetTargetDate sets the "target_date" field.
func (m *StrategicRoadmapMutation) SetTargetDate(t time.Time) {
	m.target_date = &t
}

// TargetDate returns the value of the "target_date" field in the mutation.
func (m *StrategicRoadmapMutation) TargetDate() (r time.Time, exists bool) {
	v := m.target_date
	if v == nil {
		return
	}
	return *v, true
}

// OldTargetDate returns the old "target_date" field's value of the StrategicRoadmap entity.
// If the StrategicRoadmap object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StrategicRoadmapMutation) OldTargetDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTargetDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTargetDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTargetDate: %w", err)
	}
	return oldValue.TargetDate, nil
}

// ResetTargetDate resets all changes to the "target_date" field.
func (m *StrategicRoadmapMutation) ResetTargetDate() {
	m.target_date = nil
}

// SetStrategicCommentary sets the "strategic_commentary" field.
func (m *StrategicRoadmapMutation) SetStrategicCommentary(s string) {
	m.strategic_commentary = &s
}

// StrategicCommentary returns the value of the "strategic_commentary" field in the mutation.
func (m *StrategicRoadmapMutation) StrategicCommentary() (r string, exists bool) {
	v := m.strategic_commentary
	if v == nil {
		return
	}
	return *v, true
}

// OldStrategicCommentary returns the old "strategic_commentary" field's value of the StrategicRoadmap entity.
// If the StrategicRoadmap object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StrategicRoadmapMutation) OldStrategicCommentary(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStrategicCommentary is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStrategicCommentary requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStrategicCommentary: %w", err)
	}
	return oldValue.StrategicCommentary, nil
}

// ClearStrategicCommentary clears the value of the "strategic_commentary" field.
func (m *StrategicRoadmapMutation) ClearStrategicCommentary() {
	m.strategic_commentary = nil
	m.clearedFields[strategicroadmap.FieldStrategicCommentary] = struct{}{}
}

// StrategicCommentaryCleared returns if the "strategic_commentary" field was cleared in this mutation.
func (m *StrategicRoadmapMutation) StrategicCommentaryCleared() bool {
	_, ok := m.clearedFields[strategicroadmap.FieldStrategicCommentary]
	return ok
}

// ResetStrategicCommentary resets all changes to the "strategic_commentary" field.
func (m *StrategicRoadmapMutation) ResetStrategicCommentary() {
	m.strategic_commentary = nil
	delete(m.clearedFields, strategicroadmap.FieldStrategicCommentary)
}

// SetCreatedAt sets the "created_at" field.
func (m *StrategicRoadmapMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *StrategicRoadmapMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the StrategicRoadmap entity.
// If the StrategicRoadmap object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StrategicRoadmapMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *StrategicRoadmapMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *StrategicRoadmapMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *StrategicRoadmapMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the StrategicRoadmap entity.
// If the StrategicRoadmap object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StrategicRoadmapMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *StrategicRoadmapMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetTenantID sets the "tenant" edge to the Tenant entity by id.
func (m *StrategicRoadmapMutation) SetTenantID(id int) {
	m.tenant = &id
}

// ClearTenant clears the "tenant" edge to the Tenant entity.
func (m *StrategicRoadmapMutation) ClearTenant() {
	m.clearedtenant = true
}

// TenantCleared reports if the "tenant" edge to the Tenant entity was cleared.
func (m *StrategicRoadmapMutation) TenantCleared() bool {
	return m.clearedtenant
}

// TenantID returns the "tenant" edge ID in the mutation.
func (m *StrategicRoadmapMutation) TenantID() (id int, exists bool) {
	if m.tenant != nil {
		return *m.tenant, true
	}
	return
}

// TenantIDs returns the "tenant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TenantID instead. It exists only for internal usage by the builders.
func (m *StrategicRoadmapMutation) TenantIDs() (ids []int) {
	if id := m.tenant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTenant resets all changes to the "tenant" edge.
func (m *StrategicRoadmapMutation) ResetTenant() {
	m.tenant = nil
	m.clearedtenant = false
}

// Where appends a list predicates to the StrategicRoadmapMutation builder.
func (m *StrategicRoadmapMutation) Where(ps ...predicate.StrategicRoadmap) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the StrategicRoadmapMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *StrategicRoadmapMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.StrategicRoadmap, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *StrategicRoadmapMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *StrategicRoadmapMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (StrategicRoadmap).
func (m *StrategicRoadmapMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *StrategicRoadmapMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.project_name != nil {
		fields = append(fields, strategicroadmap.FieldProjectName)
	}
	if m.description != nil {
		fields = append(fields, strategicroadmap.FieldDescription)
	}
	if m.priority != nil {
		fields = append(fields, strategicroadmap.FieldPriority)
	}
	if m.status != nil {
		fields = append(fields, strategicroadmap.FieldStatus)
	}
	if m.estimated_cost != nil {
		fields = append(fields, strategicroadmap.FieldEstimatedCost)
	}
	if m.target_date != nil {
		fields = append(fields, strategicroadmap.FieldTargetDate)
	}
	if m.strategic_commentary != nil {
		fields = append(fields, strategicroadmap.FieldStrategicCommentary)
	}
	if m.created_at != nil {
		fields = append(fields, strategicroadmap.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, strategicroadmap.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *StrategicRoadmapMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case strategicroadmap.FieldProjectName:
		return m.ProjectName()
	case strategicroadmap.FieldDescription:
		return m.Description()
	case strategicroadmap.FieldPriority:
		return m.Priority()
	case strategicroadmap.FieldStatus:
		return m.Status()
	case strategicroadmap.FieldEstimatedCost:
		return m.EstimatedCost()
	case strategicroadmap.FieldTargetDate:
		return m.TargetDate()
	case strategicroadmap.FieldStrategicCommentary:
		return m.StrategicCommentary()
	case strategicroadmap.FieldCreatedAt:
		return m.CreatedAt()
	case strategicroadmap.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *StrategicRoadmapMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case strategicroadmap.FieldProjectName:
		return m.OldProjectName(ctx)
	case strategicroadmap.FieldDescription:
		return m.OldDescription(ctx)
	case strategicroadmap.FieldPriority:
		return m.OldPriority(ctx)
	case strategicroadmap.FieldStatus:
		return m.OldStatus(ctx)
	case strategicroadmap.FieldEstimatedCost:
		return m.OldEstimatedCost(ctx)
	case strategicroadmap.FieldTargetDate:
		return m.OldTargetDate(ctx)
	case strategicroadmap.FieldStrategicCommentary:
		return m.OldStrategicCommentary(ctx)
	case strategicroadmap.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case strategicroadmap.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown StrategicRoadmap field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *StrategicRoadmapMutation) SetField(name string, value ent.Value) error {
	switch name {
	case strategicroadmap.FieldProjectName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProjectName(v)
		return nil
	case strategicroadmap.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case strategicroadmap.FieldPriority:
		v, ok := value.(strategicroadmap.Priority)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPriority(v)
		return nil
	case strategicroadmap.FieldStatus:
		v, ok := value.(strategicroadmap.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case strategicroadmap.FieldEstimatedCost:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEstimatedCost(v)
		return nil
	case strategicroadmap.FieldTargetDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTargetDate(v)
		return nil
	case strategicroadmap.FieldStrategicCommentary:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStrategicCommentary(v)
		return nil
	case strategicroadmap.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case strategicroadmap.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown StrategicRoadmap field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *StrategicRoadmapMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *StrategicRoadmapMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *StrategicRoadmapMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown StrategicRoadmap numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *StrategicRoadmapMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(strategicroadmap.FieldDescription) {
		fields = append(fields, strategicroadmap.FieldDescription)
	}
	if m.FieldCleared(strategicroadmap.FieldStrategicCommentary) {
		fields = append(fields, strategicroadmap.FieldStrategicCommentary)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *StrategicRoadmapMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *StrategicRoadmapMutation) ClearField(name string) error {
	switch name {
	case strategicroadmap.FieldDescription:
		m.ClearDescription()
		return nil
	case strategicroadmap.FieldStrategicCommentary:
		m.ClearStrategicCommentary()
		return nil
	}
	return fmt.Errorf("unknown StrategicRoadmap nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *StrategicRoadmapMutation) ResetField(name string) error {
	switch name {
	case strategicroadmap.FieldProjectName:
		m.ResetProjectName()
		return nil
	case strategicroadmap.FieldDescription:
		m.ResetDescription()
		return nil
	case strategicroadmap.FieldPriority:
		m.ResetPriority()
		return nil
	case strategicroadmap.FieldStatus:
		m.ResetStatus()
		return nil
	case strategicroadmap.FieldEstimatedCost:
		m.ResetEstimatedCost()
		return nil
	case strategicroadmap.FieldTargetDate:
		m.ResetTargetDate()
		return nil
	case strategicroadmap.FieldStrategicCommentary:
		m.ResetStrategicCommentary()
		return nil
	case strategicroadmap.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case strategicroadmap.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown StrategicRoadmap field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *StrategicRoadmapMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.tenant != nil {
		edges = append(edges, strategicroadmap.EdgeTenant)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *StrategicRoadmapMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case strategicroadmap.EdgeTenant:
		if id := m.tenant; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *StrategicRoadmapMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *StrategicRoadmapMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *StrategicRoadmapMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedtenant {
		edges = append(edges, strategicroadmap.EdgeTenant)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *StrategicRoadmapMutation) EdgeCleared(name string) bool {
	switch name {
	case strategicroadmap.EdgeTenant:
		return m.clearedtenant
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *StrategicRoadmapMutation) ClearEdge(name string) error {
	switch name {
	case strategicroadmap.EdgeTenant:
		m.ClearTenant()
		return nil
	}
	return fmt.Errorf("unknown StrategicRoadmap unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *StrategicRoadmapMutation) ResetEdge(name string) error {
	switch name {
	case strategicroadmap.EdgeTenant:
		m.ResetTenant()
		return nil
	}
	return fmt.Errorf("unknown StrategicRoadmap edge %s", name)
}

// SuccessionMapMutation represents an operation that mutates the SuccessionMap nodes in the graph.
type SuccessionMapMutation struct {
	config
	op                      Op
	typ                     string
	id                      *int
	readiness_level         *successionmap.ReadinessLevel
	notes                   *string
	created_at              *time.Time
	clearedFields           map[string]struct{}
	employee                *int
	clearedemployee         bool
	backup_candidate        *int
	clearedbackup_candidate bool
	tenant                  *int
	clearedtenant           bool
	done                    bool
	oldValue                func(context.Context) (*SuccessionMap, error)
	predicates              []predicate.SuccessionMap
}

var _ ent.Mutation = (*SuccessionMapMutation)(nil)

// successionmapOption allows management of the mutation configuration using functional options.
type successionmapOption func(*SuccessionMapMutation)

// newSuccessionMapMutation creates new mutation for the SuccessionMap entity.
func newSuccessionMapMutation(c config, op Op, opts ...successionmapOption) *SuccessionMapMutation {
	m := &SuccessionMapMutation{
		config:        c,
		op:            op,
		typ:           TypeSuccessionMap,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSuccessionMapID sets the ID field of the mutation.
func withSuccessionMapID(id int) successionmapOption {
	return func(m *SuccessionMapMutation) {
		var (
			err   error
			once  sync.Once
			value *SuccessionMap
		)
		m.oldValue = func(ctx context.Context) (*SuccessionMap, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().SuccessionMap.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSuccessionMap sets the old SuccessionMap of the mutation.
func withSuccessionMap(node *SuccessionMap) successionmapOption {
	return func(m *SuccessionMapMutation) {
		m.oldValue = func(context.Context) (*SuccessionMap, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SuccessionMapMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SuccessionMapMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SuccessionMapMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SuccessionMapMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().SuccessionMap.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetReadinessLevel sets the "readiness_level" field.
func (m *SuccessionMapMutation) SetReadinessLevel(sl successionmap.ReadinessLevel) {
	m.readiness_level = &sl
}

// ReadinessLevel returns the value of the "readiness_level" field in the mutation.
func (m *SuccessionMapMutation) ReadinessLevel() (r successionmap.ReadinessLevel, exists bool) {
	v := m.readiness_level
	if v == nil {
		return
	}
	return *v, true
}

// OldReadinessLevel returns the old "readiness_level" field's value of the SuccessionMap entity.
// If the SuccessionMap object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SuccessionMapMutation) OldReadinessLevel(ctx context.Context) (v successionmap.ReadinessLevel, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReadinessLevel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReadinessLevel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReadinessLevel: %w", err)
	}
	return oldValue.ReadinessLevel, nil
}

// ResetReadinessLevel resets all changes to the "readiness_level" field.
func (m *SuccessionMapMutation) ResetReadinessLevel() {
	m.readiness_level = nil
}

// SetNotes sets the "notes" field.
func (m *SuccessionMapMutation) SetNotes(s string) {
	m.notes = &s
}

// Notes returns the value of the "notes" field in the mutation.
func (m *SuccessionMapMutation) Notes() (r string, exists bool) {
	v := m.notes
	if v == nil {
		return
	}
	return *v, true
}

// OldNotes returns the old "notes" field's value of the SuccessionMap entity.
// If the SuccessionMap object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SuccessionMapMutation) OldNotes(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNotes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNotes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNotes: %w", err)
	}
	return oldValue.Notes, nil
}

// ClearNotes clears the value of the "notes" field.
func (m *SuccessionMapMutation) ClearNotes() {
	m.notes = nil
	m.clearedFields[successionmap.FieldNotes] = struct{}{}
}

// NotesCleared returns if the "notes" field was cleared in this mutation.
func (m *SuccessionMapMutation) NotesCleared() bool {
	_, ok := m.clearedFields[successionmap.FieldNotes]
	return ok
}

// ResetNotes resets all changes to the "notes" field.
func (m *SuccessionMapMutation) ResetNotes() {
	m.notes = nil
	delete(m.clearedFields, successionmap.FieldNotes)
}

// SetCreatedAt sets the "created_at" field.
func (m *SuccessionMapMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *SuccessionMapMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the SuccessionMap entity.
// If the SuccessionMap object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SuccessionMapMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *SuccessionMapMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetEmployeeID sets the "employee" edge to the Employee entity by id.
func (m *SuccessionMapMutation) SetEmployeeID(id int) {
	m.employee = &id
}

// ClearEmployee clears the "employee" edge to the Employee entity.
func (m *SuccessionMapMutation) ClearEmployee() {
	m.clearedemployee = true
}

// EmployeeCleared reports if the "employee" edge to the Employee entity was cleared.
func (m *SuccessionMapMutation) EmployeeCleared() bool {
	return m.clearedemployee
}

// EmployeeID returns the "employee" edge ID in the mutation.
func (m *SuccessionMapMutation) EmployeeID() (id int, exists bool) {
	if m.employee != nil {
		return *m.employee, true
	}
	return
}

// EmployeeIDs returns the "employee" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// EmployeeID instead. It exists only for internal usage by the builders.
func (m *SuccessionMapMutation) EmployeeIDs() (ids []int) {
	if id := m.employee; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEmployee resets all changes to the "employee" edge.
func (m *SuccessionMapMutation) ResetEmployee() {
	m.employee = nil
	m.clearedemployee = false
}

// SetBackupCandidateID sets the "backup_candidate" edge to the Employee entity by id.
func (m *SuccessionMapMutation) SetBackupCandidateID(id int) {
	m.backup_candidate = &id
}

// ClearBackupCandidate clears the "backup_candidate" edge to the Employee entity.
func (m *SuccessionMapMutation) ClearBackupCandidate() {
	m.clearedbackup_candidate = true
}

// BackupCandidateCleared reports if the "backup_candidate" edge to the Employee entity was cleared.
func (m *SuccessionMapMutation) BackupCandidateCleared() bool {
	return m.clearedbackup_candidate
}

// BackupCandidateID returns the "backup_candidate" edge ID in the mutation.
func (m *SuccessionMapMutation) BackupCandidateID() (id int, exists bool) {
	if m.backup_candidate != nil {
		return *m.backup_candidate, true
	}
	return
}

// BackupCandidateIDs returns the "backup_candidate" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BackupCandidateID instead. It exists only for internal usage by the builders.
func (m *SuccessionMapMutation) BackupCandidateIDs() (ids []int) {
	if id := m.backup_candidate; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBackupCandidate resets all changes to the "backup_candidate" edge.
func (m *SuccessionMapMutation) ResetBackupCandidate() {
	m.backup_candidate = nil
	m.clearedbackup_candidate = false
}

// SetTenantID sets the "tenant" edge to the Tenant entity by id.
func (m *SuccessionMapMutation) SetTenantID(id int) {
	m.tenant = &id
}

// ClearTenant clears the "tenant" edge to the Tenant entity.
func (m *SuccessionMapMutation) ClearTenant() {
	m.clearedtenant = true
}

// TenantCleared reports if the "tenant" edge to the Tenant entity was cleared.
func (m *SuccessionMapMutation) TenantCleared() bool {
	return m.clearedtenant
}

// TenantID returns the "tenant" edge ID in the mutation.
func (m *SuccessionMapMutation) TenantID() (id int, exists bool) {
	if m.tenant != nil {
		return *m.tenant, true
	}
	return
}

// TenantIDs returns the "tenant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TenantID instead. It exists only for internal usage by the builders.
func (m *SuccessionMapMutation) TenantIDs() (ids []int) {
	if id := m.tenant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTenant resets all changes to the "tenant" edge.
func (m *SuccessionMapMutation) ResetTenant() {
	m.tenant = nil
	m.clearedtenant = false
}

// Where appends a list predicates to the SuccessionMapMutation builder.
func (m *SuccessionMapMutation) Where(ps ...predicate.SuccessionMap) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SuccessionMapMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SuccessionMapMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.SuccessionMap, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SuccessionMapMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SuccessionMapMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (SuccessionMap).
func (m *SuccessionMapMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SuccessionMapMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.readiness_level != nil {
		fields = append(fields, successionmap.FieldReadinessLevel)
	}
	if m.notes != nil {
		fields = append(fields, successionmap.FieldNotes)
	}
	if m.created_at != nil {
		fields = append(fields, successionmap.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SuccessionMapMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case successionmap.FieldReadinessLevel:
		return m.ReadinessLevel()
	case successionmap.FieldNotes:
		return m.Notes()
	case successionmap.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SuccessionMapMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case successionmap.FieldReadinessLevel:
		return m.OldReadinessLevel(ctx)
	case successionmap.FieldNotes:
		return m.OldNotes(ctx)
	case successionmap.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown SuccessionMap field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SuccessionMapMutation) SetField(name string, value ent.Value) error {
	switch name {
	case successionmap.FieldReadinessLevel:
		v, ok := value.(successionmap.ReadinessLevel)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReadinessLevel(v)
		return nil
	case successionmap.FieldNotes:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNotes(v)
		return nil
	case successionmap.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown SuccessionMap field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SuccessionMapMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SuccessionMapMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SuccessionMapMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown SuccessionMap numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SuccessionMapMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(successionmap.FieldNotes) {
		fields = append(fields, successionmap.FieldNotes)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SuccessionMapMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SuccessionMapMutation) ClearField(name string) error {
	switch name {
	case successionmap.FieldNotes:
		m.ClearNotes()
		return nil
	}
	return fmt.Errorf("unknown SuccessionMap nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SuccessionMapMutation) ResetField(name string) error {
	switch name {
	case successionmap.FieldReadinessLevel:
		m.ResetReadinessLevel()
		return nil
	case successionmap.FieldNotes:
		m.ResetNotes()
		return nil
	case successionmap.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown SuccessionMap field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SuccessionMapMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.employee != nil {
		edges = append(edges, successionmap.EdgeEmployee)
	}
	if m.backup_candidate != nil {
		edges = append(edges, successionmap.EdgeBackupCandidate)
	}
	if m.tenant != nil {
		edges = append(edges, successionmap.EdgeTenant)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SuccessionMapMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case successionmap.EdgeEmployee:
		if id := m.employee; id != nil {
			return []ent.Value{*id}
		}
	case successionmap.EdgeBackupCandidate:
		if id := m.backup_candidate; id != nil {
			return []ent.Value{*id}
		}
	case successionmap.EdgeTenant:
		if id := m.tenant; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SuccessionMapMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SuccessionMapMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SuccessionMapMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedemployee {
		edges = append(edges, successionmap.EdgeEmployee)
	}
	if m.clearedbackup_candidate {
		edges = append(edges, successionmap.EdgeBackupCandidate)
	}
	if m.clearedtenant {
		edges = append(edges, successionmap.EdgeTenant)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SuccessionMapMutation) EdgeCleared(name string) bool {
	switch name {
	case successionmap.EdgeEmployee:
		return m.clearedemployee
	case successionmap.EdgeBackupCandidate:
		return m.clearedbackup_candidate
	case successionmap.EdgeTenant:
		return m.clearedtenant
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SuccessionMapMutation) ClearEdge(name string) error {
	switch name {
	case successionmap.EdgeEmployee:
		m.ClearEmployee()
		return nil
	case successionmap.EdgeBackupCandidate:
		m.ClearBackupCandidate()
		return nil
	case successionmap.EdgeTenant:
		m.ClearTenant()
		return nil
	}
	return fmt.Errorf("unknown SuccessionMap unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SuccessionMapMutation) ResetEdge(name string) error {
	switch name {
	case successionmap.EdgeEmployee:
		m.ResetEmployee()
		return nil
	case successionmap.EdgeBackupCandidate:
		m.ResetBackupCandidate()
		return nil
	case successionmap.EdgeTenant:
		m.ResetTenant()
		return nil
	}
	return fmt.Errorf("unknown SuccessionMap edge %s", name)
}

// SupplierMutation represents an operation that mutates the Supplier nodes in the graph.
type SupplierMutation struct {
	config
	op                     Op
	typ                    string
	id                     *int
	name                   *string
	contact_person         *string
	email                  *string
	phone                  *string
	address                *string
	website                *string
	clearedFields          map[string]struct{}
	tenant                 *int
	clearedtenant          bool
	products               map[int]struct{}
	removedproducts        map[int]struct{}
	clearedproducts        bool
	purchase_orders        map[int]struct{}
	removedpurchase_orders map[int]struct{}
	clearedpurchase_orders bool
	done                   bool
	oldValue               func(context.Context) (*Supplier, error)
	predicates             []predicate.Supplier
}

var _ ent.Mutation = (*SupplierMutation)(nil)

// supplierOption allows management of the mutation configuration using functional options.
type supplierOption func(*SupplierMutation)

// newSupplierMutation creates new mutation for the Supplier entity.
func newSupplierMutation(c config, op Op, opts ...supplierOption) *SupplierMutation {
	m := &SupplierMutation{
		config:        c,
		op:            op,
		typ:           TypeSupplier,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSupplierID sets the ID field of the mutation.
func withSupplierID(id int) supplierOption {
	return func(m *SupplierMutation) {
		var (
			err   error
			once  sync.Once
			value *Supplier
		)
		m.oldValue = func(ctx context.Context) (*Supplier, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Supplier.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSupplier sets the old Supplier of the mutation.
func withSupplier(node *Supplier) supplierOption {
	return func(m *SupplierMutation) {
		m.oldValue = func(context.Context) (*Supplier, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SupplierMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SupplierMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SupplierMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SupplierMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Supplier.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *SupplierMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *SupplierMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Supplier entity.
// If the Supplier object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SupplierMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *SupplierMutation) ResetName() {
	m.name = nil
}

// SetContactPerson sets the "contact_person" field.
func (m *SupplierMutation) SetContactPerson(s string) {
	m.contact_person = &s
}

// ContactPerson returns the value of the "contact_person" field in the mutation.
func (m *SupplierMutation) ContactPerson() (r string, exists bool) {
	v := m.contact_person
	if v == nil {
		return
	}
	return *v, true
}

// OldContactPerson returns the old "contact_person" field's value of the Supplier entity.
// If the Supplier object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SupplierMutation) OldContactPerson(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContactPerson is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContactPerson requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContactPerson: %w", err)
	}
	return oldValue.ContactPerson, nil
}

// ClearContactPerson clears the value of the "contact_person" field.
func (m *SupplierMutation) ClearContactPerson() {
	m.contact_person = nil
	m.clearedFields[supplier.FieldContactPerson] = struct{}{}
}

// ContactPersonCleared returns if the "contact_person" field was cleared in this mutation.
func (m *SupplierMutation) ContactPersonCleared() bool {
	_, ok := m.clearedFields[supplier.FieldContactPerson]
	return ok
}

// ResetContactPerson resets all changes to the "contact_person" field.
func (m *SupplierMutation) ResetContactPerson() {
	m.contact_person = nil
	delete(m.clearedFields, supplier.FieldContactPerson)
}

// SetEmail sets the "email" field.
func (m *SupplierMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *SupplierMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the Supplier entity.
// If the Supplier object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SupplierMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ClearEmail clears the value of the "email" field.
func (m *SupplierMutation) ClearEmail() {
	m.email = nil
	m.clearedFields[supplier.FieldEmail] = struct{}{}
}

// EmailCleared returns if the "email" field was cleared in this mutation.
func (m *SupplierMutation) EmailCleared() bool {
	_, ok := m.clearedFields[supplier.FieldEmail]
	return ok
}

// ResetEmail resets all changes to the "email" field.
func (m *SupplierMutation) ResetEmail() {
	m.email = nil
	delete(m.clearedFields, supplier.FieldEmail)
}

// SetPhone sets the "phone" field.
func (m *SupplierMutation) SetPhone(s string) {
	m.phone = &s
}

// Phone returns the value of the "phone" field in the mutation.
func (m *SupplierMutation) Phone() (r string, exists bool) {
	v := m.phone
	if v == nil {
		return
	}
	return *v, true
}

// OldPhone returns the old "phone" field's value of the Supplier entity.
// If the Supplier object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SupplierMutation) OldPhone(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPhone is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPhone requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhone: %w", err)
	}
	return oldValue.Phone, nil
}

// ClearPhone clears the value of the "phone" field.
func (m *SupplierMutation) ClearPhone() {
	m.phone = nil
	m.clearedFields[supplier.FieldPhone] = struct{}{}
}

// PhoneCleared returns if the "phone" field was cleared in this mutation.
func (m *SupplierMutation) PhoneCleared() bool {
	_, ok := m.clearedFields[supplier.FieldPhone]
	return ok
}

// ResetPhone resets all changes to the "phone" field.
func (m *SupplierMutation) ResetPhone() {
	m.phone = nil
	delete(m.clearedFields, supplier.FieldPhone)
}

// SetAddress sets the "address" field.
func (m *SupplierMutation) SetAddress(s string) {
	m.address = &s
}

// Address returns the value of the "address" field in the mutation.
func (m *SupplierMutation) Address() (r string, exists bool) {
	v := m.address
	if v == nil {
		return
	}
	return *v, true
}

// OldAddress returns the old "address" field's value of the Supplier entity.
// If the Supplier object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SupplierMutation) OldAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAddress: %w", err)
	}
	return oldValue.Address, nil
}

// ClearAddress clears the value of the "address" field.
func (m *SupplierMutation) ClearAddress() {
	m.address = nil
	m.clearedFields[supplier.FieldAddress] = struct{}{}
}

// AddressCleared returns if the "address" field was cleared in this mutation.
func (m *SupplierMutation) AddressCleared() bool {
	_, ok := m.clearedFields[supplier.FieldAddress]
	return ok
}

// ResetAddress resets all changes to the "address" field.
func (m *SupplierMutation) ResetAddress() {
	m.address = nil
	delete(m.clearedFields, supplier.FieldAddress)
}

// SetWebsite sets the "website" field.
func (m *SupplierMutation) SetWebsite(s string) {
	m.website = &s
}

// Website returns the value of the "website" field in the mutation.
func (m *SupplierMutation) Website() (r string, exists bool) {
	v := m.website
	if v == nil {
		return
	}
	return *v, true
}

// OldWebsite returns the old "website" field's value of the Supplier entity.
// If the Supplier object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SupplierMutation) OldWebsite(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWebsite is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWebsite requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWebsite: %w", err)
	}
	return oldValue.Website, nil
}

// ClearWebsite clears the value of the "website" field.
func (m *SupplierMutation) ClearWebsite() {
	m.website = nil
	m.clearedFields[supplier.FieldWebsite] = struct{}{}
}

// WebsiteCleared returns if the "website" field was cleared in this mutation.
func (m *SupplierMutation) WebsiteCleared() bool {
	_, ok := m.clearedFields[supplier.FieldWebsite]
	return ok
}

// ResetWebsite resets all changes to the "website" field.
func (m *SupplierMutation) ResetWebsite() {
	m.website = nil
	delete(m.clearedFields, supplier.FieldWebsite)
}

// SetTenantID sets the "tenant" edge to the Tenant entity by id.
func (m *SupplierMutation) SetTenantID(id int) {
	m.tenant = &id
}

// ClearTenant clears the "tenant" edge to the Tenant entity.
func (m *SupplierMutation) ClearTenant() {
	m.clearedtenant = true
}

// TenantCleared reports if the "tenant" edge to the Tenant entity was cleared.
func (m *SupplierMutation) TenantCleared() bool {
	return m.clearedtenant
}

// TenantID returns the "tenant" edge ID in the mutation.
func (m *SupplierMutation) TenantID() (id int, exists bool) {
	if m.tenant != nil {
		return *m.tenant, true
	}
	return
}

// TenantIDs returns the "tenant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TenantID instead. It exists only for internal usage by the builders.
func (m *SupplierMutation) TenantIDs() (ids []int) {
	if id := m.tenant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTenant resets all changes to the "tenant" edge.
func (m *SupplierMutation) ResetTenant() {
	m.tenant = nil
	m.clearedtenant = false
}

// AddProductIDs adds the "products" edge to the Product entity by ids.
func (m *SupplierMutation) AddProductIDs(ids ...int) {
	if m.products == nil {
		m.products = make(map[int]struct{})
	}
	for i := range ids {
		m.products[ids[i]] = struct{}{}
	}
}

// ClearProducts clears the "products" edge to the Product entity.
func (m *SupplierMutation) ClearProducts() {
	m.clearedproducts = true
}

// ProductsCleared reports if the "products" edge to the Product entity was cleared.
func (m *SupplierMutation) ProductsCleared() bool {
	return m.clearedproducts
}

// RemoveProductIDs removes the "products" edge to the Product entity by IDs.
func (m *SupplierMutation) RemoveProductIDs(ids ...int) {
	if m.removedproducts == nil {
		m.removedproducts = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.products, ids[i])
		m.removedproducts[ids[i]] = struct{}{}
	}
}

// RemovedProducts returns the removed IDs of the "products" edge to the Product entity.
func (m *SupplierMutation) RemovedProductsIDs() (ids []int) {
	for id := range m.removedproducts {
		ids = append(ids, id)
	}
	return
}

// ProductsIDs returns the "products" edge IDs in the mutation.
func (m *SupplierMutation) ProductsIDs() (ids []int) {
	for id := range m.products {
		ids = append(ids, id)
	}
	return
}

// ResetProducts resets all changes to the "products" edge.
func (m *SupplierMutation) ResetProducts() {
	m.products = nil
	m.clearedproducts = false
	m.removedproducts = nil
}

// AddPurchaseOrderIDs adds the "purchase_orders" edge to the PurchaseOrder entity by ids.
func (m *SupplierMutation) AddPurchaseOrderIDs(ids ...int) {
	if m.purchase_orders == nil {
		m.purchase_orders = make(map[int]struct{})
	}
	for i := range ids {
		m.purchase_orders[ids[i]] = struct{}{}
	}
}

// ClearPurchaseOrders clears the "purchase_orders" edge to the PurchaseOrder entity.
func (m *SupplierMutation) ClearPurchaseOrders() {
	m.clearedpurchase_orders = true
}

// PurchaseOrdersCleared reports if the "purchase_orders" edge to the PurchaseOrder entity was cleared.
func (m *SupplierMutation) PurchaseOrdersCleared() bool {
	return m.clearedpurchase_orders
}

// RemovePurchaseOrderIDs removes the "purchase_orders" edge to the PurchaseOrder entity by IDs.
func (m *SupplierMutation) RemovePurchaseOrderIDs(ids ...int) {
	if m.removedpurchase_orders == nil {
		m.removedpurchase_orders = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.purchase_orders, ids[i])
		m.removedpurchase_orders[ids[i]] = struct{}{}
	}
}

// RemovedPurchaseOrders returns the removed IDs of the "purchase_orders" edge to the PurchaseOrder entity.
func (m *SupplierMutation) RemovedPurchaseOrdersIDs() (ids []int) {
	for id := range m.removedpurchase_orders {
		ids = append(ids, id)
	}
	return
}

// PurchaseOrdersIDs returns the "purchase_orders" edge IDs in the mutation.
func (m *SupplierMutation) PurchaseOrdersIDs() (ids []int) {
	for id := range m.purchase_orders {
		ids = append(ids, id)
	}
	return
}

// ResetPurchaseOrders resets all changes to the "purchase_orders" edge.
func (m *SupplierMutation) ResetPurchaseOrders() {
	m.purchase_orders = nil
	m.clearedpurchase_orders = false
	m.removedpurchase_orders = nil
}

// Where appends a list predicates to the SupplierMutation builder.
func (m *SupplierMutation) Where(ps ...predicate.Supplier) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SupplierMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SupplierMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Supplier, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SupplierMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SupplierMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Supplier).
func (m *SupplierMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SupplierMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.name != nil {
		fields = append(fields, supplier.FieldName)
	}
	if m.contact_person != nil {
		fields = append(fields, supplier.FieldContactPerson)
	}
	if m.email != nil {
		fields = append(fields, supplier.FieldEmail)
	}
	if m.phone != nil {
		fields = append(fields, supplier.FieldPhone)
	}
	if m.address != nil {
		fields = append(fields, supplier.FieldAddress)
	}
	if m.website != nil {
		fields = append(fields, supplier.FieldWebsite)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SupplierMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case supplier.FieldName:
		return m.Name()
	case supplier.FieldContactPerson:
		return m.ContactPerson()
	case supplier.FieldEmail:
		return m.Email()
	case supplier.FieldPhone:
		return m.Phone()
	case supplier.FieldAddress:
		return m.Address()
	case supplier.FieldWebsite:
		return m.Website()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SupplierMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case supplier.FieldName:
		return m.OldName(ctx)
	case supplier.FieldContactPerson:
		return m.OldContactPerson(ctx)
	case supplier.FieldEmail:
		return m.OldEmail(ctx)
	case supplier.FieldPhone:
		return m.OldPhone(ctx)
	case supplier.FieldAddress:
		return m.OldAddress(ctx)
	case supplier.FieldWebsite:
		return m.OldWebsite(ctx)
	}
	return nil, fmt.Errorf("unknown Supplier field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SupplierMutation) SetField(name string, value ent.Value) error {
	switch name {
	case supplier.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case supplier.FieldContactPerson:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContactPerson(v)
		return nil
	case supplier.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case supplier.FieldPhone:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhone(v)
		return nil
	case supplier.FieldAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAddress(v)
		return nil
	case supplier.FieldWebsite:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWebsite(v)
		return nil
	}
	return fmt.Errorf("unknown Supplier field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SupplierMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SupplierMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SupplierMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Supplier numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SupplierMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(supplier.FieldContactPerson) {
		fields = append(fields, supplier.FieldContactPerson)
	}
	if m.FieldCleared(supplier.FieldEmail) {
		fields = append(fields, supplier.FieldEmail)
	}
	if m.FieldCleared(supplier.FieldPhone) {
		fields = append(fields, supplier.FieldPhone)
	}
	if m.FieldCleared(supplier.FieldAddress) {
		fields = append(fields, supplier.FieldAddress)
	}
	if m.FieldCleared(supplier.FieldWebsite) {
		fields = append(fields, supplier.FieldWebsite)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SupplierMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SupplierMutation) ClearField(name string) error {
	switch name {
	case supplier.FieldContactPerson:
		m.ClearContactPerson()
		return nil
	case supplier.FieldEmail:
		m.ClearEmail()
		return nil
	case supplier.FieldPhone:
		m.ClearPhone()
		return nil
	case supplier.FieldAddress:
		m.ClearAddress()
		return nil
	case supplier.FieldWebsite:
		m.ClearWebsite()
		return nil
	}
	return fmt.Errorf("unknown Supplier nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SupplierMutation) ResetField(name string) error {
	switch name {
	case supplier.FieldName:
		m.ResetName()
		return nil
	case supplier.FieldContactPerson:
		m.ResetContactPerson()
		return nil
	case supplier.FieldEmail:
		m.ResetEmail()
		return nil
	case supplier.FieldPhone:
		m.ResetPhone()
		return nil
	case supplier.FieldAddress:
		m.ResetAddress()
		return nil
	case supplier.FieldWebsite:
		m.ResetWebsite()
		return nil
	}
	return fmt.Errorf("unknown Supplier field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SupplierMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.tenant != nil {
		edges = append(edges, supplier.EdgeTenant)
	}
	if m.products != nil {
		edges = append(edges, supplier.EdgeProducts)
	}
	if m.purchase_orders != nil {
		edges = append(edges, supplier.EdgePurchaseOrders)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SupplierMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case supplier.EdgeTenant:
		if id := m.tenant; id != nil {
			return []ent.Value{*id}
		}
	case supplier.EdgeProducts:
		ids := make([]ent.Value, 0, len(m.products))
		for id := range m.products {
			ids = append(ids, id)
		}
		return ids
	case supplier.EdgePurchaseOrders:
		ids := make([]ent.Value, 0, len(m.purchase_orders))
		for id := range m.purchase_orders {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SupplierMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedproducts != nil {
		edges = append(edges, supplier.EdgeProducts)
	}
	if m.removedpurchase_orders != nil {
		edges = append(edges, supplier.EdgePurchaseOrders)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SupplierMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case supplier.EdgeProducts:
		ids := make([]ent.Value, 0, len(m.removedproducts))
		for id := range m.removedproducts {
			ids = append(ids, id)
		}
		return ids
	case supplier.EdgePurchaseOrders:
		ids := make([]ent.Value, 0, len(m.removedpurchase_orders))
		for id := range m.removedpurchase_orders {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SupplierMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedtenant {
		edges = append(edges, supplier.EdgeTenant)
	}
	if m.clearedproducts {
		edges = append(edges, supplier.EdgeProducts)
	}
	if m.clearedpurchase_orders {
		edges = append(edges, supplier.EdgePurchaseOrders)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SupplierMutation) EdgeCleared(name string) bool {
	switch name {
	case supplier.EdgeTenant:
		return m.clearedtenant
	case supplier.EdgeProducts:
		return m.clearedproducts
	case supplier.EdgePurchaseOrders:
		return m.clearedpurchase_orders
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SupplierMutation) ClearEdge(name string) error {
	switch name {
	case supplier.EdgeTenant:
		m.ClearTenant()
		return nil
	}
	return fmt.Errorf("unknown Supplier unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SupplierMutation) ResetEdge(name string) error {
	switch name {
	case supplier.EdgeTenant:
		m.ResetTenant()
		return nil
	case supplier.EdgeProducts:
		m.ResetProducts()
		return nil
	case supplier.EdgePurchaseOrders:
		m.ResetPurchaseOrders()
		return nil
	}
	return fmt.Errorf("unknown Supplier edge %s", name)
}

// TenantMutation represents an operation that mutates the Tenant nodes in the graph.
type TenantMutation struct {
	config
	op                             Op
	typ                            string
	id                             *int
	name                           *string
	domain                         *string
	created_at                     *time.Time
	active                         *bool
	transaction_limit              *decimal.Decimal
	clearedFields                  map[string]struct{}
	parent                         *int
	clearedparent                  bool
	children                       map[int]struct{}
	removedchildren                map[int]struct{}
	clearedchildren                bool
	users                          map[int]struct{}
	removedusers                   map[int]struct{}
	clearedusers                   bool
	accounts                       map[int]struct{}
	removedaccounts                map[int]struct{}
	clearedaccounts                bool
	transactions                   map[int]struct{}
	removedtransactions            map[int]struct{}
	clearedtransactions            bool
	ledger_entries                 map[int]struct{}
	removedledger_entries          map[int]struct{}
	clearedledger_entries          bool
	products                       map[int]struct{}
	removedproducts                map[int]struct{}
	clearedproducts                bool
	stock_movements                map[int]struct{}
	removedstock_movements         map[int]struct{}
	clearedstock_movements         bool
	audit_logs                     map[int]struct{}
	removedaudit_logs              map[int]struct{}
	clearedaudit_logs              bool
	agents                         map[int]struct{}
	removedagents                  map[int]struct{}
	clearedagents                  bool
	discovery_entries              map[int]struct{}
	removeddiscovery_entries       map[int]struct{}
	cleareddiscovery_entries       bool
	assets                         map[int]struct{}
	removedassets                  map[int]struct{}
	clearedassets                  bool
	credentials                    map[int]struct{}
	removedcredentials             map[int]struct{}
	clearedcredentials             bool
	one_time_links                 map[int]struct{}
	removedone_time_links          map[int]struct{}
	clearedone_time_links          bool
	sops                           map[int]struct{}
	removedsops                    map[int]struct{}
	clearedsops                    bool
	cameras                        map[int]struct{}
	removedcameras                 map[int]struct{}
	clearedcameras                 bool
	tickets                        map[int]struct{}
	removedtickets                 map[int]struct{}
	clearedtickets                 bool
	contracts                      map[int]struct{}
	removedcontracts               map[int]struct{}
	clearedcontracts               bool
	saas_apps                      map[int]struct{}
	removedsaas_apps               map[int]struct{}
	clearedsaas_apps               bool
	saas_filters                   map[int]struct{}
	removedsaas_filters            map[int]struct{}
	clearedsaas_filters            bool
	call_logs                      map[int]struct{}
	removedcall_logs               map[int]struct{}
	clearedcall_logs               bool
	ivr_flows                      map[int]struct{}
	removedivr_flows               map[int]struct{}
	clearedivr_flows               bool
	voicemails                     map[int]struct{}
	removedvoicemails              map[int]struct{}
	clearedvoicemails              bool
	health_snapshots               map[int]struct{}
	removedhealth_snapshots        map[int]struct{}
	clearedhealth_snapshots        bool
	roadmaps                       map[int]struct{}
	removedroadmaps                map[int]struct{}
	clearedroadmaps                bool
	service_rates                  map[int]struct{}
	removedservice_rates           map[int]struct{}
	clearedservice_rates           bool
	network_devices                map[int]struct{}
	removednetwork_devices         map[int]struct{}
	clearednetwork_devices         bool
	network_backups                map[int]struct{}
	removednetwork_backups         map[int]struct{}
	clearednetwork_backups         bool
	budget_forecasts               map[int]struct{}
	removedbudget_forecasts        map[int]struct{}
	clearedbudget_forecasts        bool
	employees                      map[int]struct{}
	removedemployees               map[int]struct{}
	clearedemployees               bool
	compensation_agreements        map[int]struct{}
	removedcompensation_agreements map[int]struct{}
	clearedcompensation_agreements bool
	vault_items                    map[int]struct{}
	removedvault_items             map[int]struct{}
	clearedvault_items             bool
	vault_share_links              map[int]struct{}
	removedvault_share_links       map[int]struct{}
	clearedvault_share_links       bool
	journal_entries                map[int]struct{}
	removedjournal_entries         map[int]struct{}
	clearedjournal_entries         bool
	recurring_invoices             map[int]struct{}
	removedrecurring_invoices      map[int]struct{}
	clearedrecurring_invoices      bool
	inventory_reservations         map[int]struct{}
	removedinventory_reservations  map[int]struct{}
	clearedinventory_reservations  bool
	departments                    map[int]struct{}
	removeddepartments             map[int]struct{}
	cleareddepartments             bool
	permissions                    map[int]struct{}
	removedpermissions             map[int]struct{}
	clearedpermissions             bool
	asset_types                    map[int]struct{}
	removedasset_types             map[int]struct{}
	clearedasset_types             bool
	detection_events               map[int]struct{}
	removeddetection_events        map[int]struct{}
	cleareddetection_events        bool
	saas_identities                map[int]struct{}
	removedsaas_identities         map[int]struct{}
	clearedsaas_identities         bool
	saas_usages                    map[int]struct{}
	removedsaas_usages             map[int]struct{}
	clearedsaas_usages             bool
	recordings                     map[int]struct{}
	removedrecordings              map[int]struct{}
	clearedrecordings              bool
	network_links                  map[int]struct{}
	removednetwork_links           map[int]struct{}
	clearednetwork_links           bool
	network_ports                  map[int]struct{}
	removednetwork_ports           map[int]struct{}
	clearednetwork_ports           bool
	nexus_audits                   map[int]struct{}
	removednexus_audits            map[int]struct{}
	clearednexus_audits            bool
	succession_maps                map[int]struct{}
	removedsuccession_maps         map[int]struct{}
	clearedsuccession_maps         bool
	customer_account               *int
	clearedcustomer_account        bool
	scripts                        map[int]struct{}
	removedscripts                 map[int]struct{}
	clearedscripts                 bool
	jobs                           map[int]struct{}
	removedjobs                    map[int]struct{}
	clearedjobs                    bool
	time_off_requests              map[int]struct{}
	removedtime_off_requests       map[int]struct{}
	clearedtime_off_requests       bool
	time_off_policies              map[int]struct{}
	removedtime_off_policies       map[int]struct{}
	clearedtime_off_policies       bool
	time_off_balances              map[int]struct{}
	removedtime_off_balances       map[int]struct{}
	clearedtime_off_balances       bool
	review_cycles                  map[int]struct{}
	removedreview_cycles           map[int]struct{}
	clearedreview_cycles           bool
	performance_reviews            map[int]struct{}
	removedperformance_reviews     map[int]struct{}
	clearedperformance_reviews     bool
	goals                          map[int]struct{}
	removedgoals                   map[int]struct{}
	clearedgoals                   bool
	suppliers                      map[int]struct{}
	removedsuppliers               map[int]struct{}
	clearedsuppliers               bool
	categories                     map[int]struct{}
	removedcategories              map[int]struct{}
	clearedcategories              bool
	warehouses                     map[int]struct{}
	removedwarehouses              map[int]struct{}
	clearedwarehouses              bool
	asset_assignments              map[int]struct{}
	removedasset_assignments       map[int]struct{}
	clearedasset_assignments       bool
	contacts                       map[int]struct{}
	removedcontacts                map[int]struct{}
	clearedcontacts                bool
	legal_holds                    map[int]struct{}
	removedlegal_holds             map[int]struct{}
	clearedlegal_holds             bool
	retention_policies             map[int]struct{}
	removedretention_policies      map[int]struct{}
	clearedretention_policies      bool
	vault_templates                map[int]struct{}
	removedvault_templates         map[int]struct{}
	clearedvault_templates         bool
	stock_audit_logs               map[int]struct{}
	removedstock_audit_logs        map[int]struct{}
	clearedstock_audit_logs        bool
	maintenance_schedules          map[int]struct{}
	removedmaintenance_schedules   map[int]struct{}
	clearedmaintenance_schedules   bool
	stock_alerts                   map[int]struct{}
	removedstock_alerts            map[int]struct{}
	clearedstock_alerts            bool
	purchase_orders                map[int]struct{}
	removedpurchase_orders         map[int]struct{}
	clearedpurchase_orders         bool
	inventory_counts               map[int]struct{}
	removedinventory_counts        map[int]struct{}
	clearedinventory_counts        bool
	job_postings                   map[int]struct{}
	removedjob_postings            map[int]struct{}
	clearedjob_postings            bool
	candidates                     map[int]struct{}
	removedcandidates              map[int]struct{}
	clearedcandidates              bool
	applications                   map[int]struct{}
	removedapplications            map[int]struct{}
	clearedapplications            bool
	interviews                     map[int]struct{}
	removedinterviews              map[int]struct{}
	clearedinterviews              bool
	benefit_plans                  map[int]struct{}
	removedbenefit_plans           map[int]struct{}
	clearedbenefit_plans           bool
	benefit_enrollments            map[int]struct{}
	removedbenefit_enrollments     map[int]struct{}
	clearedbenefit_enrollments     bool
	done                           bool
	oldValue                       func(context.Context) (*Tenant, error)
	predicates                     []predicate.Tenant
}

var _ ent.Mutation = (*TenantMutation)(nil)

// tenantOption allows management of the mutation configuration using functional options.
type tenantOption func(*TenantMutation)

// newTenantMutation creates new mutation for the Tenant entity.
func newTenantMutation(c config, op Op, opts ...tenantOption) *TenantMutation {
	m := &TenantMutation{
		config:        c,
		op:            op,
		typ:           TypeTenant,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTenantID sets the ID field of the mutation.
func withTenantID(id int) tenantOption {
	return func(m *TenantMutation) {
		var (
			err   error
			once  sync.Once
			value *Tenant
		)
		m.oldValue = func(ctx context.Context) (*Tenant, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Tenant.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTenant sets the old Tenant of the mutation.
func withTenant(node *Tenant) tenantOption {
	return func(m *TenantMutation) {
		m.oldValue = func(context.Context) (*Tenant, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TenantMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TenantMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TenantMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TenantMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Tenant.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *TenantMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *TenantMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Tenant entity.
// If the Tenant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenantMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *TenantMutation) ResetName() {
	m.name = nil
}

// SetDomain sets the "domain" field.
func (m *TenantMutation) SetDomain(s string) {
	m.domain = &s
}

// Domain returns the value of the "domain" field in the mutation.
func (m *TenantMutation) Domain() (r string, exists bool) {
	v := m.domain
	if v == nil {
		return
	}
	return *v, true
}

// OldDomain returns the old "domain" field's value of the Tenant entity.
// If the Tenant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenantMutation) OldDomain(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDomain is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDomain requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDomain: %w", err)
	}
	return oldValue.Domain, nil
}

// ResetDomain resets all changes to the "domain" field.
func (m *TenantMutation) ResetDomain() {
	m.domain = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *TenantMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *TenantMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Tenant entity.
// If the Tenant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenantMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *TenantMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetActive sets the "active" field.
func (m *TenantMutation) SetActive(b bool) {
	m.active = &b
}

// Active returns the value of the "active" field in the mutation.
func (m *TenantMutation) Active() (r bool, exists bool) {
	v := m.active
	if v == nil {
		return
	}
	return *v, true
}

// OldActive returns the old "active" field's value of the Tenant entity.
// If the Tenant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenantMutation) OldActive(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldActive is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldActive requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldActive: %w", err)
	}
	return oldValue.Active, nil
}

// ResetActive resets all changes to the "active" field.
func (m *TenantMutation) ResetActive() {
	m.active = nil
}

// SetTransactionLimit sets the "transaction_limit" field.
func (m *TenantMutation) SetTransactionLimit(d decimal.Decimal) {
	m.transaction_limit = &d
}

// TransactionLimit returns the value of the "transaction_limit" field in the mutation.
func (m *TenantMutation) TransactionLimit() (r decimal.Decimal, exists bool) {
	v := m.transaction_limit
	if v == nil {
		return
	}
	return *v, true
}

// OldTransactionLimit returns the old "transaction_limit" field's value of the Tenant entity.
// If the Tenant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenantMutation) OldTransactionLimit(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTransactionLimit is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTransactionLimit requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTransactionLimit: %w", err)
	}
	return oldValue.TransactionLimit, nil
}

// ResetTransactionLimit resets all changes to the "transaction_limit" field.
func (m *TenantMutation) ResetTransactionLimit() {
	m.transaction_limit = nil
}

// SetParentID sets the "parent" edge to the Tenant entity by id.
func (m *TenantMutation) SetParentID(id int) {
	m.parent = &id
}

// ClearParent clears the "parent" edge to the Tenant entity.
func (m *TenantMutation) ClearParent() {
	m.clearedparent = true
}

// ParentCleared reports if the "parent" edge to the Tenant entity was cleared.
func (m *TenantMutation) ParentCleared() bool {
	return m.clearedparent
}

// ParentID returns the "parent" edge ID in the mutation.
func (m *TenantMutation) ParentID() (id int, exists bool) {
	if m.parent != nil {
		return *m.parent, true
	}
	return
}

// ParentIDs returns the "parent" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ParentID instead. It exists only for internal usage by the builders.
func (m *TenantMutation) ParentIDs() (ids []int) {
	if id := m.parent; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetParent resets all changes to the "parent" edge.
func (m *TenantMutation) ResetParent() {
	m.parent = nil
	m.clearedparent = false
}

// AddChildIDs adds the "children" edge to the Tenant entity by ids.
func (m *TenantMutation) AddChildIDs(ids ...int) {
	if m.children == nil {
		m.children = make(map[int]struct{})
	}
	for i := range ids {
		m.children[ids[i]] = struct{}{}
	}
}

// ClearChildren clears the "children" edge to the Tenant entity.
func (m *TenantMutation) ClearChildren() {
	m.clearedchildren = true
}

// ChildrenCleared reports if the "children" edge to the Tenant entity was cleared.
func (m *TenantMutation) ChildrenCleared() bool {
	return m.clearedchildren
}

// RemoveChildIDs removes the "children" edge to the Tenant entity by IDs.
func (m *TenantMutation) RemoveChildIDs(ids ...int) {
	if m.removedchildren == nil {
		m.removedchildren = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.children, ids[i])
		m.removedchildren[ids[i]] = struct{}{}
	}
}

// RemovedChildren returns the removed IDs of the "children" edge to the Tenant entity.
func (m *TenantMutation) RemovedChildrenIDs() (ids []int) {
	for id := range m.removedchildren {
		ids = append(ids, id)
	}
	return
}

// ChildrenIDs returns the "children" edge IDs in the mutation.
func (m *TenantMutation) ChildrenIDs() (ids []int) {
	for id := range m.children {
		ids = append(ids, id)
	}
	return
}

// ResetChildren resets all changes to the "children" edge.
func (m *TenantMutation) ResetChildren() {
	m.children = nil
	m.clearedchildren = false
	m.removedchildren = nil
}

// AddUserIDs adds the "users" edge to the User entity by ids.
func (m *TenantMutation) AddUserIDs(ids ...int) {
	if m.users == nil {
		m.users = make(map[int]struct{})
	}
	for i := range ids {
		m.users[ids[i]] = struct{}{}
	}
}

// ClearUsers clears the "users" edge to the User entity.
func (m *TenantMutation) ClearUsers() {
	m.clearedusers = true
}

// UsersCleared reports if the "users" edge to the User entity was cleared.
func (m *TenantMutation) UsersCleared() bool {
	return m.clearedusers
}

// RemoveUserIDs removes the "users" edge to the User entity by IDs.
func (m *TenantMutation) RemoveUserIDs(ids ...int) {
	if m.removedusers == nil {
		m.removedusers = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.users, ids[i])
		m.removedusers[ids[i]] = struct{}{}
	}
}

// RemovedUsers returns the removed IDs of the "users" edge to the User entity.
func (m *TenantMutation) RemovedUsersIDs() (ids []int) {
	for id := range m.removedusers {
		ids = append(ids, id)
	}
	return
}

// UsersIDs returns the "users" edge IDs in the mutation.
func (m *TenantMutation) UsersIDs() (ids []int) {
	for id := range m.users {
		ids = append(ids, id)
	}
	return
}

// ResetUsers resets all changes to the "users" edge.
func (m *TenantMutation) ResetUsers() {
	m.users = nil
	m.clearedusers = false
	m.removedusers = nil
}

// AddAccountIDs adds the "accounts" edge to the Account entity by ids.
func (m *TenantMutation) AddAccountIDs(ids ...int) {
	if m.accounts == nil {
		m.accounts = make(map[int]struct{})
	}
	for i := range ids {
		m.accounts[ids[i]] = struct{}{}
	}
}

// ClearAccounts clears the "accounts" edge to the Account entity.
func (m *TenantMutation) ClearAccounts() {
	m.clearedaccounts = true
}

// AccountsCleared reports if the "accounts" edge to the Account entity was cleared.
func (m *TenantMutation) AccountsCleared() bool {
	return m.clearedaccounts
}

// RemoveAccountIDs removes the "accounts" edge to the Account entity by IDs.
func (m *TenantMutation) RemoveAccountIDs(ids ...int) {
	if m.removedaccounts == nil {
		m.removedaccounts = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.accounts, ids[i])
		m.removedaccounts[ids[i]] = struct{}{}
	}
}

// RemovedAccounts returns the removed IDs of the "accounts" edge to the Account entity.
func (m *TenantMutation) RemovedAccountsIDs() (ids []int) {
	for id := range m.removedaccounts {
		ids = append(ids, id)
	}
	return
}

// AccountsIDs returns the "accounts" edge IDs in the mutation.
func (m *TenantMutation) AccountsIDs() (ids []int) {
	for id := range m.accounts {
		ids = append(ids, id)
	}
	return
}

// ResetAccounts resets all changes to the "accounts" edge.
func (m *TenantMutation) ResetAccounts() {
	m.accounts = nil
	m.clearedaccounts = false
	m.removedaccounts = nil
}

// AddTransactionIDs adds the "transactions" edge to the Transaction entity by ids.
func (m *TenantMutation) AddTransactionIDs(ids ...int) {
	if m.transactions == nil {
		m.transactions = make(map[int]struct{})
	}
	for i := range ids {
		m.transactions[ids[i]] = struct{}{}
	}
}

// ClearTransactions clears the "transactions" edge to the Transaction entity.
func (m *TenantMutation) ClearTransactions() {
	m.clearedtransactions = true
}

// TransactionsCleared reports if the "transactions" edge to the Transaction entity was cleared.
func (m *TenantMutation) TransactionsCleared() bool {
	return m.clearedtransactions
}

// RemoveTransactionIDs removes the "transactions" edge to the Transaction entity by IDs.
func (m *TenantMutation) RemoveTransactionIDs(ids ...int) {
	if m.removedtransactions == nil {
		m.removedtransactions = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.transactions, ids[i])
		m.removedtransactions[ids[i]] = struct{}{}
	}
}

// RemovedTransactions returns the removed IDs of the "transactions" edge to the Transaction entity.
func (m *TenantMutation) RemovedTransactionsIDs() (ids []int) {
	for id := range m.removedtransactions {
		ids = append(ids, id)
	}
	return
}

// TransactionsIDs returns the "transactions" edge IDs in the mutation.
func (m *TenantMutation) TransactionsIDs() (ids []int) {
	for id := range m.transactions {
		ids = append(ids, id)
	}
	return
}

// ResetTransactions resets all changes to the "transactions" edge.
func (m *TenantMutation) ResetTransactions() {
	m.transactions = nil
	m.clearedtransactions = false
	m.removedtransactions = nil
}

// AddLedgerEntryIDs adds the "ledger_entries" edge to the LedgerEntry entity by ids.
func (m *TenantMutation) AddLedgerEntryIDs(ids ...int) {
	if m.ledger_entries == nil {
		m.ledger_entries = make(map[int]struct{})
	}
	for i := range ids {
		m.ledger_entries[ids[i]] = struct{}{}
	}
}

// ClearLedgerEntries clears the "ledger_entries" edge to the LedgerEntry entity.
func (m *TenantMutation) ClearLedgerEntries() {
	m.clearedledger_entries = true
}

// LedgerEntriesCleared reports if the "ledger_entries" edge to the LedgerEntry entity was cleared.
func (m *TenantMutation) LedgerEntriesCleared() bool {
	return m.clearedledger_entries
}

// RemoveLedgerEntryIDs removes the "ledger_entries" edge to the LedgerEntry entity by IDs.
func (m *TenantMutation) RemoveLedgerEntryIDs(ids ...int) {
	if m.removedledger_entries == nil {
		m.removedledger_entries = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.ledger_entries, ids[i])
		m.removedledger_entries[ids[i]] = struct{}{}
	}
}

// RemovedLedgerEntries returns the removed IDs of the "ledger_entries" edge to the LedgerEntry entity.
func (m *TenantMutation) RemovedLedgerEntriesIDs() (ids []int) {
	for id := range m.removedledger_entries {
		ids = append(ids, id)
	}
	return
}

// LedgerEntriesIDs returns the "ledger_entries" edge IDs in the mutation.
func (m *TenantMutation) LedgerEntriesIDs() (ids []int) {
	for id := range m.ledger_entries {
		ids = append(ids, id)
	}
	return
}

// ResetLedgerEntries resets all changes to the "ledger_entries" edge.
func (m *TenantMutation) ResetLedgerEntries() {
	m.ledger_entries = nil
	m.clearedledger_entries = false
	m.removedledger_entries = nil
}

// AddProductIDs adds the "products" edge to the Product entity by ids.
func (m *TenantMutation) AddProductIDs(ids ...int) {
	if m.products == nil {
		m.products = make(map[int]struct{})
	}
	for i := range ids {
		m.products[ids[i]] = struct{}{}
	}
}

// ClearProducts clears the "products" edge to the Product entity.
func (m *TenantMutation) ClearProducts() {
	m.clearedproducts = true
}

// ProductsCleared reports if the "products" edge to the Product entity was cleared.
func (m *TenantMutation) ProductsCleared() bool {
	return m.clearedproducts
}

// RemoveProductIDs removes the "products" edge to the Product entity by IDs.
func (m *TenantMutation) RemoveProductIDs(ids ...int) {
	if m.removedproducts == nil {
		m.removedproducts = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.products, ids[i])
		m.removedproducts[ids[i]] = struct{}{}
	}
}

// RemovedProducts returns the removed IDs of the "products" edge to the Product entity.
func (m *TenantMutation) RemovedProductsIDs() (ids []int) {
	for id := range m.removedproducts {
		ids = append(ids, id)
	}
	return
}

// ProductsIDs returns the "products" edge IDs in the mutation.
func (m *TenantMutation) ProductsIDs() (ids []int) {
	for id := range m.products {
		ids = append(ids, id)
	}
	return
}

// ResetProducts resets all changes to the "products" edge.
func (m *TenantMutation) ResetProducts() {
	m.products = nil
	m.clearedproducts = false
	m.removedproducts = nil
}

// AddStockMovementIDs adds the "stock_movements" edge to the StockMovement entity by ids.
func (m *TenantMutation) AddStockMovementIDs(ids ...int) {
	if m.stock_movements == nil {
		m.stock_movements = make(map[int]struct{})
	}
	for i := range ids {
		m.stock_movements[ids[i]] = struct{}{}
	}
}

// ClearStockMovements clears the "stock_movements" edge to the StockMovement entity.
func (m *TenantMutation) ClearStockMovements() {
	m.clearedstock_movements = true
}

// StockMovementsCleared reports if the "stock_movements" edge to the StockMovement entity was cleared.
func (m *TenantMutation) StockMovementsCleared() bool {
	return m.clearedstock_movements
}

// RemoveStockMovementIDs removes the "stock_movements" edge to the StockMovement entity by IDs.
func (m *TenantMutation) RemoveStockMovementIDs(ids ...int) {
	if m.removedstock_movements == nil {
		m.removedstock_movements = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.stock_movements, ids[i])
		m.removedstock_movements[ids[i]] = struct{}{}
	}
}

// RemovedStockMovements returns the removed IDs of the "stock_movements" edge to the StockMovement entity.
func (m *TenantMutation) RemovedStockMovementsIDs() (ids []int) {
	for id := range m.removedstock_movements {
		ids = append(ids, id)
	}
	return
}

// StockMovementsIDs returns the "stock_movements" edge IDs in the mutation.
func (m *TenantMutation) StockMovementsIDs() (ids []int) {
	for id := range m.stock_movements {
		ids = append(ids, id)
	}
	return
}

// ResetStockMovements resets all changes to the "stock_movements" edge.
func (m *TenantMutation) ResetStockMovements() {
	m.stock_movements = nil
	m.clearedstock_movements = false
	m.removedstock_movements = nil
}

// AddAuditLogIDs adds the "audit_logs" edge to the AuditLog entity by ids.
func (m *TenantMutation) AddAuditLogIDs(ids ...int) {
	if m.audit_logs == nil {
		m.audit_logs = make(map[int]struct{})
	}
	for i := range ids {
		m.audit_logs[ids[i]] = struct{}{}
	}
}

// ClearAuditLogs clears the "audit_logs" edge to the AuditLog entity.
func (m *TenantMutation) ClearAuditLogs() {
	m.clearedaudit_logs = true
}

// AuditLogsCleared reports if the "audit_logs" edge to the AuditLog entity was cleared.
func (m *TenantMutation) AuditLogsCleared() bool {
	return m.clearedaudit_logs
}

// RemoveAuditLogIDs removes the "audit_logs" edge to the AuditLog entity by IDs.
func (m *TenantMutation) RemoveAuditLogIDs(ids ...int) {
	if m.removedaudit_logs == nil {
		m.removedaudit_logs = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.audit_logs, ids[i])
		m.removedaudit_logs[ids[i]] = struct{}{}
	}
}

// RemovedAuditLogs returns the removed IDs of the "audit_logs" edge to the AuditLog entity.
func (m *TenantMutation) RemovedAuditLogsIDs() (ids []int) {
	for id := range m.removedaudit_logs {
		ids = append(ids, id)
	}
	return
}

// AuditLogsIDs returns the "audit_logs" edge IDs in the mutation.
func (m *TenantMutation) AuditLogsIDs() (ids []int) {
	for id := range m.audit_logs {
		ids = append(ids, id)
	}
	return
}

// ResetAuditLogs resets all changes to the "audit_logs" edge.
func (m *TenantMutation) ResetAuditLogs() {
	m.audit_logs = nil
	m.clearedaudit_logs = false
	m.removedaudit_logs = nil
}

// AddAgentIDs adds the "agents" edge to the Agent entity by ids.
func (m *TenantMutation) AddAgentIDs(ids ...int) {
	if m.agents == nil {
		m.agents = make(map[int]struct{})
	}
	for i := range ids {
		m.agents[ids[i]] = struct{}{}
	}
}

// ClearAgents clears the "agents" edge to the Agent entity.
func (m *TenantMutation) ClearAgents() {
	m.clearedagents = true
}

// AgentsCleared reports if the "agents" edge to the Agent entity was cleared.
func (m *TenantMutation) AgentsCleared() bool {
	return m.clearedagents
}

// RemoveAgentIDs removes the "agents" edge to the Agent entity by IDs.
func (m *TenantMutation) RemoveAgentIDs(ids ...int) {
	if m.removedagents == nil {
		m.removedagents = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.agents, ids[i])
		m.removedagents[ids[i]] = struct{}{}
	}
}

// RemovedAgents returns the removed IDs of the "agents" edge to the Agent entity.
func (m *TenantMutation) RemovedAgentsIDs() (ids []int) {
	for id := range m.removedagents {
		ids = append(ids, id)
	}
	return
}

// AgentsIDs returns the "agents" edge IDs in the mutation.
func (m *TenantMutation) AgentsIDs() (ids []int) {
	for id := range m.agents {
		ids = append(ids, id)
	}
	return
}

// ResetAgents resets all changes to the "agents" edge.
func (m *TenantMutation) ResetAgents() {
	m.agents = nil
	m.clearedagents = false
	m.removedagents = nil
}

// AddDiscoveryEntryIDs adds the "discovery_entries" edge to the DiscoveryEntry entity by ids.
func (m *TenantMutation) AddDiscoveryEntryIDs(ids ...int) {
	if m.discovery_entries == nil {
		m.discovery_entries = make(map[int]struct{})
	}
	for i := range ids {
		m.discovery_entries[ids[i]] = struct{}{}
	}
}

// ClearDiscoveryEntries clears the "discovery_entries" edge to the DiscoveryEntry entity.
func (m *TenantMutation) ClearDiscoveryEntries() {
	m.cleareddiscovery_entries = true
}

// DiscoveryEntriesCleared reports if the "discovery_entries" edge to the DiscoveryEntry entity was cleared.
func (m *TenantMutation) DiscoveryEntriesCleared() bool {
	return m.cleareddiscovery_entries
}

// RemoveDiscoveryEntryIDs removes the "discovery_entries" edge to the DiscoveryEntry entity by IDs.
func (m *TenantMutation) RemoveDiscoveryEntryIDs(ids ...int) {
	if m.removeddiscovery_entries == nil {
		m.removeddiscovery_entries = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.discovery_entries, ids[i])
		m.removeddiscovery_entries[ids[i]] = struct{}{}
	}
}

// RemovedDiscoveryEntries returns the removed IDs of the "discovery_entries" edge to the DiscoveryEntry entity.
func (m *TenantMutation) RemovedDiscoveryEntriesIDs() (ids []int) {
	for id := range m.removeddiscovery_entries {
		ids = append(ids, id)
	}
	return
}

// DiscoveryEntriesIDs returns the "discovery_entries" edge IDs in the mutation.
func (m *TenantMutation) DiscoveryEntriesIDs() (ids []int) {
	for id := range m.discovery_entries {
		ids = append(ids, id)
	}
	return
}

// ResetDiscoveryEntries resets all changes to the "discovery_entries" edge.
func (m *TenantMutation) ResetDiscoveryEntries() {
	m.discovery_entries = nil
	m.cleareddiscovery_entries = false
	m.removeddiscovery_entries = nil
}

// AddAssetIDs adds the "assets" edge to the Asset entity by ids.
func (m *TenantMutation) AddAssetIDs(ids ...int) {
	if m.assets == nil {
		m.assets = make(map[int]struct{})
	}
	for i := range ids {
		m.assets[ids[i]] = struct{}{}
	}
}

// ClearAssets clears the "assets" edge to the Asset entity.
func (m *TenantMutation) ClearAssets() {
	m.clearedassets = true
}

// AssetsCleared reports if the "assets" edge to the Asset entity was cleared.
func (m *TenantMutation) AssetsCleared() bool {
	return m.clearedassets
}

// RemoveAssetIDs removes the "assets" edge to the Asset entity by IDs.
func (m *TenantMutation) RemoveAssetIDs(ids ...int) {
	if m.removedassets == nil {
		m.removedassets = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.assets, ids[i])
		m.removedassets[ids[i]] = struct{}{}
	}
}

// RemovedAssets returns the removed IDs of the "assets" edge to the Asset entity.
func (m *TenantMutation) RemovedAssetsIDs() (ids []int) {
	for id := range m.removedassets {
		ids = append(ids, id)
	}
	return
}

// AssetsIDs returns the "assets" edge IDs in the mutation.
func (m *TenantMutation) AssetsIDs() (ids []int) {
	for id := range m.assets {
		ids = append(ids, id)
	}
	return
}

// ResetAssets resets all changes to the "assets" edge.
func (m *TenantMutation) ResetAssets() {
	m.assets = nil
	m.clearedassets = false
	m.removedassets = nil
}

// AddCredentialIDs adds the "credentials" edge to the Credential entity by ids.
func (m *TenantMutation) AddCredentialIDs(ids ...int) {
	if m.credentials == nil {
		m.credentials = make(map[int]struct{})
	}
	for i := range ids {
		m.credentials[ids[i]] = struct{}{}
	}
}

// ClearCredentials clears the "credentials" edge to the Credential entity.
func (m *TenantMutation) ClearCredentials() {
	m.clearedcredentials = true
}

// CredentialsCleared reports if the "credentials" edge to the Credential entity was cleared.
func (m *TenantMutation) CredentialsCleared() bool {
	return m.clearedcredentials
}

// RemoveCredentialIDs removes the "credentials" edge to the Credential entity by IDs.
func (m *TenantMutation) RemoveCredentialIDs(ids ...int) {
	if m.removedcredentials == nil {
		m.removedcredentials = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.credentials, ids[i])
		m.removedcredentials[ids[i]] = struct{}{}
	}
}

// RemovedCredentials returns the removed IDs of the "credentials" edge to the Credential entity.
func (m *TenantMutation) RemovedCredentialsIDs() (ids []int) {
	for id := range m.removedcredentials {
		ids = append(ids, id)
	}
	return
}

// CredentialsIDs returns the "credentials" edge IDs in the mutation.
func (m *TenantMutation) CredentialsIDs() (ids []int) {
	for id := range m.credentials {
		ids = append(ids, id)
	}
	return
}

// ResetCredentials resets all changes to the "credentials" edge.
func (m *TenantMutation) ResetCredentials() {
	m.credentials = nil
	m.clearedcredentials = false
	m.removedcredentials = nil
}

// AddOneTimeLinkIDs adds the "one_time_links" edge to the OneTimeLink entity by ids.
func (m *TenantMutation) AddOneTimeLinkIDs(ids ...int) {
	if m.one_time_links == nil {
		m.one_time_links = make(map[int]struct{})
	}
	for i := range ids {
		m.one_time_links[ids[i]] = struct{}{}
	}
}

// ClearOneTimeLinks clears the "one_time_links" edge to the OneTimeLink entity.
func (m *TenantMutation) ClearOneTimeLinks() {
	m.clearedone_time_links = true
}

// OneTimeLinksCleared reports if the "one_time_links" edge to the OneTimeLink entity was cleared.
func (m *TenantMutation) OneTimeLinksCleared() bool {
	return m.clearedone_time_links
}

// RemoveOneTimeLinkIDs removes the "one_time_links" edge to the OneTimeLink entity by IDs.
func (m *TenantMutation) RemoveOneTimeLinkIDs(ids ...int) {
	if m.removedone_time_links == nil {
		m.removedone_time_links = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.one_time_links, ids[i])
		m.removedone_time_links[ids[i]] = struct{}{}
	}
}

// RemovedOneTimeLinks returns the removed IDs of the "one_time_links" edge to the OneTimeLink entity.
func (m *TenantMutation) RemovedOneTimeLinksIDs() (ids []int) {
	for id := range m.removedone_time_links {
		ids = append(ids, id)
	}
	return
}

// OneTimeLinksIDs returns the "one_time_links" edge IDs in the mutation.
func (m *TenantMutation) OneTimeLinksIDs() (ids []int) {
	for id := range m.one_time_links {
		ids = append(ids, id)
	}
	return
}

// ResetOneTimeLinks resets all changes to the "one_time_links" edge.
func (m *TenantMutation) ResetOneTimeLinks() {
	m.one_time_links = nil
	m.clearedone_time_links = false
	m.removedone_time_links = nil
}

// AddSopIDs adds the "sops" edge to the SOP entity by ids.
func (m *TenantMutation) AddSopIDs(ids ...int) {
	if m.sops == nil {
		m.sops = make(map[int]struct{})
	}
	for i := range ids {
		m.sops[ids[i]] = struct{}{}
	}
}

// ClearSops clears the "sops" edge to the SOP entity.
func (m *TenantMutation) ClearSops() {
	m.clearedsops = true
}

// SopsCleared reports if the "sops" edge to the SOP entity was cleared.
func (m *TenantMutation) SopsCleared() bool {
	return m.clearedsops
}

// RemoveSopIDs removes the "sops" edge to the SOP entity by IDs.
func (m *TenantMutation) RemoveSopIDs(ids ...int) {
	if m.removedsops == nil {
		m.removedsops = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.sops, ids[i])
		m.removedsops[ids[i]] = struct{}{}
	}
}

// RemovedSops returns the removed IDs of the "sops" edge to the SOP entity.
func (m *TenantMutation) RemovedSopsIDs() (ids []int) {
	for id := range m.removedsops {
		ids = append(ids, id)
	}
	return
}

// SopsIDs returns the "sops" edge IDs in the mutation.
func (m *TenantMutation) SopsIDs() (ids []int) {
	for id := range m.sops {
		ids = append(ids, id)
	}
	return
}

// ResetSops resets all changes to the "sops" edge.
func (m *TenantMutation) ResetSops() {
	m.sops = nil
	m.clearedsops = false
	m.removedsops = nil
}

// AddCameraIDs adds the "cameras" edge to the Camera entity by ids.
func (m *TenantMutation) AddCameraIDs(ids ...int) {
	if m.cameras == nil {
		m.cameras = make(map[int]struct{})
	}
	for i := range ids {
		m.cameras[ids[i]] = struct{}{}
	}
}

// ClearCameras clears the "cameras" edge to the Camera entity.
func (m *TenantMutation) ClearCameras() {
	m.clearedcameras = true
}

// CamerasCleared reports if the "cameras" edge to the Camera entity was cleared.
func (m *TenantMutation) CamerasCleared() bool {
	return m.clearedcameras
}

// RemoveCameraIDs removes the "cameras" edge to the Camera entity by IDs.
func (m *TenantMutation) RemoveCameraIDs(ids ...int) {
	if m.removedcameras == nil {
		m.removedcameras = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.cameras, ids[i])
		m.removedcameras[ids[i]] = struct{}{}
	}
}

// RemovedCameras returns the removed IDs of the "cameras" edge to the Camera entity.
func (m *TenantMutation) RemovedCamerasIDs() (ids []int) {
	for id := range m.removedcameras {
		ids = append(ids, id)
	}
	return
}

// CamerasIDs returns the "cameras" edge IDs in the mutation.
func (m *TenantMutation) CamerasIDs() (ids []int) {
	for id := range m.cameras {
		ids = append(ids, id)
	}
	return
}

// ResetCameras resets all changes to the "cameras" edge.
func (m *TenantMutation) ResetCameras() {
	m.cameras = nil
	m.clearedcameras = false
	m.removedcameras = nil
}

// AddTicketIDs adds the "tickets" edge to the Ticket entity by ids.
func (m *TenantMutation) AddTicketIDs(ids ...int) {
	if m.tickets == nil {
		m.tickets = make(map[int]struct{})
	}
	for i := range ids {
		m.tickets[ids[i]] = struct{}{}
	}
}

// ClearTickets clears the "tickets" edge to the Ticket entity.
func (m *TenantMutation) ClearTickets() {
	m.clearedtickets = true
}

// TicketsCleared reports if the "tickets" edge to the Ticket entity was cleared.
func (m *TenantMutation) TicketsCleared() bool {
	return m.clearedtickets
}

// RemoveTicketIDs removes the "tickets" edge to the Ticket entity by IDs.
func (m *TenantMutation) RemoveTicketIDs(ids ...int) {
	if m.removedtickets == nil {
		m.removedtickets = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.tickets, ids[i])
		m.removedtickets[ids[i]] = struct{}{}
	}
}

// RemovedTickets returns the removed IDs of the "tickets" edge to the Ticket entity.
func (m *TenantMutation) RemovedTicketsIDs() (ids []int) {
	for id := range m.removedtickets {
		ids = append(ids, id)
	}
	return
}

// TicketsIDs returns the "tickets" edge IDs in the mutation.
func (m *TenantMutation) TicketsIDs() (ids []int) {
	for id := range m.tickets {
		ids = append(ids, id)
	}
	return
}

// ResetTickets resets all changes to the "tickets" edge.
func (m *TenantMutation) ResetTickets() {
	m.tickets = nil
	m.clearedtickets = false
	m.removedtickets = nil
}

// AddContractIDs adds the "contracts" edge to the Contract entity by ids.
func (m *TenantMutation) AddContractIDs(ids ...int) {
	if m.contracts == nil {
		m.contracts = make(map[int]struct{})
	}
	for i := range ids {
		m.contracts[ids[i]] = struct{}{}
	}
}

// ClearContracts clears the "contracts" edge to the Contract entity.
func (m *TenantMutation) ClearContracts() {
	m.clearedcontracts = true
}

// ContractsCleared reports if the "contracts" edge to the Contract entity was cleared.
func (m *TenantMutation) ContractsCleared() bool {
	return m.clearedcontracts
}

// RemoveContractIDs removes the "contracts" edge to the Contract entity by IDs.
func (m *TenantMutation) RemoveContractIDs(ids ...int) {
	if m.removedcontracts == nil {
		m.removedcontracts = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.contracts, ids[i])
		m.removedcontracts[ids[i]] = struct{}{}
	}
}

// RemovedContracts returns the removed IDs of the "contracts" edge to the Contract entity.
func (m *TenantMutation) RemovedContractsIDs() (ids []int) {
	for id := range m.removedcontracts {
		ids = append(ids, id)
	}
	return
}

// ContractsIDs returns the "contracts" edge IDs in the mutation.
func (m *TenantMutation) ContractsIDs() (ids []int) {
	for id := range m.contracts {
		ids = append(ids, id)
	}
	return
}

// ResetContracts resets all changes to the "contracts" edge.
func (m *TenantMutation) ResetContracts() {
	m.contracts = nil
	m.clearedcontracts = false
	m.removedcontracts = nil
}

// AddSaasAppIDs adds the "saas_apps" edge to the SaaSApp entity by ids.
func (m *TenantMutation) AddSaasAppIDs(ids ...int) {
	if m.saas_apps == nil {
		m.saas_apps = make(map[int]struct{})
	}
	for i := range ids {
		m.saas_apps[ids[i]] = struct{}{}
	}
}

// ClearSaasApps clears the "saas_apps" edge to the SaaSApp entity.
func (m *TenantMutation) ClearSaasApps() {
	m.clearedsaas_apps = true
}

// SaasAppsCleared reports if the "saas_apps" edge to the SaaSApp entity was cleared.
func (m *TenantMutation) SaasAppsCleared() bool {
	return m.clearedsaas_apps
}

// RemoveSaasAppIDs removes the "saas_apps" edge to the SaaSApp entity by IDs.
func (m *TenantMutation) RemoveSaasAppIDs(ids ...int) {
	if m.removedsaas_apps == nil {
		m.removedsaas_apps = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.saas_apps, ids[i])
		m.removedsaas_apps[ids[i]] = struct{}{}
	}
}

// RemovedSaasApps returns the removed IDs of the "saas_apps" edge to the SaaSApp entity.
func (m *TenantMutation) RemovedSaasAppsIDs() (ids []int) {
	for id := range m.removedsaas_apps {
		ids = append(ids, id)
	}
	return
}

// SaasAppsIDs returns the "saas_apps" edge IDs in the mutation.
func (m *TenantMutation) SaasAppsIDs() (ids []int) {
	for id := range m.saas_apps {
		ids = append(ids, id)
	}
	return
}

// ResetSaasApps resets all changes to the "saas_apps" edge.
func (m *TenantMutation) ResetSaasApps() {
	m.saas_apps = nil
	m.clearedsaas_apps = false
	m.removedsaas_apps = nil
}

// AddSaasFilterIDs adds the "saas_filters" edge to the SaaSFilter entity by ids.
func (m *TenantMutation) AddSaasFilterIDs(ids ...int) {
	if m.saas_filters == nil {
		m.saas_filters = make(map[int]struct{})
	}
	for i := range ids {
		m.saas_filters[ids[i]] = struct{}{}
	}
}

// ClearSaasFilters clears the "saas_filters" edge to the SaaSFilter entity.
func (m *TenantMutation) ClearSaasFilters() {
	m.clearedsaas_filters = true
}

// SaasFiltersCleared reports if the "saas_filters" edge to the SaaSFilter entity was cleared.
func (m *TenantMutation) SaasFiltersCleared() bool {
	return m.clearedsaas_filters
}

// RemoveSaasFilterIDs removes the "saas_filters" edge to the SaaSFilter entity by IDs.
func (m *TenantMutation) RemoveSaasFilterIDs(ids ...int) {
	if m.removedsaas_filters == nil {
		m.removedsaas_filters = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.saas_filters, ids[i])
		m.removedsaas_filters[ids[i]] = struct{}{}
	}
}

// RemovedSaasFilters returns the removed IDs of the "saas_filters" edge to the SaaSFilter entity.
func (m *TenantMutation) RemovedSaasFiltersIDs() (ids []int) {
	for id := range m.removedsaas_filters {
		ids = append(ids, id)
	}
	return
}

// SaasFiltersIDs returns the "saas_filters" edge IDs in the mutation.
func (m *TenantMutation) SaasFiltersIDs() (ids []int) {
	for id := range m.saas_filters {
		ids = append(ids, id)
	}
	return
}

// ResetSaasFilters resets all changes to the "saas_filters" edge.
func (m *TenantMutation) ResetSaasFilters() {
	m.saas_filters = nil
	m.clearedsaas_filters = false
	m.removedsaas_filters = nil
}

// AddCallLogIDs adds the "call_logs" edge to the CallLog entity by ids.
func (m *TenantMutation) AddCallLogIDs(ids ...int) {
	if m.call_logs == nil {
		m.call_logs = make(map[int]struct{})
	}
	for i := range ids {
		m.call_logs[ids[i]] = struct{}{}
	}
}

// ClearCallLogs clears the "call_logs" edge to the CallLog entity.
func (m *TenantMutation) ClearCallLogs() {
	m.clearedcall_logs = true
}

// CallLogsCleared reports if the "call_logs" edge to the CallLog entity was cleared.
func (m *TenantMutation) CallLogsCleared() bool {
	return m.clearedcall_logs
}

// RemoveCallLogIDs removes the "call_logs" edge to the CallLog entity by IDs.
func (m *TenantMutation) RemoveCallLogIDs(ids ...int) {
	if m.removedcall_logs == nil {
		m.removedcall_logs = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.call_logs, ids[i])
		m.removedcall_logs[ids[i]] = struct{}{}
	}
}

// RemovedCallLogs returns the removed IDs of the "call_logs" edge to the CallLog entity.
func (m *TenantMutation) RemovedCallLogsIDs() (ids []int) {
	for id := range m.removedcall_logs {
		ids = append(ids, id)
	}
	return
}

// CallLogsIDs returns the "call_logs" edge IDs in the mutation.
func (m *TenantMutation) CallLogsIDs() (ids []int) {
	for id := range m.call_logs {
		ids = append(ids, id)
	}
	return
}

// ResetCallLogs resets all changes to the "call_logs" edge.
func (m *TenantMutation) ResetCallLogs() {
	m.call_logs = nil
	m.clearedcall_logs = false
	m.removedcall_logs = nil
}

// AddIvrFlowIDs adds the "ivr_flows" edge to the IVRFlow entity by ids.
func (m *TenantMutation) AddIvrFlowIDs(ids ...int) {
	if m.ivr_flows == nil {
		m.ivr_flows = make(map[int]struct{})
	}
	for i := range ids {
		m.ivr_flows[ids[i]] = struct{}{}
	}
}

// ClearIvrFlows clears the "ivr_flows" edge to the IVRFlow entity.
func (m *TenantMutation) ClearIvrFlows() {
	m.clearedivr_flows = true
}

// IvrFlowsCleared reports if the "ivr_flows" edge to the IVRFlow entity was cleared.
func (m *TenantMutation) IvrFlowsCleared() bool {
	return m.clearedivr_flows
}

// RemoveIvrFlowIDs removes the "ivr_flows" edge to the IVRFlow entity by IDs.
func (m *TenantMutation) RemoveIvrFlowIDs(ids ...int) {
	if m.removedivr_flows == nil {
		m.removedivr_flows = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.ivr_flows, ids[i])
		m.removedivr_flows[ids[i]] = struct{}{}
	}
}

// RemovedIvrFlows returns the removed IDs of the "ivr_flows" edge to the IVRFlow entity.
func (m *TenantMutation) RemovedIvrFlowsIDs() (ids []int) {
	for id := range m.removedivr_flows {
		ids = append(ids, id)
	}
	return
}

// IvrFlowsIDs returns the "ivr_flows" edge IDs in the mutation.
func (m *TenantMutation) IvrFlowsIDs() (ids []int) {
	for id := range m.ivr_flows {
		ids = append(ids, id)
	}
	return
}

// ResetIvrFlows resets all changes to the "ivr_flows" edge.
func (m *TenantMutation) ResetIvrFlows() {
	m.ivr_flows = nil
	m.clearedivr_flows = false
	m.removedivr_flows = nil
}

// AddVoicemailIDs adds the "voicemails" edge to the Voicemail entity by ids.
func (m *TenantMutation) AddVoicemailIDs(ids ...int) {
	if m.voicemails == nil {
		m.voicemails = make(map[int]struct{})
	}
	for i := range ids {
		m.voicemails[ids[i]] = struct{}{}
	}
}

// ClearVoicemails clears the "voicemails" edge to the Voicemail entity.
func (m *TenantMutation) ClearVoicemails() {
	m.clearedvoicemails = true
}

// VoicemailsCleared reports if the "voicemails" edge to the Voicemail entity was cleared.
func (m *TenantMutation) VoicemailsCleared() bool {
	return m.clearedvoicemails
}

// RemoveVoicemailIDs removes the "voicemails" edge to the Voicemail entity by IDs.
func (m *TenantMutation) RemoveVoicemailIDs(ids ...int) {
	if m.removedvoicemails == nil {
		m.removedvoicemails = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.voicemails, ids[i])
		m.removedvoicemails[ids[i]] = struct{}{}
	}
}

// RemovedVoicemails returns the removed IDs of the "voicemails" edge to the Voicemail entity.
func (m *TenantMutation) RemovedVoicemailsIDs() (ids []int) {
	for id := range m.removedvoicemails {
		ids = append(ids, id)
	}
	return
}

// VoicemailsIDs returns the "voicemails" edge IDs in the mutation.
func (m *TenantMutation) VoicemailsIDs() (ids []int) {
	for id := range m.voicemails {
		ids = append(ids, id)
	}
	return
}

// ResetVoicemails resets all changes to the "voicemails" edge.
func (m *TenantMutation) ResetVoicemails() {
	m.voicemails = nil
	m.clearedvoicemails = false
	m.removedvoicemails = nil
}

// AddHealthSnapshotIDs adds the "health_snapshots" edge to the HealthScoreSnapshot entity by ids.
func (m *TenantMutation) AddHealthSnapshotIDs(ids ...int) {
	if m.health_snapshots == nil {
		m.health_snapshots = make(map[int]struct{})
	}
	for i := range ids {
		m.health_snapshots[ids[i]] = struct{}{}
	}
}

// ClearHealthSnapshots clears the "health_snapshots" edge to the HealthScoreSnapshot entity.
func (m *TenantMutation) ClearHealthSnapshots() {
	m.clearedhealth_snapshots = true
}

// HealthSnapshotsCleared reports if the "health_snapshots" edge to the HealthScoreSnapshot entity was cleared.
func (m *TenantMutation) HealthSnapshotsCleared() bool {
	return m.clearedhealth_snapshots
}

// RemoveHealthSnapshotIDs removes the "health_snapshots" edge to the HealthScoreSnapshot entity by IDs.
func (m *TenantMutation) RemoveHealthSnapshotIDs(ids ...int) {
	if m.removedhealth_snapshots == nil {
		m.removedhealth_snapshots = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.health_snapshots, ids[i])
		m.removedhealth_snapshots[ids[i]] = struct{}{}
	}
}

// RemovedHealthSnapshots returns the removed IDs of the "health_snapshots" edge to the HealthScoreSnapshot entity.
func (m *TenantMutation) RemovedHealthSnapshotsIDs() (ids []int) {
	for id := range m.removedhealth_snapshots {
		ids = append(ids, id)
	}
	return
}

// HealthSnapshotsIDs returns the "health_snapshots" edge IDs in the mutation.
func (m *TenantMutation) HealthSnapshotsIDs() (ids []int) {
	for id := range m.health_snapshots {
		ids = append(ids, id)
	}
	return
}

// ResetHealthSnapshots resets all changes to the "health_snapshots" edge.
func (m *TenantMutation) ResetHealthSnapshots() {
	m.health_snapshots = nil
	m.clearedhealth_snapshots = false
	m.removedhealth_snapshots = nil
}

// AddRoadmapIDs adds the "roadmaps" edge to the StrategicRoadmap entity by ids.
func (m *TenantMutation) AddRoadmapIDs(ids ...int) {
	if m.roadmaps == nil {
		m.roadmaps = make(map[int]struct{})
	}
	for i := range ids {
		m.roadmaps[ids[i]] = struct{}{}
	}
}

// ClearRoadmaps clears the "roadmaps" edge to the StrategicRoadmap entity.
func (m *TenantMutation) ClearRoadmaps() {
	m.clearedroadmaps = true
}

// RoadmapsCleared reports if the "roadmaps" edge to the StrategicRoadmap entity was cleared.
func (m *TenantMutation) RoadmapsCleared() bool {
	return m.clearedroadmaps
}

// RemoveRoadmapIDs removes the "roadmaps" edge to the StrategicRoadmap entity by IDs.
func (m *TenantMutation) RemoveRoadmapIDs(ids ...int) {
	if m.removedroadmaps == nil {
		m.removedroadmaps = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.roadmaps, ids[i])
		m.removedroadmaps[ids[i]] = struct{}{}
	}
}

// RemovedRoadmaps returns the removed IDs of the "roadmaps" edge to the StrategicRoadmap entity.
func (m *TenantMutation) RemovedRoadmapsIDs() (ids []int) {
	for id := range m.removedroadmaps {
		ids = append(ids, id)
	}
	return
}

// RoadmapsIDs returns the "roadmaps" edge IDs in the mutation.
func (m *TenantMutation) RoadmapsIDs() (ids []int) {
	for id := range m.roadmaps {
		ids = append(ids, id)
	}
	return
}

// ResetRoadmaps resets all changes to the "roadmaps" edge.
func (m *TenantMutation) ResetRoadmaps() {
	m.roadmaps = nil
	m.clearedroadmaps = false
	m.removedroadmaps = nil
}

// AddServiceRateIDs adds the "service_rates" edge to the ServiceRate entity by ids.
func (m *TenantMutation) AddServiceRateIDs(ids ...int) {
	if m.service_rates == nil {
		m.service_rates = make(map[int]struct{})
	}
	for i := range ids {
		m.service_rates[ids[i]] = struct{}{}
	}
}

// ClearServiceRates clears the "service_rates" edge to the ServiceRate entity.
func (m *TenantMutation) ClearServiceRates() {
	m.clearedservice_rates = true
}

// ServiceRatesCleared reports if the "service_rates" edge to the ServiceRate entity was cleared.
func (m *TenantMutation) ServiceRatesCleared() bool {
	return m.clearedservice_rates
}

// RemoveServiceRateIDs removes the "service_rates" edge to the ServiceRate entity by IDs.
func (m *TenantMutation) RemoveServiceRateIDs(ids ...int) {
	if m.removedservice_rates == nil {
		m.removedservice_rates = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.service_rates, ids[i])
		m.removedservice_rates[ids[i]] = struct{}{}
	}
}

// RemovedServiceRates returns the removed IDs of the "service_rates" edge to the ServiceRate entity.
func (m *TenantMutation) RemovedServiceRatesIDs() (ids []int) {
	for id := range m.removedservice_rates {
		ids = append(ids, id)
	}
	return
}

// ServiceRatesIDs returns the "service_rates" edge IDs in the mutation.
func (m *TenantMutation) ServiceRatesIDs() (ids []int) {
	for id := range m.service_rates {
		ids = append(ids, id)
	}
	return
}

// ResetServiceRates resets all changes to the "service_rates" edge.
func (m *TenantMutation) ResetServiceRates() {
	m.service_rates = nil
	m.clearedservice_rates = false
	m.removedservice_rates = nil
}

// AddNetworkDeviceIDs adds the "network_devices" edge to the NetworkDevice entity by ids.
func (m *TenantMutation) AddNetworkDeviceIDs(ids ...int) {
	if m.network_devices == nil {
		m.network_devices = make(map[int]struct{})
	}
	for i := range ids {
		m.network_devices[ids[i]] = struct{}{}
	}
}

// ClearNetworkDevices clears the "network_devices" edge to the NetworkDevice entity.
func (m *TenantMutation) ClearNetworkDevices() {
	m.clearednetwork_devices = true
}

// NetworkDevicesCleared reports if the "network_devices" edge to the NetworkDevice entity was cleared.
func (m *TenantMutation) NetworkDevicesCleared() bool {
	return m.clearednetwork_devices
}

// RemoveNetworkDeviceIDs removes the "network_devices" edge to the NetworkDevice entity by IDs.
func (m *TenantMutation) RemoveNetworkDeviceIDs(ids ...int) {
	if m.removednetwork_devices == nil {
		m.removednetwork_devices = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.network_devices, ids[i])
		m.removednetwork_devices[ids[i]] = struct{}{}
	}
}

// RemovedNetworkDevices returns the removed IDs of the "network_devices" edge to the NetworkDevice entity.
func (m *TenantMutation) RemovedNetworkDevicesIDs() (ids []int) {
	for id := range m.removednetwork_devices {
		ids = append(ids, id)
	}
	return
}

// NetworkDevicesIDs returns the "network_devices" edge IDs in the mutation.
func (m *TenantMutation) NetworkDevicesIDs() (ids []int) {
	for id := range m.network_devices {
		ids = append(ids, id)
	}
	return
}

// ResetNetworkDevices resets all changes to the "network_devices" edge.
func (m *TenantMutation) ResetNetworkDevices() {
	m.network_devices = nil
	m.clearednetwork_devices = false
	m.removednetwork_devices = nil
}

// AddNetworkBackupIDs adds the "network_backups" edge to the NetworkBackup entity by ids.
func (m *TenantMutation) AddNetworkBackupIDs(ids ...int) {
	if m.network_backups == nil {
		m.network_backups = make(map[int]struct{})
	}
	for i := range ids {
		m.network_backups[ids[i]] = struct{}{}
	}
}

// ClearNetworkBackups clears the "network_backups" edge to the NetworkBackup entity.
func (m *TenantMutation) ClearNetworkBackups() {
	m.clearednetwork_backups = true
}

// NetworkBackupsCleared reports if the "network_backups" edge to the NetworkBackup entity was cleared.
func (m *TenantMutation) NetworkBackupsCleared() bool {
	return m.clearednetwork_backups
}

// RemoveNetworkBackupIDs removes the "network_backups" edge to the NetworkBackup entity by IDs.
func (m *TenantMutation) RemoveNetworkBackupIDs(ids ...int) {
	if m.removednetwork_backups == nil {
		m.removednetwork_backups = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.network_backups, ids[i])
		m.removednetwork_backups[ids[i]] = struct{}{}
	}
}

// RemovedNetworkBackups returns the removed IDs of the "network_backups" edge to the NetworkBackup entity.
func (m *TenantMutation) RemovedNetworkBackupsIDs() (ids []int) {
	for id := range m.removednetwork_backups {
		ids = append(ids, id)
	}
	return
}

// NetworkBackupsIDs returns the "network_backups" edge IDs in the mutation.
func (m *TenantMutation) NetworkBackupsIDs() (ids []int) {
	for id := range m.network_backups {
		ids = append(ids, id)
	}
	return
}

// ResetNetworkBackups resets all changes to the "network_backups" edge.
func (m *TenantMutation) ResetNetworkBackups() {
	m.network_backups = nil
	m.clearednetwork_backups = false
	m.removednetwork_backups = nil
}

// AddBudgetForecastIDs adds the "budget_forecasts" edge to the BudgetForecast entity by ids.
func (m *TenantMutation) AddBudgetForecastIDs(ids ...int) {
	if m.budget_forecasts == nil {
		m.budget_forecasts = make(map[int]struct{})
	}
	for i := range ids {
		m.budget_forecasts[ids[i]] = struct{}{}
	}
}

// ClearBudgetForecasts clears the "budget_forecasts" edge to the BudgetForecast entity.
func (m *TenantMutation) ClearBudgetForecasts() {
	m.clearedbudget_forecasts = true
}

// BudgetForecastsCleared reports if the "budget_forecasts" edge to the BudgetForecast entity was cleared.
func (m *TenantMutation) BudgetForecastsCleared() bool {
	return m.clearedbudget_forecasts
}

// RemoveBudgetForecastIDs removes the "budget_forecasts" edge to the BudgetForecast entity by IDs.
func (m *TenantMutation) RemoveBudgetForecastIDs(ids ...int) {
	if m.removedbudget_forecasts == nil {
		m.removedbudget_forecasts = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.budget_forecasts, ids[i])
		m.removedbudget_forecasts[ids[i]] = struct{}{}
	}
}

// RemovedBudgetForecasts returns the removed IDs of the "budget_forecasts" edge to the BudgetForecast entity.
func (m *TenantMutation) RemovedBudgetForecastsIDs() (ids []int) {
	for id := range m.removedbudget_forecasts {
		ids = append(ids, id)
	}
	return
}

// BudgetForecastsIDs returns the "budget_forecasts" edge IDs in the mutation.
func (m *TenantMutation) BudgetForecastsIDs() (ids []int) {
	for id := range m.budget_forecasts {
		ids = append(ids, id)
	}
	return
}

// ResetBudgetForecasts resets all changes to the "budget_forecasts" edge.
func (m *TenantMutation) ResetBudgetForecasts() {
	m.budget_forecasts = nil
	m.clearedbudget_forecasts = false
	m.removedbudget_forecasts = nil
}

// AddEmployeeIDs adds the "employees" edge to the Employee entity by ids.
func (m *TenantMutation) AddEmployeeIDs(ids ...int) {
	if m.employees == nil {
		m.employees = make(map[int]struct{})
	}
	for i := range ids {
		m.employees[ids[i]] = struct{}{}
	}
}

// ClearEmployees clears the "employees" edge to the Employee entity.
func (m *TenantMutation) ClearEmployees() {
	m.clearedemployees = true
}

// EmployeesCleared reports if the "employees" edge to the Employee entity was cleared.
func (m *TenantMutation) EmployeesCleared() bool {
	return m.clearedemployees
}

// RemoveEmployeeIDs removes the "employees" edge to the Employee entity by IDs.
func (m *TenantMutation) RemoveEmployeeIDs(ids ...int) {
	if m.removedemployees == nil {
		m.removedemployees = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.employees, ids[i])
		m.removedemployees[ids[i]] = struct{}{}
	}
}

// RemovedEmployees returns the removed IDs of the "employees" edge to the Employee entity.
func (m *TenantMutation) RemovedEmployeesIDs() (ids []int) {
	for id := range m.removedemployees {
		ids = append(ids, id)
	}
	return
}

// EmployeesIDs returns the "employees" edge IDs in the mutation.
func (m *TenantMutation) EmployeesIDs() (ids []int) {
	for id := range m.employees {
		ids = append(ids, id)
	}
	return
}

// ResetEmployees resets all changes to the "employees" edge.
func (m *TenantMutation) ResetEmployees() {
	m.employees = nil
	m.clearedemployees = false
	m.removedemployees = nil
}

// AddCompensationAgreementIDs adds the "compensation_agreements" edge to the CompensationAgreement entity by ids.
func (m *TenantMutation) AddCompensationAgreementIDs(ids ...int) {
	if m.compensation_agreements == nil {
		m.compensation_agreements = make(map[int]struct{})
	}
	for i := range ids {
		m.compensation_agreements[ids[i]] = struct{}{}
	}
}

// ClearCompensationAgreements clears the "compensation_agreements" edge to the CompensationAgreement entity.
func (m *TenantMutation) ClearCompensationAgreements() {
	m.clearedcompensation_agreements = true
}

// CompensationAgreementsCleared reports if the "compensation_agreements" edge to the CompensationAgreement entity was cleared.
func (m *TenantMutation) CompensationAgreementsCleared() bool {
	return m.clearedcompensation_agreements
}

// RemoveCompensationAgreementIDs removes the "compensation_agreements" edge to the CompensationAgreement entity by IDs.
func (m *TenantMutation) RemoveCompensationAgreementIDs(ids ...int) {
	if m.removedcompensation_agreements == nil {
		m.removedcompensation_agreements = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.compensation_agreements, ids[i])
		m.removedcompensation_agreements[ids[i]] = struct{}{}
	}
}

// RemovedCompensationAgreements returns the removed IDs of the "compensation_agreements" edge to the CompensationAgreement entity.
func (m *TenantMutation) RemovedCompensationAgreementsIDs() (ids []int) {
	for id := range m.removedcompensation_agreements {
		ids = append(ids, id)
	}
	return
}

// CompensationAgreementsIDs returns the "compensation_agreements" edge IDs in the mutation.
func (m *TenantMutation) CompensationAgreementsIDs() (ids []int) {
	for id := range m.compensation_agreements {
		ids = append(ids, id)
	}
	return
}

// ResetCompensationAgreements resets all changes to the "compensation_agreements" edge.
func (m *TenantMutation) ResetCompensationAgreements() {
	m.compensation_agreements = nil
	m.clearedcompensation_agreements = false
	m.removedcompensation_agreements = nil
}

// AddVaultItemIDs adds the "vault_items" edge to the VaultItem entity by ids.
func (m *TenantMutation) AddVaultItemIDs(ids ...int) {
	if m.vault_items == nil {
		m.vault_items = make(map[int]struct{})
	}
	for i := range ids {
		m.vault_items[ids[i]] = struct{}{}
	}
}

// ClearVaultItems clears the "vault_items" edge to the VaultItem entity.
func (m *TenantMutation) ClearVaultItems() {
	m.clearedvault_items = true
}

// VaultItemsCleared reports if the "vault_items" edge to the VaultItem entity was cleared.
func (m *TenantMutation) VaultItemsCleared() bool {
	return m.clearedvault_items
}

// RemoveVaultItemIDs removes the "vault_items" edge to the VaultItem entity by IDs.
func (m *TenantMutation) RemoveVaultItemIDs(ids ...int) {
	if m.removedvault_items == nil {
		m.removedvault_items = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.vault_items, ids[i])
		m.removedvault_items[ids[i]] = struct{}{}
	}
}

// RemovedVaultItems returns the removed IDs of the "vault_items" edge to the VaultItem entity.
func (m *TenantMutation) RemovedVaultItemsIDs() (ids []int) {
	for id := range m.removedvault_items {
		ids = append(ids, id)
	}
	return
}

// VaultItemsIDs returns the "vault_items" edge IDs in the mutation.
func (m *TenantMutation) VaultItemsIDs() (ids []int) {
	for id := range m.vault_items {
		ids = append(ids, id)
	}
	return
}

// ResetVaultItems resets all changes to the "vault_items" edge.
func (m *TenantMutation) ResetVaultItems() {
	m.vault_items = nil
	m.clearedvault_items = false
	m.removedvault_items = nil
}

// AddVaultShareLinkIDs adds the "vault_share_links" edge to the VaultShareLink entity by ids.
func (m *TenantMutation) AddVaultShareLinkIDs(ids ...int) {
	if m.vault_share_links == nil {
		m.vault_share_links = make(map[int]struct{})
	}
	for i := range ids {
		m.vault_share_links[ids[i]] = struct{}{}
	}
}

// ClearVaultShareLinks clears the "vault_share_links" edge to the VaultShareLink entity.
func (m *TenantMutation) ClearVaultShareLinks() {
	m.clearedvault_share_links = true
}

// VaultShareLinksCleared reports if the "vault_share_links" edge to the VaultShareLink entity was cleared.
func (m *TenantMutation) VaultShareLinksCleared() bool {
	return m.clearedvault_share_links
}

// RemoveVaultShareLinkIDs removes the "vault_share_links" edge to the VaultShareLink entity by IDs.
func (m *TenantMutation) RemoveVaultShareLinkIDs(ids ...int) {
	if m.removedvault_share_links == nil {
		m.removedvault_share_links = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.vault_share_links, ids[i])
		m.removedvault_share_links[ids[i]] = struct{}{}
	}
}

// RemovedVaultShareLinks returns the removed IDs of the "vault_share_links" edge to the VaultShareLink entity.
func (m *TenantMutation) RemovedVaultShareLinksIDs() (ids []int) {
	for id := range m.removedvault_share_links {
		ids = append(ids, id)
	}
	return
}

// VaultShareLinksIDs returns the "vault_share_links" edge IDs in the mutation.
func (m *TenantMutation) VaultShareLinksIDs() (ids []int) {
	for id := range m.vault_share_links {
		ids = append(ids, id)
	}
	return
}

// ResetVaultShareLinks resets all changes to the "vault_share_links" edge.
func (m *TenantMutation) ResetVaultShareLinks() {
	m.vault_share_links = nil
	m.clearedvault_share_links = false
	m.removedvault_share_links = nil
}

// AddJournalEntryIDs adds the "journal_entries" edge to the JournalEntry entity by ids.
func (m *TenantMutation) AddJournalEntryIDs(ids ...int) {
	if m.journal_entries == nil {
		m.journal_entries = make(map[int]struct{})
	}
	for i := range ids {
		m.journal_entries[ids[i]] = struct{}{}
	}
}

// ClearJournalEntries clears the "journal_entries" edge to the JournalEntry entity.
func (m *TenantMutation) ClearJournalEntries() {
	m.clearedjournal_entries = true
}

// JournalEntriesCleared reports if the "journal_entries" edge to the JournalEntry entity was cleared.
func (m *TenantMutation) JournalEntriesCleared() bool {
	return m.clearedjournal_entries
}

// RemoveJournalEntryIDs removes the "journal_entries" edge to the JournalEntry entity by IDs.
func (m *TenantMutation) RemoveJournalEntryIDs(ids ...int) {
	if m.removedjournal_entries == nil {
		m.removedjournal_entries = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.journal_entries, ids[i])
		m.removedjournal_entries[ids[i]] = struct{}{}
	}
}

// RemovedJournalEntries returns the removed IDs of the "journal_entries" edge to the JournalEntry entity.
func (m *TenantMutation) RemovedJournalEntriesIDs() (ids []int) {
	for id := range m.removedjournal_entries {
		ids = append(ids, id)
	}
	return
}

// JournalEntriesIDs returns the "journal_entries" edge IDs in the mutation.
func (m *TenantMutation) JournalEntriesIDs() (ids []int) {
	for id := range m.journal_entries {
		ids = append(ids, id)
	}
	return
}

// ResetJournalEntries resets all changes to the "journal_entries" edge.
func (m *TenantMutation) ResetJournalEntries() {
	m.journal_entries = nil
	m.clearedjournal_entries = false
	m.removedjournal_entries = nil
}

// AddRecurringInvoiceIDs adds the "recurring_invoices" edge to the RecurringInvoice entity by ids.
func (m *TenantMutation) AddRecurringInvoiceIDs(ids ...int) {
	if m.recurring_invoices == nil {
		m.recurring_invoices = make(map[int]struct{})
	}
	for i := range ids {
		m.recurring_invoices[ids[i]] = struct{}{}
	}
}

// ClearRecurringInvoices clears the "recurring_invoices" edge to the RecurringInvoice entity.
func (m *TenantMutation) ClearRecurringInvoices() {
	m.clearedrecurring_invoices = true
}

// RecurringInvoicesCleared reports if the "recurring_invoices" edge to the RecurringInvoice entity was cleared.
func (m *TenantMutation) RecurringInvoicesCleared() bool {
	return m.clearedrecurring_invoices
}

// RemoveRecurringInvoiceIDs removes the "recurring_invoices" edge to the RecurringInvoice entity by IDs.
func (m *TenantMutation) RemoveRecurringInvoiceIDs(ids ...int) {
	if m.removedrecurring_invoices == nil {
		m.removedrecurring_invoices = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.recurring_invoices, ids[i])
		m.removedrecurring_invoices[ids[i]] = struct{}{}
	}
}

// RemovedRecurringInvoices returns the removed IDs of the "recurring_invoices" edge to the RecurringInvoice entity.
func (m *TenantMutation) RemovedRecurringInvoicesIDs() (ids []int) {
	for id := range m.removedrecurring_invoices {
		ids = append(ids, id)
	}
	return
}

// RecurringInvoicesIDs returns the "recurring_invoices" edge IDs in the mutation.
func (m *TenantMutation) RecurringInvoicesIDs() (ids []int) {
	for id := range m.recurring_invoices {
		ids = append(ids, id)
	}
	return
}

// ResetRecurringInvoices resets all changes to the "recurring_invoices" edge.
func (m *TenantMutation) ResetRecurringInvoices() {
	m.recurring_invoices = nil
	m.clearedrecurring_invoices = false
	m.removedrecurring_invoices = nil
}

// AddInventoryReservationIDs adds the "inventory_reservations" edge to the InventoryReservation entity by ids.
func (m *TenantMutation) AddInventoryReservationIDs(ids ...int) {
	if m.inventory_reservations == nil {
		m.inventory_reservations = make(map[int]struct{})
	}
	for i := range ids {
		m.inventory_reservations[ids[i]] = struct{}{}
	}
}

// ClearInventoryReservations clears the "inventory_reservations" edge to the InventoryReservation entity.
func (m *TenantMutation) ClearInventoryReservations() {
	m.clearedinventory_reservations = true
}

// InventoryReservationsCleared reports if the "inventory_reservations" edge to the InventoryReservation entity was cleared.
func (m *TenantMutation) InventoryReservationsCleared() bool {
	return m.clearedinventory_reservations
}

// RemoveInventoryReservationIDs removes the "inventory_reservations" edge to the InventoryReservation entity by IDs.
func (m *TenantMutation) RemoveInventoryReservationIDs(ids ...int) {
	if m.removedinventory_reservations == nil {
		m.removedinventory_reservations = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.inventory_reservations, ids[i])
		m.removedinventory_reservations[ids[i]] = struct{}{}
	}
}

// RemovedInventoryReservations returns the removed IDs of the "inventory_reservations" edge to the InventoryReservation entity.
func (m *TenantMutation) RemovedInventoryReservationsIDs() (ids []int) {
	for id := range m.removedinventory_reservations {
		ids = append(ids, id)
	}
	return
}

// InventoryReservationsIDs returns the "inventory_reservations" edge IDs in the mutation.
func (m *TenantMutation) InventoryReservationsIDs() (ids []int) {
	for id := range m.inventory_reservations {
		ids = append(ids, id)
	}
	return
}

// ResetInventoryReservations resets all changes to the "inventory_reservations" edge.
func (m *TenantMutation) ResetInventoryReservations() {
	m.inventory_reservations = nil
	m.clearedinventory_reservations = false
	m.removedinventory_reservations = nil
}

// AddDepartmentIDs adds the "departments" edge to the Department entity by ids.
func (m *TenantMutation) AddDepartmentIDs(ids ...int) {
	if m.departments == nil {
		m.departments = make(map[int]struct{})
	}
	for i := range ids {
		m.departments[ids[i]] = struct{}{}
	}
}

// ClearDepartments clears the "departments" edge to the Department entity.
func (m *TenantMutation) ClearDepartments() {
	m.cleareddepartments = true
}

// DepartmentsCleared reports if the "departments" edge to the Department entity was cleared.
func (m *TenantMutation) DepartmentsCleared() bool {
	return m.cleareddepartments
}

// RemoveDepartmentIDs removes the "departments" edge to the Department entity by IDs.
func (m *TenantMutation) RemoveDepartmentIDs(ids ...int) {
	if m.removeddepartments == nil {
		m.removeddepartments = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.departments, ids[i])
		m.removeddepartments[ids[i]] = struct{}{}
	}
}

// RemovedDepartments returns the removed IDs of the "departments" edge to the Department entity.
func (m *TenantMutation) RemovedDepartmentsIDs() (ids []int) {
	for id := range m.removeddepartments {
		ids = append(ids, id)
	}
	return
}

// DepartmentsIDs returns the "departments" edge IDs in the mutation.
func (m *TenantMutation) DepartmentsIDs() (ids []int) {
	for id := range m.departments {
		ids = append(ids, id)
	}
	return
}

// ResetDepartments resets all changes to the "departments" edge.
func (m *TenantMutation) ResetDepartments() {
	m.departments = nil
	m.cleareddepartments = false
	m.removeddepartments = nil
}

// AddPermissionIDs adds the "permissions" edge to the Permission entity by ids.
func (m *TenantMutation) AddPermissionIDs(ids ...int) {
	if m.permissions == nil {
		m.permissions = make(map[int]struct{})
	}
	for i := range ids {
		m.permissions[ids[i]] = struct{}{}
	}
}

// ClearPermissions clears the "permissions" edge to the Permission entity.
func (m *TenantMutation) ClearPermissions() {
	m.clearedpermissions = true
}

// PermissionsCleared reports if the "permissions" edge to the Permission entity was cleared.
func (m *TenantMutation) PermissionsCleared() bool {
	return m.clearedpermissions
}

// RemovePermissionIDs removes the "permissions" edge to the Permission entity by IDs.
func (m *TenantMutation) RemovePermissionIDs(ids ...int) {
	if m.removedpermissions == nil {
		m.removedpermissions = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.permissions, ids[i])
		m.removedpermissions[ids[i]] = struct{}{}
	}
}

// RemovedPermissions returns the removed IDs of the "permissions" edge to the Permission entity.
func (m *TenantMutation) RemovedPermissionsIDs() (ids []int) {
	for id := range m.removedpermissions {
		ids = append(ids, id)
	}
	return
}

// PermissionsIDs returns the "permissions" edge IDs in the mutation.
func (m *TenantMutation) PermissionsIDs() (ids []int) {
	for id := range m.permissions {
		ids = append(ids, id)
	}
	return
}

// ResetPermissions resets all changes to the "permissions" edge.
func (m *TenantMutation) ResetPermissions() {
	m.permissions = nil
	m.clearedpermissions = false
	m.removedpermissions = nil
}

// AddAssetTypeIDs adds the "asset_types" edge to the AssetType entity by ids.
func (m *TenantMutation) AddAssetTypeIDs(ids ...int) {
	if m.asset_types == nil {
		m.asset_types = make(map[int]struct{})
	}
	for i := range ids {
		m.asset_types[ids[i]] = struct{}{}
	}
}

// ClearAssetTypes clears the "asset_types" edge to the AssetType entity.
func (m *TenantMutation) ClearAssetTypes() {
	m.clearedasset_types = true
}

// AssetTypesCleared reports if the "asset_types" edge to the AssetType entity was cleared.
func (m *TenantMutation) AssetTypesCleared() bool {
	return m.clearedasset_types
}

// RemoveAssetTypeIDs removes the "asset_types" edge to the AssetType entity by IDs.
func (m *TenantMutation) RemoveAssetTypeIDs(ids ...int) {
	if m.removedasset_types == nil {
		m.removedasset_types = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.asset_types, ids[i])
		m.removedasset_types[ids[i]] = struct{}{}
	}
}

// RemovedAssetTypes returns the removed IDs of the "asset_types" edge to the AssetType entity.
func (m *TenantMutation) RemovedAssetTypesIDs() (ids []int) {
	for id := range m.removedasset_types {
		ids = append(ids, id)
	}
	return
}

// AssetTypesIDs returns the "asset_types" edge IDs in the mutation.
func (m *TenantMutation) AssetTypesIDs() (ids []int) {
	for id := range m.asset_types {
		ids = append(ids, id)
	}
	return
}

// ResetAssetTypes resets all changes to the "asset_types" edge.
func (m *TenantMutation) ResetAssetTypes() {
	m.asset_types = nil
	m.clearedasset_types = false
	m.removedasset_types = nil
}

// AddDetectionEventIDs adds the "detection_events" edge to the DetectionEvent entity by ids.
func (m *TenantMutation) AddDetectionEventIDs(ids ...int) {
	if m.detection_events == nil {
		m.detection_events = make(map[int]struct{})
	}
	for i := range ids {
		m.detection_events[ids[i]] = struct{}{}
	}
}

// ClearDetectionEvents clears the "detection_events" edge to the DetectionEvent entity.
func (m *TenantMutation) ClearDetectionEvents() {
	m.cleareddetection_events = true
}

// DetectionEventsCleared reports if the "detection_events" edge to the DetectionEvent entity was cleared.
func (m *TenantMutation) DetectionEventsCleared() bool {
	return m.cleareddetection_events
}

// RemoveDetectionEventIDs removes the "detection_events" edge to the DetectionEvent entity by IDs.
func (m *TenantMutation) RemoveDetectionEventIDs(ids ...int) {
	if m.removeddetection_events == nil {
		m.removeddetection_events = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.detection_events, ids[i])
		m.removeddetection_events[ids[i]] = struct{}{}
	}
}

// RemovedDetectionEvents returns the removed IDs of the "detection_events" edge to the DetectionEvent entity.
func (m *TenantMutation) RemovedDetectionEventsIDs() (ids []int) {
	for id := range m.removeddetection_events {
		ids = append(ids, id)
	}
	return
}

// DetectionEventsIDs returns the "detection_events" edge IDs in the mutation.
func (m *TenantMutation) DetectionEventsIDs() (ids []int) {
	for id := range m.detection_events {
		ids = append(ids, id)
	}
	return
}

// ResetDetectionEvents resets all changes to the "detection_events" edge.
func (m *TenantMutation) ResetDetectionEvents() {
	m.detection_events = nil
	m.cleareddetection_events = false
	m.removeddetection_events = nil
}

// AddSaasIdentityIDs adds the "saas_identities" edge to the SaaSIdentity entity by ids.
func (m *TenantMutation) AddSaasIdentityIDs(ids ...int) {
	if m.saas_identities == nil {
		m.saas_identities = make(map[int]struct{})
	}
	for i := range ids {
		m.saas_identities[ids[i]] = struct{}{}
	}
}

// ClearSaasIdentities clears the "saas_identities" edge to the SaaSIdentity entity.
func (m *TenantMutation) ClearSaasIdentities() {
	m.clearedsaas_identities = true
}

// SaasIdentitiesCleared reports if the "saas_identities" edge to the SaaSIdentity entity was cleared.
func (m *TenantMutation) SaasIdentitiesCleared() bool {
	return m.clearedsaas_identities
}

// RemoveSaasIdentityIDs removes the "saas_identities" edge to the SaaSIdentity entity by IDs.
func (m *TenantMutation) RemoveSaasIdentityIDs(ids ...int) {
	if m.removedsaas_identities == nil {
		m.removedsaas_identities = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.saas_identities, ids[i])
		m.removedsaas_identities[ids[i]] = struct{}{}
	}
}

// RemovedSaasIdentities returns the removed IDs of the "saas_identities" edge to the SaaSIdentity entity.
func (m *TenantMutation) RemovedSaasIdentitiesIDs() (ids []int) {
	for id := range m.removedsaas_identities {
		ids = append(ids, id)
	}
	return
}

// SaasIdentitiesIDs returns the "saas_identities" edge IDs in the mutation.
func (m *TenantMutation) SaasIdentitiesIDs() (ids []int) {
	for id := range m.saas_identities {
		ids = append(ids, id)
	}
	return
}

// ResetSaasIdentities resets all changes to the "saas_identities" edge.
func (m *TenantMutation) ResetSaasIdentities() {
	m.saas_identities = nil
	m.clearedsaas_identities = false
	m.removedsaas_identities = nil
}

// AddSaasUsageIDs adds the "saas_usages" edge to the SaaSUsage entity by ids.
func (m *TenantMutation) AddSaasUsageIDs(ids ...int) {
	if m.saas_usages == nil {
		m.saas_usages = make(map[int]struct{})
	}
	for i := range ids {
		m.saas_usages[ids[i]] = struct{}{}
	}
}

// ClearSaasUsages clears the "saas_usages" edge to the SaaSUsage entity.
func (m *TenantMutation) ClearSaasUsages() {
	m.clearedsaas_usages = true
}

// SaasUsagesCleared reports if the "saas_usages" edge to the SaaSUsage entity was cleared.
func (m *TenantMutation) SaasUsagesCleared() bool {
	return m.clearedsaas_usages
}

// RemoveSaasUsageIDs removes the "saas_usages" edge to the SaaSUsage entity by IDs.
func (m *TenantMutation) RemoveSaasUsageIDs(ids ...int) {
	if m.removedsaas_usages == nil {
		m.removedsaas_usages = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.saas_usages, ids[i])
		m.removedsaas_usages[ids[i]] = struct{}{}
	}
}

// RemovedSaasUsages returns the removed IDs of the "saas_usages" edge to the SaaSUsage entity.
func (m *TenantMutation) RemovedSaasUsagesIDs() (ids []int) {
	for id := range m.removedsaas_usages {
		ids = append(ids, id)
	}
	return
}

// SaasUsagesIDs returns the "saas_usages" edge IDs in the mutation.
func (m *TenantMutation) SaasUsagesIDs() (ids []int) {
	for id := range m.saas_usages {
		ids = append(ids, id)
	}
	return
}

// ResetSaasUsages resets all changes to the "saas_usages" edge.
func (m *TenantMutation) ResetSaasUsages() {
	m.saas_usages = nil
	m.clearedsaas_usages = false
	m.removedsaas_usages = nil
}

// AddRecordingIDs adds the "recordings" edge to the Recording entity by ids.
func (m *TenantMutation) AddRecordingIDs(ids ...int) {
	if m.recordings == nil {
		m.recordings = make(map[int]struct{})
	}
	for i := range ids {
		m.recordings[ids[i]] = struct{}{}
	}
}

// ClearRecordings clears the "recordings" edge to the Recording entity.
func (m *TenantMutation) ClearRecordings() {
	m.clearedrecordings = true
}

// RecordingsCleared reports if the "recordings" edge to the Recording entity was cleared.
func (m *TenantMutation) RecordingsCleared() bool {
	return m.clearedrecordings
}

// RemoveRecordingIDs removes the "recordings" edge to the Recording entity by IDs.
func (m *TenantMutation) RemoveRecordingIDs(ids ...int) {
	if m.removedrecordings == nil {
		m.removedrecordings = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.recordings, ids[i])
		m.removedrecordings[ids[i]] = struct{}{}
	}
}

// RemovedRecordings returns the removed IDs of the "recordings" edge to the Recording entity.
func (m *TenantMutation) RemovedRecordingsIDs() (ids []int) {
	for id := range m.removedrecordings {
		ids = append(ids, id)
	}
	return
}

// RecordingsIDs returns the "recordings" edge IDs in the mutation.
func (m *TenantMutation) RecordingsIDs() (ids []int) {
	for id := range m.recordings {
		ids = append(ids, id)
	}
	return
}

// ResetRecordings resets all changes to the "recordings" edge.
func (m *TenantMutation) ResetRecordings() {
	m.recordings = nil
	m.clearedrecordings = false
	m.removedrecordings = nil
}

// AddNetworkLinkIDs adds the "network_links" edge to the NetworkLink entity by ids.
func (m *TenantMutation) AddNetworkLinkIDs(ids ...int) {
	if m.network_links == nil {
		m.network_links = make(map[int]struct{})
	}
	for i := range ids {
		m.network_links[ids[i]] = struct{}{}
	}
}

// ClearNetworkLinks clears the "network_links" edge to the NetworkLink entity.
func (m *TenantMutation) ClearNetworkLinks() {
	m.clearednetwork_links = true
}

// NetworkLinksCleared reports if the "network_links" edge to the NetworkLink entity was cleared.
func (m *TenantMutation) NetworkLinksCleared() bool {
	return m.clearednetwork_links
}

// RemoveNetworkLinkIDs removes the "network_links" edge to the NetworkLink entity by IDs.
func (m *TenantMutation) RemoveNetworkLinkIDs(ids ...int) {
	if m.removednetwork_links == nil {
		m.removednetwork_links = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.network_links, ids[i])
		m.removednetwork_links[ids[i]] = struct{}{}
	}
}

// RemovedNetworkLinks returns the removed IDs of the "network_links" edge to the NetworkLink entity.
func (m *TenantMutation) RemovedNetworkLinksIDs() (ids []int) {
	for id := range m.removednetwork_links {
		ids = append(ids, id)
	}
	return
}

// NetworkLinksIDs returns the "network_links" edge IDs in the mutation.
func (m *TenantMutation) NetworkLinksIDs() (ids []int) {
	for id := range m.network_links {
		ids = append(ids, id)
	}
	return
}

// ResetNetworkLinks resets all changes to the "network_links" edge.
func (m *TenantMutation) ResetNetworkLinks() {
	m.network_links = nil
	m.clearednetwork_links = false
	m.removednetwork_links = nil
}

// AddNetworkPortIDs adds the "network_ports" edge to the NetworkPort entity by ids.
func (m *TenantMutation) AddNetworkPortIDs(ids ...int) {
	if m.network_ports == nil {
		m.network_ports = make(map[int]struct{})
	}
	for i := range ids {
		m.network_ports[ids[i]] = struct{}{}
	}
}

// ClearNetworkPorts clears the "network_ports" edge to the NetworkPort entity.
func (m *TenantMutation) ClearNetworkPorts() {
	m.clearednetwork_ports = true
}

// NetworkPortsCleared reports if the "network_ports" edge to the NetworkPort entity was cleared.
func (m *TenantMutation) NetworkPortsCleared() bool {
	return m.clearednetwork_ports
}

// RemoveNetworkPortIDs removes the "network_ports" edge to the NetworkPort entity by IDs.
func (m *TenantMutation) RemoveNetworkPortIDs(ids ...int) {
	if m.removednetwork_ports == nil {
		m.removednetwork_ports = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.network_ports, ids[i])
		m.removednetwork_ports[ids[i]] = struct{}{}
	}
}

// RemovedNetworkPorts returns the removed IDs of the "network_ports" edge to the NetworkPort entity.
func (m *TenantMutation) RemovedNetworkPortsIDs() (ids []int) {
	for id := range m.removednetwork_ports {
		ids = append(ids, id)
	}
	return
}

// NetworkPortsIDs returns the "network_ports" edge IDs in the mutation.
func (m *TenantMutation) NetworkPortsIDs() (ids []int) {
	for id := range m.network_ports {
		ids = append(ids, id)
	}
	return
}

// ResetNetworkPorts resets all changes to the "network_ports" edge.
func (m *TenantMutation) ResetNetworkPorts() {
	m.network_ports = nil
	m.clearednetwork_ports = false
	m.removednetwork_ports = nil
}

// AddNexusAuditIDs adds the "nexus_audits" edge to the NexusAudit entity by ids.
func (m *TenantMutation) AddNexusAuditIDs(ids ...int) {
	if m.nexus_audits == nil {
		m.nexus_audits = make(map[int]struct{})
	}
	for i := range ids {
		m.nexus_audits[ids[i]] = struct{}{}
	}
}

// ClearNexusAudits clears the "nexus_audits" edge to the NexusAudit entity.
func (m *TenantMutation) ClearNexusAudits() {
	m.clearednexus_audits = true
}

// NexusAuditsCleared reports if the "nexus_audits" edge to the NexusAudit entity was cleared.
func (m *TenantMutation) NexusAuditsCleared() bool {
	return m.clearednexus_audits
}

// RemoveNexusAuditIDs removes the "nexus_audits" edge to the NexusAudit entity by IDs.
func (m *TenantMutation) RemoveNexusAuditIDs(ids ...int) {
	if m.removednexus_audits == nil {
		m.removednexus_audits = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.nexus_audits, ids[i])
		m.removednexus_audits[ids[i]] = struct{}{}
	}
}

// RemovedNexusAudits returns the removed IDs of the "nexus_audits" edge to the NexusAudit entity.
func (m *TenantMutation) RemovedNexusAuditsIDs() (ids []int) {
	for id := range m.removednexus_audits {
		ids = append(ids, id)
	}
	return
}

// NexusAuditsIDs returns the "nexus_audits" edge IDs in the mutation.
func (m *TenantMutation) NexusAuditsIDs() (ids []int) {
	for id := range m.nexus_audits {
		ids = append(ids, id)
	}
	return
}

// ResetNexusAudits resets all changes to the "nexus_audits" edge.
func (m *TenantMutation) ResetNexusAudits() {
	m.nexus_audits = nil
	m.clearednexus_audits = false
	m.removednexus_audits = nil
}

// AddSuccessionMapIDs adds the "succession_maps" edge to the SuccessionMap entity by ids.
func (m *TenantMutation) AddSuccessionMapIDs(ids ...int) {
	if m.succession_maps == nil {
		m.succession_maps = make(map[int]struct{})
	}
	for i := range ids {
		m.succession_maps[ids[i]] = struct{}{}
	}
}

// ClearSuccessionMaps clears the "succession_maps" edge to the SuccessionMap entity.
func (m *TenantMutation) ClearSuccessionMaps() {
	m.clearedsuccession_maps = true
}

// SuccessionMapsCleared reports if the "succession_maps" edge to the SuccessionMap entity was cleared.
func (m *TenantMutation) SuccessionMapsCleared() bool {
	return m.clearedsuccession_maps
}

// RemoveSuccessionMapIDs removes the "succession_maps" edge to the SuccessionMap entity by IDs.
func (m *TenantMutation) RemoveSuccessionMapIDs(ids ...int) {
	if m.removedsuccession_maps == nil {
		m.removedsuccession_maps = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.succession_maps, ids[i])
		m.removedsuccession_maps[ids[i]] = struct{}{}
	}
}

// RemovedSuccessionMaps returns the removed IDs of the "succession_maps" edge to the SuccessionMap entity.
func (m *TenantMutation) RemovedSuccessionMapsIDs() (ids []int) {
	for id := range m.removedsuccession_maps {
		ids = append(ids, id)
	}
	return
}

// SuccessionMapsIDs returns the "succession_maps" edge IDs in the mutation.
func (m *TenantMutation) SuccessionMapsIDs() (ids []int) {
	for id := range m.succession_maps {
		ids = append(ids, id)
	}
	return
}

// ResetSuccessionMaps resets all changes to the "succession_maps" edge.
func (m *TenantMutation) ResetSuccessionMaps() {
	m.succession_maps = nil
	m.clearedsuccession_maps = false
	m.removedsuccession_maps = nil
}

// SetCustomerAccountID sets the "customer_account" edge to the Account entity by id.
func (m *TenantMutation) SetCustomerAccountID(id int) {
	m.customer_account = &id
}

// ClearCustomerAccount clears the "customer_account" edge to the Account entity.
func (m *TenantMutation) ClearCustomerAccount() {
	m.clearedcustomer_account = true
}

// CustomerAccountCleared reports if the "customer_account" edge to the Account entity was cleared.
func (m *TenantMutation) CustomerAccountCleared() bool {
	return m.clearedcustomer_account
}

// CustomerAccountID returns the "customer_account" edge ID in the mutation.
func (m *TenantMutation) CustomerAccountID() (id int, exists bool) {
	if m.customer_account != nil {
		return *m.customer_account, true
	}
	return
}

// CustomerAccountIDs returns the "customer_account" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CustomerAccountID instead. It exists only for internal usage by the builders.
func (m *TenantMutation) CustomerAccountIDs() (ids []int) {
	if id := m.customer_account; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCustomerAccount resets all changes to the "customer_account" edge.
func (m *TenantMutation) ResetCustomerAccount() {
	m.customer_account = nil
	m.clearedcustomer_account = false
}

// AddScriptIDs adds the "scripts" edge to the Script entity by ids.
func (m *TenantMutation) AddScriptIDs(ids ...int) {
	if m.scripts == nil {
		m.scripts = make(map[int]struct{})
	}
	for i := range ids {
		m.scripts[ids[i]] = struct{}{}
	}
}

// ClearScripts clears the "scripts" edge to the Script entity.
func (m *TenantMutation) ClearScripts() {
	m.clearedscripts = true
}

// ScriptsCleared reports if the "scripts" edge to the Script entity was cleared.
func (m *TenantMutation) ScriptsCleared() bool {
	return m.clearedscripts
}

// RemoveScriptIDs removes the "scripts" edge to the Script entity by IDs.
func (m *TenantMutation) RemoveScriptIDs(ids ...int) {
	if m.removedscripts == nil {
		m.removedscripts = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.scripts, ids[i])
		m.removedscripts[ids[i]] = struct{}{}
	}
}

// RemovedScripts returns the removed IDs of the "scripts" edge to the Script entity.
func (m *TenantMutation) RemovedScriptsIDs() (ids []int) {
	for id := range m.removedscripts {
		ids = append(ids, id)
	}
	return
}

// ScriptsIDs returns the "scripts" edge IDs in the mutation.
func (m *TenantMutation) ScriptsIDs() (ids []int) {
	for id := range m.scripts {
		ids = append(ids, id)
	}
	return
}

// ResetScripts resets all changes to the "scripts" edge.
func (m *TenantMutation) ResetScripts() {
	m.scripts = nil
	m.clearedscripts = false
	m.removedscripts = nil
}

// AddJobIDs adds the "jobs" edge to the Job entity by ids.
func (m *TenantMutation) AddJobIDs(ids ...int) {
	if m.jobs == nil {
		m.jobs = make(map[int]struct{})
	}
	for i := range ids {
		m.jobs[ids[i]] = struct{}{}
	}
}

// ClearJobs clears the "jobs" edge to the Job entity.
func (m *TenantMutation) ClearJobs() {
	m.clearedjobs = true
}

// JobsCleared reports if the "jobs" edge to the Job entity was cleared.
func (m *TenantMutation) JobsCleared() bool {
	return m.clearedjobs
}

// RemoveJobIDs removes the "jobs" edge to the Job entity by IDs.
func (m *TenantMutation) RemoveJobIDs(ids ...int) {
	if m.removedjobs == nil {
		m.removedjobs = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.jobs, ids[i])
		m.removedjobs[ids[i]] = struct{}{}
	}
}

// RemovedJobs returns the removed IDs of the "jobs" edge to the Job entity.
func (m *TenantMutation) RemovedJobsIDs() (ids []int) {
	for id := range m.removedjobs {
		ids = append(ids, id)
	}
	return
}

// JobsIDs returns the "jobs" edge IDs in the mutation.
func (m *TenantMutation) JobsIDs() (ids []int) {
	for id := range m.jobs {
		ids = append(ids, id)
	}
	return
}

// ResetJobs resets all changes to the "jobs" edge.
func (m *TenantMutation) ResetJobs() {
	m.jobs = nil
	m.clearedjobs = false
	m.removedjobs = nil
}

// AddTimeOffRequestIDs adds the "time_off_requests" edge to the TimeOffRequest entity by ids.
func (m *TenantMutation) AddTimeOffRequestIDs(ids ...int) {
	if m.time_off_requests == nil {
		m.time_off_requests = make(map[int]struct{})
	}
	for i := range ids {
		m.time_off_requests[ids[i]] = struct{}{}
	}
}

// ClearTimeOffRequests clears the "time_off_requests" edge to the TimeOffRequest entity.
func (m *TenantMutation) ClearTimeOffRequests() {
	m.clearedtime_off_requests = true
}

// TimeOffRequestsCleared reports if the "time_off_requests" edge to the TimeOffRequest entity was cleared.
func (m *TenantMutation) TimeOffRequestsCleared() bool {
	return m.clearedtime_off_requests
}

// RemoveTimeOffRequestIDs removes the "time_off_requests" edge to the TimeOffRequest entity by IDs.
func (m *TenantMutation) RemoveTimeOffRequestIDs(ids ...int) {
	if m.removedtime_off_requests == nil {
		m.removedtime_off_requests = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.time_off_requests, ids[i])
		m.removedtime_off_requests[ids[i]] = struct{}{}
	}
}

// RemovedTimeOffRequests returns the removed IDs of the "time_off_requests" edge to the TimeOffRequest entity.
func (m *TenantMutation) RemovedTimeOffRequestsIDs() (ids []int) {
	for id := range m.removedtime_off_requests {
		ids = append(ids, id)
	}
	return
}

// TimeOffRequestsIDs returns the "time_off_requests" edge IDs in the mutation.
func (m *TenantMutation) TimeOffRequestsIDs() (ids []int) {
	for id := range m.time_off_requests {
		ids = append(ids, id)
	}
	return
}

// ResetTimeOffRequests resets all changes to the "time_off_requests" edge.
func (m *TenantMutation) ResetTimeOffRequests() {
	m.time_off_requests = nil
	m.clearedtime_off_requests = false
	m.removedtime_off_requests = nil
}

// AddTimeOffPolicyIDs adds the "time_off_policies" edge to the TimeOffPolicy entity by ids.
func (m *TenantMutation) AddTimeOffPolicyIDs(ids ...int) {
	if m.time_off_policies == nil {
		m.time_off_policies = make(map[int]struct{})
	}
	for i := range ids {
		m.time_off_policies[ids[i]] = struct{}{}
	}
}

// ClearTimeOffPolicies clears the "time_off_policies" edge to the TimeOffPolicy entity.
func (m *TenantMutation) ClearTimeOffPolicies() {
	m.clearedtime_off_policies = true
}

// TimeOffPoliciesCleared reports if the "time_off_policies" edge to the TimeOffPolicy entity was cleared.
func (m *TenantMutation) TimeOffPoliciesCleared() bool {
	return m.clearedtime_off_policies
}

// RemoveTimeOffPolicyIDs removes the "time_off_policies" edge to the TimeOffPolicy entity by IDs.
func (m *TenantMutation) RemoveTimeOffPolicyIDs(ids ...int) {
	if m.removedtime_off_policies == nil {
		m.removedtime_off_policies = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.time_off_policies, ids[i])
		m.removedtime_off_policies[ids[i]] = struct{}{}
	}
}

// RemovedTimeOffPolicies returns the removed IDs of the "time_off_policies" edge to the TimeOffPolicy entity.
func (m *TenantMutation) RemovedTimeOffPoliciesIDs() (ids []int) {
	for id := range m.removedtime_off_policies {
		ids = append(ids, id)
	}
	return
}

// TimeOffPoliciesIDs returns the "time_off_policies" edge IDs in the mutation.
func (m *TenantMutation) TimeOffPoliciesIDs() (ids []int) {
	for id := range m.time_off_policies {
		ids = append(ids, id)
	}
	return
}

// ResetTimeOffPolicies resets all changes to the "time_off_policies" edge.
func (m *TenantMutation) ResetTimeOffPolicies() {
	m.time_off_policies = nil
	m.clearedtime_off_policies = false
	m.removedtime_off_policies = nil
}

// AddTimeOffBalanceIDs adds the "time_off_balances" edge to the TimeOffBalance entity by ids.
func (m *TenantMutation) AddTimeOffBalanceIDs(ids ...int) {
	if m.time_off_balances == nil {
		m.time_off_balances = make(map[int]struct{})
	}
	for i := range ids {
		m.time_off_balances[ids[i]] = struct{}{}
	}
}

// ClearTimeOffBalances clears the "time_off_balances" edge to the TimeOffBalance entity.
func (m *TenantMutation) ClearTimeOffBalances() {
	m.clearedtime_off_balances = true
}

// TimeOffBalancesCleared reports if the "time_off_balances" edge to the TimeOffBalance entity was cleared.
func (m *TenantMutation) TimeOffBalancesCleared() bool {
	return m.clearedtime_off_balances
}

// RemoveTimeOffBalanceIDs removes the "time_off_balances" edge to the TimeOffBalance entity by IDs.
func (m *TenantMutation) RemoveTimeOffBalanceIDs(ids ...int) {
	if m.removedtime_off_balances == nil {
		m.removedtime_off_balances = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.time_off_balances, ids[i])
		m.removedtime_off_balances[ids[i]] = struct{}{}
	}
}

// RemovedTimeOffBalances returns the removed IDs of the "time_off_balances" edge to the TimeOffBalance entity.
func (m *TenantMutation) RemovedTimeOffBalancesIDs() (ids []int) {
	for id := range m.removedtime_off_balances {
		ids = append(ids, id)
	}
	return
}

// TimeOffBalancesIDs returns the "time_off_balances" edge IDs in the mutation.
func (m *TenantMutation) TimeOffBalancesIDs() (ids []int) {
	for id := range m.time_off_balances {
		ids = append(ids, id)
	}
	return
}

// ResetTimeOffBalances resets all changes to the "time_off_balances" edge.
func (m *TenantMutation) ResetTimeOffBalances() {
	m.time_off_balances = nil
	m.clearedtime_off_balances = false
	m.removedtime_off_balances = nil
}

// AddReviewCycleIDs adds the "review_cycles" edge to the ReviewCycle entity by ids.
func (m *TenantMutation) AddReviewCycleIDs(ids ...int) {
	if m.review_cycles == nil {
		m.review_cycles = make(map[int]struct{})
	}
	for i := range ids {
		m.review_cycles[ids[i]] = struct{}{}
	}
}

// ClearReviewCycles clears the "review_cycles" edge to the ReviewCycle entity.
func (m *TenantMutation) ClearReviewCycles() {
	m.clearedreview_cycles = true
}

// ReviewCyclesCleared reports if the "review_cycles" edge to the ReviewCycle entity was cleared.
func (m *TenantMutation) ReviewCyclesCleared() bool {
	return m.clearedreview_cycles
}

// RemoveReviewCycleIDs removes the "review_cycles" edge to the ReviewCycle entity by IDs.
func (m *TenantMutation) RemoveReviewCycleIDs(ids ...int) {
	if m.removedreview_cycles == nil {
		m.removedreview_cycles = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.review_cycles, ids[i])
		m.removedreview_cycles[ids[i]] = struct{}{}
	}
}

// RemovedReviewCycles returns the removed IDs of the "review_cycles" edge to the ReviewCycle entity.
func (m *TenantMutation) RemovedReviewCyclesIDs() (ids []int) {
	for id := range m.removedreview_cycles {
		ids = append(ids, id)
	}
	return
}

// ReviewCyclesIDs returns the "review_cycles" edge IDs in the mutation.
func (m *TenantMutation) ReviewCyclesIDs() (ids []int) {
	for id := range m.review_cycles {
		ids = append(ids, id)
	}
	return
}

// ResetReviewCycles resets all changes to the "review_cycles" edge.
func (m *TenantMutation) ResetReviewCycles() {
	m.review_cycles = nil
	m.clearedreview_cycles = false
	m.removedreview_cycles = nil
}

// AddPerformanceReviewIDs adds the "performance_reviews" edge to the PerformanceReview entity by ids.
func (m *TenantMutation) AddPerformanceReviewIDs(ids ...int) {
	if m.performance_reviews == nil {
		m.performance_reviews = make(map[int]struct{})
	}
	for i := range ids {
		m.performance_reviews[ids[i]] = struct{}{}
	}
}

// ClearPerformanceReviews clears the "performance_reviews" edge to the PerformanceReview entity.
func (m *TenantMutation) ClearPerformanceReviews() {
	m.clearedperformance_reviews = true
}

// PerformanceReviewsCleared reports if the "performance_reviews" edge to the PerformanceReview entity was cleared.
func (m *TenantMutation) PerformanceReviewsCleared() bool {
	return m.clearedperformance_reviews
}

// RemovePerformanceReviewIDs removes the "performance_reviews" edge to the PerformanceReview entity by IDs.
func (m *TenantMutation) RemovePerformanceReviewIDs(ids ...int) {
	if m.removedperformance_reviews == nil {
		m.removedperformance_reviews = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.performance_reviews, ids[i])
		m.removedperformance_reviews[ids[i]] = struct{}{}
	}
}

// RemovedPerformanceReviews returns the removed IDs of the "performance_reviews" edge to the PerformanceReview entity.
func (m *TenantMutation) RemovedPerformanceReviewsIDs() (ids []int) {
	for id := range m.removedperformance_reviews {
		ids = append(ids, id)
	}
	return
}

// PerformanceReviewsIDs returns the "performance_reviews" edge IDs in the mutation.
func (m *TenantMutation) PerformanceReviewsIDs() (ids []int) {
	for id := range m.performance_reviews {
		ids = append(ids, id)
	}
	return
}

// ResetPerformanceReviews resets all changes to the "performance_reviews" edge.
func (m *TenantMutation) ResetPerformanceReviews() {
	m.performance_reviews = nil
	m.clearedperformance_reviews = false
	m.removedperformance_reviews = nil
}

// AddGoalIDs adds the "goals" edge to the Goal entity by ids.
func (m *TenantMutation) AddGoalIDs(ids ...int) {
	if m.goals == nil {
		m.goals = make(map[int]struct{})
	}
	for i := range ids {
		m.goals[ids[i]] = struct{}{}
	}
}

// ClearGoals clears the "goals" edge to the Goal entity.
func (m *TenantMutation) ClearGoals() {
	m.clearedgoals = true
}

// GoalsCleared reports if the "goals" edge to the Goal entity was cleared.
func (m *TenantMutation) GoalsCleared() bool {
	return m.clearedgoals
}

// RemoveGoalIDs removes the "goals" edge to the Goal entity by IDs.
func (m *TenantMutation) RemoveGoalIDs(ids ...int) {
	if m.removedgoals == nil {
		m.removedgoals = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.goals, ids[i])
		m.removedgoals[ids[i]] = struct{}{}
	}
}

// RemovedGoals returns the removed IDs of the "goals" edge to the Goal entity.
func (m *TenantMutation) RemovedGoalsIDs() (ids []int) {
	for id := range m.removedgoals {
		ids = append(ids, id)
	}
	return
}

// GoalsIDs returns the "goals" edge IDs in the mutation.
func (m *TenantMutation) GoalsIDs() (ids []int) {
	for id := range m.goals {
		ids = append(ids, id)
	}
	return
}

// ResetGoals resets all changes to the "goals" edge.
func (m *TenantMutation) ResetGoals() {
	m.goals = nil
	m.clearedgoals = false
	m.removedgoals = nil
}

// AddSupplierIDs adds the "suppliers" edge to the Supplier entity by ids.
func (m *TenantMutation) AddSupplierIDs(ids ...int) {
	if m.suppliers == nil {
		m.suppliers = make(map[int]struct{})
	}
	for i := range ids {
		m.suppliers[ids[i]] = struct{}{}
	}
}

// ClearSuppliers clears the "suppliers" edge to the Supplier entity.
func (m *TenantMutation) ClearSuppliers() {
	m.clearedsuppliers = true
}

// SuppliersCleared reports if the "suppliers" edge to the Supplier entity was cleared.
func (m *TenantMutation) SuppliersCleared() bool {
	return m.clearedsuppliers
}

// RemoveSupplierIDs removes the "suppliers" edge to the Supplier entity by IDs.
func (m *TenantMutation) RemoveSupplierIDs(ids ...int) {
	if m.removedsuppliers == nil {
		m.removedsuppliers = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.suppliers, ids[i])
		m.removedsuppliers[ids[i]] = struct{}{}
	}
}

// RemovedSuppliers returns the removed IDs of the "suppliers" edge to the Supplier entity.
func (m *TenantMutation) RemovedSuppliersIDs() (ids []int) {
	for id := range m.removedsuppliers {
		ids = append(ids, id)
	}
	return
}

// SuppliersIDs returns the "suppliers" edge IDs in the mutation.
func (m *TenantMutation) SuppliersIDs() (ids []int) {
	for id := range m.suppliers {
		ids = append(ids, id)
	}
	return
}

// ResetSuppliers resets all changes to the "suppliers" edge.
func (m *TenantMutation) ResetSuppliers() {
	m.suppliers = nil
	m.clearedsuppliers = false
	m.removedsuppliers = nil
}

// AddCategoryIDs adds the "categories" edge to the Category entity by ids.
func (m *TenantMutation) AddCategoryIDs(ids ...int) {
	if m.categories == nil {
		m.categories = make(map[int]struct{})
	}
	for i := range ids {
		m.categories[ids[i]] = struct{}{}
	}
}

// ClearCategories clears the "categories" edge to the Category entity.
func (m *TenantMutation) ClearCategories() {
	m.clearedcategories = true
}

// CategoriesCleared reports if the "categories" edge to the Category entity was cleared.
func (m *TenantMutation) CategoriesCleared() bool {
	return m.clearedcategories
}

// RemoveCategoryIDs removes the "categories" edge to the Category entity by IDs.
func (m *TenantMutation) RemoveCategoryIDs(ids ...int) {
	if m.removedcategories == nil {
		m.removedcategories = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.categories, ids[i])
		m.removedcategories[ids[i]] = struct{}{}
	}
}

// RemovedCategories returns the removed IDs of the "categories" edge to the Category entity.
func (m *TenantMutation) RemovedCategoriesIDs() (ids []int) {
	for id := range m.removedcategories {
		ids = append(ids, id)
	}
	return
}

// CategoriesIDs returns the "categories" edge IDs in the mutation.
func (m *TenantMutation) CategoriesIDs() (ids []int) {
	for id := range m.categories {
		ids = append(ids, id)
	}
	return
}

// ResetCategories resets all changes to the "categories" edge.
func (m *TenantMutation) ResetCategories() {
	m.categories = nil
	m.clearedcategories = false
	m.removedcategories = nil
}

// AddWarehouseIDs adds the "warehouses" edge to the Warehouse entity by ids.
func (m *TenantMutation) AddWarehouseIDs(ids ...int) {
	if m.warehouses == nil {
		m.warehouses = make(map[int]struct{})
	}
	for i := range ids {
		m.warehouses[ids[i]] = struct{}{}
	}
}

// ClearWarehouses clears the "warehouses" edge to the Warehouse entity.
func (m *TenantMutation) ClearWarehouses() {
	m.clearedwarehouses = true
}

// WarehousesCleared reports if the "warehouses" edge to the Warehouse entity was cleared.
func (m *TenantMutation) WarehousesCleared() bool {
	return m.clearedwarehouses
}

// RemoveWarehouseIDs removes the "warehouses" edge to the Warehouse entity by IDs.
func (m *TenantMutation) RemoveWarehouseIDs(ids ...int) {
	if m.removedwarehouses == nil {
		m.removedwarehouses = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.warehouses, ids[i])
		m.removedwarehouses[ids[i]] = struct{}{}
	}
}

// RemovedWarehouses returns the removed IDs of the "warehouses" edge to the Warehouse entity.
func (m *TenantMutation) RemovedWarehousesIDs() (ids []int) {
	for id := range m.removedwarehouses {
		ids = append(ids, id)
	}
	return
}

// WarehousesIDs returns the "warehouses" edge IDs in the mutation.
func (m *TenantMutation) WarehousesIDs() (ids []int) {
	for id := range m.warehouses {
		ids = append(ids, id)
	}
	return
}

// ResetWarehouses resets all changes to the "warehouses" edge.
func (m *TenantMutation) ResetWarehouses() {
	m.warehouses = nil
	m.clearedwarehouses = false
	m.removedwarehouses = nil
}

// AddAssetAssignmentIDs adds the "asset_assignments" edge to the AssetAssignment entity by ids.
func (m *TenantMutation) AddAssetAssignmentIDs(ids ...int) {
	if m.asset_assignments == nil {
		m.asset_assignments = make(map[int]struct{})
	}
	for i := range ids {
		m.asset_assignments[ids[i]] = struct{}{}
	}
}

// ClearAssetAssignments clears the "asset_assignments" edge to the AssetAssignment entity.
func (m *TenantMutation) ClearAssetAssignments() {
	m.clearedasset_assignments = true
}

// AssetAssignmentsCleared reports if the "asset_assignments" edge to the AssetAssignment entity was cleared.
func (m *TenantMutation) AssetAssignmentsCleared() bool {
	return m.clearedasset_assignments
}

// RemoveAssetAssignmentIDs removes the "asset_assignments" edge to the AssetAssignment entity by IDs.
func (m *TenantMutation) RemoveAssetAssignmentIDs(ids ...int) {
	if m.removedasset_assignments == nil {
		m.removedasset_assignments = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.asset_assignments, ids[i])
		m.removedasset_assignments[ids[i]] = struct{}{}
	}
}

// RemovedAssetAssignments returns the removed IDs of the "asset_assignments" edge to the AssetAssignment entity.
func (m *TenantMutation) RemovedAssetAssignmentsIDs() (ids []int) {
	for id := range m.removedasset_assignments {
		ids = append(ids, id)
	}
	return
}

// AssetAssignmentsIDs returns the "asset_assignments" edge IDs in the mutation.
func (m *TenantMutation) AssetAssignmentsIDs() (ids []int) {
	for id := range m.asset_assignments {
		ids = append(ids, id)
	}
	return
}

// ResetAssetAssignments resets all changes to the "asset_assignments" edge.
func (m *TenantMutation) ResetAssetAssignments() {
	m.asset_assignments = nil
	m.clearedasset_assignments = false
	m.removedasset_assignments = nil
}

// AddContactIDs adds the "contacts" edge to the Contact entity by ids.
func (m *TenantMutation) AddContactIDs(ids ...int) {
	if m.contacts == nil {
		m.contacts = make(map[int]struct{})
	}
	for i := range ids {
		m.contacts[ids[i]] = struct{}{}
	}
}

// ClearContacts clears the "contacts" edge to the Contact entity.
func (m *TenantMutation) ClearContacts() {
	m.clearedcontacts = true
}

// ContactsCleared reports if the "contacts" edge to the Contact entity was cleared.
func (m *TenantMutation) ContactsCleared() bool {
	return m.clearedcontacts
}

// RemoveContactIDs removes the "contacts" edge to the Contact entity by IDs.
func (m *TenantMutation) RemoveContactIDs(ids ...int) {
	if m.removedcontacts == nil {
		m.removedcontacts = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.contacts, ids[i])
		m.removedcontacts[ids[i]] = struct{}{}
	}
}

// RemovedContacts returns the removed IDs of the "contacts" edge to the Contact entity.
func (m *TenantMutation) RemovedContactsIDs() (ids []int) {
	for id := range m.removedcontacts {
		ids = append(ids, id)
	}
	return
}

// ContactsIDs returns the "contacts" edge IDs in the mutation.
func (m *TenantMutation) ContactsIDs() (ids []int) {
	for id := range m.contacts {
		ids = append(ids, id)
	}
	return
}

// ResetContacts resets all changes to the "contacts" edge.
func (m *TenantMutation) ResetContacts() {
	m.contacts = nil
	m.clearedcontacts = false
	m.removedcontacts = nil
}

// AddLegalHoldIDs adds the "legal_holds" edge to the LegalHold entity by ids.
func (m *TenantMutation) AddLegalHoldIDs(ids ...int) {
	if m.legal_holds == nil {
		m.legal_holds = make(map[int]struct{})
	}
	for i := range ids {
		m.legal_holds[ids[i]] = struct{}{}
	}
}

// ClearLegalHolds clears the "legal_holds" edge to the LegalHold entity.
func (m *TenantMutation) ClearLegalHolds() {
	m.clearedlegal_holds = true
}

// LegalHoldsCleared reports if the "legal_holds" edge to the LegalHold entity was cleared.
func (m *TenantMutation) LegalHoldsCleared() bool {
	return m.clearedlegal_holds
}

// RemoveLegalHoldIDs removes the "legal_holds" edge to the LegalHold entity by IDs.
func (m *TenantMutation) RemoveLegalHoldIDs(ids ...int) {
	if m.removedlegal_holds == nil {
		m.removedlegal_holds = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.legal_holds, ids[i])
		m.removedlegal_holds[ids[i]] = struct{}{}
	}
}

// RemovedLegalHolds returns the removed IDs of the "legal_holds" edge to the LegalHold entity.
func (m *TenantMutation) RemovedLegalHoldsIDs() (ids []int) {
	for id := range m.removedlegal_holds {
		ids = append(ids, id)
	}
	return
}

// LegalHoldsIDs returns the "legal_holds" edge IDs in the mutation.
func (m *TenantMutation) LegalHoldsIDs() (ids []int) {
	for id := range m.legal_holds {
		ids = append(ids, id)
	}
	return
}

// ResetLegalHolds resets all changes to the "legal_holds" edge.
func (m *TenantMutation) ResetLegalHolds() {
	m.legal_holds = nil
	m.clearedlegal_holds = false
	m.removedlegal_holds = nil
}

// AddRetentionPolicyIDs adds the "retention_policies" edge to the RetentionPolicy entity by ids.
func (m *TenantMutation) AddRetentionPolicyIDs(ids ...int) {
	if m.retention_policies == nil {
		m.retention_policies = make(map[int]struct{})
	}
	for i := range ids {
		m.retention_policies[ids[i]] = struct{}{}
	}
}

// ClearRetentionPolicies clears the "retention_policies" edge to the RetentionPolicy entity.
func (m *TenantMutation) ClearRetentionPolicies() {
	m.clearedretention_policies = true
}

// RetentionPoliciesCleared reports if the "retention_policies" edge to the RetentionPolicy entity was cleared.
func (m *TenantMutation) RetentionPoliciesCleared() bool {
	return m.clearedretention_policies
}

// RemoveRetentionPolicyIDs removes the "retention_policies" edge to the RetentionPolicy entity by IDs.
func (m *TenantMutation) RemoveRetentionPolicyIDs(ids ...int) {
	if m.removedretention_policies == nil {
		m.removedretention_policies = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.retention_policies, ids[i])
		m.removedretention_policies[ids[i]] = struct{}{}
	}
}

// RemovedRetentionPolicies returns the removed IDs of the "retention_policies" edge to the RetentionPolicy entity.
func (m *TenantMutation) RemovedRetentionPoliciesIDs() (ids []int) {
	for id := range m.removedretention_policies {
		ids = append(ids, id)
	}
	return
}

// RetentionPoliciesIDs returns the "retention_policies" edge IDs in the mutation.
func (m *TenantMutation) RetentionPoliciesIDs() (ids []int) {
	for id := range m.retention_policies {
		ids = append(ids, id)
	}
	return
}

// ResetRetentionPolicies resets all changes to the "retention_policies" edge.
func (m *TenantMutation) ResetRetentionPolicies() {
	m.retention_policies = nil
	m.clearedretention_policies = false
	m.removedretention_policies = nil
}

// AddVaultTemplateIDs adds the "vault_templates" edge to the VaultTemplate entity by ids.
func (m *TenantMutation) AddVaultTemplateIDs(ids ...int) {
	if m.vault_templates == nil {
		m.vault_templates = make(map[int]struct{})
	}
	for i := range ids {
		m.vault_templates[ids[i]] = struct{}{}
	}
}

// ClearVaultTemplates clears the "vault_templates" edge to the VaultTemplate entity.
func (m *TenantMutation) ClearVaultTemplates() {
	m.clearedvault_templates = true
}

// VaultTemplatesCleared reports if the "vault_templates" edge to the VaultTemplate entity was cleared.
func (m *TenantMutation) VaultTemplatesCleared() bool {
	return m.clearedvault_templates
}

// RemoveVaultTemplateIDs removes the "vault_templates" edge to the VaultTemplate entity by IDs.
func (m *TenantMutation) RemoveVaultTemplateIDs(ids ...int) {
	if m.removedvault_templates == nil {
		m.removedvault_templates = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.vault_templates, ids[i])
		m.removedvault_templates[ids[i]] = struct{}{}
	}
}

// RemovedVaultTemplates returns the removed IDs of the "vault_templates" edge to the VaultTemplate entity.
func (m *TenantMutation) RemovedVaultTemplatesIDs() (ids []int) {
	for id := range m.removedvault_templates {
		ids = append(ids, id)
	}
	return
}

// VaultTemplatesIDs returns the "vault_templates" edge IDs in the mutation.
func (m *TenantMutation) VaultTemplatesIDs() (ids []int) {
	for id := range m.vault_templates {
		ids = append(ids, id)
	}
	return
}

// ResetVaultTemplates resets all changes to the "vault_templates" edge.
func (m *TenantMutation) ResetVaultTemplates() {
	m.vault_templates = nil
	m.clearedvault_templates = false
	m.removedvault_templates = nil
}

// AddStockAuditLogIDs adds the "stock_audit_logs" edge to the StockAuditLog entity by ids.
func (m *TenantMutation) AddStockAuditLogIDs(ids ...int) {
	if m.stock_audit_logs == nil {
		m.stock_audit_logs = make(map[int]struct{})
	}
	for i := range ids {
		m.stock_audit_logs[ids[i]] = struct{}{}
	}
}

// ClearStockAuditLogs clears the "stock_audit_logs" edge to the StockAuditLog entity.
func (m *TenantMutation) ClearStockAuditLogs() {
	m.clearedstock_audit_logs = true
}

// StockAuditLogsCleared reports if the "stock_audit_logs" edge to the StockAuditLog entity was cleared.
func (m *TenantMutation) StockAuditLogsCleared() bool {
	return m.clearedstock_audit_logs
}

// RemoveStockAuditLogIDs removes the "stock_audit_logs" edge to the StockAuditLog entity by IDs.
func (m *TenantMutation) RemoveStockAuditLogIDs(ids ...int) {
	if m.removedstock_audit_logs == nil {
		m.removedstock_audit_logs = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.stock_audit_logs, ids[i])
		m.removedstock_audit_logs[ids[i]] = struct{}{}
	}
}

// RemovedStockAuditLogs returns the removed IDs of the "stock_audit_logs" edge to the StockAuditLog entity.
func (m *TenantMutation) RemovedStockAuditLogsIDs() (ids []int) {
	for id := range m.removedstock_audit_logs {
		ids = append(ids, id)
	}
	return
}

// StockAuditLogsIDs returns the "stock_audit_logs" edge IDs in the mutation.
func (m *TenantMutation) StockAuditLogsIDs() (ids []int) {
	for id := range m.stock_audit_logs {
		ids = append(ids, id)
	}
	return
}

// ResetStockAuditLogs resets all changes to the "stock_audit_logs" edge.
func (m *TenantMutation) ResetStockAuditLogs() {
	m.stock_audit_logs = nil
	m.clearedstock_audit_logs = false
	m.removedstock_audit_logs = nil
}

// AddMaintenanceScheduleIDs adds the "maintenance_schedules" edge to the MaintenanceSchedule entity by ids.
func (m *TenantMutation) AddMaintenanceScheduleIDs(ids ...int) {
	if m.maintenance_schedules == nil {
		m.maintenance_schedules = make(map[int]struct{})
	}
	for i := range ids {
		m.maintenance_schedules[ids[i]] = struct{}{}
	}
}

// ClearMaintenanceSchedules clears the "maintenance_schedules" edge to the MaintenanceSchedule entity.
func (m *TenantMutation) ClearMaintenanceSchedules() {
	m.clearedmaintenance_schedules = true
}

// MaintenanceSchedulesCleared reports if the "maintenance_schedules" edge to the MaintenanceSchedule entity was cleared.
func (m *TenantMutation) MaintenanceSchedulesCleared() bool {
	return m.clearedmaintenance_schedules
}

// RemoveMaintenanceScheduleIDs removes the "maintenance_schedules" edge to the MaintenanceSchedule entity by IDs.
func (m *TenantMutation) RemoveMaintenanceScheduleIDs(ids ...int) {
	if m.removedmaintenance_schedules == nil {
		m.removedmaintenance_schedules = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.maintenance_schedules, ids[i])
		m.removedmaintenance_schedules[ids[i]] = struct{}{}
	}
}

// RemovedMaintenanceSchedules returns the removed IDs of the "maintenance_schedules" edge to the MaintenanceSchedule entity.
func (m *TenantMutation) RemovedMaintenanceSchedulesIDs() (ids []int) {
	for id := range m.removedmaintenance_schedules {
		ids = append(ids, id)
	}
	return
}

// MaintenanceSchedulesIDs returns the "maintenance_schedules" edge IDs in the mutation.
func (m *TenantMutation) MaintenanceSchedulesIDs() (ids []int) {
	for id := range m.maintenance_schedules {
		ids = append(ids, id)
	}
	return
}

// ResetMaintenanceSchedules resets all changes to the "maintenance_schedules" edge.
func (m *TenantMutation) ResetMaintenanceSchedules() {
	m.maintenance_schedules = nil
	m.clearedmaintenance_schedules = false
	m.removedmaintenance_schedules = nil
}

// AddStockAlertIDs adds the "stock_alerts" edge to the StockAlert entity by ids.
func (m *TenantMutation) AddStockAlertIDs(ids ...int) {
	if m.stock_alerts == nil {
		m.stock_alerts = make(map[int]struct{})
	}
	for i := range ids {
		m.stock_alerts[ids[i]] = struct{}{}
	}
}

// ClearStockAlerts clears the "stock_alerts" edge to the StockAlert entity.
func (m *TenantMutation) ClearStockAlerts() {
	m.clearedstock_alerts = true
}

// StockAlertsCleared reports if the "stock_alerts" edge to the StockAlert entity was cleared.
func (m *TenantMutation) StockAlertsCleared() bool {
	return m.clearedstock_alerts
}

// RemoveStockAlertIDs removes the "stock_alerts" edge to the StockAlert entity by IDs.
func (m *TenantMutation) RemoveStockAlertIDs(ids ...int) {
	if m.removedstock_alerts == nil {
		m.removedstock_alerts = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.stock_alerts, ids[i])
		m.removedstock_alerts[ids[i]] = struct{}{}
	}
}

// RemovedStockAlerts returns the removed IDs of the "stock_alerts" edge to the StockAlert entity.
func (m *TenantMutation) RemovedStockAlertsIDs() (ids []int) {
	for id := range m.removedstock_alerts {
		ids = append(ids, id)
	}
	return
}

// StockAlertsIDs returns the "stock_alerts" edge IDs in the mutation.
func (m *TenantMutation) StockAlertsIDs() (ids []int) {
	for id := range m.stock_alerts {
		ids = append(ids, id)
	}
	return
}

// ResetStockAlerts resets all changes to the "stock_alerts" edge.
func (m *TenantMutation) ResetStockAlerts() {
	m.stock_alerts = nil
	m.clearedstock_alerts = false
	m.removedstock_alerts = nil
}

// AddPurchaseOrderIDs adds the "purchase_orders" edge to the PurchaseOrder entity by ids.
func (m *TenantMutation) AddPurchaseOrderIDs(ids ...int) {
	if m.purchase_orders == nil {
		m.purchase_orders = make(map[int]struct{})
	}
	for i := range ids {
		m.purchase_orders[ids[i]] = struct{}{}
	}
}

// ClearPurchaseOrders clears the "purchase_orders" edge to the PurchaseOrder entity.
func (m *TenantMutation) ClearPurchaseOrders() {
	m.clearedpurchase_orders = true
}

// PurchaseOrdersCleared reports if the "purchase_orders" edge to the PurchaseOrder entity was cleared.
func (m *TenantMutation) PurchaseOrdersCleared() bool {
	return m.clearedpurchase_orders
}

// RemovePurchaseOrderIDs removes the "purchase_orders" edge to the PurchaseOrder entity by IDs.
func (m *TenantMutation) RemovePurchaseOrderIDs(ids ...int) {
	if m.removedpurchase_orders == nil {
		m.removedpurchase_orders = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.purchase_orders, ids[i])
		m.removedpurchase_orders[ids[i]] = struct{}{}
	}
}

// RemovedPurchaseOrders returns the removed IDs of the "purchase_orders" edge to the PurchaseOrder entity.
func (m *TenantMutation) RemovedPurchaseOrdersIDs() (ids []int) {
	for id := range m.removedpurchase_orders {
		ids = append(ids, id)
	}
	return
}

// PurchaseOrdersIDs returns the "purchase_orders" edge IDs in the mutation.
func (m *TenantMutation) PurchaseOrdersIDs() (ids []int) {
	for id := range m.purchase_orders {
		ids = append(ids, id)
	}
	return
}

// ResetPurchaseOrders resets all changes to the "purchase_orders" edge.
func (m *TenantMutation) ResetPurchaseOrders() {
	m.purchase_orders = nil
	m.clearedpurchase_orders = false
	m.removedpurchase_orders = nil
}

// AddInventoryCountIDs adds the "inventory_counts" edge to the InventoryCount entity by ids.
func (m *TenantMutation) AddInventoryCountIDs(ids ...int) {
	if m.inventory_counts == nil {
		m.inventory_counts = make(map[int]struct{})
	}
	for i := range ids {
		m.inventory_counts[ids[i]] = struct{}{}
	}
}

// ClearInventoryCounts clears the "inventory_counts" edge to the InventoryCount entity.
func (m *TenantMutation) ClearInventoryCounts() {
	m.clearedinventory_counts = true
}

// InventoryCountsCleared reports if the "inventory_counts" edge to the InventoryCount entity was cleared.
func (m *TenantMutation) InventoryCountsCleared() bool {
	return m.clearedinventory_counts
}

// RemoveInventoryCountIDs removes the "inventory_counts" edge to the InventoryCount entity by IDs.
func (m *TenantMutation) RemoveInventoryCountIDs(ids ...int) {
	if m.removedinventory_counts == nil {
		m.removedinventory_counts = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.inventory_counts, ids[i])
		m.removedinventory_counts[ids[i]] = struct{}{}
	}
}

// RemovedInventoryCounts returns the removed IDs of the "inventory_counts" edge to the InventoryCount entity.
func (m *TenantMutation) RemovedInventoryCountsIDs() (ids []int) {
	for id := range m.removedinventory_counts {
		ids = append(ids, id)
	}
	return
}

// InventoryCountsIDs returns the "inventory_counts" edge IDs in the mutation.
func (m *TenantMutation) InventoryCountsIDs() (ids []int) {
	for id := range m.inventory_counts {
		ids = append(ids, id)
	}
	return
}

// ResetInventoryCounts resets all changes to the "inventory_counts" edge.
func (m *TenantMutation) ResetInventoryCounts() {
	m.inventory_counts = nil
	m.clearedinventory_counts = false
	m.removedinventory_counts = nil
}

// AddJobPostingIDs adds the "job_postings" edge to the JobPosting entity by ids.
func (m *TenantMutation) AddJobPostingIDs(ids ...int) {
	if m.job_postings == nil {
		m.job_postings = make(map[int]struct{})
	}
	for i := range ids {
		m.job_postings[ids[i]] = struct{}{}
	}
}

// ClearJobPostings clears the "job_postings" edge to the JobPosting entity.
func (m *TenantMutation) ClearJobPostings() {
	m.clearedjob_postings = true
}

// JobPostingsCleared reports if the "job_postings" edge to the JobPosting entity was cleared.
func (m *TenantMutation) JobPostingsCleared() bool {
	return m.clearedjob_postings
}

// RemoveJobPostingIDs removes the "job_postings" edge to the JobPosting entity by IDs.
func (m *TenantMutation) RemoveJobPostingIDs(ids ...int) {
	if m.removedjob_postings == nil {
		m.removedjob_postings = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.job_postings, ids[i])
		m.removedjob_postings[ids[i]] = struct{}{}
	}
}

// RemovedJobPostings returns the removed IDs of the "job_postings" edge to the JobPosting entity.
func (m *TenantMutation) RemovedJobPostingsIDs() (ids []int) {
	for id := range m.removedjob_postings {
		ids = append(ids, id)
	}
	return
}

// JobPostingsIDs returns the "job_postings" edge IDs in the mutation.
func (m *TenantMutation) JobPostingsIDs() (ids []int) {
	for id := range m.job_postings {
		ids = append(ids, id)
	}
	return
}

// ResetJobPostings resets all changes to the "job_postings" edge.
func (m *TenantMutation) ResetJobPostings() {
	m.job_postings = nil
	m.clearedjob_postings = false
	m.removedjob_postings = nil
}

// AddCandidateIDs adds the "candidates" edge to the Candidate entity by ids.
func (m *TenantMutation) AddCandidateIDs(ids ...int) {
	if m.candidates == nil {
		m.candidates = make(map[int]struct{})
	}
	for i := range ids {
		m.candidates[ids[i]] = struct{}{}
	}
}

// ClearCandidates clears the "candidates" edge to the Candidate entity.
func (m *TenantMutation) ClearCandidates() {
	m.clearedcandidates = true
}

// CandidatesCleared reports if the "candidates" edge to the Candidate entity was cleared.
func (m *TenantMutation) CandidatesCleared() bool {
	return m.clearedcandidates
}

// RemoveCandidateIDs removes the "candidates" edge to the Candidate entity by IDs.
func (m *TenantMutation) RemoveCandidateIDs(ids ...int) {
	if m.removedcandidates == nil {
		m.removedcandidates = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.candidates, ids[i])
		m.removedcandidates[ids[i]] = struct{}{}
	}
}

// RemovedCandidates returns the removed IDs of the "candidates" edge to the Candidate entity.
func (m *TenantMutation) RemovedCandidatesIDs() (ids []int) {
	for id := range m.removedcandidates {
		ids = append(ids, id)
	}
	return
}

// CandidatesIDs returns the "candidates" edge IDs in the mutation.
func (m *TenantMutation) CandidatesIDs() (ids []int) {
	for id := range m.candidates {
		ids = append(ids, id)
	}
	return
}

// ResetCandidates resets all changes to the "candidates" edge.
func (m *TenantMutation) ResetCandidates() {
	m.candidates = nil
	m.clearedcandidates = false
	m.removedcandidates = nil
}

// AddApplicationIDs adds the "applications" edge to the Application entity by ids.
func (m *TenantMutation) AddApplicationIDs(ids ...int) {
	if m.applications == nil {
		m.applications = make(map[int]struct{})
	}
	for i := range ids {
		m.applications[ids[i]] = struct{}{}
	}
}

// ClearApplications clears the "applications" edge to the Application entity.
func (m *TenantMutation) ClearApplications() {
	m.clearedapplications = true
}

// ApplicationsCleared reports if the "applications" edge to the Application entity was cleared.
func (m *TenantMutation) ApplicationsCleared() bool {
	return m.clearedapplications
}

// RemoveApplicationIDs removes the "applications" edge to the Application entity by IDs.
func (m *TenantMutation) RemoveApplicationIDs(ids ...int) {
	if m.removedapplications == nil {
		m.removedapplications = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.applications, ids[i])
		m.removedapplications[ids[i]] = struct{}{}
	}
}

// RemovedApplications returns the removed IDs of the "applications" edge to the Application entity.
func (m *TenantMutation) RemovedApplicationsIDs() (ids []int) {
	for id := range m.removedapplications {
		ids = append(ids, id)
	}
	return
}

// ApplicationsIDs returns the "applications" edge IDs in the mutation.
func (m *TenantMutation) ApplicationsIDs() (ids []int) {
	for id := range m.applications {
		ids = append(ids, id)
	}
	return
}

// ResetApplications resets all changes to the "applications" edge.
func (m *TenantMutation) ResetApplications() {
	m.applications = nil
	m.clearedapplications = false
	m.removedapplications = nil
}

// AddInterviewIDs adds the "interviews" edge to the Interview entity by ids.
func (m *TenantMutation) AddInterviewIDs(ids ...int) {
	if m.interviews == nil {
		m.interviews = make(map[int]struct{})
	}
	for i := range ids {
		m.interviews[ids[i]] = struct{}{}
	}
}

// ClearInterviews clears the "interviews" edge to the Interview entity.
func (m *TenantMutation) ClearInterviews() {
	m.clearedinterviews = true
}

// InterviewsCleared reports if the "interviews" edge to the Interview entity was cleared.
func (m *TenantMutation) InterviewsCleared() bool {
	return m.clearedinterviews
}

// RemoveInterviewIDs removes the "interviews" edge to the Interview entity by IDs.
func (m *TenantMutation) RemoveInterviewIDs(ids ...int) {
	if m.removedinterviews == nil {
		m.removedinterviews = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.interviews, ids[i])
		m.removedinterviews[ids[i]] = struct{}{}
	}
}

// RemovedInterviews returns the removed IDs of the "interviews" edge to the Interview entity.
func (m *TenantMutation) RemovedInterviewsIDs() (ids []int) {
	for id := range m.removedinterviews {
		ids = append(ids, id)
	}
	return
}

// InterviewsIDs returns the "interviews" edge IDs in the mutation.
func (m *TenantMutation) InterviewsIDs() (ids []int) {
	for id := range m.interviews {
		ids = append(ids, id)
	}
	return
}

// ResetInterviews resets all changes to the "interviews" edge.
func (m *TenantMutation) ResetInterviews() {
	m.interviews = nil
	m.clearedinterviews = false
	m.removedinterviews = nil
}

// AddBenefitPlanIDs adds the "benefit_plans" edge to the BenefitPlan entity by ids.
func (m *TenantMutation) AddBenefitPlanIDs(ids ...int) {
	if m.benefit_plans == nil {
		m.benefit_plans = make(map[int]struct{})
	}
	for i := range ids {
		m.benefit_plans[ids[i]] = struct{}{}
	}
}

// ClearBenefitPlans clears the "benefit_plans" edge to the BenefitPlan entity.
func (m *TenantMutation) ClearBenefitPlans() {
	m.clearedbenefit_plans = true
}

// BenefitPlansCleared reports if the "benefit_plans" edge to the BenefitPlan entity was cleared.
func (m *TenantMutation) BenefitPlansCleared() bool {
	return m.clearedbenefit_plans
}

// RemoveBenefitPlanIDs removes the "benefit_plans" edge to the BenefitPlan entity by IDs.
func (m *TenantMutation) RemoveBenefitPlanIDs(ids ...int) {
	if m.removedbenefit_plans == nil {
		m.removedbenefit_plans = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.benefit_plans, ids[i])
		m.removedbenefit_plans[ids[i]] = struct{}{}
	}
}

// RemovedBenefitPlans returns the removed IDs of the "benefit_plans" edge to the BenefitPlan entity.
func (m *TenantMutation) RemovedBenefitPlansIDs() (ids []int) {
	for id := range m.removedbenefit_plans {
		ids = append(ids, id)
	}
	return
}

// BenefitPlansIDs returns the "benefit_plans" edge IDs in the mutation.
func (m *TenantMutation) BenefitPlansIDs() (ids []int) {
	for id := range m.benefit_plans {
		ids = append(ids, id)
	}
	return
}

// ResetBenefitPlans resets all changes to the "benefit_plans" edge.
func (m *TenantMutation) ResetBenefitPlans() {
	m.benefit_plans = nil
	m.clearedbenefit_plans = false
	m.removedbenefit_plans = nil
}

// AddBenefitEnrollmentIDs adds the "benefit_enrollments" edge to the BenefitEnrollment entity by ids.
func (m *TenantMutation) AddBenefitEnrollmentIDs(ids ...int) {
	if m.benefit_enrollments == nil {
		m.benefit_enrollments = make(map[int]struct{})
	}
	for i := range ids {
		m.benefit_enrollments[ids[i]] = struct{}{}
	}
}

// ClearBenefitEnrollments clears the "benefit_enrollments" edge to the BenefitEnrollment entity.
func (m *TenantMutation) ClearBenefitEnrollments() {
	m.clearedbenefit_enrollments = true
}

// BenefitEnrollmentsCleared reports if the "benefit_enrollments" edge to the BenefitEnrollment entity was cleared.
func (m *TenantMutation) BenefitEnrollmentsCleared() bool {
	return m.clearedbenefit_enrollments
}

// RemoveBenefitEnrollmentIDs removes the "benefit_enrollments" edge to the BenefitEnrollment entity by IDs.
func (m *TenantMutation) RemoveBenefitEnrollmentIDs(ids ...int) {
	if m.removedbenefit_enrollments == nil {
		m.removedbenefit_enrollments = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.benefit_enrollments, ids[i])
		m.removedbenefit_enrollments[ids[i]] = struct{}{}
	}
}

// RemovedBenefitEnrollments returns the removed IDs of the "benefit_enrollments" edge to the BenefitEnrollment entity.
func (m *TenantMutation) RemovedBenefitEnrollmentsIDs() (ids []int) {
	for id := range m.removedbenefit_enrollments {
		ids = append(ids, id)
	}
	return
}

// BenefitEnrollmentsIDs returns the "benefit_enrollments" edge IDs in the mutation.
func (m *TenantMutation) BenefitEnrollmentsIDs() (ids []int) {
	for id := range m.benefit_enrollments {
		ids = append(ids, id)
	}
	return
}

// ResetBenefitEnrollments resets all changes to the "benefit_enrollments" edge.
func (m *TenantMutation) ResetBenefitEnrollments() {
	m.benefit_enrollments = nil
	m.clearedbenefit_enrollments = false
	m.removedbenefit_enrollments = nil
}

// Where appends a list predicates to the TenantMutation builder.
func (m *TenantMutation) Where(ps ...predicate.Tenant) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TenantMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TenantMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Tenant, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TenantMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TenantMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Tenant).
func (m *TenantMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TenantMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.name != nil {
		fields = append(fields, tenant.FieldName)
	}
	if m.domain != nil {
		fields = append(fields, tenant.FieldDomain)
	}
	if m.created_at != nil {
		fields = append(fields, tenant.FieldCreatedAt)
	}
	if m.active != nil {
		fields = append(fields, tenant.FieldActive)
	}
	if m.transaction_limit != nil {
		fields = append(fields, tenant.FieldTransactionLimit)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TenantMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case tenant.FieldName:
		return m.Name()
	case tenant.FieldDomain:
		return m.Domain()
	case tenant.FieldCreatedAt:
		return m.CreatedAt()
	case tenant.FieldActive:
		return m.Active()
	case tenant.FieldTransactionLimit:
		return m.TransactionLimit()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TenantMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case tenant.FieldName:
		return m.OldName(ctx)
	case tenant.FieldDomain:
		return m.OldDomain(ctx)
	case tenant.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case tenant.FieldActive:
		return m.OldActive(ctx)
	case tenant.FieldTransactionLimit:
		return m.OldTransactionLimit(ctx)
	}
	return nil, fmt.Errorf("unknown Tenant field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TenantMutation) SetField(name string, value ent.Value) error {
	switch name {
	case tenant.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case tenant.FieldDomain:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDomain(v)
		return nil
	case tenant.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case tenant.FieldActive:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetActive(v)
		return nil
	case tenant.FieldTransactionLimit:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTransactionLimit(v)
		return nil
	}
	return fmt.Errorf("unknown Tenant field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TenantMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TenantMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TenantMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Tenant numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TenantMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TenantMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TenantMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Tenant nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TenantMutation) ResetField(name string) error {
	switch name {
	case tenant.FieldName:
		m.ResetName()
		return nil
	case tenant.FieldDomain:
		m.ResetDomain()
		return nil
	case tenant.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case tenant.FieldActive:
		m.ResetActive()
		return nil
	case tenant.FieldTransactionLimit:
		m.ResetTransactionLimit()
		return nil
	}
	return fmt.Errorf("unknown Tenant field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TenantMutation) AddedEdges() []string {
	edges := make([]string, 0, 75)
	if m.parent != nil {
		edges = append(edges, tenant.EdgeParent)
	}
	if m.children != nil {
		edges = append(edges, tenant.EdgeChildren)
	}
	if m.users != nil {
		edges = append(edges, tenant.EdgeUsers)
	}
	if m.accounts != nil {
		edges = append(edges, tenant.EdgeAccounts)
	}
	if m.transactions != nil {
		edges = append(edges, tenant.EdgeTransactions)
	}
	if m.ledger_entries != nil {
		edges = append(edges, tenant.EdgeLedgerEntries)
	}
	if m.products != nil {
		edges = append(edges, tenant.EdgeProducts)
	}
	if m.stock_movements != nil {
		edges = append(edges, tenant.EdgeStockMovements)
	}
	if m.audit_logs != nil {
		edges = append(edges, tenant.EdgeAuditLogs)
	}
	if m.agents != nil {
		edges = append(edges, tenant.EdgeAgents)
	}
	if m.discovery_entries != nil {
		edges = append(edges, tenant.EdgeDiscoveryEntries)
	}
	if m.assets != nil {
		edges = append(edges, tenant.EdgeAssets)
	}
	if m.credentials != nil {
		edges = append(edges, tenant.EdgeCredentials)
	}
	if m.one_time_links != nil {
		edges = append(edges, tenant.EdgeOneTimeLinks)
	}
	if m.sops != nil {
		edges = append(edges, tenant.EdgeSops)
	}
	if m.cameras != nil {
		edges = append(edges, tenant.EdgeCameras)
	}
	if m.tickets != nil {
		edges = append(edges, tenant.EdgeTickets)
	}
	if m.contracts != nil {
		edges = append(edges, tenant.EdgeContracts)
	}
	if m.saas_apps != nil {
		edges = append(edges, tenant.EdgeSaasApps)
	}
	if m.saas_filters != nil {
		edges = append(edges, tenant.EdgeSaasFilters)
	}
	if m.call_logs != nil {
		edges = append(edges, tenant.EdgeCallLogs)
	}
	if m.ivr_flows != nil {
		edges = append(edges, tenant.EdgeIvrFlows)
	}
	if m.voicemails != nil {
		edges = append(edges, tenant.EdgeVoicemails)
	}
	if m.health_snapshots != nil {
		edges = append(edges, tenant.EdgeHealthSnapshots)
	}
	if m.roadmaps != nil {
		edges = append(edges, tenant.EdgeRoadmaps)
	}
	if m.service_rates != nil {
		edges = append(edges, tenant.EdgeServiceRates)
	}
	if m.network_devices != nil {
		edges = append(edges, tenant.EdgeNetworkDevices)
	}
	if m.network_backups != nil {
		edges = append(edges, tenant.EdgeNetworkBackups)
	}
	if m.budget_forecasts != nil {
		edges = append(edges, tenant.EdgeBudgetForecasts)
	}
	if m.employees != nil {
		edges = append(edges, tenant.EdgeEmployees)
	}
	if m.compensation_agreements != nil {
		edges = append(edges, tenant.EdgeCompensationAgreements)
	}
	if m.vault_items != nil {
		edges = append(edges, tenant.EdgeVaultItems)
	}
	if m.vault_share_links != nil {
		edges = append(edges, tenant.EdgeVaultShareLinks)
	}
	if m.journal_entries != nil {
		edges = append(edges, tenant.EdgeJournalEntries)
	}
	if m.recurring_invoices != nil {
		edges = append(edges, tenant.EdgeRecurringInvoices)
	}
	if m.inventory_reservations != nil {
		edges = append(edges, tenant.EdgeInventoryReservations)
	}
	if m.departments != nil {
		edges = append(edges, tenant.EdgeDepartments)
	}
	if m.permissions != nil {
		edges = append(edges, tenant.EdgePermissions)
	}
	if m.asset_types != nil {
		edges = append(edges, tenant.EdgeAssetTypes)
	}
	if m.detection_events != nil {
		edges = append(edges, tenant.EdgeDetectionEvents)
	}
	if m.saas_identities != nil {
		edges = append(edges, tenant.EdgeSaasIdentities)
	}
	if m.saas_usages != nil {
		edges = append(edges, tenant.EdgeSaasUsages)
	}
	if m.recordings != nil {
		edges = append(edges, tenant.EdgeRecordings)
	}
	if m.network_links != nil {
		edges = append(edges, tenant.EdgeNetworkLinks)
	}
	if m.network_ports != nil {
		edges = append(edges, tenant.EdgeNetworkPorts)
	}
	if m.nexus_audits != nil {
		edges = append(edges, tenant.EdgeNexusAudits)
	}
	if m.succession_maps != nil {
		edges = append(edges, tenant.EdgeSuccessionMaps)
	}
	if m.customer_account != nil {
		edges = append(edges, tenant.EdgeCustomerAccount)
	}
	if m.scripts != nil {
		edges = append(edges, tenant.EdgeScripts)
	}
	if m.jobs != nil {
		edges = append(edges, tenant.EdgeJobs)
	}
	if m.time_off_requests != nil {
		edges = append(edges, tenant.EdgeTimeOffRequests)
	}
	if m.time_off_policies != nil {
		edges = append(edges, tenant.EdgeTimeOffPolicies)
	}
	if m.time_off_balances != nil {
		edges = append(edges, tenant.EdgeTimeOffBalances)
	}
	if m.review_cycles != nil {
		edges = append(edges, tenant.EdgeReviewCycles)
	}
	if m.performance_reviews != nil {
		edges = append(edges, tenant.EdgePerformanceReviews)
	}
	if m.goals != nil {
		edges = append(edges, tenant.EdgeGoals)
	}
	if m.suppliers != nil {
		edges = append(edges, tenant.EdgeSuppliers)
	}
	if m.categories != nil {
		edges = append(edges, tenant.EdgeCategories)
	}
	if m.warehouses != nil {
		edges = append(edges, tenant.EdgeWarehouses)
	}
	if m.asset_assignments != nil {
		edges = append(edges, tenant.EdgeAssetAssignments)
	}
	if m.contacts != nil {
		edges = append(edges, tenant.EdgeContacts)
	}
	if m.legal_holds != nil {
		edges = append(edges, tenant.EdgeLegalHolds)
	}
	if m.retention_policies != nil {
		edges = append(edges, tenant.EdgeRetentionPolicies)
	}
	if m.vault_templates != nil {
		edges = append(edges, tenant.EdgeVaultTemplates)
	}
	if m.stock_audit_logs != nil {
		edges = append(edges, tenant.EdgeStockAuditLogs)
	}
	if m.maintenance_schedules != nil {
		edges = append(edges, tenant.EdgeMaintenanceSchedules)
	}
	if m.stock_alerts != nil {
		edges = append(edges, tenant.EdgeStockAlerts)
	}
	if m.purchase_orders != nil {
		edges = append(edges, tenant.EdgePurchaseOrders)
	}
	if m.inventory_counts != nil {
		edges = append(edges, tenant.EdgeInventoryCounts)
	}
	if m.job_postings != nil {
		edges = append(edges, tenant.EdgeJobPostings)
	}
	if m.candidates != nil {
		edges = append(edges, tenant.EdgeCandidates)
	}
	if m.applications != nil {
		edges = append(edges, tenant.EdgeApplications)
	}
	if m.interviews != nil {
		edges = append(edges, tenant.EdgeInterviews)
	}
	if m.benefit_plans != nil {
		edges = append(edges, tenant.EdgeBenefitPlans)
	}
	if m.benefit_enrollments != nil {
		edges = append(edges, tenant.EdgeBenefitEnrollments)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TenantMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case tenant.EdgeParent:
		if id := m.parent; id != nil {
			return []ent.Value{*id}
		}
	case tenant.EdgeChildren:
		ids := make([]ent.Value, 0, len(m.children))
		for id := range m.children {
			ids = append(ids, id)
		}
		return ids
	case tenant.EdgeUsers:
		ids := make([]ent.Value, 0, len(m.users))
		for id := range m.users {
			ids = append(ids, id)
		}
		return ids
	case tenant.EdgeAccounts:
		ids := make([]ent.Value, 0, len(m.accounts))
		for id := range m.accounts {
			ids = append(ids, id)
		}
		return ids
	case tenant.EdgeTransactions:
		ids := make([]ent.Value, 0, len(m.transactions))
		for id := range m.transactions {
			ids = append(ids, id)
		}
		return ids
	case tenant.EdgeLedgerEntries:
		ids := make([]ent.Value, 0, len(m.ledger_entries))
		for id := range m.ledger_entries {
			ids = append(ids, id)
		}
		return ids
	case tenant.EdgeProducts:
		ids := make([]ent.Value, 0, len(m.products))
		for id := range m.products {
			ids = append(ids, id)
		}
		return ids
	case tenant.EdgeStockMovements:
		ids := make([]ent.Value, 0, len(m.stock_movements))
		for id := range m.stock_movements {
			ids = append(ids, id)
		}
		return ids
	case tenant.EdgeAuditLogs:
		ids := make([]ent.Value, 0, len(m.audit_logs))
		for id := range m.audit_logs {
			ids = append(ids, id)
		}
		return ids
	case tenant.EdgeAgents:
		ids := make([]ent.Value, 0, len(m.agents))
		for id := range m.agents {
			ids = append(ids, id)
		}
		return ids
	case tenant.EdgeDiscoveryEntries:
		ids := make([]ent.Value, 0, len(m.discovery_entries))
		for id := range m.discovery_entries {
			ids = append(ids, id)
		}
		return ids
	case tenant.EdgeAssets:
		ids := make([]ent.Value, 0, len(m.assets))
		for id := range m.assets {
			ids = append(ids, id)
		}
		return ids
	case tenant.EdgeCredentials:
		ids := make([]ent.Value, 0, len(m.credentials))
		for id := range m.credentials {
			ids = append(ids, id)
		}
		return ids
	case tenant.EdgeOneTimeLinks:
		ids := make([]ent.Value, 0, len(m.one_time_links))
		for id := range m.one_time_links {
			ids = append(ids, id)
		}
		return ids
	case tenant.EdgeSops:
		ids := make([]ent.Value, 0, len(m.sops))
		for id := range m.sops {
			ids = append(ids, id)
		}
		return ids
	case tenant.EdgeCameras:
		ids := make([]ent.Value, 0, len(m.cameras))
		for id := range m.cameras {
			ids = append(ids, id)
		}
		return ids
	case tenant.EdgeTickets:
		ids := make([]ent.Value, 0, len(m.tickets))
		for id := range m.tickets {
			ids = append(ids, id)
		}
		return ids
	case tenant.EdgeContracts:
		ids := make([]ent.Value, 0, len(m.contracts))
		for id := range m.contracts {
			ids = append(ids, id)
		}
		return ids
	case tenant.EdgeSaasApps:
		ids := make([]ent.Value, 0, len(m.saas_apps))
		for id := range m.saas_apps {
			ids = append(ids, id)
		}
		return ids
	case tenant.EdgeSaasFilters:
		ids := make([]ent.Value, 0, len(m.saas_filters))
		for id := range m.saas_filters {
			ids = append(ids, id)
		}
		return ids
	case tenant.EdgeCallLogs:
		ids := make([]ent.Value, 0, len(m.call_logs))
		for id := range m.call_logs {
			ids = append(ids, id)
		}
		return ids
	case tenant.EdgeIvrFlows:
		ids := make([]ent.Value, 0, len(m.ivr_flows))
		for id := range m.ivr_flows {
			ids = append(ids, id)
		}
		return ids
	case tenant.EdgeVoicemails:
		ids := make([]ent.Value, 0, len(m.voicemails))
		for id := range m.voicemails {
			ids = append(ids, id)
		}
		return ids
	case tenant.EdgeHealthSnapshots:
		ids := make([]ent.Value, 0, len(m.health_snapshots))
		for id := range m.health_snapshots {
			ids = append(ids, id)
		}
		return ids
	case tenant.EdgeRoadmaps:
		ids := make([]ent.Value, 0, len(m.roadmaps))
		for id := range m.roadmaps {
			ids = append(ids, id)
		}
		return ids
	case tenant.EdgeServiceRates:
		ids := make([]ent.Value, 0, len(m.service_rates))
		for id := range m.service_rates {
			ids = append(ids, id)
		}
		return ids
	case tenant.EdgeNetworkDevices:
		ids := make([]ent.Value, 0, len(m.network_devices))
		for id := range m.network_devices {
			ids = append(ids, id)
		}
		return ids
	case tenant.EdgeNetworkBackups:
		ids := make([]ent.Value, 0, len(m.network_backups))
		for id := range m.network_backups {
			ids = append(ids, id)
		}
		return ids
	case tenant.EdgeBudgetForecasts:
		ids := make([]ent.Value, 0, len(m.budget_forecasts))
		for id := range m.budget_forecasts {
			ids = append(ids, id)
		}
		return ids
	case tenant.EdgeEmployees:
		ids := make([]ent.Value, 0, len(m.employees))
		for id := range m.employees {
			ids = append(ids, id)
		}
		return ids
	case tenant.EdgeCompensationAgreements:
		ids := make([]ent.Value, 0, len(m.compensation_agreements))
		for id := range m.compensation_agreements {
			ids = append(ids, id)
		}
		return ids
	case tenant.EdgeVaultItems:
		ids := make([]ent.Value, 0, len(m.vault_items))
		for id := range m.vault_items {
			ids = append(ids, id)
		}
		return ids
	case tenant.EdgeVaultShareLinks:
		ids := make([]ent.Value, 0, len(m.vault_share_links))
		for id := range m.vault_share_links {
			ids = append(ids, id)
		}
		return ids
	case tenant.EdgeJournalEntries:
		ids := make([]ent.Value, 0, len(m.journal_entries))
		for id := range m.journal_entries {
			ids = append(ids, id)
		}
		return ids
	case tenant.EdgeRecurringInvoices:
		ids := make([]ent.Value, 0, len(m.recurring_invoices))
		for id := range m.recurring_invoices {
			ids = append(ids, id)
		}
		return ids
	case tenant.EdgeInventoryReservations:
		ids := make([]ent.Value, 0, len(m.inventory_reservations))
		for id := range m.inventory_reservations {
			ids = append(ids, id)
		}
		return ids
	case tenant.EdgeDepartments:
		ids := make([]ent.Value, 0, len(m.departments))
		for id := range m.departments {
			ids = append(ids, id)
		}
		return ids
	case tenant.EdgePermissions:
		ids := make([]ent.Value, 0, len(m.permissions))
		for id := range m.permissions {
			ids = append(ids, id)
		}
		return ids
	case tenant.EdgeAssetTypes:
		ids := make([]ent.Value, 0, len(m.asset_types))
		for id := range m.asset_types {
			ids = append(ids, id)
		}
		return ids
	case tenant.EdgeDetectionEvents:
		ids := make([]ent.Value, 0, len(m.detection_events))
		for id := range m.detection_events {
			ids = append(ids, id)
		}
		return ids
	case tenant.EdgeSaasIdentities:
		ids := make([]ent.Value, 0, len(m.saas_identities))
		for id := range m.saas_identities {
			ids = append(ids, id)
		}
		return ids
	case tenant.EdgeSaasUsages:
		ids := make([]ent.Value, 0, len(m.saas_usages))
		for id := range m.saas_usages {
			ids = append(ids, id)
		}
		return ids
	case tenant.EdgeRecordings:
		ids := make([]ent.Value, 0, len(m.recordings))
		for id := range m.recordings {
			ids = append(ids, id)
		}
		return ids
	case tenant.EdgeNetworkLinks:
		ids := make([]ent.Value, 0, len(m.network_links))
		for id := range m.network_links {
			ids = append(ids, id)
		}
		return ids
	case tenant.EdgeNetworkPorts:
		ids := make([]ent.Value, 0, len(m.network_ports))
		for id := range m.network_ports {
			ids = append(ids, id)
		}
		return ids
	case tenant.EdgeNexusAudits:
		ids := make([]ent.Value, 0, len(m.nexus_audits))
		for id := range m.nexus_audits {
			ids = append(ids, id)
		}
		return ids
	case tenant.EdgeSuccessionMaps:
		ids := make([]ent.Value, 0, len(m.succession_maps))
		for id := range m.succession_maps {
			ids = append(ids, id)
		}
		return ids
	case tenant.EdgeCustomerAccount:
		if id := m.customer_account; id != nil {
			return []ent.Value{*id}
		}
	case tenant.EdgeScripts:
		ids := make([]ent.Value, 0, len(m.scripts))
		for id := range m.scripts {
			ids = append(ids, id)
		}
		return ids
	case tenant.EdgeJobs:
		ids := make([]ent.Value, 0, len(m.jobs))
		for id := range m.jobs {
			ids = append(ids, id)
		}
		return ids
	case tenant.EdgeTimeOffRequests:
		ids := make([]ent.Value, 0, len(m.time_off_requests))
		for id := range m.time_off_requests {
			ids = append(ids, id)
		}
		return ids
	case tenant.EdgeTimeOffPolicies:
		ids := make([]ent.Value, 0, len(m.time_off_policies))
		for id := range m.time_off_policies {
			ids = append(ids, id)
		}
		return ids
	case tenant.EdgeTimeOffBalances:
		ids := make([]ent.Value, 0, len(m.time_off_balances))
		for id := range m.time_off_balances {
			ids = append(ids, id)
		}
		return ids
	case tenant.EdgeReviewCycles:
		ids := make([]ent.Value, 0, len(m.review_cycles))
		for id := range m.review_cycles {
			ids = append(ids, id)
		}
		return ids
	case tenant.EdgePerformanceReviews:
		ids := make([]ent.Value, 0, len(m.performance_reviews))
		for id := range m.performance_reviews {
			ids = append(ids, id)
		}
		return ids
	case tenant.EdgeGoals:
		ids := make([]ent.Value, 0, len(m.goals))
		for id := range m.goals {
			ids = append(ids, id)
		}
		return ids
	case tenant.EdgeSuppliers:
		ids := make([]ent.Value, 0, len(m.suppliers))
		for id := range m.suppliers {
			ids = append(ids, id)
		}
		return ids
	case tenant.EdgeCategories:
		ids := make([]ent.Value, 0, len(m.categories))
		for id := range m.categories {
			ids = append(ids, id)
		}
		return ids
	case tenant.EdgeWarehouses:
		ids := make([]ent.Value, 0, len(m.warehouses))
		for id := range m.warehouses {
			ids = append(ids, id)
		}
		return ids
	case tenant.EdgeAssetAssignments:
		ids := make([]ent.Value, 0, len(m.asset_assignments))
		for id := range m.asset_assignments {
			ids = append(ids, id)
		}
		return ids
	case tenant.EdgeContacts:
		ids := make([]ent.Value, 0, len(m.contacts))
		for id := range m.contacts {
			ids = append(ids, id)
		}
		return ids
	case tenant.EdgeLegalHolds:
		ids := make([]ent.Value, 0, len(m.legal_holds))
		for id := range m.legal_holds {
			ids = append(ids, id)
		}
		return ids
	case tenant.EdgeRetentionPolicies:
		ids := make([]ent.Value, 0, len(m.retention_policies))
		for id := range m.retention_policies {
			ids = append(ids, id)
		}
		return ids
	case tenant.EdgeVaultTemplates:
		ids := make([]ent.Value, 0, len(m.vault_templates))
		for id := range m.vault_templates {
			ids = append(ids, id)
		}
		return ids
	case tenant.EdgeStockAuditLogs:
		ids := make([]ent.Value, 0, len(m.stock_audit_logs))
		for id := range m.stock_audit_logs {
			ids = append(ids, id)
		}
		return ids
	case tenant.EdgeMaintenanceSchedules:
		ids := make([]ent.Value, 0, len(m.maintenance_schedules))
		for id := range m.maintenance_schedules {
			ids = append(ids, id)
		}
		return ids
	case tenant.EdgeStockAlerts:
		ids := make([]ent.Value, 0, len(m.stock_alerts))
		for id := range m.stock_alerts {
			ids = append(ids, id)
		}
		return ids
	case tenant.EdgePurchaseOrders:
		ids := make([]ent.Value, 0, len(m.purchase_orders))
		for id := range m.purchase_orders {
			ids = append(ids, id)
		}
		return ids
	case tenant.EdgeInventoryCounts:
		ids := make([]ent.Value, 0, len(m.inventory_counts))
		for id := range m.inventory_counts {
			ids = append(ids, id)
		}
		return ids
	case tenant.EdgeJobPostings:
		ids := make([]ent.Value, 0, len(m.job_postings))
		for id := range m.job_postings {
			ids = append(ids, id)
		}
		return ids
	case tenant.EdgeCandidates:
		ids := make([]ent.Value, 0, len(m.candidates))
		for id := range m.candidates {
			ids = append(ids, id)
		}
		return ids
	case tenant.EdgeApplications:
		ids := make([]ent.Value, 0, len(m.applications))
		for id := range m.applications {
			ids = append(ids, id)
		}
		return ids
	case tenant.EdgeInterviews:
		ids := make([]ent.Value, 0, len(m.interviews))
		for id := range m.interviews {
			ids = append(ids, id)
		}
		return ids
	case tenant.EdgeBenefitPlans:
		ids := make([]ent.Value, 0, len(m.benefit_plans))
		for id := range m.benefit_plans {
			ids = append(ids, id)
		}
		return ids
	case tenant.EdgeBenefitEnrollments:
		ids := make([]ent.Value, 0, len(m.benefit_enrollments))
		for id := range m.benefit_enrollments {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TenantMutation) RemovedEdges() []string {
	edges := make([]string, 0, 75)
	if m.removedchildren != nil {
		edges = append(edges, tenant.EdgeChildren)
	}
	if m.removedusers != nil {
		edges = append(edges, tenant.EdgeUsers)
	}
	if m.removedaccounts != nil {
		edges = append(edges, tenant.EdgeAccounts)
	}
	if m.removedtransactions != nil {
		edges = append(edges, tenant.EdgeTransactions)
	}
	if m.removedledger_entries != nil {
		edges = append(edges, tenant.EdgeLedgerEntries)
	}
	if m.removedproducts != nil {
		edges = append(edges, tenant.EdgeProducts)
	}
	if m.removedstock_movements != nil {
		edges = append(edges, tenant.EdgeStockMovements)
	}
	if m.removedaudit_logs != nil {
		edges = append(edges, tenant.EdgeAuditLogs)
	}
	if m.removedagents != nil {
		edges = append(edges, tenant.EdgeAgents)
	}
	if m.removeddiscovery_entries != nil {
		edges = append(edges, tenant.EdgeDiscoveryEntries)
	}
	if m.removedassets != nil {
		edges = append(edges, tenant.EdgeAssets)
	}
	if m.removedcredentials != nil {
		edges = append(edges, tenant.EdgeCredentials)
	}
	if m.removedone_time_links != nil {
		edges = append(edges, tenant.EdgeOneTimeLinks)
	}
	if m.removedsops != nil {
		edges = append(edges, tenant.EdgeSops)
	}
	if m.removedcameras != nil {
		edges = append(edges, tenant.EdgeCameras)
	}
	if m.removedtickets != nil {
		edges = append(edges, tenant.EdgeTickets)
	}
	if m.removedcontracts != nil {
		edges = append(edges, tenant.EdgeContracts)
	}
	if m.removedsaas_apps != nil {
		edges = append(edges, tenant.EdgeSaasApps)
	}
	if m.removedsaas_filters != nil {
		edges = append(edges, tenant.EdgeSaasFilters)
	}
	if m.removedcall_logs != nil {
		edges = append(edges, tenant.EdgeCallLogs)
	}
	if m.removedivr_flows != nil {
		edges = append(edges, tenant.EdgeIvrFlows)
	}
	if m.removedvoicemails != nil {
		edges = append(edges, tenant.EdgeVoicemails)
	}
	if m.removedhealth_snapshots != nil {
		edges = append(edges, tenant.EdgeHealthSnapshots)
	}
	if m.removedroadmaps != nil {
		edges = append(edges, tenant.EdgeRoadmaps)
	}
	if m.removedservice_rates != nil {
		edges = append(edges, tenant.EdgeServiceRates)
	}
	if m.removednetwork_devices != nil {
		edges = append(edges, tenant.EdgeNetworkDevices)
	}
	if m.removednetwork_backups != nil {
		edges = append(edges, tenant.EdgeNetworkBackups)
	}
	if m.removedbudget_forecasts != nil {
		edges = append(edges, tenant.EdgeBudgetForecasts)
	}
	if m.removedemployees != nil {
		edges = append(edges, tenant.EdgeEmployees)
	}
	if m.removedcompensation_agreements != nil {
		edges = append(edges, tenant.EdgeCompensationAgreements)
	}
	if m.removedvault_items != nil {
		edges = append(edges, tenant.EdgeVaultItems)
	}
	if m.removedvault_share_links != nil {
		edges = append(edges, tenant.EdgeVaultShareLinks)
	}
	if m.removedjournal_entries != nil {
		edges = append(edges, tenant.EdgeJournalEntries)
	}
	if m.removedrecurring_invoices != nil {
		edges = append(edges, tenant.EdgeRecurringInvoices)
	}
	if m.removedinventory_reservations != nil {
		edges = append(edges, tenant.EdgeInventoryReservations)
	}
	if m.removeddepartments != nil {
		edges = append(edges, tenant.EdgeDepartments)
	}
	if m.removedpermissions != nil {
		edges = append(edges, tenant.EdgePermissions)
	}
	if m.removedasset_types != nil {
		edges = append(edges, tenant.EdgeAssetTypes)
	}
	if m.removeddetection_events != nil {
		edges = append(edges, tenant.EdgeDetectionEvents)
	}
	if m.removedsaas_identities != nil {
		edges = append(edges, tenant.EdgeSaasIdentities)
	}
	if m.removedsaas_usages != nil {
		edges = append(edges, tenant.EdgeSaasUsages)
	}
	if m.removedrecordings != nil {
		edges = append(edges, tenant.EdgeRecordings)
	}
	if m.removednetwork_links != nil {
		edges = append(edges, tenant.EdgeNetworkLinks)
	}
	if m.removednetwork_ports != nil {
		edges = append(edges, tenant.EdgeNetworkPorts)
	}
	if m.removednexus_audits != nil {
		edges = append(edges, tenant.EdgeNexusAudits)
	}
	if m.removedsuccession_maps != nil {
		edges = append(edges, tenant.EdgeSuccessionMaps)
	}
	if m.removedscripts != nil {
		edges = append(edges, tenant.EdgeScripts)
	}
	if m.removedjobs != nil {
		edges = append(edges, tenant.EdgeJobs)
	}
	if m.removedtime_off_requests != nil {
		edges = append(edges, tenant.EdgeTimeOffRequests)
	}
	if m.removedtime_off_policies != nil {
		edges = append(edges, tenant.EdgeTimeOffPolicies)
	}
	if m.removedtime_off_balances != nil {
		edges = append(edges, tenant.EdgeTimeOffBalances)
	}
	if m.removedreview_cycles != nil {
		edges = append(edges, tenant.EdgeReviewCycles)
	}
	if m.removedperformance_reviews != nil {
		edges = append(edges, tenant.EdgePerformanceReviews)
	}
	if m.removedgoals != nil {
		edges = append(edges, tenant.EdgeGoals)
	}
	if m.removedsuppliers != nil {
		edges = append(edges, tenant.EdgeSuppliers)
	}
	if m.removedcategories != nil {
		edges = append(edges, tenant.EdgeCategories)
	}
	if m.removedwarehouses != nil {
		edges = append(edges, tenant.EdgeWarehouses)
	}
	if m.removedasset_assignments != nil {
		edges = append(edges, tenant.EdgeAssetAssignments)
	}
	if m.removedcontacts != nil {
		edges = append(edges, tenant.EdgeContacts)
	}
	if m.removedlegal_holds != nil {
		edges = append(edges, tenant.EdgeLegalHolds)
	}
	if m.removedretention_policies != nil {
		edges = append(edges, tenant.EdgeRetentionPolicies)
	}
	if m.removedvault_templates != nil {
		edges = append(edges, tenant.EdgeVaultTemplates)
	}
	if m.removedstock_audit_logs != nil {
		edges = append(edges, tenant.EdgeStockAuditLogs)
	}
	if m.removedmaintenance_schedules != nil {
		edges = append(edges, tenant.EdgeMaintenanceSchedules)
	}
	if m.removedstock_alerts != nil {
		edges = append(edges, tenant.EdgeStockAlerts)
	}
	if m.removedpurchase_orders != nil {
		edges = append(edges, tenant.EdgePurchaseOrders)
	}
	if m.removedinventory_counts != nil {
		edges = append(edges, tenant.EdgeInventoryCounts)
	}
	if m.removedjob_postings != nil {
		edges = append(edges, tenant.EdgeJobPostings)
	}
	if m.removedcandidates != nil {
		edges = append(edges, tenant.EdgeCandidates)
	}
	if m.removedapplications != nil {
		edges = append(edges, tenant.EdgeApplications)
	}
	if m.removedinterviews != nil {
		edges = append(edges, tenant.EdgeInterviews)
	}
	if m.removedbenefit_plans != nil {
		edges = append(edges, tenant.EdgeBenefitPlans)
	}
	if m.removedbenefit_enrollments != nil {
		edges = append(edges, tenant.EdgeBenefitEnrollments)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TenantMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case tenant.EdgeChildren:
		ids := make([]ent.Value, 0, len(m.removedchildren))
		for id := range m.removedchildren {
			ids = append(ids, id)
		}
		return ids
	case tenant.EdgeUsers:
		ids := make([]ent.Value, 0, len(m.removedusers))
		for id := range m.removedusers {
			ids = append(ids, id)
		}
		return ids
	case tenant.EdgeAccounts:
		ids := make([]ent.Value, 0, len(m.removedaccounts))
		for id := range m.removedaccounts {
			ids = append(ids, id)
		}
		return ids
	case tenant.EdgeTransactions:
		ids := make([]ent.Value, 0, len(m.removedtransactions))
		for id := range m.removedtransactions {
			ids = append(ids, id)
		}
		return ids
	case tenant.EdgeLedgerEntries:
		ids := make([]ent.Value, 0, len(m.removedledger_entries))
		for id := range m.removedledger_entries {
			ids = append(ids, id)
		}
		return ids
	case tenant.EdgeProducts:
		ids := make([]ent.Value, 0, len(m.removedproducts))
		for id := range m.removedproducts {
			ids = append(ids, id)
		}
		return ids
	case tenant.EdgeStockMovements:
		ids := make([]ent.Value, 0, len(m.removedstock_movements))
		for id := range m.removedstock_movements {
			ids = append(ids, id)
		}
		return ids
	case tenant.EdgeAuditLogs:
		ids := make([]ent.Value, 0, len(m.removedaudit_logs))
		for id := range m.removedaudit_logs {
			ids = append(ids, id)
		}
		return ids
	case tenant.EdgeAgents:
		ids := make([]ent.Value, 0, len(m.removedagents))
		for id := range m.removedagents {
			ids = append(ids, id)
		}
		return ids
	case tenant.EdgeDiscoveryEntries:
		ids := make([]ent.Value, 0, len(m.removeddiscovery_entries))
		for id := range m.removeddiscovery_entries {
			ids = append(ids, id)
		}
		return ids
	case tenant.EdgeAssets:
		ids := make([]ent.Value, 0, len(m.removedassets))
		for id := range m.removedassets {
			ids = append(ids, id)
		}
		return ids
	case tenant.EdgeCredentials:
		ids := make([]ent.Value, 0, len(m.removedcredentials))
		for id := range m.removedcredentials {
			ids = append(ids, id)
		}
		return ids
	case tenant.EdgeOneTimeLinks:
		ids := make([]ent.Value, 0, len(m.removedone_time_links))
		for id := range m.removedone_time_links {
			ids = append(ids, id)
		}
		return ids
	case tenant.EdgeSops:
		ids := make([]ent.Value, 0, len(m.removedsops))
		for id := range m.removedsops {
			ids = append(ids, id)
		}
		return ids
	case tenant.EdgeCameras:
		ids := make([]ent.Value, 0, len(m.removedcameras))
		for id := range m.removedcameras {
			ids = append(ids, id)
		}
		return ids
	case tenant.EdgeTickets:
		ids := make([]ent.Value, 0, len(m.removedtickets))
		for id := range m.removedtickets {
			ids = append(ids, id)
		}
		return ids
	case tenant.EdgeContracts:
		ids := make([]ent.Value, 0, len(m.removedcontracts))
		for id := range m.removedcontracts {
			ids = append(ids, id)
		}
		return ids
	case tenant.EdgeSaasApps:
		ids := make([]ent.Value, 0, len(m.removedsaas_apps))
		for id := range m.removedsaas_apps {
			ids = append(ids, id)
		}
		return ids
	case tenant.EdgeSaasFilters:
		ids := make([]ent.Value, 0, len(m.removedsaas_filters))
		for id := range m.removedsaas_filters {
			ids = append(ids, id)
		}
		return ids
	case tenant.EdgeCallLogs:
		ids := make([]ent.Value, 0, len(m.removedcall_logs))
		for id := range m.removedcall_logs {
			ids = append(ids, id)
		}
		return ids
	case tenant.EdgeIvrFlows:
		ids := make([]ent.Value, 0, len(m.removedivr_flows))
		for id := range m.removedivr_flows {
			ids = append(ids, id)
		}
		return ids
	case tenant.EdgeVoicemails:
		ids := make([]ent.Value, 0, len(m.removedvoicemails))
		for id := range m.removedvoicemails {
			ids = append(ids, id)
		}
		return ids
	case tenant.EdgeHealthSnapshots:
		ids := make([]ent.Value, 0, len(m.removedhealth_snapshots))
		for id := range m.removedhealth_snapshots {
			ids = append(ids, id)
		}
		return ids
	case tenant.EdgeRoadmaps:
		ids := make([]ent.Value, 0, len(m.removedroadmaps))
		for id := range m.removedroadmaps {
			ids = append(ids, id)
		}
		return ids
	case tenant.EdgeServiceRates:
		ids := make([]ent.Value, 0, len(m.removedservice_rates))
		for id := range m.removedservice_rates {
			ids = append(ids, id)
		}
		return ids
	case tenant.EdgeNetworkDevices:
		ids := make([]ent.Value, 0, len(m.removednetwork_devices))
		for id := range m.removednetwork_devices {
			ids = append(ids, id)
		}
		return ids
	case tenant.EdgeNetworkBackups:
		ids := make([]ent.Value, 0, len(m.removednetwork_backups))
		for id := range m.removednetwork_backups {
			ids = append(ids, id)
		}
		return ids
	case tenant.EdgeBudgetForecasts:
		ids := make([]ent.Value, 0, len(m.removedbudget_forecasts))
		for id := range m.removedbudget_forecasts {
			ids = append(ids, id)
		}
		return ids
	case tenant.EdgeEmployees:
		ids := make([]ent.Value, 0, len(m.removedemployees))
		for id := range m.removedemployees {
			ids = append(ids, id)
		}
		return ids
	case tenant.EdgeCompensationAgreements:
		ids := make([]ent.Value, 0, len(m.removedcompensation_agreements))
		for id := range m.removedcompensation_agreements {
			ids = append(ids, id)
		}
		return ids
	case tenant.EdgeVaultItems:
		ids := make([]ent.Value, 0, len(m.removedvault_items))
		for id := range m.removedvault_items {
			ids = append(ids, id)
		}
		return ids
	case tenant.EdgeVaultShareLinks:
		ids := make([]ent.Value, 0, len(m.removedvault_share_links))
		for id := range m.removedvault_share_links {
			ids = append(ids, id)
		}
		return ids
	case tenant.EdgeJournalEntries:
		ids := make([]ent.Value, 0, len(m.removedjournal_entries))
		for id := range m.removedjournal_entries {
			ids = append(ids, id)
		}
		return ids
	case tenant.EdgeRecurringInvoices:
		ids := make([]ent.Value, 0, len(m.removedrecurring_invoices))
		for id := range m.removedrecurring_invoices {
			ids = append(ids, id)
		}
		return ids
	case tenant.EdgeInventoryReservations:
		ids := make([]ent.Value, 0, len(m.removedinventory_reservations))
		for id := range m.removedinventory_reservations {
			ids = append(ids, id)
		}
		return ids
	case tenant.EdgeDepartments:
		ids := make([]ent.Value, 0, len(m.removeddepartments))
		for id := range m.removeddepartments {
			ids = append(ids, id)
		}
		return ids
	case tenant.EdgePermissions:
		ids := make([]ent.Value, 0, len(m.removedpermissions))
		for id := range m.removedpermissions {
			ids = append(ids, id)
		}
		return ids
	case tenant.EdgeAssetTypes:
		ids := make([]ent.Value, 0, len(m.removedasset_types))
		for id := range m.removedasset_types {
			ids = append(ids, id)
		}
		return ids
	case tenant.EdgeDetectionEvents:
		ids := make([]ent.Value, 0, len(m.removeddetection_events))
		for id := range m.removeddetection_events {
			ids = append(ids, id)
		}
		return ids
	case tenant.EdgeSaasIdentities:
		ids := make([]ent.Value, 0, len(m.removedsaas_identities))
		for id := range m.removedsaas_identities {
			ids = append(ids, id)
		}
		return ids
	case tenant.EdgeSaasUsages:
		ids := make([]ent.Value, 0, len(m.removedsaas_usages))
		for id := range m.removedsaas_usages {
			ids = append(ids, id)
		}
		return ids
	case tenant.EdgeRecordings:
		ids := make([]ent.Value, 0, len(m.removedrecordings))
		for id := range m.removedrecordings {
			ids = append(ids, id)
		}
		return ids
	case tenant.EdgeNetworkLinks:
		ids := make([]ent.Value, 0, len(m.removednetwork_links))
		for id := range m.removednetwork_links {
			ids = append(ids, id)
		}
		return ids
	case tenant.EdgeNetworkPorts:
		ids := make([]ent.Value, 0, len(m.removednetwork_ports))
		for id := range m.removednetwork_ports {
			ids = append(ids, id)
		}
		return ids
	case tenant.EdgeNexusAudits:
		ids := make([]ent.Value, 0, len(m.removednexus_audits))
		for id := range m.removednexus_audits {
			ids = append(ids, id)
		}
		return ids
	case tenant.EdgeSuccessionMaps:
		ids := make([]ent.Value, 0, len(m.removedsuccession_maps))
		for id := range m.removedsuccession_maps {
			ids = append(ids, id)
		}
		return ids
	case tenant.EdgeScripts:
		ids := make([]ent.Value, 0, len(m.removedscripts))
		for id := range m.removedscripts {
			ids = append(ids, id)
		}
		return ids
	case tenant.EdgeJobs:
		ids := make([]ent.Value, 0, len(m.removedjobs))
		for id := range m.removedjobs {
			ids = append(ids, id)
		}
		return ids
	case tenant.EdgeTimeOffRequests:
		ids := make([]ent.Value, 0, len(m.removedtime_off_requests))
		for id := range m.removedtime_off_requests {
			ids = append(ids, id)
		}
		return ids
	case tenant.EdgeTimeOffPolicies:
		ids := make([]ent.Value, 0, len(m.removedtime_off_policies))
		for id := range m.removedtime_off_policies {
			ids = append(ids, id)
		}
		return ids
	case tenant.EdgeTimeOffBalances:
		ids := make([]ent.Value, 0, len(m.removedtime_off_balances))
		for id := range m.removedtime_off_balances {
			ids = append(ids, id)
		}
		return ids
	case tenant.EdgeReviewCycles:
		ids := make([]ent.Value, 0, len(m.removedreview_cycles))
		for id := range m.removedreview_cycles {
			ids = append(ids, id)
		}
		return ids
	case tenant.EdgePerformanceReviews:
		ids := make([]ent.Value, 0, len(m.removedperformance_reviews))
		for id := range m.removedperformance_reviews {
			ids = append(ids, id)
		}
		return ids
	case tenant.EdgeGoals:
		ids := make([]ent.Value, 0, len(m.removedgoals))
		for id := range m.removedgoals {
			ids = append(ids, id)
		}
		return ids
	case tenant.EdgeSuppliers:
		ids := make([]ent.Value, 0, len(m.removedsuppliers))
		for id := range m.removedsuppliers {
			ids = append(ids, id)
		}
		return ids
	case tenant.EdgeCategories:
		ids := make([]ent.Value, 0, len(m.removedcategories))
		for id := range m.removedcategories {
			ids = append(ids, id)
		}
		return ids
	case tenant.EdgeWarehouses:
		ids := make([]ent.Value, 0, len(m.removedwarehouses))
		for id := range m.removedwarehouses {
			ids = append(ids, id)
		}
		return ids
	case tenant.EdgeAssetAssignments:
		ids := make([]ent.Value, 0, len(m.removedasset_assignments))
		for id := range m.removedasset_assignments {
			ids = append(ids, id)
		}
		return ids
	case tenant.EdgeContacts:
		ids := make([]ent.Value, 0, len(m.removedcontacts))
		for id := range m.removedcontacts {
			ids = append(ids, id)
		}
		return ids
	case tenant.EdgeLegalHolds:
		ids := make([]ent.Value, 0, len(m.removedlegal_holds))
		for id := range m.removedlegal_holds {
			ids = append(ids, id)
		}
		return ids
	case tenant.EdgeRetentionPolicies:
		ids := make([]ent.Value, 0, len(m.removedretention_policies))
		for id := range m.removedretention_policies {
			ids = append(ids, id)
		}
		return ids
	case tenant.EdgeVaultTemplates:
		ids := make([]ent.Value, 0, len(m.removedvault_templates))
		for id := range m.removedvault_templates {
			ids = append(ids, id)
		}
		return ids
	case tenant.EdgeStockAuditLogs:
		ids := make([]ent.Value, 0, len(m.removedstock_audit_logs))
		for id := range m.removedstock_audit_logs {
			ids = append(ids, id)
		}
		return ids
	case tenant.EdgeMaintenanceSchedules:
		ids := make([]ent.Value, 0, len(m.removedmaintenance_schedules))
		for id := range m.removedmaintenance_schedules {
			ids = append(ids, id)
		}
		return ids
	case tenant.EdgeStockAlerts:
		ids := make([]ent.Value, 0, len(m.removedstock_alerts))
		for id := range m.removedstock_alerts {
			ids = append(ids, id)
		}
		return ids
	case tenant.EdgePurchaseOrders:
		ids := make([]ent.Value, 0, len(m.removedpurchase_orders))
		for id := range m.removedpurchase_orders {
			ids = append(ids, id)
		}
		return ids
	case tenant.EdgeInventoryCounts:
		ids := make([]ent.Value, 0, len(m.removedinventory_counts))
		for id := range m.removedinventory_counts {
			ids = append(ids, id)
		}
		return ids
	case tenant.EdgeJobPostings:
		ids := make([]ent.Value, 0, len(m.removedjob_postings))
		for id := range m.removedjob_postings {
			ids = append(ids, id)
		}
		return ids
	case tenant.EdgeCandidates:
		ids := make([]ent.Value, 0, len(m.removedcandidates))
		for id := range m.removedcandidates {
			ids = append(ids, id)
		}
		return ids
	case tenant.EdgeApplications:
		ids := make([]ent.Value, 0, len(m.removedapplications))
		for id := range m.removedapplications {
			ids = append(ids, id)
		}
		return ids
	case tenant.EdgeInterviews:
		ids := make([]ent.Value, 0, len(m.removedinterviews))
		for id := range m.removedinterviews {
			ids = append(ids, id)
		}
		return ids
	case tenant.EdgeBenefitPlans:
		ids := make([]ent.Value, 0, len(m.removedbenefit_plans))
		for id := range m.removedbenefit_plans {
			ids = append(ids, id)
		}
		return ids
	case tenant.EdgeBenefitEnrollments:
		ids := make([]ent.Value, 0, len(m.removedbenefit_enrollments))
		for id := range m.removedbenefit_enrollments {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TenantMutation) ClearedEdges() []string {
	edges := make([]string, 0, 75)
	if m.clearedparent {
		edges = append(edges, tenant.EdgeParent)
	}
	if m.clearedchildren {
		edges = append(edges, tenant.EdgeChildren)
	}
	if m.clearedusers {
		edges = append(edges, tenant.EdgeUsers)
	}
	if m.clearedaccounts {
		edges = append(edges, tenant.EdgeAccounts)
	}
	if m.clearedtransactions {
		edges = append(edges, tenant.EdgeTransactions)
	}
	if m.clearedledger_entries {
		edges = append(edges, tenant.EdgeLedgerEntries)
	}
	if m.clearedproducts {
		edges = append(edges, tenant.EdgeProducts)
	}
	if m.clearedstock_movements {
		edges = append(edges, tenant.EdgeStockMovements)
	}
	if m.clearedaudit_logs {
		edges = append(edges, tenant.EdgeAuditLogs)
	}
	if m.clearedagents {
		edges = append(edges, tenant.EdgeAgents)
	}
	if m.cleareddiscovery_entries {
		edges = append(edges, tenant.EdgeDiscoveryEntries)
	}
	if m.clearedassets {
		edges = append(edges, tenant.EdgeAssets)
	}
	if m.clearedcredentials {
		edges = append(edges, tenant.EdgeCredentials)
	}
	if m.clearedone_time_links {
		edges = append(edges, tenant.EdgeOneTimeLinks)
	}
	if m.clearedsops {
		edges = append(edges, tenant.EdgeSops)
	}
	if m.clearedcameras {
		edges = append(edges, tenant.EdgeCameras)
	}
	if m.clearedtickets {
		edges = append(edges, tenant.EdgeTickets)
	}
	if m.clearedcontracts {
		edges = append(edges, tenant.EdgeContracts)
	}
	if m.clearedsaas_apps {
		edges = append(edges, tenant.EdgeSaasApps)
	}
	if m.clearedsaas_filters {
		edges = append(edges, tenant.EdgeSaasFilters)
	}
	if m.clearedcall_logs {
		edges = append(edges, tenant.EdgeCallLogs)
	}
	if m.clearedivr_flows {
		edges = append(edges, tenant.EdgeIvrFlows)
	}
	if m.clearedvoicemails {
		edges = append(edges, tenant.EdgeVoicemails)
	}
	if m.clearedhealth_snapshots {
		edges = append(edges, tenant.EdgeHealthSnapshots)
	}
	if m.clearedroadmaps {
		edges = append(edges, tenant.EdgeRoadmaps)
	}
	if m.clearedservice_rates {
		edges = append(edges, tenant.EdgeServiceRates)
	}
	if m.clearednetwork_devices {
		edges = append(edges, tenant.EdgeNetworkDevices)
	}
	if m.clearednetwork_backups {
		edges = append(edges, tenant.EdgeNetworkBackups)
	}
	if m.clearedbudget_forecasts {
		edges = append(edges, tenant.EdgeBudgetForecasts)
	}
	if m.clearedemployees {
		edges = append(edges, tenant.EdgeEmployees)
	}
	if m.clearedcompensation_agreements {
		edges = append(edges, tenant.EdgeCompensationAgreements)
	}
	if m.clearedvault_items {
		edges = append(edges, tenant.EdgeVaultItems)
	}
	if m.clearedvault_share_links {
		edges = append(edges, tenant.EdgeVaultShareLinks)
	}
	if m.clearedjournal_entries {
		edges = append(edges, tenant.EdgeJournalEntries)
	}
	if m.clearedrecurring_invoices {
		edges = append(edges, tenant.EdgeRecurringInvoices)
	}
	if m.clearedinventory_reservations {
		edges = append(edges, tenant.EdgeInventoryReservations)
	}
	if m.cleareddepartments {
		edges = append(edges, tenant.EdgeDepartments)
	}
	if m.clearedpermissions {
		edges = append(edges, tenant.EdgePermissions)
	}
	if m.clearedasset_types {
		edges = append(edges, tenant.EdgeAssetTypes)
	}
	if m.cleareddetection_events {
		edges = append(edges, tenant.EdgeDetectionEvents)
	}
	if m.clearedsaas_identities {
		edges = append(edges, tenant.EdgeSaasIdentities)
	}
	if m.clearedsaas_usages {
		edges = append(edges, tenant.EdgeSaasUsages)
	}
	if m.clearedrecordings {
		edges = append(edges, tenant.EdgeRecordings)
	}
	if m.clearednetwork_links {
		edges = append(edges, tenant.EdgeNetworkLinks)
	}
	if m.clearednetwork_ports {
		edges = append(edges, tenant.EdgeNetworkPorts)
	}
	if m.clearednexus_audits {
		edges = append(edges, tenant.EdgeNexusAudits)
	}
	if m.clearedsuccession_maps {
		edges = append(edges, tenant.EdgeSuccessionMaps)
	}
	if m.clearedcustomer_account {
		edges = append(edges, tenant.EdgeCustomerAccount)
	}
	if m.clearedscripts {
		edges = append(edges, tenant.EdgeScripts)
	}
	if m.clearedjobs {
		edges = append(edges, tenant.EdgeJobs)
	}
	if m.clearedtime_off_requests {
		edges = append(edges, tenant.EdgeTimeOffRequests)
	}
	if m.clearedtime_off_policies {
		edges = append(edges, tenant.EdgeTimeOffPolicies)
	}
	if m.clearedtime_off_balances {
		edges = append(edges, tenant.EdgeTimeOffBalances)
	}
	if m.clearedreview_cycles {
		edges = append(edges, tenant.EdgeReviewCycles)
	}
	if m.clearedperformance_reviews {
		edges = append(edges, tenant.EdgePerformanceReviews)
	}
	if m.clearedgoals {
		edges = append(edges, tenant.EdgeGoals)
	}
	if m.clearedsuppliers {
		edges = append(edges, tenant.EdgeSuppliers)
	}
	if m.clearedcategories {
		edges = append(edges, tenant.EdgeCategories)
	}
	if m.clearedwarehouses {
		edges = append(edges, tenant.EdgeWarehouses)
	}
	if m.clearedasset_assignments {
		edges = append(edges, tenant.EdgeAssetAssignments)
	}
	if m.clearedcontacts {
		edges = append(edges, tenant.EdgeContacts)
	}
	if m.clearedlegal_holds {
		edges = append(edges, tenant.EdgeLegalHolds)
	}
	if m.clearedretention_policies {
		edges = append(edges, tenant.EdgeRetentionPolicies)
	}
	if m.clearedvault_templates {
		edges = append(edges, tenant.EdgeVaultTemplates)
	}
	if m.clearedstock_audit_logs {
		edges = append(edges, tenant.EdgeStockAuditLogs)
	}
	if m.clearedmaintenance_schedules {
		edges = append(edges, tenant.EdgeMaintenanceSchedules)
	}
	if m.clearedstock_alerts {
		edges = append(edges, tenant.EdgeStockAlerts)
	}
	if m.clearedpurchase_orders {
		edges = append(edges, tenant.EdgePurchaseOrders)
	}
	if m.clearedinventory_counts {
		edges = append(edges, tenant.EdgeInventoryCounts)
	}
	if m.clearedjob_postings {
		edges = append(edges, tenant.EdgeJobPostings)
	}
	if m.clearedcandidates {
		edges = append(edges, tenant.EdgeCandidates)
	}
	if m.clearedapplications {
		edges = append(edges, tenant.EdgeApplications)
	}
	if m.clearedinterviews {
		edges = append(edges, tenant.EdgeInterviews)
	}
	if m.clearedbenefit_plans {
		edges = append(edges, tenant.EdgeBenefitPlans)
	}
	if m.clearedbenefit_enrollments {
		edges = append(edges, tenant.EdgeBenefitEnrollments)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TenantMutation) EdgeCleared(name string) bool {
	switch name {
	case tenant.EdgeParent:
		return m.clearedparent
	case tenant.EdgeChildren:
		return m.clearedchildren
	case tenant.EdgeUsers:
		return m.clearedusers
	case tenant.EdgeAccounts:
		return m.clearedaccounts
	case tenant.EdgeTransactions:
		return m.clearedtransactions
	case tenant.EdgeLedgerEntries:
		return m.clearedledger_entries
	case tenant.EdgeProducts:
		return m.clearedproducts
	case tenant.EdgeStockMovements:
		return m.clearedstock_movements
	case tenant.EdgeAuditLogs:
		return m.clearedaudit_logs
	case tenant.EdgeAgents:
		return m.clearedagents
	case tenant.EdgeDiscoveryEntries:
		return m.cleareddiscovery_entries
	case tenant.EdgeAssets:
		return m.clearedassets
	case tenant.EdgeCredentials:
		return m.clearedcredentials
	case tenant.EdgeOneTimeLinks:
		return m.clearedone_time_links
	case tenant.EdgeSops:
		return m.clearedsops
	case tenant.EdgeCameras:
		return m.clearedcameras
	case tenant.EdgeTickets:
		return m.clearedtickets
	case tenant.EdgeContracts:
		return m.clearedcontracts
	case tenant.EdgeSaasApps:
		return m.clearedsaas_apps
	case tenant.EdgeSaasFilters:
		return m.clearedsaas_filters
	case tenant.EdgeCallLogs:
		return m.clearedcall_logs
	case tenant.EdgeIvrFlows:
		return m.clearedivr_flows
	case tenant.EdgeVoicemails:
		return m.clearedvoicemails
	case tenant.EdgeHealthSnapshots:
		return m.clearedhealth_snapshots
	case tenant.EdgeRoadmaps:
		return m.clearedroadmaps
	case tenant.EdgeServiceRates:
		return m.clearedservice_rates
	case tenant.EdgeNetworkDevices:
		return m.clearednetwork_devices
	case tenant.EdgeNetworkBackups:
		return m.clearednetwork_backups
	case tenant.EdgeBudgetForecasts:
		return m.clearedbudget_forecasts
	case tenant.EdgeEmployees:
		return m.clearedemployees
	case tenant.EdgeCompensationAgreements:
		return m.clearedcompensation_agreements
	case tenant.EdgeVaultItems:
		return m.clearedvault_items
	case tenant.EdgeVaultShareLinks:
		return m.clearedvault_share_links
	case tenant.EdgeJournalEntries:
		return m.clearedjournal_entries
	case tenant.EdgeRecurringInvoices:
		return m.clearedrecurring_invoices
	case tenant.EdgeInventoryReservations:
		return m.clearedinventory_reservations
	case tenant.EdgeDepartments:
		return m.cleareddepartments
	case tenant.EdgePermissions:
		return m.clearedpermissions
	case tenant.EdgeAssetTypes:
		return m.clearedasset_types
	case tenant.EdgeDetectionEvents:
		return m.cleareddetection_events
	case tenant.EdgeSaasIdentities:
		return m.clearedsaas_identities
	case tenant.EdgeSaasUsages:
		return m.clearedsaas_usages
	case tenant.EdgeRecordings:
		return m.clearedrecordings
	case tenant.EdgeNetworkLinks:
		return m.clearednetwork_links
	case tenant.EdgeNetworkPorts:
		return m.clearednetwork_ports
	case tenant.EdgeNexusAudits:
		return m.clearednexus_audits
	case tenant.EdgeSuccessionMaps:
		return m.clearedsuccession_maps
	case tenant.EdgeCustomerAccount:
		return m.clearedcustomer_account
	case tenant.EdgeScripts:
		return m.clearedscripts
	case tenant.EdgeJobs:
		return m.clearedjobs
	case tenant.EdgeTimeOffRequests:
		return m.clearedtime_off_requests
	case tenant.EdgeTimeOffPolicies:
		return m.clearedtime_off_policies
	case tenant.EdgeTimeOffBalances:
		return m.clearedtime_off_balances
	case tenant.EdgeReviewCycles:
		return m.clearedreview_cycles
	case tenant.EdgePerformanceReviews:
		return m.clearedperformance_reviews
	case tenant.EdgeGoals:
		return m.clearedgoals
	case tenant.EdgeSuppliers:
		return m.clearedsuppliers
	case tenant.EdgeCategories:
		return m.clearedcategories
	case tenant.EdgeWarehouses:
		return m.clearedwarehouses
	case tenant.EdgeAssetAssignments:
		return m.clearedasset_assignments
	case tenant.EdgeContacts:
		return m.clearedcontacts
	case tenant.EdgeLegalHolds:
		return m.clearedlegal_holds
	case tenant.EdgeRetentionPolicies:
		return m.clearedretention_policies
	case tenant.EdgeVaultTemplates:
		return m.clearedvault_templates
	case tenant.EdgeStockAuditLogs:
		return m.clearedstock_audit_logs
	case tenant.EdgeMaintenanceSchedules:
		return m.clearedmaintenance_schedules
	case tenant.EdgeStockAlerts:
		return m.clearedstock_alerts
	case tenant.EdgePurchaseOrders:
		return m.clearedpurchase_orders
	case tenant.EdgeInventoryCounts:
		return m.clearedinventory_counts
	case tenant.EdgeJobPostings:
		return m.clearedjob_postings
	case tenant.EdgeCandidates:
		return m.clearedcandidates
	case tenant.EdgeApplications:
		return m.clearedapplications
	case tenant.EdgeInterviews:
		return m.clearedinterviews
	case tenant.EdgeBenefitPlans:
		return m.clearedbenefit_plans
	case tenant.EdgeBenefitEnrollments:
		return m.clearedbenefit_enrollments
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TenantMutation) ClearEdge(name string) error {
	switch name {
	case tenant.EdgeParent:
		m.ClearParent()
		return nil
	case tenant.EdgeCustomerAccount:
		m.ClearCustomerAccount()
		return nil
	}
	return fmt.Errorf("unknown Tenant unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TenantMutation) ResetEdge(name string) error {
	switch name {
	case tenant.EdgeParent:
		m.ResetParent()
		return nil
	case tenant.EdgeChildren:
		m.ResetChildren()
		return nil
	case tenant.EdgeUsers:
		m.ResetUsers()
		return nil
	case tenant.EdgeAccounts:
		m.ResetAccounts()
		return nil
	case tenant.EdgeTransactions:
		m.ResetTransactions()
		return nil
	case tenant.EdgeLedgerEntries:
		m.ResetLedgerEntries()
		return nil
	case tenant.EdgeProducts:
		m.ResetProducts()
		return nil
	case tenant.EdgeStockMovements:
		m.ResetStockMovements()
		return nil
	case tenant.EdgeAuditLogs:
		m.ResetAuditLogs()
		return nil
	case tenant.EdgeAgents:
		m.ResetAgents()
		return nil
	case tenant.EdgeDiscoveryEntries:
		m.ResetDiscoveryEntries()
		return nil
	case tenant.EdgeAssets:
		m.ResetAssets()
		return nil
	case tenant.EdgeCredentials:
		m.ResetCredentials()
		return nil
	case tenant.EdgeOneTimeLinks:
		m.ResetOneTimeLinks()
		return nil
	case tenant.EdgeSops:
		m.ResetSops()
		return nil
	case tenant.EdgeCameras:
		m.ResetCameras()
		return nil
	case tenant.EdgeTickets:
		m.ResetTickets()
		return nil
	case tenant.EdgeContracts:
		m.ResetContracts()
		return nil
	case tenant.EdgeSaasApps:
		m.ResetSaasApps()
		return nil
	case tenant.EdgeSaasFilters:
		m.ResetSaasFilters()
		return nil
	case tenant.EdgeCallLogs:
		m.ResetCallLogs()
		return nil
	case tenant.EdgeIvrFlows:
		m.ResetIvrFlows()
		return nil
	case tenant.EdgeVoicemails:
		m.ResetVoicemails()
		return nil
	case tenant.EdgeHealthSnapshots:
		m.ResetHealthSnapshots()
		return nil
	case tenant.EdgeRoadmaps:
		m.ResetRoadmaps()
		return nil
	case tenant.EdgeServiceRates:
		m.ResetServiceRates()
		return nil
	case tenant.EdgeNetworkDevices:
		m.ResetNetworkDevices()
		return nil
	case tenant.EdgeNetworkBackups:
		m.ResetNetworkBackups()
		return nil
	case tenant.EdgeBudgetForecasts:
		m.ResetBudgetForecasts()
		return nil
	case tenant.EdgeEmployees:
		m.ResetEmployees()
		return nil
	case tenant.EdgeCompensationAgreements:
		m.ResetCompensationAgreements()
		return nil
	case tenant.EdgeVaultItems:
		m.ResetVaultItems()
		return nil
	case tenant.EdgeVaultShareLinks:
		m.ResetVaultShareLinks()
		return nil
	case tenant.EdgeJournalEntries:
		m.ResetJournalEntries()
		return nil
	case tenant.EdgeRecurringInvoices:
		m.ResetRecurringInvoices()
		return nil
	case tenant.EdgeInventoryReservations:
		m.ResetInventoryReservations()
		return nil
	case tenant.EdgeDepartments:
		m.ResetDepartments()
		return nil
	case tenant.EdgePermissions:
		m.ResetPermissions()
		return nil
	case tenant.EdgeAssetTypes:
		m.ResetAssetTypes()
		return nil
	case tenant.EdgeDetectionEvents:
		m.ResetDetectionEvents()
		return nil
	case tenant.EdgeSaasIdentities:
		m.ResetSaasIdentities()
		return nil
	case tenant.EdgeSaasUsages:
		m.ResetSaasUsages()
		return nil
	case tenant.EdgeRecordings:
		m.ResetRecordings()
		return nil
	case tenant.EdgeNetworkLinks:
		m.ResetNetworkLinks()
		return nil
	case tenant.EdgeNetworkPorts:
		m.ResetNetworkPorts()
		return nil
	case tenant.EdgeNexusAudits:
		m.ResetNexusAudits()
		return nil
	case tenant.EdgeSuccessionMaps:
		m.ResetSuccessionMaps()
		return nil
	case tenant.EdgeCustomerAccount:
		m.ResetCustomerAccount()
		return nil
	case tenant.EdgeScripts:
		m.ResetScripts()
		return nil
	case tenant.EdgeJobs:
		m.ResetJobs()
		return nil
	case tenant.EdgeTimeOffRequests:
		m.ResetTimeOffRequests()
		return nil
	case tenant.EdgeTimeOffPolicies:
		m.ResetTimeOffPolicies()
		return nil
	case tenant.EdgeTimeOffBalances:
		m.ResetTimeOffBalances()
		return nil
	case tenant.EdgeReviewCycles:
		m.ResetReviewCycles()
		return nil
	case tenant.EdgePerformanceReviews:
		m.ResetPerformanceReviews()
		return nil
	case tenant.EdgeGoals:
		m.ResetGoals()
		return nil
	case tenant.EdgeSuppliers:
		m.ResetSuppliers()
		return nil
	case tenant.EdgeCategories:
		m.ResetCategories()
		return nil
	case tenant.EdgeWarehouses:
		m.ResetWarehouses()
		return nil
	case tenant.EdgeAssetAssignments:
		m.ResetAssetAssignments()
		return nil
	case tenant.EdgeContacts:
		m.ResetContacts()
		return nil
	case tenant.EdgeLegalHolds:
		m.ResetLegalHolds()
		return nil
	case tenant.EdgeRetentionPolicies:
		m.ResetRetentionPolicies()
		return nil
	case tenant.EdgeVaultTemplates:
		m.ResetVaultTemplates()
		return nil
	case tenant.EdgeStockAuditLogs:
		m.ResetStockAuditLogs()
		return nil
	case tenant.EdgeMaintenanceSchedules:
		m.ResetMaintenanceSchedules()
		return nil
	case tenant.EdgeStockAlerts:
		m.ResetStockAlerts()
		return nil
	case tenant.EdgePurchaseOrders:
		m.ResetPurchaseOrders()
		return nil
	case tenant.EdgeInventoryCounts:
		m.ResetInventoryCounts()
		return nil
	case tenant.EdgeJobPostings:
		m.ResetJobPostings()
		return nil
	case tenant.EdgeCandidates:
		m.ResetCandidates()
		return nil
	case tenant.EdgeApplications:
		m.ResetApplications()
		return nil
	case tenant.EdgeInterviews:
		m.ResetInterviews()
		return nil
	case tenant.EdgeBenefitPlans:
		m.ResetBenefitPlans()
		return nil
	case tenant.EdgeBenefitEnrollments:
		m.ResetBenefitEnrollments()
		return nil
	}
	return fmt.Errorf("unknown Tenant edge %s", name)
}

// TicketMutation represents an operation that mutates the Ticket nodes in the graph.
type TicketMutation struct {
	config
	op                       Op
	typ                      string
	id                       *int
	subject                  *string
	description              *string
	status                   *ticket.Status
	priority                 *ticket.Priority
	metadata                 *string
	created_at               *time.Time
	updated_at               *time.Time
	resolved_at              *time.Time
	due_date                 *time.Time
	claim_lease_owner        *string
	claim_lease_expires_at   *time.Time
	deep_link                *string
	execution_plan           *map[string]interface{}
	clearedFields            map[string]struct{}
	tenant                   *int
	clearedtenant            bool
	requester                *int
	clearedrequester         bool
	assignee                 *int
	clearedassignee          bool
	asset                    *int
	clearedasset             bool
	work_logs                map[int]struct{}
	removedwork_logs         map[int]struct{}
	clearedwork_logs         bool
	remediation_steps        map[int]struct{}
	removedremediation_steps map[int]struct{}
	clearedremediation_steps bool
	done                     bool
	oldValue                 func(context.Context) (*Ticket, error)
	predicates               []predicate.Ticket
}

var _ ent.Mutation = (*TicketMutation)(nil)

// ticketOption allows management of the mutation configuration using functional options.
type ticketOption func(*TicketMutation)

// newTicketMutation creates new mutation for the Ticket entity.
func newTicketMutation(c config, op Op, opts ...ticketOption) *TicketMutation {
	m := &TicketMutation{
		config:        c,
		op:            op,
		typ:           TypeTicket,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTicketID sets the ID field of the mutation.
func withTicketID(id int) ticketOption {
	return func(m *TicketMutation) {
		var (
			err   error
			once  sync.Once
			value *Ticket
		)
		m.oldValue = func(ctx context.Context) (*Ticket, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Ticket.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTicket sets the old Ticket of the mutation.
func withTicket(node *Ticket) ticketOption {
	return func(m *TicketMutation) {
		m.oldValue = func(context.Context) (*Ticket, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TicketMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TicketMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TicketMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TicketMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Ticket.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetSubject sets the "subject" field.
func (m *TicketMutation) SetSubject(s string) {
	m.subject = &s
}

// Subject returns the value of the "subject" field in the mutation.
func (m *TicketMutation) Subject() (r string, exists bool) {
	v := m.subject
	if v == nil {
		return
	}
	return *v, true
}

// OldSubject returns the old "subject" field's value of the Ticket entity.
// If the Ticket object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TicketMutation) OldSubject(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSubject is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSubject requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSubject: %w", err)
	}
	return oldValue.Subject, nil
}

// ResetSubject resets all changes to the "subject" field.
func (m *TicketMutation) ResetSubject() {
	m.subject = nil
}

// SetDescription sets the "description" field.
func (m *TicketMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *TicketMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Ticket entity.
// If the Ticket object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TicketMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *TicketMutation) ResetDescription() {
	m.description = nil
}

// SetStatus sets the "status" field.
func (m *TicketMutation) SetStatus(t ticket.Status) {
	m.status = &t
}

// Status returns the value of the "status" field in the mutation.
func (m *TicketMutation) Status() (r ticket.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Ticket entity.
// If the Ticket object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TicketMutation) OldStatus(ctx context.Context) (v ticket.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *TicketMutation) ResetStatus() {
	m.status = nil
}

// SetPriority sets the "priority" field.
func (m *TicketMutation) SetPriority(t ticket.Priority) {
	m.priority = &t
}

// Priority returns the value of the "priority" field in the mutation.
func (m *TicketMutation) Priority() (r ticket.Priority, exists bool) {
	v := m.priority
	if v == nil {
		return
	}
	return *v, true
}

// OldPriority returns the old "priority" field's value of the Ticket entity.
// If the Ticket object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TicketMutation) OldPriority(ctx context.Context) (v ticket.Priority, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPriority is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPriority requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPriority: %w", err)
	}
	return oldValue.Priority, nil
}

// ResetPriority resets all changes to the "priority" field.
func (m *TicketMutation) ResetPriority() {
	m.priority = nil
}

// SetMetadata sets the "metadata" field.
func (m *TicketMutation) SetMetadata(s string) {
	m.metadata = &s
}

// Metadata returns the value of the "metadata" field in the mutation.
func (m *TicketMutation) Metadata() (r string, exists bool) {
	v := m.metadata
	if v == nil {
		return
	}
	return *v, true
}

// OldMetadata returns the old "metadata" field's value of the Ticket entity.
// If the Ticket object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TicketMutation) OldMetadata(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMetadata is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMetadata requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetadata: %w", err)
	}
	return oldValue.Metadata, nil
}

// ClearMetadata clears the value of the "metadata" field.
func (m *TicketMutation) ClearMetadata() {
	m.metadata = nil
	m.clearedFields[ticket.FieldMetadata] = struct{}{}
}

// MetadataCleared returns if the "metadata" field was cleared in this mutation.
func (m *TicketMutation) MetadataCleared() bool {
	_, ok := m.clearedFields[ticket.FieldMetadata]
	return ok
}

// ResetMetadata resets all changes to the "metadata" field.
func (m *TicketMutation) ResetMetadata() {
	m.metadata = nil
	delete(m.clearedFields, ticket.FieldMetadata)
}

// SetCreatedAt sets the "created_at" field.
func (m *TicketMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *TicketMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Ticket entity.
// If the Ticket object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TicketMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *TicketMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *TicketMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *TicketMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Ticket entity.
// If the Ticket object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TicketMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *TicketMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetResolvedAt sets the "resolved_at" field.
func (m *TicketMutation) SetResolvedAt(t time.Time) {
	m.resolved_at = &t
}

// ResolvedAt returns the value of the "resolved_at" field in the mutation.
func (m *TicketMutation) ResolvedAt() (r time.Time, exists bool) {
	v := m.resolved_at
	if v == nil {
		return
	}
	return *v, true
}

// OldResolvedAt returns the old "resolved_at" field's value of the Ticket entity.
// If the Ticket object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TicketMutation) OldResolvedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResolvedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResolvedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResolvedAt: %w", err)
	}
	return oldValue.ResolvedAt, nil
}

// ClearResolvedAt clears the value of the "resolved_at" field.
func (m *TicketMutation) ClearResolvedAt() {
	m.resolved_at = nil
	m.clearedFields[ticket.FieldResolvedAt] = struct{}{}
}

// ResolvedAtCleared returns if the "resolved_at" field was cleared in this mutation.
func (m *TicketMutation) ResolvedAtCleared() bool {
	_, ok := m.clearedFields[ticket.FieldResolvedAt]
	return ok
}

// ResetResolvedAt resets all changes to the "resolved_at" field.
func (m *TicketMutation) ResetResolvedAt() {
	m.resolved_at = nil
	delete(m.clearedFields, ticket.FieldResolvedAt)
}

// SetDueDate sets the "due_date" field.
func (m *TicketMutation) SetDueDate(t time.Time) {
	m.due_date = &t
}

// DueDate returns the value of the "due_date" field in the mutation.
func (m *TicketMutation) DueDate() (r time.Time, exists bool) {
	v := m.due_date
	if v == nil {
		return
	}
	return *v, true
}

// OldDueDate returns the old "due_date" field's value of the Ticket entity.
// If the Ticket object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TicketMutation) OldDueDate(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDueDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDueDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDueDate: %w", err)
	}
	return oldValue.DueDate, nil
}

// ClearDueDate clears the value of the "due_date" field.
func (m *TicketMutation) ClearDueDate() {
	m.due_date = nil
	m.clearedFields[ticket.FieldDueDate] = struct{}{}
}

// DueDateCleared returns if the "due_date" field was cleared in this mutation.
func (m *TicketMutation) DueDateCleared() bool {
	_, ok := m.clearedFields[ticket.FieldDueDate]
	return ok
}

// ResetDueDate resets all changes to the "due_date" field.
func (m *TicketMutation) ResetDueDate() {
	m.due_date = nil
	delete(m.clearedFields, ticket.FieldDueDate)
}

// SetClaimLeaseOwner sets the "claim_lease_owner" field.
func (m *TicketMutation) SetClaimLeaseOwner(s string) {
	m.claim_lease_owner = &s
}

// ClaimLeaseOwner returns the value of the "claim_lease_owner" field in the mutation.
func (m *TicketMutation) ClaimLeaseOwner() (r string, exists bool) {
	v := m.claim_lease_owner
	if v == nil {
		return
	}
	return *v, true
}

// OldClaimLeaseOwner returns the old "claim_lease_owner" field's value of the Ticket entity.
// If the Ticket object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TicketMutation) OldClaimLeaseOwner(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClaimLeaseOwner is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClaimLeaseOwner requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClaimLeaseOwner: %w", err)
	}
	return oldValue.ClaimLeaseOwner, nil
}

// ClearClaimLeaseOwner clears the value of the "claim_lease_owner" field.
func (m *TicketMutation) ClearClaimLeaseOwner() {
	m.claim_lease_owner = nil
	m.clearedFields[ticket.FieldClaimLeaseOwner] = struct{}{}
}

// ClaimLeaseOwnerCleared returns if the "claim_lease_owner" field was cleared in this mutation.
func (m *TicketMutation) ClaimLeaseOwnerCleared() bool {
	_, ok := m.clearedFields[ticket.FieldClaimLeaseOwner]
	return ok
}

// ResetClaimLeaseOwner resets all changes to the "claim_lease_owner" field.
func (m *TicketMutation) ResetClaimLeaseOwner() {
	m.claim_lease_owner = nil
	delete(m.clearedFields, ticket.FieldClaimLeaseOwner)
}

// SetClaimLeaseExpiresAt sets the "claim_lease_expires_at" field.
func (m *TicketMutation) SetClaimLeaseExpiresAt(t time.Time) {
	m.claim_lease_expires_at = &t
}

// ClaimLeaseExpiresAt returns the value of the "claim_lease_expires_at" field in the mutation.
func (m *TicketMutation) ClaimLeaseExpiresAt() (r time.Time, exists bool) {
	v := m.claim_lease_expires_at
	if v == nil {
		return
	}
	return *v, true
}

// OldClaimLeaseExpiresAt returns the old "claim_lease_expires_at" field's value of the Ticket entity.
// If the Ticket object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TicketMutation) OldClaimLeaseExpiresAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClaimLeaseExpiresAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClaimLeaseExpiresAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClaimLeaseExpiresAt: %w", err)
	}
	return oldValue.ClaimLeaseExpiresAt, nil
}

// ClearClaimLeaseExpiresAt clears the value of the "claim_lease_expires_at" field.
func (m *TicketMutation) ClearClaimLeaseExpiresAt() {
	m.claim_lease_expires_at = nil
	m.clearedFields[ticket.FieldClaimLeaseExpiresAt] = struct{}{}
}

// ClaimLeaseExpiresAtCleared returns if the "claim_lease_expires_at" field was cleared in this mutation.
func (m *TicketMutation) ClaimLeaseExpiresAtCleared() bool {
	_, ok := m.clearedFields[ticket.FieldClaimLeaseExpiresAt]
	return ok
}

// ResetClaimLeaseExpiresAt resets all changes to the "claim_lease_expires_at" field.
func (m *TicketMutation) ResetClaimLeaseExpiresAt() {
	m.claim_lease_expires_at = nil
	delete(m.clearedFields, ticket.FieldClaimLeaseExpiresAt)
}

// SetDeepLink sets the "deep_link" field.
func (m *TicketMutation) SetDeepLink(s string) {
	m.deep_link = &s
}

// DeepLink returns the value of the "deep_link" field in the mutation.
func (m *TicketMutation) DeepLink() (r string, exists bool) {
	v := m.deep_link
	if v == nil {
		return
	}
	return *v, true
}

// OldDeepLink returns the old "deep_link" field's value of the Ticket entity.
// If the Ticket object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TicketMutation) OldDeepLink(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeepLink is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeepLink requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeepLink: %w", err)
	}
	return oldValue.DeepLink, nil
}

// ClearDeepLink clears the value of the "deep_link" field.
func (m *TicketMutation) ClearDeepLink() {
	m.deep_link = nil
	m.clearedFields[ticket.FieldDeepLink] = struct{}{}
}

// DeepLinkCleared returns if the "deep_link" field was cleared in this mutation.
func (m *TicketMutation) DeepLinkCleared() bool {
	_, ok := m.clearedFields[ticket.FieldDeepLink]
	return ok
}

// ResetDeepLink resets all changes to the "deep_link" field.
func (m *TicketMutation) ResetDeepLink() {
	m.deep_link = nil
	delete(m.clearedFields, ticket.FieldDeepLink)
}

// SetExecutionPlan sets the "execution_plan" field.
func (m *TicketMutation) SetExecutionPlan(value map[string]interface{}) {
	m.execution_plan = &value
}

// ExecutionPlan returns the value of the "execution_plan" field in the mutation.
func (m *TicketMutation) ExecutionPlan() (r map[string]interface{}, exists bool) {
	v := m.execution_plan
	if v == nil {
		return
	}
	return *v, true
}

// OldExecutionPlan returns the old "execution_plan" field's value of the Ticket entity.
// If the Ticket object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TicketMutation) OldExecutionPlan(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExecutionPlan is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExecutionPlan requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExecutionPlan: %w", err)
	}
	return oldValue.ExecutionPlan, nil
}

// ClearExecutionPlan clears the value of the "execution_plan" field.
func (m *TicketMutation) ClearExecutionPlan() {
	m.execution_plan = nil
	m.clearedFields[ticket.FieldExecutionPlan] = struct{}{}
}

// ExecutionPlanCleared returns if the "execution_plan" field was cleared in this mutation.
func (m *TicketMutation) ExecutionPlanCleared() bool {
	_, ok := m.clearedFields[ticket.FieldExecutionPlan]
	return ok
}

// ResetExecutionPlan resets all changes to the "execution_plan" field.
func (m *TicketMutation) ResetExecutionPlan() {
	m.execution_plan = nil
	delete(m.clearedFields, ticket.FieldExecutionPlan)
}

// SetTenantID sets the "tenant" edge to the Tenant entity by id.
func (m *TicketMutation) SetTenantID(id int) {
	m.tenant = &id
}

// ClearTenant clears the "tenant" edge to the Tenant entity.
func (m *TicketMutation) ClearTenant() {
	m.clearedtenant = true
}

// TenantCleared reports if the "tenant" edge to the Tenant entity was cleared.
func (m *TicketMutation) TenantCleared() bool {
	return m.clearedtenant
}

// TenantID returns the "tenant" edge ID in the mutation.
func (m *TicketMutation) TenantID() (id int, exists bool) {
	if m.tenant != nil {
		return *m.tenant, true
	}
	return
}

// TenantIDs returns the "tenant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TenantID instead. It exists only for internal usage by the builders.
func (m *TicketMutation) TenantIDs() (ids []int) {
	if id := m.tenant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTenant resets all changes to the "tenant" edge.
func (m *TicketMutation) ResetTenant() {
	m.tenant = nil
	m.clearedtenant = false
}

// SetRequesterID sets the "requester" edge to the User entity by id.
func (m *TicketMutation) SetRequesterID(id int) {
	m.requester = &id
}

// ClearRequester clears the "requester" edge to the User entity.
func (m *TicketMutation) ClearRequester() {
	m.clearedrequester = true
}

// RequesterCleared reports if the "requester" edge to the User entity was cleared.
func (m *TicketMutation) RequesterCleared() bool {
	return m.clearedrequester
}

// RequesterID returns the "requester" edge ID in the mutation.
func (m *TicketMutation) RequesterID() (id int, exists bool) {
	if m.requester != nil {
		return *m.requester, true
	}
	return
}

// RequesterIDs returns the "requester" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RequesterID instead. It exists only for internal usage by the builders.
func (m *TicketMutation) RequesterIDs() (ids []int) {
	if id := m.requester; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRequester resets all changes to the "requester" edge.
func (m *TicketMutation) ResetRequester() {
	m.requester = nil
	m.clearedrequester = false
}

// SetAssigneeID sets the "assignee" edge to the User entity by id.
func (m *TicketMutation) SetAssigneeID(id int) {
	m.assignee = &id
}

// ClearAssignee clears the "assignee" edge to the User entity.
func (m *TicketMutation) ClearAssignee() {
	m.clearedassignee = true
}

// AssigneeCleared reports if the "assignee" edge to the User entity was cleared.
func (m *TicketMutation) AssigneeCleared() bool {
	return m.clearedassignee
}

// AssigneeID returns the "assignee" edge ID in the mutation.
func (m *TicketMutation) AssigneeID() (id int, exists bool) {
	if m.assignee != nil {
		return *m.assignee, true
	}
	return
}

// AssigneeIDs returns the "assignee" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AssigneeID instead. It exists only for internal usage by the builders.
func (m *TicketMutation) AssigneeIDs() (ids []int) {
	if id := m.assignee; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAssignee resets all changes to the "assignee" edge.
func (m *TicketMutation) ResetAssignee() {
	m.assignee = nil
	m.clearedassignee = false
}

// SetAssetID sets the "asset" edge to the Asset entity by id.
func (m *TicketMutation) SetAssetID(id int) {
	m.asset = &id
}

// ClearAsset clears the "asset" edge to the Asset entity.
func (m *TicketMutation) ClearAsset() {
	m.clearedasset = true
}

// AssetCleared reports if the "asset" edge to the Asset entity was cleared.
func (m *TicketMutation) AssetCleared() bool {
	return m.clearedasset
}

// AssetID returns the "asset" edge ID in the mutation.
func (m *TicketMutation) AssetID() (id int, exists bool) {
	if m.asset != nil {
		return *m.asset, true
	}
	return
}

// AssetIDs returns the "asset" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AssetID instead. It exists only for internal usage by the builders.
func (m *TicketMutation) AssetIDs() (ids []int) {
	if id := m.asset; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAsset resets all changes to the "asset" edge.
func (m *TicketMutation) ResetAsset() {
	m.asset = nil
	m.clearedasset = false
}

// AddWorkLogIDs adds the "work_logs" edge to the WorkLog entity by ids.
func (m *TicketMutation) AddWorkLogIDs(ids ...int) {
	if m.work_logs == nil {
		m.work_logs = make(map[int]struct{})
	}
	for i := range ids {
		m.work_logs[ids[i]] = struct{}{}
	}
}

// ClearWorkLogs clears the "work_logs" edge to the WorkLog entity.
func (m *TicketMutation) ClearWorkLogs() {
	m.clearedwork_logs = true
}

// WorkLogsCleared reports if the "work_logs" edge to the WorkLog entity was cleared.
func (m *TicketMutation) WorkLogsCleared() bool {
	return m.clearedwork_logs
}

// RemoveWorkLogIDs removes the "work_logs" edge to the WorkLog entity by IDs.
func (m *TicketMutation) RemoveWorkLogIDs(ids ...int) {
	if m.removedwork_logs == nil {
		m.removedwork_logs = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.work_logs, ids[i])
		m.removedwork_logs[ids[i]] = struct{}{}
	}
}

// RemovedWorkLogs returns the removed IDs of the "work_logs" edge to the WorkLog entity.
func (m *TicketMutation) RemovedWorkLogsIDs() (ids []int) {
	for id := range m.removedwork_logs {
		ids = append(ids, id)
	}
	return
}

// WorkLogsIDs returns the "work_logs" edge IDs in the mutation.
func (m *TicketMutation) WorkLogsIDs() (ids []int) {
	for id := range m.work_logs {
		ids = append(ids, id)
	}
	return
}

// ResetWorkLogs resets all changes to the "work_logs" edge.
func (m *TicketMutation) ResetWorkLogs() {
	m.work_logs = nil
	m.clearedwork_logs = false
	m.removedwork_logs = nil
}

// AddRemediationStepIDs adds the "remediation_steps" edge to the RemediationStep entity by ids.
func (m *TicketMutation) AddRemediationStepIDs(ids ...int) {
	if m.remediation_steps == nil {
		m.remediation_steps = make(map[int]struct{})
	}
	for i := range ids {
		m.remediation_steps[ids[i]] = struct{}{}
	}
}

// ClearRemediationSteps clears the "remediation_steps" edge to the RemediationStep entity.
func (m *TicketMutation) ClearRemediationSteps() {
	m.clearedremediation_steps = true
}

// RemediationStepsCleared reports if the "remediation_steps" edge to the RemediationStep entity was cleared.
func (m *TicketMutation) RemediationStepsCleared() bool {
	return m.clearedremediation_steps
}

// RemoveRemediationStepIDs removes the "remediation_steps" edge to the RemediationStep entity by IDs.
func (m *TicketMutation) RemoveRemediationStepIDs(ids ...int) {
	if m.removedremediation_steps == nil {
		m.removedremediation_steps = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.remediation_steps, ids[i])
		m.removedremediation_steps[ids[i]] = struct{}{}
	}
}

// RemovedRemediationSteps returns the removed IDs of the "remediation_steps" edge to the RemediationStep entity.
func (m *TicketMutation) RemovedRemediationStepsIDs() (ids []int) {
	for id := range m.removedremediation_steps {
		ids = append(ids, id)
	}
	return
}

// RemediationStepsIDs returns the "remediation_steps" edge IDs in the mutation.
func (m *TicketMutation) RemediationStepsIDs() (ids []int) {
	for id := range m.remediation_steps {
		ids = append(ids, id)
	}
	return
}

// ResetRemediationSteps resets all changes to the "remediation_steps" edge.
func (m *TicketMutation) ResetRemediationSteps() {
	m.remediation_steps = nil
	m.clearedremediation_steps = false
	m.removedremediation_steps = nil
}

// Where appends a list predicates to the TicketMutation builder.
func (m *TicketMutation) Where(ps ...predicate.Ticket) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TicketMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TicketMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Ticket, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TicketMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TicketMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Ticket).
func (m *TicketMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TicketMutation) Fields() []string {
	fields := make([]string, 0, 13)
	if m.subject != nil {
		fields = append(fields, ticket.FieldSubject)
	}
	if m.description != nil {
		fields = append(fields, ticket.FieldDescription)
	}
	if m.status != nil {
		fields = append(fields, ticket.FieldStatus)
	}
	if m.priority != nil {
		fields = append(fields, ticket.FieldPriority)
	}
	if m.metadata != nil {
		fields = append(fields, ticket.FieldMetadata)
	}
	if m.created_at != nil {
		fields = append(fields, ticket.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, ticket.FieldUpdatedAt)
	}
	if m.resolved_at != nil {
		fields = append(fields, ticket.FieldResolvedAt)
	}
	if m.due_date != nil {
		fields = append(fields, ticket.FieldDueDate)
	}
	if m.claim_lease_owner != nil {
		fields = append(fields, ticket.FieldClaimLeaseOwner)
	}
	if m.claim_lease_expires_at != nil {
		fields = append(fields, ticket.FieldClaimLeaseExpiresAt)
	}
	if m.deep_link != nil {
		fields = append(fields, ticket.FieldDeepLink)
	}
	if m.execution_plan != nil {
		fields = append(fields, ticket.FieldExecutionPlan)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TicketMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case ticket.FieldSubject:
		return m.Subject()
	case ticket.FieldDescription:
		return m.Description()
	case ticket.FieldStatus:
		return m.Status()
	case ticket.FieldPriority:
		return m.Priority()
	case ticket.FieldMetadata:
		return m.Metadata()
	case ticket.FieldCreatedAt:
		return m.CreatedAt()
	case ticket.FieldUpdatedAt:
		return m.UpdatedAt()
	case ticket.FieldResolvedAt:
		return m.ResolvedAt()
	case ticket.FieldDueDate:
		return m.DueDate()
	case ticket.FieldClaimLeaseOwner:
		return m.ClaimLeaseOwner()
	case ticket.FieldClaimLeaseExpiresAt:
		return m.ClaimLeaseExpiresAt()
	case ticket.FieldDeepLink:
		return m.DeepLink()
	case ticket.FieldExecutionPlan:
		return m.ExecutionPlan()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TicketMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case ticket.FieldSubject:
		return m.OldSubject(ctx)
	case ticket.FieldDescription:
		return m.OldDescription(ctx)
	case ticket.FieldStatus:
		return m.OldStatus(ctx)
	case ticket.FieldPriority:
		return m.OldPriority(ctx)
	case ticket.FieldMetadata:
		return m.OldMetadata(ctx)
	case ticket.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case ticket.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case ticket.FieldResolvedAt:
		return m.OldResolvedAt(ctx)
	case ticket.FieldDueDate:
		return m.OldDueDate(ctx)
	case ticket.FieldClaimLeaseOwner:
		return m.OldClaimLeaseOwner(ctx)
	case ticket.FieldClaimLeaseExpiresAt:
		return m.OldClaimLeaseExpiresAt(ctx)
	case ticket.FieldDeepLink:
		return m.OldDeepLink(ctx)
	case ticket.FieldExecutionPlan:
		return m.OldExecutionPlan(ctx)
	}
	return nil, fmt.Errorf("unknown Ticket field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TicketMutation) SetField(name string, value ent.Value) error {
	switch name {
	case ticket.FieldSubject:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSubject(v)
		return nil
	case ticket.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case ticket.FieldStatus:
		v, ok := value.(ticket.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case ticket.FieldPriority:
		v, ok := value.(ticket.Priority)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPriority(v)
		return nil
	case ticket.FieldMetadata:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetadata(v)
		return nil
	case ticket.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case ticket.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case ticket.FieldResolvedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResolvedAt(v)
		return nil
	case ticket.FieldDueDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDueDate(v)
		return nil
	case ticket.FieldClaimLeaseOwner:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClaimLeaseOwner(v)
		return nil
	case ticket.FieldClaimLeaseExpiresAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClaimLeaseExpiresAt(v)
		return nil
	case ticket.FieldDeepLink:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeepLink(v)
		return nil
	case ticket.FieldExecutionPlan:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExecutionPlan(v)
		return nil
	}
	return fmt.Errorf("unknown Ticket field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TicketMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TicketMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TicketMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Ticket numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TicketMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(ticket.FieldMetadata) {
		fields = append(fields, ticket.FieldMetadata)
	}
	if m.FieldCleared(ticket.FieldResolvedAt) {
		fields = append(fields, ticket.FieldResolvedAt)
	}
	if m.FieldCleared(ticket.FieldDueDate) {
		fields = append(fields, ticket.FieldDueDate)
	}
	if m.FieldCleared(ticket.FieldClaimLeaseOwner) {
		fields = append(fields, ticket.FieldClaimLeaseOwner)
	}
	if m.FieldCleared(ticket.FieldClaimLeaseExpiresAt) {
		fields = append(fields, ticket.FieldClaimLeaseExpiresAt)
	}
	if m.FieldCleared(ticket.FieldDeepLink) {
		fields = append(fields, ticket.FieldDeepLink)
	}
	if m.FieldCleared(ticket.FieldExecutionPlan) {
		fields = append(fields, ticket.FieldExecutionPlan)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TicketMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TicketMutation) ClearField(name string) error {
	switch name {
	case ticket.FieldMetadata:
		m.ClearMetadata()
		return nil
	case ticket.FieldResolvedAt:
		m.ClearResolvedAt()
		return nil
	case ticket.FieldDueDate:
		m.ClearDueDate()
		return nil
	case ticket.FieldClaimLeaseOwner:
		m.ClearClaimLeaseOwner()
		return nil
	case ticket.FieldClaimLeaseExpiresAt:
		m.ClearClaimLeaseExpiresAt()
		return nil
	case ticket.FieldDeepLink:
		m.ClearDeepLink()
		return nil
	case ticket.FieldExecutionPlan:
		m.ClearExecutionPlan()
		return nil
	}
	return fmt.Errorf("unknown Ticket nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TicketMutation) ResetField(name string) error {
	switch name {
	case ticket.FieldSubject:
		m.ResetSubject()
		return nil
	case ticket.FieldDescription:
		m.ResetDescription()
		return nil
	case ticket.FieldStatus:
		m.ResetStatus()
		return nil
	case ticket.FieldPriority:
		m.ResetPriority()
		return nil
	case ticket.FieldMetadata:
		m.ResetMetadata()
		return nil
	case ticket.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case ticket.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case ticket.FieldResolvedAt:
		m.ResetResolvedAt()
		return nil
	case ticket.FieldDueDate:
		m.ResetDueDate()
		return nil
	case ticket.FieldClaimLeaseOwner:
		m.ResetClaimLeaseOwner()
		return nil
	case ticket.FieldClaimLeaseExpiresAt:
		m.ResetClaimLeaseExpiresAt()
		return nil
	case ticket.FieldDeepLink:
		m.ResetDeepLink()
		return nil
	case ticket.FieldExecutionPlan:
		m.ResetExecutionPlan()
		return nil
	}
	return fmt.Errorf("unknown Ticket field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TicketMutation) AddedEdges() []string {
	edges := make([]string, 0, 6)
	if m.tenant != nil {
		edges = append(edges, ticket.EdgeTenant)
	}
	if m.requester != nil {
		edges = append(edges, ticket.EdgeRequester)
	}
	if m.assignee != nil {
		edges = append(edges, ticket.EdgeAssignee)
	}
	if m.asset != nil {
		edges = append(edges, ticket.EdgeAsset)
	}
	if m.work_logs != nil {
		edges = append(edges, ticket.EdgeWorkLogs)
	}
	if m.remediation_steps != nil {
		edges = append(edges, ticket.EdgeRemediationSteps)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TicketMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case ticket.EdgeTenant:
		if id := m.tenant; id != nil {
			return []ent.Value{*id}
		}
	case ticket.EdgeRequester:
		if id := m.requester; id != nil {
			return []ent.Value{*id}
		}
	case ticket.EdgeAssignee:
		if id := m.assignee; id != nil {
			return []ent.Value{*id}
		}
	case ticket.EdgeAsset:
		if id := m.asset; id != nil {
			return []ent.Value{*id}
		}
	case ticket.EdgeWorkLogs:
		ids := make([]ent.Value, 0, len(m.work_logs))
		for id := range m.work_logs {
			ids = append(ids, id)
		}
		return ids
	case ticket.EdgeRemediationSteps:
		ids := make([]ent.Value, 0, len(m.remediation_steps))
		for id := range m.remediation_steps {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TicketMutation) RemovedEdges() []string {
	edges := make([]string, 0, 6)
	if m.removedwork_logs != nil {
		edges = append(edges, ticket.EdgeWorkLogs)
	}
	if m.removedremediation_steps != nil {
		edges = append(edges, ticket.EdgeRemediationSteps)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TicketMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case ticket.EdgeWorkLogs:
		ids := make([]ent.Value, 0, len(m.removedwork_logs))
		for id := range m.removedwork_logs {
			ids = append(ids, id)
		}
		return ids
	case ticket.EdgeRemediationSteps:
		ids := make([]ent.Value, 0, len(m.removedremediation_steps))
		for id := range m.removedremediation_steps {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TicketMutation) ClearedEdges() []string {
	edges := make([]string, 0, 6)
	if m.clearedtenant {
		edges = append(edges, ticket.EdgeTenant)
	}
	if m.clearedrequester {
		edges = append(edges, ticket.EdgeRequester)
	}
	if m.clearedassignee {
		edges = append(edges, ticket.EdgeAssignee)
	}
	if m.clearedasset {
		edges = append(edges, ticket.EdgeAsset)
	}
	if m.clearedwork_logs {
		edges = append(edges, ticket.EdgeWorkLogs)
	}
	if m.clearedremediation_steps {
		edges = append(edges, ticket.EdgeRemediationSteps)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TicketMutation) EdgeCleared(name string) bool {
	switch name {
	case ticket.EdgeTenant:
		return m.clearedtenant
	case ticket.EdgeRequester:
		return m.clearedrequester
	case ticket.EdgeAssignee:
		return m.clearedassignee
	case ticket.EdgeAsset:
		return m.clearedasset
	case ticket.EdgeWorkLogs:
		return m.clearedwork_logs
	case ticket.EdgeRemediationSteps:
		return m.clearedremediation_steps
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TicketMutation) ClearEdge(name string) error {
	switch name {
	case ticket.EdgeTenant:
		m.ClearTenant()
		return nil
	case ticket.EdgeRequester:
		m.ClearRequester()
		return nil
	case ticket.EdgeAssignee:
		m.ClearAssignee()
		return nil
	case ticket.EdgeAsset:
		m.ClearAsset()
		return nil
	}
	return fmt.Errorf("unknown Ticket unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TicketMutation) ResetEdge(name string) error {
	switch name {
	case ticket.EdgeTenant:
		m.ResetTenant()
		return nil
	case ticket.EdgeRequester:
		m.ResetRequester()
		return nil
	case ticket.EdgeAssignee:
		m.ResetAssignee()
		return nil
	case ticket.EdgeAsset:
		m.ResetAsset()
		return nil
	case ticket.EdgeWorkLogs:
		m.ResetWorkLogs()
		return nil
	case ticket.EdgeRemediationSteps:
		m.ResetRemediationSteps()
		return nil
	}
	return fmt.Errorf("unknown Ticket edge %s", name)
}

// TimeEntryMutation represents an operation that mutates the TimeEntry nodes in the graph.
type TimeEntryMutation struct {
	config
	op                Op
	typ               string
	id                *int
	start_time        *time.Time
	end_time          *time.Time
	created_at        *time.Time
	technician_id     *int
	addtechnician_id  *int
	status            *timeentry.Status
	work_type         *string
	duration_hours    *float64
	addduration_hours *float64
	invoice_id        *int
	addinvoice_id     *int
	clearedFields     map[string]struct{}
	employee          *int
	clearedemployee   bool
	ticket            *int
	clearedticket     bool
	done              bool
	oldValue          func(context.Context) (*TimeEntry, error)
	predicates        []predicate.TimeEntry
}

var _ ent.Mutation = (*TimeEntryMutation)(nil)

// timeentryOption allows management of the mutation configuration using functional options.
type timeentryOption func(*TimeEntryMutation)

// newTimeEntryMutation creates new mutation for the TimeEntry entity.
func newTimeEntryMutation(c config, op Op, opts ...timeentryOption) *TimeEntryMutation {
	m := &TimeEntryMutation{
		config:        c,
		op:            op,
		typ:           TypeTimeEntry,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTimeEntryID sets the ID field of the mutation.
func withTimeEntryID(id int) timeentryOption {
	return func(m *TimeEntryMutation) {
		var (
			err   error
			once  sync.Once
			value *TimeEntry
		)
		m.oldValue = func(ctx context.Context) (*TimeEntry, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().TimeEntry.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTimeEntry sets the old TimeEntry of the mutation.
func withTimeEntry(node *TimeEntry) timeentryOption {
	return func(m *TimeEntryMutation) {
		m.oldValue = func(context.Context) (*TimeEntry, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TimeEntryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TimeEntryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TimeEntryMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TimeEntryMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().TimeEntry.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetStartTime sets the "start_time" field.
func (m *TimeEntryMutation) SetStartTime(t time.Time) {
	m.start_time = &t
}

// StartTime returns the value of the "start_time" field in the mutation.
func (m *TimeEntryMutation) StartTime() (r time.Time, exists bool) {
	v := m.start_time
	if v == nil {
		return
	}
	return *v, true
}

// OldStartTime returns the old "start_time" field's value of the TimeEntry entity.
// If the TimeEntry object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TimeEntryMutation) OldStartTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartTime: %w", err)
	}
	return oldValue.StartTime, nil
}

// ResetStartTime resets all changes to the "start_time" field.
func (m *TimeEntryMutation) ResetStartTime() {
	m.start_time = nil
}

// SetEndTime sets the "end_time" field.
func (m *TimeEntryMutation) SetEndTime(t time.Time) {
	m.end_time = &t
}

// EndTime returns the value of the "end_time" field in the mutation.
func (m *TimeEntryMutation) EndTime() (r time.Time, exists bool) {
	v := m.end_time
	if v == nil {
		return
	}
	return *v, true
}

// OldEndTime returns the old "end_time" field's value of the TimeEntry entity.
// If the TimeEntry object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TimeEntryMutation) OldEndTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEndTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEndTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndTime: %w", err)
	}
	return oldValue.EndTime, nil
}

// ClearEndTime clears the value of the "end_time" field.
func (m *TimeEntryMutation) ClearEndTime() {
	m.end_time = nil
	m.clearedFields[timeentry.FieldEndTime] = struct{}{}
}

// EndTimeCleared returns if the "end_time" field was cleared in this mutation.
func (m *TimeEntryMutation) EndTimeCleared() bool {
	_, ok := m.clearedFields[timeentry.FieldEndTime]
	return ok
}

// ResetEndTime resets all changes to the "end_time" field.
func (m *TimeEntryMutation) ResetEndTime() {
	m.end_time = nil
	delete(m.clearedFields, timeentry.FieldEndTime)
}

// SetCreatedAt sets the "created_at" field.
func (m *TimeEntryMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *TimeEntryMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the TimeEntry entity.
// If the TimeEntry object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TimeEntryMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *TimeEntryMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetTicketID sets the "ticket_id" field.
func (m *TimeEntryMutation) SetTicketID(i int) {
	m.ticket = &i
}

// TicketID returns the value of the "ticket_id" field in the mutation.
func (m *TimeEntryMutation) TicketID() (r int, exists bool) {
	v := m.ticket
	if v == nil {
		return
	}
	return *v, true
}

// OldTicketID returns the old "ticket_id" field's value of the TimeEntry entity.
// If the TimeEntry object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TimeEntryMutation) OldTicketID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTicketID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTicketID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTicketID: %w", err)
	}
	return oldValue.TicketID, nil
}

// ClearTicketID clears the value of the "ticket_id" field.
func (m *TimeEntryMutation) ClearTicketID() {
	m.ticket = nil
	m.clearedFields[timeentry.FieldTicketID] = struct{}{}
}

// TicketIDCleared returns if the "ticket_id" field was cleared in this mutation.
func (m *TimeEntryMutation) TicketIDCleared() bool {
	_, ok := m.clearedFields[timeentry.FieldTicketID]
	return ok
}

// ResetTicketID resets all changes to the "ticket_id" field.
func (m *TimeEntryMutation) ResetTicketID() {
	m.ticket = nil
	delete(m.clearedFields, timeentry.FieldTicketID)
}

// SetTechnicianID sets the "technician_id" field.
func (m *TimeEntryMutation) SetTechnicianID(i int) {
	m.technician_id = &i
	m.addtechnician_id = nil
}

// TechnicianID returns the value of the "technician_id" field in the mutation.
func (m *TimeEntryMutation) TechnicianID() (r int, exists bool) {
	v := m.technician_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTechnicianID returns the old "technician_id" field's value of the TimeEntry entity.
// If the TimeEntry object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TimeEntryMutation) OldTechnicianID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTechnicianID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTechnicianID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTechnicianID: %w", err)
	}
	return oldValue.TechnicianID, nil
}

// AddTechnicianID adds i to the "technician_id" field.
func (m *TimeEntryMutation) AddTechnicianID(i int) {
	if m.addtechnician_id != nil {
		*m.addtechnician_id += i
	} else {
		m.addtechnician_id = &i
	}
}

// AddedTechnicianID returns the value that was added to the "technician_id" field in this mutation.
func (m *TimeEntryMutation) AddedTechnicianID() (r int, exists bool) {
	v := m.addtechnician_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearTechnicianID clears the value of the "technician_id" field.
func (m *TimeEntryMutation) ClearTechnicianID() {
	m.technician_id = nil
	m.addtechnician_id = nil
	m.clearedFields[timeentry.FieldTechnicianID] = struct{}{}
}

// TechnicianIDCleared returns if the "technician_id" field was cleared in this mutation.
func (m *TimeEntryMutation) TechnicianIDCleared() bool {
	_, ok := m.clearedFields[timeentry.FieldTechnicianID]
	return ok
}

// ResetTechnicianID resets all changes to the "technician_id" field.
func (m *TimeEntryMutation) ResetTechnicianID() {
	m.technician_id = nil
	m.addtechnician_id = nil
	delete(m.clearedFields, timeentry.FieldTechnicianID)
}

// SetStatus sets the "status" field.
func (m *TimeEntryMutation) SetStatus(t timeentry.Status) {
	m.status = &t
}

// Status returns the value of the "status" field in the mutation.
func (m *TimeEntryMutation) Status() (r timeentry.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the TimeEntry entity.
// If the TimeEntry object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TimeEntryMutation) OldStatus(ctx context.Context) (v timeentry.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *TimeEntryMutation) ResetStatus() {
	m.status = nil
}

// SetWorkType sets the "work_type" field.
func (m *TimeEntryMutation) SetWorkType(s string) {
	m.work_type = &s
}

// WorkType returns the value of the "work_type" field in the mutation.
func (m *TimeEntryMutation) WorkType() (r string, exists bool) {
	v := m.work_type
	if v == nil {
		return
	}
	return *v, true
}

// OldWorkType returns the old "work_type" field's value of the TimeEntry entity.
// If the TimeEntry object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TimeEntryMutation) OldWorkType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWorkType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWorkType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWorkType: %w", err)
	}
	return oldValue.WorkType, nil
}

// ResetWorkType resets all changes to the "work_type" field.
func (m *TimeEntryMutation) ResetWorkType() {
	m.work_type = nil
}

// SetDurationHours sets the "duration_hours" field.
func (m *TimeEntryMutation) SetDurationHours(f float64) {
	m.duration_hours = &f
	m.addduration_hours = nil
}

// DurationHours returns the value of the "duration_hours" field in the mutation.
func (m *TimeEntryMutation) DurationHours() (r float64, exists bool) {
	v := m.duration_hours
	if v == nil {
		return
	}
	return *v, true
}

// OldDurationHours returns the old "duration_hours" field's value of the TimeEntry entity.
// If the TimeEntry object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TimeEntryMutation) OldDurationHours(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDurationHours is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDurationHours requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDurationHours: %w", err)
	}
	return oldValue.DurationHours, nil
}

// AddDurationHours adds f to the "duration_hours" field.
func (m *TimeEntryMutation) AddDurationHours(f float64) {
	if m.addduration_hours != nil {
		*m.addduration_hours += f
	} else {
		m.addduration_hours = &f
	}
}

// AddedDurationHours returns the value that was added to the "duration_hours" field in this mutation.
func (m *TimeEntryMutation) AddedDurationHours() (r float64, exists bool) {
	v := m.addduration_hours
	if v == nil {
		return
	}
	return *v, true
}

// ClearDurationHours clears the value of the "duration_hours" field.
func (m *TimeEntryMutation) ClearDurationHours() {
	m.duration_hours = nil
	m.addduration_hours = nil
	m.clearedFields[timeentry.FieldDurationHours] = struct{}{}
}

// DurationHoursCleared returns if the "duration_hours" field was cleared in this mutation.
func (m *TimeEntryMutation) DurationHoursCleared() bool {
	_, ok := m.clearedFields[timeentry.FieldDurationHours]
	return ok
}

// ResetDurationHours resets all changes to the "duration_hours" field.
func (m *TimeEntryMutation) ResetDurationHours() {
	m.duration_hours = nil
	m.addduration_hours = nil
	delete(m.clearedFields, timeentry.FieldDurationHours)
}

// SetInvoiceID sets the "invoice_id" field.
func (m *TimeEntryMutation) SetInvoiceID(i int) {
	m.invoice_id = &i
	m.addinvoice_id = nil
}

// InvoiceID returns the value of the "invoice_id" field in the mutation.
func (m *TimeEntryMutation) InvoiceID() (r int, exists bool) {
	v := m.invoice_id
	if v == nil {
		return
	}
	return *v, true
}

// OldInvoiceID returns the old "invoice_id" field's value of the TimeEntry entity.
// If the TimeEntry object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TimeEntryMutation) OldInvoiceID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInvoiceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInvoiceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInvoiceID: %w", err)
	}
	return oldValue.InvoiceID, nil
}

// AddInvoiceID adds i to the "invoice_id" field.
func (m *TimeEntryMutation) AddInvoiceID(i int) {
	if m.addinvoice_id != nil {
		*m.addinvoice_id += i
	} else {
		m.addinvoice_id = &i
	}
}

// AddedInvoiceID returns the value that was added to the "invoice_id" field in this mutation.
func (m *TimeEntryMutation) AddedInvoiceID() (r int, exists bool) {
	v := m.addinvoice_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearInvoiceID clears the value of the "invoice_id" field.
func (m *TimeEntryMutation) ClearInvoiceID() {
	m.invoice_id = nil
	m.addinvoice_id = nil
	m.clearedFields[timeentry.FieldInvoiceID] = struct{}{}
}

// InvoiceIDCleared returns if the "invoice_id" field was cleared in this mutation.
func (m *TimeEntryMutation) InvoiceIDCleared() bool {
	_, ok := m.clearedFields[timeentry.FieldInvoiceID]
	return ok
}

// ResetInvoiceID resets all changes to the "invoice_id" field.
func (m *TimeEntryMutation) ResetInvoiceID() {
	m.invoice_id = nil
	m.addinvoice_id = nil
	delete(m.clearedFields, timeentry.FieldInvoiceID)
}

// SetEmployeeID sets the "employee" edge to the Employee entity by id.
func (m *TimeEntryMutation) SetEmployeeID(id int) {
	m.employee = &id
}

// ClearEmployee clears the "employee" edge to the Employee entity.
func (m *TimeEntryMutation) ClearEmployee() {
	m.clearedemployee = true
}

// EmployeeCleared reports if the "employee" edge to the Employee entity was cleared.
func (m *TimeEntryMutation) EmployeeCleared() bool {
	return m.clearedemployee
}

// EmployeeID returns the "employee" edge ID in the mutation.
func (m *TimeEntryMutation) EmployeeID() (id int, exists bool) {
	if m.employee != nil {
		return *m.employee, true
	}
	return
}

// EmployeeIDs returns the "employee" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// EmployeeID instead. It exists only for internal usage by the builders.
func (m *TimeEntryMutation) EmployeeIDs() (ids []int) {
	if id := m.employee; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEmployee resets all changes to the "employee" edge.
func (m *TimeEntryMutation) ResetEmployee() {
	m.employee = nil
	m.clearedemployee = false
}

// ClearTicket clears the "ticket" edge to the Ticket entity.
func (m *TimeEntryMutation) ClearTicket() {
	m.clearedticket = true
	m.clearedFields[timeentry.FieldTicketID] = struct{}{}
}

// TicketCleared reports if the "ticket" edge to the Ticket entity was cleared.
func (m *TimeEntryMutation) TicketCleared() bool {
	return m.TicketIDCleared() || m.clearedticket
}

// TicketIDs returns the "ticket" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TicketID instead. It exists only for internal usage by the builders.
func (m *TimeEntryMutation) TicketIDs() (ids []int) {
	if id := m.ticket; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTicket resets all changes to the "ticket" edge.
func (m *TimeEntryMutation) ResetTicket() {
	m.ticket = nil
	m.clearedticket = false
}

// Where appends a list predicates to the TimeEntryMutation builder.
func (m *TimeEntryMutation) Where(ps ...predicate.TimeEntry) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TimeEntryMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TimeEntryMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.TimeEntry, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TimeEntryMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TimeEntryMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (TimeEntry).
func (m *TimeEntryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TimeEntryMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.start_time != nil {
		fields = append(fields, timeentry.FieldStartTime)
	}
	if m.end_time != nil {
		fields = append(fields, timeentry.FieldEndTime)
	}
	if m.created_at != nil {
		fields = append(fields, timeentry.FieldCreatedAt)
	}
	if m.ticket != nil {
		fields = append(fields, timeentry.FieldTicketID)
	}
	if m.technician_id != nil {
		fields = append(fields, timeentry.FieldTechnicianID)
	}
	if m.status != nil {
		fields = append(fields, timeentry.FieldStatus)
	}
	if m.work_type != nil {
		fields = append(fields, timeentry.FieldWorkType)
	}
	if m.duration_hours != nil {
		fields = append(fields, timeentry.FieldDurationHours)
	}
	if m.invoice_id != nil {
		fields = append(fields, timeentry.FieldInvoiceID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TimeEntryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case timeentry.FieldStartTime:
		return m.StartTime()
	case timeentry.FieldEndTime:
		return m.EndTime()
	case timeentry.FieldCreatedAt:
		return m.CreatedAt()
	case timeentry.FieldTicketID:
		return m.TicketID()
	case timeentry.FieldTechnicianID:
		return m.TechnicianID()
	case timeentry.FieldStatus:
		return m.Status()
	case timeentry.FieldWorkType:
		return m.WorkType()
	case timeentry.FieldDurationHours:
		return m.DurationHours()
	case timeentry.FieldInvoiceID:
		return m.InvoiceID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TimeEntryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case timeentry.FieldStartTime:
		return m.OldStartTime(ctx)
	case timeentry.FieldEndTime:
		return m.OldEndTime(ctx)
	case timeentry.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case timeentry.FieldTicketID:
		return m.OldTicketID(ctx)
	case timeentry.FieldTechnicianID:
		return m.OldTechnicianID(ctx)
	case timeentry.FieldStatus:
		return m.OldStatus(ctx)
	case timeentry.FieldWorkType:
		return m.OldWorkType(ctx)
	case timeentry.FieldDurationHours:
		return m.OldDurationHours(ctx)
	case timeentry.FieldInvoiceID:
		return m.OldInvoiceID(ctx)
	}
	return nil, fmt.Errorf("unknown TimeEntry field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TimeEntryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case timeentry.FieldStartTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartTime(v)
		return nil
	case timeentry.FieldEndTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndTime(v)
		return nil
	case timeentry.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case timeentry.FieldTicketID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTicketID(v)
		return nil
	case timeentry.FieldTechnicianID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTechnicianID(v)
		return nil
	case timeentry.FieldStatus:
		v, ok := value.(timeentry.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case timeentry.FieldWorkType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWorkType(v)
		return nil
	case timeentry.FieldDurationHours:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDurationHours(v)
		return nil
	case timeentry.FieldInvoiceID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInvoiceID(v)
		return nil
	}
	return fmt.Errorf("unknown TimeEntry field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TimeEntryMutation) AddedFields() []string {
	var fields []string
	if m.addtechnician_id != nil {
		fields = append(fields, timeentry.FieldTechnicianID)
	}
	if m.addduration_hours != nil {
		fields = append(fields, timeentry.FieldDurationHours)
	}
	if m.addinvoice_id != nil {
		fields = append(fields, timeentry.FieldInvoiceID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TimeEntryMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case timeentry.FieldTechnicianID:
		return m.AddedTechnicianID()
	case timeentry.FieldDurationHours:
		return m.AddedDurationHours()
	case timeentry.FieldInvoiceID:
		return m.AddedInvoiceID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TimeEntryMutation) AddField(name string, value ent.Value) error {
	switch name {
	case timeentry.FieldTechnicianID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTechnicianID(v)
		return nil
	case timeentry.FieldDurationHours:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDurationHours(v)
		return nil
	case timeentry.FieldInvoiceID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddInvoiceID(v)
		return nil
	}
	return fmt.Errorf("unknown TimeEntry numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TimeEntryMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(timeentry.FieldEndTime) {
		fields = append(fields, timeentry.FieldEndTime)
	}
	if m.FieldCleared(timeentry.FieldTicketID) {
		fields = append(fields, timeentry.FieldTicketID)
	}
	if m.FieldCleared(timeentry.FieldTechnicianID) {
		fields = append(fields, timeentry.FieldTechnicianID)
	}
	if m.FieldCleared(timeentry.FieldDurationHours) {
		fields = append(fields, timeentry.FieldDurationHours)
	}
	if m.FieldCleared(timeentry.FieldInvoiceID) {
		fields = append(fields, timeentry.FieldInvoiceID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TimeEntryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TimeEntryMutation) ClearField(name string) error {
	switch name {
	case timeentry.FieldEndTime:
		m.ClearEndTime()
		return nil
	case timeentry.FieldTicketID:
		m.ClearTicketID()
		return nil
	case timeentry.FieldTechnicianID:
		m.ClearTechnicianID()
		return nil
	case timeentry.FieldDurationHours:
		m.ClearDurationHours()
		return nil
	case timeentry.FieldInvoiceID:
		m.ClearInvoiceID()
		return nil
	}
	return fmt.Errorf("unknown TimeEntry nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TimeEntryMutation) ResetField(name string) error {
	switch name {
	case timeentry.FieldStartTime:
		m.ResetStartTime()
		return nil
	case timeentry.FieldEndTime:
		m.ResetEndTime()
		return nil
	case timeentry.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case timeentry.FieldTicketID:
		m.ResetTicketID()
		return nil
	case timeentry.FieldTechnicianID:
		m.ResetTechnicianID()
		return nil
	case timeentry.FieldStatus:
		m.ResetStatus()
		return nil
	case timeentry.FieldWorkType:
		m.ResetWorkType()
		return nil
	case timeentry.FieldDurationHours:
		m.ResetDurationHours()
		return nil
	case timeentry.FieldInvoiceID:
		m.ResetInvoiceID()
		return nil
	}
	return fmt.Errorf("unknown TimeEntry field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TimeEntryMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.employee != nil {
		edges = append(edges, timeentry.EdgeEmployee)
	}
	if m.ticket != nil {
		edges = append(edges, timeentry.EdgeTicket)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TimeEntryMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case timeentry.EdgeEmployee:
		if id := m.employee; id != nil {
			return []ent.Value{*id}
		}
	case timeentry.EdgeTicket:
		if id := m.ticket; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TimeEntryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TimeEntryMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TimeEntryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedemployee {
		edges = append(edges, timeentry.EdgeEmployee)
	}
	if m.clearedticket {
		edges = append(edges, timeentry.EdgeTicket)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TimeEntryMutation) EdgeCleared(name string) bool {
	switch name {
	case timeentry.EdgeEmployee:
		return m.clearedemployee
	case timeentry.EdgeTicket:
		return m.clearedticket
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TimeEntryMutation) ClearEdge(name string) error {
	switch name {
	case timeentry.EdgeEmployee:
		m.ClearEmployee()
		return nil
	case timeentry.EdgeTicket:
		m.ClearTicket()
		return nil
	}
	return fmt.Errorf("unknown TimeEntry unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TimeEntryMutation) ResetEdge(name string) error {
	switch name {
	case timeentry.EdgeEmployee:
		m.ResetEmployee()
		return nil
	case timeentry.EdgeTicket:
		m.ResetTicket()
		return nil
	}
	return fmt.Errorf("unknown TimeEntry edge %s", name)
}

// TimeOffBalanceMutation represents an operation that mutates the TimeOffBalance nodes in the graph.
type TimeOffBalanceMutation struct {
	config
	op                    Op
	typ                   string
	id                    *int
	year                  *int
	addyear               *int
	available_hours       *float64
	addavailable_hours    *float64
	used_hours            *float64
	addused_hours         *float64
	pending_hours         *float64
	addpending_hours      *float64
	accrued_hours         *float64
	addaccrued_hours      *float64
	carried_over_hours    *float64
	addcarried_over_hours *float64
	created_at            *time.Time
	updated_at            *time.Time
	clearedFields         map[string]struct{}
	tenant                *int
	clearedtenant         bool
	employee              *int
	clearedemployee       bool
	policy                *int
	clearedpolicy         bool
	done                  bool
	oldValue              func(context.Context) (*TimeOffBalance, error)
	predicates            []predicate.TimeOffBalance
}

var _ ent.Mutation = (*TimeOffBalanceMutation)(nil)

// timeoffbalanceOption allows management of the mutation configuration using functional options.
type timeoffbalanceOption func(*TimeOffBalanceMutation)

// newTimeOffBalanceMutation creates new mutation for the TimeOffBalance entity.
func newTimeOffBalanceMutation(c config, op Op, opts ...timeoffbalanceOption) *TimeOffBalanceMutation {
	m := &TimeOffBalanceMutation{
		config:        c,
		op:            op,
		typ:           TypeTimeOffBalance,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTimeOffBalanceID sets the ID field of the mutation.
func withTimeOffBalanceID(id int) timeoffbalanceOption {
	return func(m *TimeOffBalanceMutation) {
		var (
			err   error
			once  sync.Once
			value *TimeOffBalance
		)
		m.oldValue = func(ctx context.Context) (*TimeOffBalance, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().TimeOffBalance.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTimeOffBalance sets the old TimeOffBalance of the mutation.
func withTimeOffBalance(node *TimeOffBalance) timeoffbalanceOption {
	return func(m *TimeOffBalanceMutation) {
		m.oldValue = func(context.Context) (*TimeOffBalance, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TimeOffBalanceMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TimeOffBalanceMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TimeOffBalanceMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TimeOffBalanceMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().TimeOffBalance.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetYear sets the "year" field.
func (m *TimeOffBalanceMutation) SetYear(i int) {
	m.year = &i
	m.addyear = nil
}

// Year returns the value of the "year" field in the mutation.
func (m *TimeOffBalanceMutation) Year() (r int, exists bool) {
	v := m.year
	if v == nil {
		return
	}
	return *v, true
}

// OldYear returns the old "year" field's value of the TimeOffBalance entity.
// If the TimeOffBalance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TimeOffBalanceMutation) OldYear(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldYear is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldYear requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldYear: %w", err)
	}
	return oldValue.Year, nil
}

// AddYear adds i to the "year" field.
func (m *TimeOffBalanceMutation) AddYear(i int) {
	if m.addyear != nil {
		*m.addyear += i
	} else {
		m.addyear = &i
	}
}

// AddedYear returns the value that was added to the "year" field in this mutation.
func (m *TimeOffBalanceMutation) AddedYear() (r int, exists bool) {
	v := m.addyear
	if v == nil {
		return
	}
	return *v, true
}

// ResetYear resets all changes to the "year" field.
func (m *TimeOffBalanceMutation) ResetYear() {
	m.year = nil
	m.addyear = nil
}

// SetAvailableHours sets the "available_hours" field.
func (m *TimeOffBalanceMutation) SetAvailableHours(f float64) {
	m.available_hours = &f
	m.addavailable_hours = nil
}

// AvailableHours returns the value of the "available_hours" field in the mutation.
func (m *TimeOffBalanceMutation) AvailableHours() (r float64, exists bool) {
	v := m.available_hours
	if v == nil {
		return
	}
	return *v, true
}

// OldAvailableHours returns the old "available_hours" field's value of the TimeOffBalance entity.
// If the TimeOffBalance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TimeOffBalanceMutation) OldAvailableHours(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAvailableHours is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAvailableHours requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAvailableHours: %w", err)
	}
	return oldValue.AvailableHours, nil
}

// AddAvailableHours adds f to the "available_hours" field.
func (m *TimeOffBalanceMutation) AddAvailableHours(f float64) {
	if m.addavailable_hours != nil {
		*m.addavailable_hours += f
	} else {
		m.addavailable_hours = &f
	}
}

// AddedAvailableHours returns the value that was added to the "available_hours" field in this mutation.
func (m *TimeOffBalanceMutation) AddedAvailableHours() (r float64, exists bool) {
	v := m.addavailable_hours
	if v == nil {
		return
	}
	return *v, true
}

// ResetAvailableHours resets all changes to the "available_hours" field.
func (m *TimeOffBalanceMutation) ResetAvailableHours() {
	m.available_hours = nil
	m.addavailable_hours = nil
}

// SetUsedHours sets the "used_hours" field.
func (m *TimeOffBalanceMutation) SetUsedHours(f float64) {
	m.used_hours = &f
	m.addused_hours = nil
}

// UsedHours returns the value of the "used_hours" field in the mutation.
func (m *TimeOffBalanceMutation) UsedHours() (r float64, exists bool) {
	v := m.used_hours
	if v == nil {
		return
	}
	return *v, true
}

// OldUsedHours returns the old "used_hours" field's value of the TimeOffBalance entity.
// If the TimeOffBalance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TimeOffBalanceMutation) OldUsedHours(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsedHours is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsedHours requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsedHours: %w", err)
	}
	return oldValue.UsedHours, nil
}

// AddUsedHours adds f to the "used_hours" field.
func (m *TimeOffBalanceMutation) AddUsedHours(f float64) {
	if m.addused_hours != nil {
		*m.addused_hours += f
	} else {
		m.addused_hours = &f
	}
}

// AddedUsedHours returns the value that was added to the "used_hours" field in this mutation.
func (m *TimeOffBalanceMutation) AddedUsedHours() (r float64, exists bool) {
	v := m.addused_hours
	if v == nil {
		return
	}
	return *v, true
}

// ResetUsedHours resets all changes to the "used_hours" field.
func (m *TimeOffBalanceMutation) ResetUsedHours() {
	m.used_hours = nil
	m.addused_hours = nil
}

// SetPendingHours sets the "pending_hours" field.
func (m *TimeOffBalanceMutation) SetPendingHours(f float64) {
	m.pending_hours = &f
	m.addpending_hours = nil
}

// PendingHours returns the value of the "pending_hours" field in the mutation.
func (m *TimeOffBalanceMutation) PendingHours() (r float64, exists bool) {
	v := m.pending_hours
	if v == nil {
		return
	}
	return *v, true
}

// OldPendingHours returns the old "pending_hours" field's value of the TimeOffBalance entity.
// If the TimeOffBalance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TimeOffBalanceMutation) OldPendingHours(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPendingHours is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPendingHours requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPendingHours: %w", err)
	}
	return oldValue.PendingHours, nil
}

// AddPendingHours adds f to the "pending_hours" field.
func (m *TimeOffBalanceMutation) AddPendingHours(f float64) {
	if m.addpending_hours != nil {
		*m.addpending_hours += f
	} else {
		m.addpending_hours = &f
	}
}

// AddedPendingHours returns the value that was added to the "pending_hours" field in this mutation.
func (m *TimeOffBalanceMutation) AddedPendingHours() (r float64, exists bool) {
	v := m.addpending_hours
	if v == nil {
		return
	}
	return *v, true
}

// ResetPendingHours resets all changes to the "pending_hours" field.
func (m *TimeOffBalanceMutation) ResetPendingHours() {
	m.pending_hours = nil
	m.addpending_hours = nil
}

// SetAccruedHours sets the "accrued_hours" field.
func (m *TimeOffBalanceMutation) SetAccruedHours(f float64) {
	m.accrued_hours = &f
	m.addaccrued_hours = nil
}

// AccruedHours returns the value of the "accrued_hours" field in the mutation.
func (m *TimeOffBalanceMutation) AccruedHours() (r float64, exists bool) {
	v := m.accrued_hours
	if v == nil {
		return
	}
	return *v, true
}

// OldAccruedHours returns the old "accrued_hours" field's value of the TimeOffBalance entity.
// If the TimeOffBalance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TimeOffBalanceMutation) OldAccruedHours(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAccruedHours is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAccruedHours requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAccruedHours: %w", err)
	}
	return oldValue.AccruedHours, nil
}

// AddAccruedHours adds f to the "accrued_hours" field.
func (m *TimeOffBalanceMutation) AddAccruedHours(f float64) {
	if m.addaccrued_hours != nil {
		*m.addaccrued_hours += f
	} else {
		m.addaccrued_hours = &f
	}
}

// AddedAccruedHours returns the value that was added to the "accrued_hours" field in this mutation.
func (m *TimeOffBalanceMutation) AddedAccruedHours() (r float64, exists bool) {
	v := m.addaccrued_hours
	if v == nil {
		return
	}
	return *v, true
}

// ResetAccruedHours resets all changes to the "accrued_hours" field.
func (m *TimeOffBalanceMutation) ResetAccruedHours() {
	m.accrued_hours = nil
	m.addaccrued_hours = nil
}

// SetCarriedOverHours sets the "carried_over_hours" field.
func (m *TimeOffBalanceMutation) SetCarriedOverHours(f float64) {
	m.carried_over_hours = &f
	m.addcarried_over_hours = nil
}

// CarriedOverHours returns the value of the "carried_over_hours" field in the mutation.
func (m *TimeOffBalanceMutation) CarriedOverHours() (r float64, exists bool) {
	v := m.carried_over_hours
	if v == nil {
		return
	}
	return *v, true
}

// OldCarriedOverHours returns the old "carried_over_hours" field's value of the TimeOffBalance entity.
// If the TimeOffBalance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TimeOffBalanceMutation) OldCarriedOverHours(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCarriedOverHours is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCarriedOverHours requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCarriedOverHours: %w", err)
	}
	return oldValue.CarriedOverHours, nil
}

// AddCarriedOverHours adds f to the "carried_over_hours" field.
func (m *TimeOffBalanceMutation) AddCarriedOverHours(f float64) {
	if m.addcarried_over_hours != nil {
		*m.addcarried_over_hours += f
	} else {
		m.addcarried_over_hours = &f
	}
}

// AddedCarriedOverHours returns the value that was added to the "carried_over_hours" field in this mutation.
func (m *TimeOffBalanceMutation) AddedCarriedOverHours() (r float64, exists bool) {
	v := m.addcarried_over_hours
	if v == nil {
		return
	}
	return *v, true
}

// ResetCarriedOverHours resets all changes to the "carried_over_hours" field.
func (m *TimeOffBalanceMutation) ResetCarriedOverHours() {
	m.carried_over_hours = nil
	m.addcarried_over_hours = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *TimeOffBalanceMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *TimeOffBalanceMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the TimeOffBalance entity.
// If the TimeOffBalance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TimeOffBalanceMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *TimeOffBalanceMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *TimeOffBalanceMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *TimeOffBalanceMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the TimeOffBalance entity.
// If the TimeOffBalance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TimeOffBalanceMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *TimeOffBalanceMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetTenantID sets the "tenant" edge to the Tenant entity by id.
func (m *TimeOffBalanceMutation) SetTenantID(id int) {
	m.tenant = &id
}

// ClearTenant clears the "tenant" edge to the Tenant entity.
func (m *TimeOffBalanceMutation) ClearTenant() {
	m.clearedtenant = true
}

// TenantCleared reports if the "tenant" edge to the Tenant entity was cleared.
func (m *TimeOffBalanceMutation) TenantCleared() bool {
	return m.clearedtenant
}

// TenantID returns the "tenant" edge ID in the mutation.
func (m *TimeOffBalanceMutation) TenantID() (id int, exists bool) {
	if m.tenant != nil {
		return *m.tenant, true
	}
	return
}

// TenantIDs returns the "tenant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TenantID instead. It exists only for internal usage by the builders.
func (m *TimeOffBalanceMutation) TenantIDs() (ids []int) {
	if id := m.tenant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTenant resets all changes to the "tenant" edge.
func (m *TimeOffBalanceMutation) ResetTenant() {
	m.tenant = nil
	m.clearedtenant = false
}

// SetEmployeeID sets the "employee" edge to the Employee entity by id.
func (m *TimeOffBalanceMutation) SetEmployeeID(id int) {
	m.employee = &id
}

// ClearEmployee clears the "employee" edge to the Employee entity.
func (m *TimeOffBalanceMutation) ClearEmployee() {
	m.clearedemployee = true
}

// EmployeeCleared reports if the "employee" edge to the Employee entity was cleared.
func (m *TimeOffBalanceMutation) EmployeeCleared() bool {
	return m.clearedemployee
}

// EmployeeID returns the "employee" edge ID in the mutation.
func (m *TimeOffBalanceMutation) EmployeeID() (id int, exists bool) {
	if m.employee != nil {
		return *m.employee, true
	}
	return
}

// EmployeeIDs returns the "employee" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// EmployeeID instead. It exists only for internal usage by the builders.
func (m *TimeOffBalanceMutation) EmployeeIDs() (ids []int) {
	if id := m.employee; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEmployee resets all changes to the "employee" edge.
func (m *TimeOffBalanceMutation) ResetEmployee() {
	m.employee = nil
	m.clearedemployee = false
}

// SetPolicyID sets the "policy" edge to the TimeOffPolicy entity by id.
func (m *TimeOffBalanceMutation) SetPolicyID(id int) {
	m.policy = &id
}

// ClearPolicy clears the "policy" edge to the TimeOffPolicy entity.
func (m *TimeOffBalanceMutation) ClearPolicy() {
	m.clearedpolicy = true
}

// PolicyCleared reports if the "policy" edge to the TimeOffPolicy entity was cleared.
func (m *TimeOffBalanceMutation) PolicyCleared() bool {
	return m.clearedpolicy
}

// PolicyID returns the "policy" edge ID in the mutation.
func (m *TimeOffBalanceMutation) PolicyID() (id int, exists bool) {
	if m.policy != nil {
		return *m.policy, true
	}
	return
}

// PolicyIDs returns the "policy" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PolicyID instead. It exists only for internal usage by the builders.
func (m *TimeOffBalanceMutation) PolicyIDs() (ids []int) {
	if id := m.policy; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPolicy resets all changes to the "policy" edge.
func (m *TimeOffBalanceMutation) ResetPolicy() {
	m.policy = nil
	m.clearedpolicy = false
}

// Where appends a list predicates to the TimeOffBalanceMutation builder.
func (m *TimeOffBalanceMutation) Where(ps ...predicate.TimeOffBalance) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TimeOffBalanceMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TimeOffBalanceMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.TimeOffBalance, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TimeOffBalanceMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TimeOffBalanceMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (TimeOffBalance).
func (m *TimeOffBalanceMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TimeOffBalanceMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.year != nil {
		fields = append(fields, timeoffbalance.FieldYear)
	}
	if m.available_hours != nil {
		fields = append(fields, timeoffbalance.FieldAvailableHours)
	}
	if m.used_hours != nil {
		fields = append(fields, timeoffbalance.FieldUsedHours)
	}
	if m.pending_hours != nil {
		fields = append(fields, timeoffbalance.FieldPendingHours)
	}
	if m.accrued_hours != nil {
		fields = append(fields, timeoffbalance.FieldAccruedHours)
	}
	if m.carried_over_hours != nil {
		fields = append(fields, timeoffbalance.FieldCarriedOverHours)
	}
	if m.created_at != nil {
		fields = append(fields, timeoffbalance.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, timeoffbalance.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TimeOffBalanceMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case timeoffbalance.FieldYear:
		return m.Year()
	case timeoffbalance.FieldAvailableHours:
		return m.AvailableHours()
	case timeoffbalance.FieldUsedHours:
		return m.UsedHours()
	case timeoffbalance.FieldPendingHours:
		return m.PendingHours()
	case timeoffbalance.FieldAccruedHours:
		return m.AccruedHours()
	case timeoffbalance.FieldCarriedOverHours:
		return m.CarriedOverHours()
	case timeoffbalance.FieldCreatedAt:
		return m.CreatedAt()
	case timeoffbalance.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TimeOffBalanceMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case timeoffbalance.FieldYear:
		return m.OldYear(ctx)
	case timeoffbalance.FieldAvailableHours:
		return m.OldAvailableHours(ctx)
	case timeoffbalance.FieldUsedHours:
		return m.OldUsedHours(ctx)
	case timeoffbalance.FieldPendingHours:
		return m.OldPendingHours(ctx)
	case timeoffbalance.FieldAccruedHours:
		return m.OldAccruedHours(ctx)
	case timeoffbalance.FieldCarriedOverHours:
		return m.OldCarriedOverHours(ctx)
	case timeoffbalance.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case timeoffbalance.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown TimeOffBalance field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TimeOffBalanceMutation) SetField(name string, value ent.Value) error {
	switch name {
	case timeoffbalance.FieldYear:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetYear(v)
		return nil
	case timeoffbalance.FieldAvailableHours:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAvailableHours(v)
		return nil
	case timeoffbalance.FieldUsedHours:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsedHours(v)
		return nil
	case timeoffbalance.FieldPendingHours:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPendingHours(v)
		return nil
	case timeoffbalance.FieldAccruedHours:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAccruedHours(v)
		return nil
	case timeoffbalance.FieldCarriedOverHours:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCarriedOverHours(v)
		return nil
	case timeoffbalance.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case timeoffbalance.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown TimeOffBalance field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TimeOffBalanceMutation) AddedFields() []string {
	var fields []string
	if m.addyear != nil {
		fields = append(fields, timeoffbalance.FieldYear)
	}
	if m.addavailable_hours != nil {
		fields = append(fields, timeoffbalance.FieldAvailableHours)
	}
	if m.addused_hours != nil {
		fields = append(fields, timeoffbalance.FieldUsedHours)
	}
	if m.addpending_hours != nil {
		fields = append(fields, timeoffbalance.FieldPendingHours)
	}
	if m.addaccrued_hours != nil {
		fields = append(fields, timeoffbalance.FieldAccruedHours)
	}
	if m.addcarried_over_hours != nil {
		fields = append(fields, timeoffbalance.FieldCarriedOverHours)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TimeOffBalanceMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case timeoffbalance.FieldYear:
		return m.AddedYear()
	case timeoffbalance.FieldAvailableHours:
		return m.AddedAvailableHours()
	case timeoffbalance.FieldUsedHours:
		return m.AddedUsedHours()
	case timeoffbalance.FieldPendingHours:
		return m.AddedPendingHours()
	case timeoffbalance.FieldAccruedHours:
		return m.AddedAccruedHours()
	case timeoffbalance.FieldCarriedOverHours:
		return m.AddedCarriedOverHours()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TimeOffBalanceMutation) AddField(name string, value ent.Value) error {
	switch name {
	case timeoffbalance.FieldYear:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddYear(v)
		return nil
	case timeoffbalance.FieldAvailableHours:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAvailableHours(v)
		return nil
	case timeoffbalance.FieldUsedHours:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUsedHours(v)
		return nil
	case timeoffbalance.FieldPendingHours:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPendingHours(v)
		return nil
	case timeoffbalance.FieldAccruedHours:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAccruedHours(v)
		return nil
	case timeoffbalance.FieldCarriedOverHours:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCarriedOverHours(v)
		return nil
	}
	return fmt.Errorf("unknown TimeOffBalance numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TimeOffBalanceMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TimeOffBalanceMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TimeOffBalanceMutation) ClearField(name string) error {
	return fmt.Errorf("unknown TimeOffBalance nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TimeOffBalanceMutation) ResetField(name string) error {
	switch name {
	case timeoffbalance.FieldYear:
		m.ResetYear()
		return nil
	case timeoffbalance.FieldAvailableHours:
		m.ResetAvailableHours()
		return nil
	case timeoffbalance.FieldUsedHours:
		m.ResetUsedHours()
		return nil
	case timeoffbalance.FieldPendingHours:
		m.ResetPendingHours()
		return nil
	case timeoffbalance.FieldAccruedHours:
		m.ResetAccruedHours()
		return nil
	case timeoffbalance.FieldCarriedOverHours:
		m.ResetCarriedOverHours()
		return nil
	case timeoffbalance.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case timeoffbalance.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown TimeOffBalance field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TimeOffBalanceMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.tenant != nil {
		edges = append(edges, timeoffbalance.EdgeTenant)
	}
	if m.employee != nil {
		edges = append(edges, timeoffbalance.EdgeEmployee)
	}
	if m.policy != nil {
		edges = append(edges, timeoffbalance.EdgePolicy)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TimeOffBalanceMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case timeoffbalance.EdgeTenant:
		if id := m.tenant; id != nil {
			return []ent.Value{*id}
		}
	case timeoffbalance.EdgeEmployee:
		if id := m.employee; id != nil {
			return []ent.Value{*id}
		}
	case timeoffbalance.EdgePolicy:
		if id := m.policy; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TimeOffBalanceMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TimeOffBalanceMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TimeOffBalanceMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedtenant {
		edges = append(edges, timeoffbalance.EdgeTenant)
	}
	if m.clearedemployee {
		edges = append(edges, timeoffbalance.EdgeEmployee)
	}
	if m.clearedpolicy {
		edges = append(edges, timeoffbalance.EdgePolicy)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TimeOffBalanceMutation) EdgeCleared(name string) bool {
	switch name {
	case timeoffbalance.EdgeTenant:
		return m.clearedtenant
	case timeoffbalance.EdgeEmployee:
		return m.clearedemployee
	case timeoffbalance.EdgePolicy:
		return m.clearedpolicy
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TimeOffBalanceMutation) ClearEdge(name string) error {
	switch name {
	case timeoffbalance.EdgeTenant:
		m.ClearTenant()
		return nil
	case timeoffbalance.EdgeEmployee:
		m.ClearEmployee()
		return nil
	case timeoffbalance.EdgePolicy:
		m.ClearPolicy()
		return nil
	}
	return fmt.Errorf("unknown TimeOffBalance unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TimeOffBalanceMutation) ResetEdge(name string) error {
	switch name {
	case timeoffbalance.EdgeTenant:
		m.ResetTenant()
		return nil
	case timeoffbalance.EdgeEmployee:
		m.ResetEmployee()
		return nil
	case timeoffbalance.EdgePolicy:
		m.ResetPolicy()
		return nil
	}
	return fmt.Errorf("unknown TimeOffBalance edge %s", name)
}

// TimeOffPolicyMutation represents an operation that mutates the TimeOffPolicy nodes in the graph.
type TimeOffPolicyMutation struct {
	config
	op                  Op
	typ                 string
	id                  *int
	name                *string
	description         *string
	policy_type         *timeoffpolicy.PolicyType
	leave_type          *timeoffpolicy.LeaveType
	annual_allowance    *float64
	addannual_allowance *float64
	accrual_rate        *float64
	addaccrual_rate     *float64
	carry_over_max      *float64
	addcarry_over_max   *float64
	requires_approval   *bool
	min_notice_days     *int
	addmin_notice_days  *int
	is_active           *bool
	created_at          *time.Time
	updated_at          *time.Time
	clearedFields       map[string]struct{}
	tenant              *int
	clearedtenant       bool
	balances            map[int]struct{}
	removedbalances     map[int]struct{}
	clearedbalances     bool
	done                bool
	oldValue            func(context.Context) (*TimeOffPolicy, error)
	predicates          []predicate.TimeOffPolicy
}

var _ ent.Mutation = (*TimeOffPolicyMutation)(nil)

// timeoffpolicyOption allows management of the mutation configuration using functional options.
type timeoffpolicyOption func(*TimeOffPolicyMutation)

// newTimeOffPolicyMutation creates new mutation for the TimeOffPolicy entity.
func newTimeOffPolicyMutation(c config, op Op, opts ...timeoffpolicyOption) *TimeOffPolicyMutation {
	m := &TimeOffPolicyMutation{
		config:        c,
		op:            op,
		typ:           TypeTimeOffPolicy,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTimeOffPolicyID sets the ID field of the mutation.
func withTimeOffPolicyID(id int) timeoffpolicyOption {
	return func(m *TimeOffPolicyMutation) {
		var (
			err   error
			once  sync.Once
			value *TimeOffPolicy
		)
		m.oldValue = func(ctx context.Context) (*TimeOffPolicy, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().TimeOffPolicy.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTimeOffPolicy sets the old TimeOffPolicy of the mutation.
func withTimeOffPolicy(node *TimeOffPolicy) timeoffpolicyOption {
	return func(m *TimeOffPolicyMutation) {
		m.oldValue = func(context.Context) (*TimeOffPolicy, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TimeOffPolicyMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TimeOffPolicyMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TimeOffPolicyMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TimeOffPolicyMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().TimeOffPolicy.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *TimeOffPolicyMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *TimeOffPolicyMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the TimeOffPolicy entity.
// If the TimeOffPolicy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TimeOffPolicyMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *TimeOffPolicyMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *TimeOffPolicyMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *TimeOffPolicyMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the TimeOffPolicy entity.
// If the TimeOffPolicy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TimeOffPolicyMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *TimeOffPolicyMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[timeoffpolicy.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *TimeOffPolicyMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[timeoffpolicy.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *TimeOffPolicyMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, timeoffpolicy.FieldDescription)
}

// SetPolicyType sets the "policy_type" field.
func (m *TimeOffPolicyMutation) SetPolicyType(tt timeoffpolicy.PolicyType) {
	m.policy_type = &tt
}

// PolicyType returns the value of the "policy_type" field in the mutation.
func (m *TimeOffPolicyMutation) PolicyType() (r timeoffpolicy.PolicyType, exists bool) {
	v := m.policy_type
	if v == nil {
		return
	}
	return *v, true
}

// OldPolicyType returns the old "policy_type" field's value of the TimeOffPolicy entity.
// If the TimeOffPolicy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TimeOffPolicyMutation) OldPolicyType(ctx context.Context) (v timeoffpolicy.PolicyType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPolicyType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPolicyType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPolicyType: %w", err)
	}
	return oldValue.PolicyType, nil
}

// ResetPolicyType resets all changes to the "policy_type" field.
func (m *TimeOffPolicyMutation) ResetPolicyType() {
	m.policy_type = nil
}

// SetLeaveType sets the "leave_type" field.
func (m *TimeOffPolicyMutation) SetLeaveType(tt timeoffpolicy.LeaveType) {
	m.leave_type = &tt
}

// LeaveType returns the value of the "leave_type" field in the mutation.
func (m *TimeOffPolicyMutation) LeaveType() (r timeoffpolicy.LeaveType, exists bool) {
	v := m.leave_type
	if v == nil {
		return
	}
	return *v, true
}

// OldLeaveType returns the old "leave_type" field's value of the TimeOffPolicy entity.
// If the TimeOffPolicy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TimeOffPolicyMutation) OldLeaveType(ctx context.Context) (v timeoffpolicy.LeaveType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLeaveType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLeaveType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLeaveType: %w", err)
	}
	return oldValue.LeaveType, nil
}

// ResetLeaveType resets all changes to the "leave_type" field.
func (m *TimeOffPolicyMutation) ResetLeaveType() {
	m.leave_type = nil
}

// SetAnnualAllowance sets the "annual_allowance" field.
func (m *TimeOffPolicyMutation) SetAnnualAllowance(f float64) {
	m.annual_allowance = &f
	m.addannual_allowance = nil
}

// AnnualAllowance returns the value of the "annual_allowance" field in the mutation.
func (m *TimeOffPolicyMutation) AnnualAllowance() (r float64, exists bool) {
	v := m.annual_allowance
	if v == nil {
		return
	}
	return *v, true
}

// OldAnnualAllowance returns the old "annual_allowance" field's value of the TimeOffPolicy entity.
// If the TimeOffPolicy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TimeOffPolicyMutation) OldAnnualAllowance(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAnnualAllowance is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAnnualAllowance requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAnnualAllowance: %w", err)
	}
	return oldValue.AnnualAllowance, nil
}

// AddAnnualAllowance adds f to the "annual_allowance" field.
func (m *TimeOffPolicyMutation) AddAnnualAllowance(f float64) {
	if m.addannual_allowance != nil {
		*m.addannual_allowance += f
	} else {
		m.addannual_allowance = &f
	}
}

// AddedAnnualAllowance returns the value that was added to the "annual_allowance" field in this mutation.
func (m *TimeOffPolicyMutation) AddedAnnualAllowance() (r float64, exists bool) {
	v := m.addannual_allowance
	if v == nil {
		return
	}
	return *v, true
}

// ResetAnnualAllowance resets all changes to the "annual_allowance" field.
func (m *TimeOffPolicyMutation) ResetAnnualAllowance() {
	m.annual_allowance = nil
	m.addannual_allowance = nil
}

// SetAccrualRate sets the "accrual_rate" field.
func (m *TimeOffPolicyMutation) SetAccrualRate(f float64) {
	m.accrual_rate = &f
	m.addaccrual_rate = nil
}

// AccrualRate returns the value of the "accrual_rate" field in the mutation.
func (m *TimeOffPolicyMutation) AccrualRate() (r float64, exists bool) {
	v := m.accrual_rate
	if v == nil {
		return
	}
	return *v, true
}

// OldAccrualRate returns the old "accrual_rate" field's value of the TimeOffPolicy entity.
// If the TimeOffPolicy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TimeOffPolicyMutation) OldAccrualRate(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAccrualRate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAccrualRate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAccrualRate: %w", err)
	}
	return oldValue.AccrualRate, nil
}

// AddAccrualRate adds f to the "accrual_rate" field.
func (m *TimeOffPolicyMutation) AddAccrualRate(f float64) {
	if m.addaccrual_rate != nil {
		*m.addaccrual_rate += f
	} else {
		m.addaccrual_rate = &f
	}
}

// AddedAccrualRate returns the value that was added to the "accrual_rate" field in this mutation.
func (m *TimeOffPolicyMutation) AddedAccrualRate() (r float64, exists bool) {
	v := m.addaccrual_rate
	if v == nil {
		return
	}
	return *v, true
}

// ClearAccrualRate clears the value of the "accrual_rate" field.
func (m *TimeOffPolicyMutation) ClearAccrualRate() {
	m.accrual_rate = nil
	m.addaccrual_rate = nil
	m.clearedFields[timeoffpolicy.FieldAccrualRate] = struct{}{}
}

// AccrualRateCleared returns if the "accrual_rate" field was cleared in this mutation.
func (m *TimeOffPolicyMutation) AccrualRateCleared() bool {
	_, ok := m.clearedFields[timeoffpolicy.FieldAccrualRate]
	return ok
}

// ResetAccrualRate resets all changes to the "accrual_rate" field.
func (m *TimeOffPolicyMutation) ResetAccrualRate() {
	m.accrual_rate = nil
	m.addaccrual_rate = nil
	delete(m.clearedFields, timeoffpolicy.FieldAccrualRate)
}

// SetCarryOverMax sets the "carry_over_max" field.
func (m *TimeOffPolicyMutation) SetCarryOverMax(f float64) {
	m.carry_over_max = &f
	m.addcarry_over_max = nil
}

// CarryOverMax returns the value of the "carry_over_max" field in the mutation.
func (m *TimeOffPolicyMutation) CarryOverMax() (r float64, exists bool) {
	v := m.carry_over_max
	if v == nil {
		return
	}
	return *v, true
}

// OldCarryOverMax returns the old "carry_over_max" field's value of the TimeOffPolicy entity.
// If the TimeOffPolicy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TimeOffPolicyMutation) OldCarryOverMax(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCarryOverMax is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCarryOverMax requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCarryOverMax: %w", err)
	}
	return oldValue.CarryOverMax, nil
}

// AddCarryOverMax adds f to the "carry_over_max" field.
func (m *TimeOffPolicyMutation) AddCarryOverMax(f float64) {
	if m.addcarry_over_max != nil {
		*m.addcarry_over_max += f
	} else {
		m.addcarry_over_max = &f
	}
}

// AddedCarryOverMax returns the value that was added to the "carry_over_max" field in this mutation.
func (m *TimeOffPolicyMutation) AddedCarryOverMax() (r float64, exists bool) {
	v := m.addcarry_over_max
	if v == nil {
		return
	}
	return *v, true
}

// ResetCarryOverMax resets all changes to the "carry_over_max" field.
func (m *TimeOffPolicyMutation) ResetCarryOverMax() {
	m.carry_over_max = nil
	m.addcarry_over_max = nil
}

// SetRequiresApproval sets the "requires_approval" field.
func (m *TimeOffPolicyMutation) SetRequiresApproval(b bool) {
	m.requires_approval = &b
}

// RequiresApproval returns the value of the "requires_approval" field in the mutation.
func (m *TimeOffPolicyMutation) RequiresApproval() (r bool, exists bool) {
	v := m.requires_approval
	if v == nil {
		return
	}
	return *v, true
}

// OldRequiresApproval returns the old "requires_approval" field's value of the TimeOffPolicy entity.
// If the TimeOffPolicy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TimeOffPolicyMutation) OldRequiresApproval(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRequiresApproval is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRequiresApproval requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRequiresApproval: %w", err)
	}
	return oldValue.RequiresApproval, nil
}

// ResetRequiresApproval resets all changes to the "requires_approval" field.
func (m *TimeOffPolicyMutation) ResetRequiresApproval() {
	m.requires_approval = nil
}

// SetMinNoticeDays sets the "min_notice_days" field.
func (m *TimeOffPolicyMutation) SetMinNoticeDays(i int) {
	m.min_notice_days = &i
	m.addmin_notice_days = nil
}

// MinNoticeDays returns the value of the "min_notice_days" field in the mutation.
func (m *TimeOffPolicyMutation) MinNoticeDays() (r int, exists bool) {
	v := m.min_notice_days
	if v == nil {
		return
	}
	return *v, true
}

// OldMinNoticeDays returns the old "min_notice_days" field's value of the TimeOffPolicy entity.
// If the TimeOffPolicy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TimeOffPolicyMutation) OldMinNoticeDays(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMinNoticeDays is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMinNoticeDays requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMinNoticeDays: %w", err)
	}
	return oldValue.MinNoticeDays, nil
}

// AddMinNoticeDays adds i to the "min_notice_days" field.
func (m *TimeOffPolicyMutation) AddMinNoticeDays(i int) {
	if m.addmin_notice_days != nil {
		*m.addmin_notice_days += i
	} else {
		m.addmin_notice_days = &i
	}
}

// AddedMinNoticeDays returns the value that was added to the "min_notice_days" field in this mutation.
func (m *TimeOffPolicyMutation) AddedMinNoticeDays() (r int, exists bool) {
	v := m.addmin_notice_days
	if v == nil {
		return
	}
	return *v, true
}

// ResetMinNoticeDays resets all changes to the "min_notice_days" field.
func (m *TimeOffPolicyMutation) ResetMinNoticeDays() {
	m.min_notice_days = nil
	m.addmin_notice_days = nil
}

// SetIsActive sets the "is_active" field.
func (m *TimeOffPolicyMutation) SetIsActive(b bool) {
	m.is_active = &b
}

// IsActive returns the value of the "is_active" field in the mutation.
func (m *TimeOffPolicyMutation) IsActive() (r bool, exists bool) {
	v := m.is_active
	if v == nil {
		return
	}
	return *v, true
}

// OldIsActive returns the old "is_active" field's value of the TimeOffPolicy entity.
// If the TimeOffPolicy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TimeOffPolicyMutation) OldIsActive(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsActive is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsActive requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsActive: %w", err)
	}
	return oldValue.IsActive, nil
}

// ResetIsActive resets all changes to the "is_active" field.
func (m *TimeOffPolicyMutation) ResetIsActive() {
	m.is_active = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *TimeOffPolicyMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *TimeOffPolicyMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the TimeOffPolicy entity.
// If the TimeOffPolicy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TimeOffPolicyMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *TimeOffPolicyMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *TimeOffPolicyMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *TimeOffPolicyMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the TimeOffPolicy entity.
// If the TimeOffPolicy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TimeOffPolicyMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *TimeOffPolicyMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetTenantID sets the "tenant" edge to the Tenant entity by id.
func (m *TimeOffPolicyMutation) SetTenantID(id int) {
	m.tenant = &id
}

// ClearTenant clears the "tenant" edge to the Tenant entity.
func (m *TimeOffPolicyMutation) ClearTenant() {
	m.clearedtenant = true
}

// TenantCleared reports if the "tenant" edge to the Tenant entity was cleared.
func (m *TimeOffPolicyMutation) TenantCleared() bool {
	return m.clearedtenant
}

// TenantID returns the "tenant" edge ID in the mutation.
func (m *TimeOffPolicyMutation) TenantID() (id int, exists bool) {
	if m.tenant != nil {
		return *m.tenant, true
	}
	return
}

// TenantIDs returns the "tenant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TenantID instead. It exists only for internal usage by the builders.
func (m *TimeOffPolicyMutation) TenantIDs() (ids []int) {
	if id := m.tenant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTenant resets all changes to the "tenant" edge.
func (m *TimeOffPolicyMutation) ResetTenant() {
	m.tenant = nil
	m.clearedtenant = false
}

// AddBalanceIDs adds the "balances" edge to the TimeOffBalance entity by ids.
func (m *TimeOffPolicyMutation) AddBalanceIDs(ids ...int) {
	if m.balances == nil {
		m.balances = make(map[int]struct{})
	}
	for i := range ids {
		m.balances[ids[i]] = struct{}{}
	}
}

// ClearBalances clears the "balances" edge to the TimeOffBalance entity.
func (m *TimeOffPolicyMutation) ClearBalances() {
	m.clearedbalances = true
}

// BalancesCleared reports if the "balances" edge to the TimeOffBalance entity was cleared.
func (m *TimeOffPolicyMutation) BalancesCleared() bool {
	return m.clearedbalances
}

// RemoveBalanceIDs removes the "balances" edge to the TimeOffBalance entity by IDs.
func (m *TimeOffPolicyMutation) RemoveBalanceIDs(ids ...int) {
	if m.removedbalances == nil {
		m.removedbalances = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.balances, ids[i])
		m.removedbalances[ids[i]] = struct{}{}
	}
}

// RemovedBalances returns the removed IDs of the "balances" edge to the TimeOffBalance entity.
func (m *TimeOffPolicyMutation) RemovedBalancesIDs() (ids []int) {
	for id := range m.removedbalances {
		ids = append(ids, id)
	}
	return
}

// BalancesIDs returns the "balances" edge IDs in the mutation.
func (m *TimeOffPolicyMutation) BalancesIDs() (ids []int) {
	for id := range m.balances {
		ids = append(ids, id)
	}
	return
}

// ResetBalances resets all changes to the "balances" edge.
func (m *TimeOffPolicyMutation) ResetBalances() {
	m.balances = nil
	m.clearedbalances = false
	m.removedbalances = nil
}

// Where appends a list predicates to the TimeOffPolicyMutation builder.
func (m *TimeOffPolicyMutation) Where(ps ...predicate.TimeOffPolicy) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TimeOffPolicyMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TimeOffPolicyMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.TimeOffPolicy, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TimeOffPolicyMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TimeOffPolicyMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (TimeOffPolicy).
func (m *TimeOffPolicyMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TimeOffPolicyMutation) Fields() []string {
	fields := make([]string, 0, 12)
	if m.name != nil {
		fields = append(fields, timeoffpolicy.FieldName)
	}
	if m.description != nil {
		fields = append(fields, timeoffpolicy.FieldDescription)
	}
	if m.policy_type != nil {
		fields = append(fields, timeoffpolicy.FieldPolicyType)
	}
	if m.leave_type != nil {
		fields = append(fields, timeoffpolicy.FieldLeaveType)
	}
	if m.annual_allowance != nil {
		fields = append(fields, timeoffpolicy.FieldAnnualAllowance)
	}
	if m.accrual_rate != nil {
		fields = append(fields, timeoffpolicy.FieldAccrualRate)
	}
	if m.carry_over_max != nil {
		fields = append(fields, timeoffpolicy.FieldCarryOverMax)
	}
	if m.requires_approval != nil {
		fields = append(fields, timeoffpolicy.FieldRequiresApproval)
	}
	if m.min_notice_days != nil {
		fields = append(fields, timeoffpolicy.FieldMinNoticeDays)
	}
	if m.is_active != nil {
		fields = append(fields, timeoffpolicy.FieldIsActive)
	}
	if m.created_at != nil {
		fields = append(fields, timeoffpolicy.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, timeoffpolicy.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TimeOffPolicyMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case timeoffpolicy.FieldName:
		return m.Name()
	case timeoffpolicy.FieldDescription:
		return m.Description()
	case timeoffpolicy.FieldPolicyType:
		return m.PolicyType()
	case timeoffpolicy.FieldLeaveType:
		return m.LeaveType()
	case timeoffpolicy.FieldAnnualAllowance:
		return m.AnnualAllowance()
	case timeoffpolicy.FieldAccrualRate:
		return m.AccrualRate()
	case timeoffpolicy.FieldCarryOverMax:
		return m.CarryOverMax()
	case timeoffpolicy.FieldRequiresApproval:
		return m.RequiresApproval()
	case timeoffpolicy.FieldMinNoticeDays:
		return m.MinNoticeDays()
	case timeoffpolicy.FieldIsActive:
		return m.IsActive()
	case timeoffpolicy.FieldCreatedAt:
		return m.CreatedAt()
	case timeoffpolicy.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TimeOffPolicyMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case timeoffpolicy.FieldName:
		return m.OldName(ctx)
	case timeoffpolicy.FieldDescription:
		return m.OldDescription(ctx)
	case timeoffpolicy.FieldPolicyType:
		return m.OldPolicyType(ctx)
	case timeoffpolicy.FieldLeaveType:
		return m.OldLeaveType(ctx)
	case timeoffpolicy.FieldAnnualAllowance:
		return m.OldAnnualAllowance(ctx)
	case timeoffpolicy.FieldAccrualRate:
		return m.OldAccrualRate(ctx)
	case timeoffpolicy.FieldCarryOverMax:
		return m.OldCarryOverMax(ctx)
	case timeoffpolicy.FieldRequiresApproval:
		return m.OldRequiresApproval(ctx)
	case timeoffpolicy.FieldMinNoticeDays:
		return m.OldMinNoticeDays(ctx)
	case timeoffpolicy.FieldIsActive:
		return m.OldIsActive(ctx)
	case timeoffpolicy.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case timeoffpolicy.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown TimeOffPolicy field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TimeOffPolicyMutation) SetField(name string, value ent.Value) error {
	switch name {
	case timeoffpolicy.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case timeoffpolicy.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case timeoffpolicy.FieldPolicyType:
		v, ok := value.(timeoffpolicy.PolicyType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPolicyType(v)
		return nil
	case timeoffpolicy.FieldLeaveType:
		v, ok := value.(timeoffpolicy.LeaveType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLeaveType(v)
		return nil
	case timeoffpolicy.FieldAnnualAllowance:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAnnualAllowance(v)
		return nil
	case timeoffpolicy.FieldAccrualRate:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAccrualRate(v)
		return nil
	case timeoffpolicy.FieldCarryOverMax:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCarryOverMax(v)
		return nil
	case timeoffpolicy.FieldRequiresApproval:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRequiresApproval(v)
		return nil
	case timeoffpolicy.FieldMinNoticeDays:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMinNoticeDays(v)
		return nil
	case timeoffpolicy.FieldIsActive:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsActive(v)
		return nil
	case timeoffpolicy.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case timeoffpolicy.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown TimeOffPolicy field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TimeOffPolicyMutation) AddedFields() []string {
	var fields []string
	if m.addannual_allowance != nil {
		fields = append(fields, timeoffpolicy.FieldAnnualAllowance)
	}
	if m.addaccrual_rate != nil {
		fields = append(fields, timeoffpolicy.FieldAccrualRate)
	}
	if m.addcarry_over_max != nil {
		fields = append(fields, timeoffpolicy.FieldCarryOverMax)
	}
	if m.addmin_notice_days != nil {
		fields = append(fields, timeoffpolicy.FieldMinNoticeDays)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TimeOffPolicyMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case timeoffpolicy.FieldAnnualAllowance:
		return m.AddedAnnualAllowance()
	case timeoffpolicy.FieldAccrualRate:
		return m.AddedAccrualRate()
	case timeoffpolicy.FieldCarryOverMax:
		return m.AddedCarryOverMax()
	case timeoffpolicy.FieldMinNoticeDays:
		return m.AddedMinNoticeDays()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TimeOffPolicyMutation) AddField(name string, value ent.Value) error {
	switch name {
	case timeoffpolicy.FieldAnnualAllowance:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAnnualAllowance(v)
		return nil
	case timeoffpolicy.FieldAccrualRate:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAccrualRate(v)
		return nil
	case timeoffpolicy.FieldCarryOverMax:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCarryOverMax(v)
		return nil
	case timeoffpolicy.FieldMinNoticeDays:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMinNoticeDays(v)
		return nil
	}
	return fmt.Errorf("unknown TimeOffPolicy numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TimeOffPolicyMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(timeoffpolicy.FieldDescription) {
		fields = append(fields, timeoffpolicy.FieldDescription)
	}
	if m.FieldCleared(timeoffpolicy.FieldAccrualRate) {
		fields = append(fields, timeoffpolicy.FieldAccrualRate)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TimeOffPolicyMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TimeOffPolicyMutation) ClearField(name string) error {
	switch name {
	case timeoffpolicy.FieldDescription:
		m.ClearDescription()
		return nil
	case timeoffpolicy.FieldAccrualRate:
		m.ClearAccrualRate()
		return nil
	}
	return fmt.Errorf("unknown TimeOffPolicy nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TimeOffPolicyMutation) ResetField(name string) error {
	switch name {
	case timeoffpolicy.FieldName:
		m.ResetName()
		return nil
	case timeoffpolicy.FieldDescription:
		m.ResetDescription()
		return nil
	case timeoffpolicy.FieldPolicyType:
		m.ResetPolicyType()
		return nil
	case timeoffpolicy.FieldLeaveType:
		m.ResetLeaveType()
		return nil
	case timeoffpolicy.FieldAnnualAllowance:
		m.ResetAnnualAllowance()
		return nil
	case timeoffpolicy.FieldAccrualRate:
		m.ResetAccrualRate()
		return nil
	case timeoffpolicy.FieldCarryOverMax:
		m.ResetCarryOverMax()
		return nil
	case timeoffpolicy.FieldRequiresApproval:
		m.ResetRequiresApproval()
		return nil
	case timeoffpolicy.FieldMinNoticeDays:
		m.ResetMinNoticeDays()
		return nil
	case timeoffpolicy.FieldIsActive:
		m.ResetIsActive()
		return nil
	case timeoffpolicy.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case timeoffpolicy.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown TimeOffPolicy field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TimeOffPolicyMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.tenant != nil {
		edges = append(edges, timeoffpolicy.EdgeTenant)
	}
	if m.balances != nil {
		edges = append(edges, timeoffpolicy.EdgeBalances)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TimeOffPolicyMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case timeoffpolicy.EdgeTenant:
		if id := m.tenant; id != nil {
			return []ent.Value{*id}
		}
	case timeoffpolicy.EdgeBalances:
		ids := make([]ent.Value, 0, len(m.balances))
		for id := range m.balances {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TimeOffPolicyMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedbalances != nil {
		edges = append(edges, timeoffpolicy.EdgeBalances)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TimeOffPolicyMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case timeoffpolicy.EdgeBalances:
		ids := make([]ent.Value, 0, len(m.removedbalances))
		for id := range m.removedbalances {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TimeOffPolicyMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedtenant {
		edges = append(edges, timeoffpolicy.EdgeTenant)
	}
	if m.clearedbalances {
		edges = append(edges, timeoffpolicy.EdgeBalances)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TimeOffPolicyMutation) EdgeCleared(name string) bool {
	switch name {
	case timeoffpolicy.EdgeTenant:
		return m.clearedtenant
	case timeoffpolicy.EdgeBalances:
		return m.clearedbalances
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TimeOffPolicyMutation) ClearEdge(name string) error {
	switch name {
	case timeoffpolicy.EdgeTenant:
		m.ClearTenant()
		return nil
	}
	return fmt.Errorf("unknown TimeOffPolicy unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TimeOffPolicyMutation) ResetEdge(name string) error {
	switch name {
	case timeoffpolicy.EdgeTenant:
		m.ResetTenant()
		return nil
	case timeoffpolicy.EdgeBalances:
		m.ResetBalances()
		return nil
	}
	return fmt.Errorf("unknown TimeOffPolicy edge %s", name)
}

// TimeOffRequestMutation represents an operation that mutates the TimeOffRequest nodes in the graph.
type TimeOffRequestMutation struct {
	config
	op                 Op
	typ                string
	id                 *int
	request_type       *timeoffrequest.RequestType
	start_date         *time.Time
	end_date           *time.Time
	requested_hours    *float64
	addrequested_hours *float64
	status             *timeoffrequest.Status
	notes              *string
	rejection_reason   *string
	reviewed_at        *time.Time
	created_at         *time.Time
	updated_at         *time.Time
	clearedFields      map[string]struct{}
	tenant             *int
	clearedtenant      bool
	employee           *int
	clearedemployee    bool
	approved_by        *int
	clearedapproved_by bool
	done               bool
	oldValue           func(context.Context) (*TimeOffRequest, error)
	predicates         []predicate.TimeOffRequest
}

var _ ent.Mutation = (*TimeOffRequestMutation)(nil)

// timeoffrequestOption allows management of the mutation configuration using functional options.
type timeoffrequestOption func(*TimeOffRequestMutation)

// newTimeOffRequestMutation creates new mutation for the TimeOffRequest entity.
func newTimeOffRequestMutation(c config, op Op, opts ...timeoffrequestOption) *TimeOffRequestMutation {
	m := &TimeOffRequestMutation{
		config:        c,
		op:            op,
		typ:           TypeTimeOffRequest,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTimeOffRequestID sets the ID field of the mutation.
func withTimeOffRequestID(id int) timeoffrequestOption {
	return func(m *TimeOffRequestMutation) {
		var (
			err   error
			once  sync.Once
			value *TimeOffRequest
		)
		m.oldValue = func(ctx context.Context) (*TimeOffRequest, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().TimeOffRequest.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTimeOffRequest sets the old TimeOffRequest of the mutation.
func withTimeOffRequest(node *TimeOffRequest) timeoffrequestOption {
	return func(m *TimeOffRequestMutation) {
		m.oldValue = func(context.Context) (*TimeOffRequest, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TimeOffRequestMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TimeOffRequestMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TimeOffRequestMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TimeOffRequestMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().TimeOffRequest.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetRequestType sets the "request_type" field.
func (m *TimeOffRequestMutation) SetRequestType(tt timeoffrequest.RequestType) {
	m.request_type = &tt
}

// RequestType returns the value of the "request_type" field in the mutation.
func (m *TimeOffRequestMutation) RequestType() (r timeoffrequest.RequestType, exists bool) {
	v := m.request_type
	if v == nil {
		return
	}
	return *v, true
}

// OldRequestType returns the old "request_type" field's value of the TimeOffRequest entity.
// If the TimeOffRequest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TimeOffRequestMutation) OldRequestType(ctx context.Context) (v timeoffrequest.RequestType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRequestType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRequestType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRequestType: %w", err)
	}
	return oldValue.RequestType, nil
}

// ResetRequestType resets all changes to the "request_type" field.
func (m *TimeOffRequestMutation) ResetRequestType() {
	m.request_type = nil
}

// SetStartDate sets the "start_date" field.
func (m *TimeOffRequestMutation) SetStartDate(t time.Time) {
	m.start_date = &t
}

// StartDate returns the value of the "start_date" field in the mutation.
func (m *TimeOffRequestMutation) StartDate() (r time.Time, exists bool) {
	v := m.start_date
	if v == nil {
		return
	}
	return *v, true
}

// OldStartDate returns the old "start_date" field's value of the TimeOffRequest entity.
// If the TimeOffRequest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TimeOffRequestMutation) OldStartDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartDate: %w", err)
	}
	return oldValue.StartDate, nil
}

// ResetStartDate resets all changes to the "start_date" field.
func (m *TimeOffRequestMutation) ResetStartDate() {
	m.start_date = nil
}

// SetEndDate sets the "end_date" field.
func (m *TimeOffRequestMutation) SetEndDate(t time.Time) {
	m.end_date = &t
}

// EndDate returns the value of the "end_date" field in the mutation.
func (m *TimeOffRequestMutation) EndDate() (r time.Time, exists bool) {
	v := m.end_date
	if v == nil {
		return
	}
	return *v, true
}

// OldEndDate returns the old "end_date" field's value of the TimeOffRequest entity.
// If the TimeOffRequest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TimeOffRequestMutation) OldEndDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEndDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEndDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndDate: %w", err)
	}
	return oldValue.EndDate, nil
}

// ResetEndDate resets all changes to the "end_date" field.
func (m *TimeOffRequestMutation) ResetEndDate() {
	m.end_date = nil
}

// SetRequestedHours sets the "requested_hours" field.
func (m *TimeOffRequestMutation) SetRequestedHours(f float64) {
	m.requested_hours = &f
	m.addrequested_hours = nil
}

// RequestedHours returns the value of the "requested_hours" field in the mutation.
func (m *TimeOffRequestMutation) RequestedHours() (r float64, exists bool) {
	v := m.requested_hours
	if v == nil {
		return
	}
	return *v, true
}

// OldRequestedHours returns the old "requested_hours" field's value of the TimeOffRequest entity.
// If the TimeOffRequest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TimeOffRequestMutation) OldRequestedHours(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRequestedHours is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRequestedHours requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRequestedHours: %w", err)
	}
	return oldValue.RequestedHours, nil
}

// AddRequestedHours adds f to the "requested_hours" field.
func (m *TimeOffRequestMutation) AddRequestedHours(f float64) {
	if m.addrequested_hours != nil {
		*m.addrequested_hours += f
	} else {
		m.addrequested_hours = &f
	}
}

// AddedRequestedHours returns the value that was added to the "requested_hours" field in this mutation.
func (m *TimeOffRequestMutation) AddedRequestedHours() (r float64, exists bool) {
	v := m.addrequested_hours
	if v == nil {
		return
	}
	return *v, true
}

// ResetRequestedHours resets all changes to the "requested_hours" field.
func (m *TimeOffRequestMutation) ResetRequestedHours() {
	m.requested_hours = nil
	m.addrequested_hours = nil
}

// SetStatus sets the "status" field.
func (m *TimeOffRequestMutation) SetStatus(t timeoffrequest.Status) {
	m.status = &t
}

// Status returns the value of the "status" field in the mutation.
func (m *TimeOffRequestMutation) Status() (r timeoffrequest.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the TimeOffRequest entity.
// If the TimeOffRequest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TimeOffRequestMutation) OldStatus(ctx context.Context) (v timeoffrequest.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *TimeOffRequestMutation) ResetStatus() {
	m.status = nil
}

// SetNotes sets the "notes" field.
func (m *TimeOffRequestMutation) SetNotes(s string) {
	m.notes = &s
}

// Notes returns the value of the "notes" field in the mutation.
func (m *TimeOffRequestMutation) Notes() (r string, exists bool) {
	v := m.notes
	if v == nil {
		return
	}
	return *v, true
}

// OldNotes returns the old "notes" field's value of the TimeOffRequest entity.
// If the TimeOffRequest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TimeOffRequestMutation) OldNotes(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNotes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNotes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNotes: %w", err)
	}
	return oldValue.Notes, nil
}

// ClearNotes clears the value of the "notes" field.
func (m *TimeOffRequestMutation) ClearNotes() {
	m.notes = nil
	m.clearedFields[timeoffrequest.FieldNotes] = struct{}{}
}

// NotesCleared returns if the "notes" field was cleared in this mutation.
func (m *TimeOffRequestMutation) NotesCleared() bool {
	_, ok := m.clearedFields[timeoffrequest.FieldNotes]
	return ok
}

// ResetNotes resets all changes to the "notes" field.
func (m *TimeOffRequestMutation) ResetNotes() {
	m.notes = nil
	delete(m.clearedFields, timeoffrequest.FieldNotes)
}

// SetRejectionReason sets the "rejection_reason" field.
func (m *TimeOffRequestMutation) SetRejectionReason(s string) {
	m.rejection_reason = &s
}

// RejectionReason returns the value of the "rejection_reason" field in the mutation.
func (m *TimeOffRequestMutation) RejectionReason() (r string, exists bool) {
	v := m.rejection_reason
	if v == nil {
		return
	}
	return *v, true
}

// OldRejectionReason returns the old "rejection_reason" field's value of the TimeOffRequest entity.
// If the TimeOffRequest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TimeOffRequestMutation) OldRejectionReason(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRejectionReason is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRejectionReason requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRejectionReason: %w", err)
	}
	return oldValue.RejectionReason, nil
}

// ClearRejectionReason clears the value of the "rejection_reason" field.
func (m *TimeOffRequestMutation) ClearRejectionReason() {
	m.rejection_reason = nil
	m.clearedFields[timeoffrequest.FieldRejectionReason] = struct{}{}
}

// RejectionReasonCleared returns if the "rejection_reason" field was cleared in this mutation.
func (m *TimeOffRequestMutation) RejectionReasonCleared() bool {
	_, ok := m.clearedFields[timeoffrequest.FieldRejectionReason]
	return ok
}

// ResetRejectionReason resets all changes to the "rejection_reason" field.
func (m *TimeOffRequestMutation) ResetRejectionReason() {
	m.rejection_reason = nil
	delete(m.clearedFields, timeoffrequest.FieldRejectionReason)
}

// SetReviewedAt sets the "reviewed_at" field.
func (m *TimeOffRequestMutation) SetReviewedAt(t time.Time) {
	m.reviewed_at = &t
}

// ReviewedAt returns the value of the "reviewed_at" field in the mutation.
func (m *TimeOffRequestMutation) ReviewedAt() (r time.Time, exists bool) {
	v := m.reviewed_at
	if v == nil {
		return
	}
	return *v, true
}

// OldReviewedAt returns the old "reviewed_at" field's value of the TimeOffRequest entity.
// If the TimeOffRequest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TimeOffRequestMutation) OldReviewedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReviewedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReviewedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReviewedAt: %w", err)
	}
	return oldValue.ReviewedAt, nil
}

// ClearReviewedAt clears the value of the "reviewed_at" field.
func (m *TimeOffRequestMutation) ClearReviewedAt() {
	m.reviewed_at = nil
	m.clearedFields[timeoffrequest.FieldReviewedAt] = struct{}{}
}

// ReviewedAtCleared returns if the "reviewed_at" field was cleared in this mutation.
func (m *TimeOffRequestMutation) ReviewedAtCleared() bool {
	_, ok := m.clearedFields[timeoffrequest.FieldReviewedAt]
	return ok
}

// ResetReviewedAt resets all changes to the "reviewed_at" field.
func (m *TimeOffRequestMutation) ResetReviewedAt() {
	m.reviewed_at = nil
	delete(m.clearedFields, timeoffrequest.FieldReviewedAt)
}

// SetCreatedAt sets the "created_at" field.
func (m *TimeOffRequestMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *TimeOffRequestMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the TimeOffRequest entity.
// If the TimeOffRequest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TimeOffRequestMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *TimeOffRequestMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *TimeOffRequestMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *TimeOffRequestMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the TimeOffRequest entity.
// If the TimeOffRequest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TimeOffRequestMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *TimeOffRequestMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetTenantID sets the "tenant" edge to the Tenant entity by id.
func (m *TimeOffRequestMutation) SetTenantID(id int) {
	m.tenant = &id
}

// ClearTenant clears the "tenant" edge to the Tenant entity.
func (m *TimeOffRequestMutation) ClearTenant() {
	m.clearedtenant = true
}

// TenantCleared reports if the "tenant" edge to the Tenant entity was cleared.
func (m *TimeOffRequestMutation) TenantCleared() bool {
	return m.clearedtenant
}

// TenantID returns the "tenant" edge ID in the mutation.
func (m *TimeOffRequestMutation) TenantID() (id int, exists bool) {
	if m.tenant != nil {
		return *m.tenant, true
	}
	return
}

// TenantIDs returns the "tenant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TenantID instead. It exists only for internal usage by the builders.
func (m *TimeOffRequestMutation) TenantIDs() (ids []int) {
	if id := m.tenant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTenant resets all changes to the "tenant" edge.
func (m *TimeOffRequestMutation) ResetTenant() {
	m.tenant = nil
	m.clearedtenant = false
}

// SetEmployeeID sets the "employee" edge to the Employee entity by id.
func (m *TimeOffRequestMutation) SetEmployeeID(id int) {
	m.employee = &id
}

// ClearEmployee clears the "employee" edge to the Employee entity.
func (m *TimeOffRequestMutation) ClearEmployee() {
	m.clearedemployee = true
}

// EmployeeCleared reports if the "employee" edge to the Employee entity was cleared.
func (m *TimeOffRequestMutation) EmployeeCleared() bool {
	return m.clearedemployee
}

// EmployeeID returns the "employee" edge ID in the mutation.
func (m *TimeOffRequestMutation) EmployeeID() (id int, exists bool) {
	if m.employee != nil {
		return *m.employee, true
	}
	return
}

// EmployeeIDs returns the "employee" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// EmployeeID instead. It exists only for internal usage by the builders.
func (m *TimeOffRequestMutation) EmployeeIDs() (ids []int) {
	if id := m.employee; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEmployee resets all changes to the "employee" edge.
func (m *TimeOffRequestMutation) ResetEmployee() {
	m.employee = nil
	m.clearedemployee = false
}

// SetApprovedByID sets the "approved_by" edge to the Employee entity by id.
func (m *TimeOffRequestMutation) SetApprovedByID(id int) {
	m.approved_by = &id
}

// ClearApprovedBy clears the "approved_by" edge to the Employee entity.
func (m *TimeOffRequestMutation) ClearApprovedBy() {
	m.clearedapproved_by = true
}

// ApprovedByCleared reports if the "approved_by" edge to the Employee entity was cleared.
func (m *TimeOffRequestMutation) ApprovedByCleared() bool {
	return m.clearedapproved_by
}

// ApprovedByID returns the "approved_by" edge ID in the mutation.
func (m *TimeOffRequestMutation) ApprovedByID() (id int, exists bool) {
	if m.approved_by != nil {
		return *m.approved_by, true
	}
	return
}

// ApprovedByIDs returns the "approved_by" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ApprovedByID instead. It exists only for internal usage by the builders.
func (m *TimeOffRequestMutation) ApprovedByIDs() (ids []int) {
	if id := m.approved_by; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetApprovedBy resets all changes to the "approved_by" edge.
func (m *TimeOffRequestMutation) ResetApprovedBy() {
	m.approved_by = nil
	m.clearedapproved_by = false
}

// Where appends a list predicates to the TimeOffRequestMutation builder.
func (m *TimeOffRequestMutation) Where(ps ...predicate.TimeOffRequest) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TimeOffRequestMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TimeOffRequestMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.TimeOffRequest, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TimeOffRequestMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TimeOffRequestMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (TimeOffRequest).
func (m *TimeOffRequestMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TimeOffRequestMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.request_type != nil {
		fields = append(fields, timeoffrequest.FieldRequestType)
	}
	if m.start_date != nil {
		fields = append(fields, timeoffrequest.FieldStartDate)
	}
	if m.end_date != nil {
		fields = append(fields, timeoffrequest.FieldEndDate)
	}
	if m.requested_hours != nil {
		fields = append(fields, timeoffrequest.FieldRequestedHours)
	}
	if m.status != nil {
		fields = append(fields, timeoffrequest.FieldStatus)
	}
	if m.notes != nil {
		fields = append(fields, timeoffrequest.FieldNotes)
	}
	if m.rejection_reason != nil {
		fields = append(fields, timeoffrequest.FieldRejectionReason)
	}
	if m.reviewed_at != nil {
		fields = append(fields, timeoffrequest.FieldReviewedAt)
	}
	if m.created_at != nil {
		fields = append(fields, timeoffrequest.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, timeoffrequest.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TimeOffRequestMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case timeoffrequest.FieldRequestType:
		return m.RequestType()
	case timeoffrequest.FieldStartDate:
		return m.StartDate()
	case timeoffrequest.FieldEndDate:
		return m.EndDate()
	case timeoffrequest.FieldRequestedHours:
		return m.RequestedHours()
	case timeoffrequest.FieldStatus:
		return m.Status()
	case timeoffrequest.FieldNotes:
		return m.Notes()
	case timeoffrequest.FieldRejectionReason:
		return m.RejectionReason()
	case timeoffrequest.FieldReviewedAt:
		return m.ReviewedAt()
	case timeoffrequest.FieldCreatedAt:
		return m.CreatedAt()
	case timeoffrequest.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TimeOffRequestMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case timeoffrequest.FieldRequestType:
		return m.OldRequestType(ctx)
	case timeoffrequest.FieldStartDate:
		return m.OldStartDate(ctx)
	case timeoffrequest.FieldEndDate:
		return m.OldEndDate(ctx)
	case timeoffrequest.FieldRequestedHours:
		return m.OldRequestedHours(ctx)
	case timeoffrequest.FieldStatus:
		return m.OldStatus(ctx)
	case timeoffrequest.FieldNotes:
		return m.OldNotes(ctx)
	case timeoffrequest.FieldRejectionReason:
		return m.OldRejectionReason(ctx)
	case timeoffrequest.FieldReviewedAt:
		return m.OldReviewedAt(ctx)
	case timeoffrequest.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case timeoffrequest.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown TimeOffRequest field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TimeOffRequestMutation) SetField(name string, value ent.Value) error {
	switch name {
	case timeoffrequest.FieldRequestType:
		v, ok := value.(timeoffrequest.RequestType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRequestType(v)
		return nil
	case timeoffrequest.FieldStartDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartDate(v)
		return nil
	case timeoffrequest.FieldEndDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndDate(v)
		return nil
	case timeoffrequest.FieldRequestedHours:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRequestedHours(v)
		return nil
	case timeoffrequest.FieldStatus:
		v, ok := value.(timeoffrequest.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case timeoffrequest.FieldNotes:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNotes(v)
		return nil
	case timeoffrequest.FieldRejectionReason:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRejectionReason(v)
		return nil
	case timeoffrequest.FieldReviewedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReviewedAt(v)
		return nil
	case timeoffrequest.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case timeoffrequest.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown TimeOffRequest field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TimeOffRequestMutation) AddedFields() []string {
	var fields []string
	if m.addrequested_hours != nil {
		fields = append(fields, timeoffrequest.FieldRequestedHours)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TimeOffRequestMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case timeoffrequest.FieldRequestedHours:
		return m.AddedRequestedHours()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TimeOffRequestMutation) AddField(name string, value ent.Value) error {
	switch name {
	case timeoffrequest.FieldRequestedHours:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRequestedHours(v)
		return nil
	}
	return fmt.Errorf("unknown TimeOffRequest numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TimeOffRequestMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(timeoffrequest.FieldNotes) {
		fields = append(fields, timeoffrequest.FieldNotes)
	}
	if m.FieldCleared(timeoffrequest.FieldRejectionReason) {
		fields = append(fields, timeoffrequest.FieldRejectionReason)
	}
	if m.FieldCleared(timeoffrequest.FieldReviewedAt) {
		fields = append(fields, timeoffrequest.FieldReviewedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TimeOffRequestMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TimeOffRequestMutation) ClearField(name string) error {
	switch name {
	case timeoffrequest.FieldNotes:
		m.ClearNotes()
		return nil
	case timeoffrequest.FieldRejectionReason:
		m.ClearRejectionReason()
		return nil
	case timeoffrequest.FieldReviewedAt:
		m.ClearReviewedAt()
		return nil
	}
	return fmt.Errorf("unknown TimeOffRequest nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TimeOffRequestMutation) ResetField(name string) error {
	switch name {
	case timeoffrequest.FieldRequestType:
		m.ResetRequestType()
		return nil
	case timeoffrequest.FieldStartDate:
		m.ResetStartDate()
		return nil
	case timeoffrequest.FieldEndDate:
		m.ResetEndDate()
		return nil
	case timeoffrequest.FieldRequestedHours:
		m.ResetRequestedHours()
		return nil
	case timeoffrequest.FieldStatus:
		m.ResetStatus()
		return nil
	case timeoffrequest.FieldNotes:
		m.ResetNotes()
		return nil
	case timeoffrequest.FieldRejectionReason:
		m.ResetRejectionReason()
		return nil
	case timeoffrequest.FieldReviewedAt:
		m.ResetReviewedAt()
		return nil
	case timeoffrequest.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case timeoffrequest.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown TimeOffRequest field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TimeOffRequestMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.tenant != nil {
		edges = append(edges, timeoffrequest.EdgeTenant)
	}
	if m.employee != nil {
		edges = append(edges, timeoffrequest.EdgeEmployee)
	}
	if m.approved_by != nil {
		edges = append(edges, timeoffrequest.EdgeApprovedBy)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TimeOffRequestMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case timeoffrequest.EdgeTenant:
		if id := m.tenant; id != nil {
			return []ent.Value{*id}
		}
	case timeoffrequest.EdgeEmployee:
		if id := m.employee; id != nil {
			return []ent.Value{*id}
		}
	case timeoffrequest.EdgeApprovedBy:
		if id := m.approved_by; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TimeOffRequestMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TimeOffRequestMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TimeOffRequestMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedtenant {
		edges = append(edges, timeoffrequest.EdgeTenant)
	}
	if m.clearedemployee {
		edges = append(edges, timeoffrequest.EdgeEmployee)
	}
	if m.clearedapproved_by {
		edges = append(edges, timeoffrequest.EdgeApprovedBy)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TimeOffRequestMutation) EdgeCleared(name string) bool {
	switch name {
	case timeoffrequest.EdgeTenant:
		return m.clearedtenant
	case timeoffrequest.EdgeEmployee:
		return m.clearedemployee
	case timeoffrequest.EdgeApprovedBy:
		return m.clearedapproved_by
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TimeOffRequestMutation) ClearEdge(name string) error {
	switch name {
	case timeoffrequest.EdgeTenant:
		m.ClearTenant()
		return nil
	case timeoffrequest.EdgeEmployee:
		m.ClearEmployee()
		return nil
	case timeoffrequest.EdgeApprovedBy:
		m.ClearApprovedBy()
		return nil
	}
	return fmt.Errorf("unknown TimeOffRequest unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TimeOffRequestMutation) ResetEdge(name string) error {
	switch name {
	case timeoffrequest.EdgeTenant:
		m.ResetTenant()
		return nil
	case timeoffrequest.EdgeEmployee:
		m.ResetEmployee()
		return nil
	case timeoffrequest.EdgeApprovedBy:
		m.ResetApprovedBy()
		return nil
	}
	return fmt.Errorf("unknown TimeOffRequest edge %s", name)
}

// TransactionMutation represents an operation that mutates the Transaction nodes in the graph.
type TransactionMutation struct {
	config
	op                     Op
	typ                    string
	id                     *int
	description            *string
	date                   *time.Time
	total_amount           *decimal.Decimal
	tax_amount             *decimal.Decimal
	_type                  *string
	reference              *string
	uuid                   *string
	approval_status        *transaction.ApprovalStatus
	is_intercompany        *bool
	clearedFields          map[string]struct{}
	tenant                 *int
	clearedtenant          bool
	ledger_entries         map[int]struct{}
	removedledger_entries  map[int]struct{}
	clearedledger_entries  bool
	journal_entries        map[int]struct{}
	removedjournal_entries map[int]struct{}
	clearedjournal_entries bool
	recording              *int
	clearedrecording       bool
	approved_by            *int
	clearedapproved_by     bool
	done                   bool
	oldValue               func(context.Context) (*Transaction, error)
	predicates             []predicate.Transaction
}

var _ ent.Mutation = (*TransactionMutation)(nil)

// transactionOption allows management of the mutation configuration using functional options.
type transactionOption func(*TransactionMutation)

// newTransactionMutation creates new mutation for the Transaction entity.
func newTransactionMutation(c config, op Op, opts ...transactionOption) *TransactionMutation {
	m := &TransactionMutation{
		config:        c,
		op:            op,
		typ:           TypeTransaction,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTransactionID sets the ID field of the mutation.
func withTransactionID(id int) transactionOption {
	return func(m *TransactionMutation) {
		var (
			err   error
			once  sync.Once
			value *Transaction
		)
		m.oldValue = func(ctx context.Context) (*Transaction, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Transaction.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTransaction sets the old Transaction of the mutation.
func withTransaction(node *Transaction) transactionOption {
	return func(m *TransactionMutation) {
		m.oldValue = func(context.Context) (*Transaction, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TransactionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TransactionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TransactionMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TransactionMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Transaction.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetDescription sets the "description" field.
func (m *TransactionMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *TransactionMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Transaction entity.
// If the Transaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransactionMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *TransactionMutation) ResetDescription() {
	m.description = nil
}

// SetDate sets the "date" field.
func (m *TransactionMutation) SetDate(t time.Time) {
	m.date = &t
}

// Date returns the value of the "date" field in the mutation.
func (m *TransactionMutation) Date() (r time.Time, exists bool) {
	v := m.date
	if v == nil {
		return
	}
	return *v, true
}

// OldDate returns the old "date" field's value of the Transaction entity.
// If the Transaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransactionMutation) OldDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDate: %w", err)
	}
	return oldValue.Date, nil
}

// ResetDate resets all changes to the "date" field.
func (m *TransactionMutation) ResetDate() {
	m.date = nil
}

// SetTotalAmount sets the "total_amount" field.
func (m *TransactionMutation) SetTotalAmount(d decimal.Decimal) {
	m.total_amount = &d
}

// TotalAmount returns the value of the "total_amount" field in the mutation.
func (m *TransactionMutation) TotalAmount() (r decimal.Decimal, exists bool) {
	v := m.total_amount
	if v == nil {
		return
	}
	return *v, true
}

// OldTotalAmount returns the old "total_amount" field's value of the Transaction entity.
// If the Transaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransactionMutation) OldTotalAmount(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTotalAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTotalAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTotalAmount: %w", err)
	}
	return oldValue.TotalAmount, nil
}

// ResetTotalAmount resets all changes to the "total_amount" field.
func (m *TransactionMutation) ResetTotalAmount() {
	m.total_amount = nil
}

// SetTaxAmount sets the "tax_amount" field.
func (m *TransactionMutation) SetTaxAmount(d decimal.Decimal) {
	m.tax_amount = &d
}

// TaxAmount returns the value of the "tax_amount" field in the mutation.
func (m *TransactionMutation) TaxAmount() (r decimal.Decimal, exists bool) {
	v := m.tax_amount
	if v == nil {
		return
	}
	return *v, true
}

// OldTaxAmount returns the old "tax_amount" field's value of the Transaction entity.
// If the Transaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransactionMutation) OldTaxAmount(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTaxAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTaxAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTaxAmount: %w", err)
	}
	return oldValue.TaxAmount, nil
}

// ResetTaxAmount resets all changes to the "tax_amount" field.
func (m *TransactionMutation) ResetTaxAmount() {
	m.tax_amount = nil
}

// SetType sets the "type" field.
func (m *TransactionMutation) SetType(s string) {
	m._type = &s
}

// GetType returns the value of the "type" field in the mutation.
func (m *TransactionMutation) GetType() (r string, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Transaction entity.
// If the Transaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransactionMutation) OldType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ClearType clears the value of the "type" field.
func (m *TransactionMutation) ClearType() {
	m._type = nil
	m.clearedFields[transaction.FieldType] = struct{}{}
}

// TypeCleared returns if the "type" field was cleared in this mutation.
func (m *TransactionMutation) TypeCleared() bool {
	_, ok := m.clearedFields[transaction.FieldType]
	return ok
}

// ResetType resets all changes to the "type" field.
func (m *TransactionMutation) ResetType() {
	m._type = nil
	delete(m.clearedFields, transaction.FieldType)
}

// SetReference sets the "reference" field.
func (m *TransactionMutation) SetReference(s string) {
	m.reference = &s
}

// Reference returns the value of the "reference" field in the mutation.
func (m *TransactionMutation) Reference() (r string, exists bool) {
	v := m.reference
	if v == nil {
		return
	}
	return *v, true
}

// OldReference returns the old "reference" field's value of the Transaction entity.
// If the Transaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransactionMutation) OldReference(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReference is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReference requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReference: %w", err)
	}
	return oldValue.Reference, nil
}

// ClearReference clears the value of the "reference" field.
func (m *TransactionMutation) ClearReference() {
	m.reference = nil
	m.clearedFields[transaction.FieldReference] = struct{}{}
}

// ReferenceCleared returns if the "reference" field was cleared in this mutation.
func (m *TransactionMutation) ReferenceCleared() bool {
	_, ok := m.clearedFields[transaction.FieldReference]
	return ok
}

// ResetReference resets all changes to the "reference" field.
func (m *TransactionMutation) ResetReference() {
	m.reference = nil
	delete(m.clearedFields, transaction.FieldReference)
}

// SetUUID sets the "uuid" field.
func (m *TransactionMutation) SetUUID(s string) {
	m.uuid = &s
}

// UUID returns the value of the "uuid" field in the mutation.
func (m *TransactionMutation) UUID() (r string, exists bool) {
	v := m.uuid
	if v == nil {
		return
	}
	return *v, true
}

// OldUUID returns the old "uuid" field's value of the Transaction entity.
// If the Transaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransactionMutation) OldUUID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUUID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUUID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUUID: %w", err)
	}
	return oldValue.UUID, nil
}

// ResetUUID resets all changes to the "uuid" field.
func (m *TransactionMutation) ResetUUID() {
	m.uuid = nil
}

// SetRecordingID sets the "recording_id" field.
func (m *TransactionMutation) SetRecordingID(i int) {
	m.recording = &i
}

// RecordingID returns the value of the "recording_id" field in the mutation.
func (m *TransactionMutation) RecordingID() (r int, exists bool) {
	v := m.recording
	if v == nil {
		return
	}
	return *v, true
}

// OldRecordingID returns the old "recording_id" field's value of the Transaction entity.
// If the Transaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransactionMutation) OldRecordingID(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRecordingID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRecordingID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRecordingID: %w", err)
	}
	return oldValue.RecordingID, nil
}

// ClearRecordingID clears the value of the "recording_id" field.
func (m *TransactionMutation) ClearRecordingID() {
	m.recording = nil
	m.clearedFields[transaction.FieldRecordingID] = struct{}{}
}

// RecordingIDCleared returns if the "recording_id" field was cleared in this mutation.
func (m *TransactionMutation) RecordingIDCleared() bool {
	_, ok := m.clearedFields[transaction.FieldRecordingID]
	return ok
}

// ResetRecordingID resets all changes to the "recording_id" field.
func (m *TransactionMutation) ResetRecordingID() {
	m.recording = nil
	delete(m.clearedFields, transaction.FieldRecordingID)
}

// SetApprovalStatus sets the "approval_status" field.
func (m *TransactionMutation) SetApprovalStatus(ts transaction.ApprovalStatus) {
	m.approval_status = &ts
}

// ApprovalStatus returns the value of the "approval_status" field in the mutation.
func (m *TransactionMutation) ApprovalStatus() (r transaction.ApprovalStatus, exists bool) {
	v := m.approval_status
	if v == nil {
		return
	}
	return *v, true
}

// OldApprovalStatus returns the old "approval_status" field's value of the Transaction entity.
// If the Transaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransactionMutation) OldApprovalStatus(ctx context.Context) (v transaction.ApprovalStatus, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldApprovalStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldApprovalStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldApprovalStatus: %w", err)
	}
	return oldValue.ApprovalStatus, nil
}

// ResetApprovalStatus resets all changes to the "approval_status" field.
func (m *TransactionMutation) ResetApprovalStatus() {
	m.approval_status = nil
}

// SetIsIntercompany sets the "is_intercompany" field.
func (m *TransactionMutation) SetIsIntercompany(b bool) {
	m.is_intercompany = &b
}

// IsIntercompany returns the value of the "is_intercompany" field in the mutation.
func (m *TransactionMutation) IsIntercompany() (r bool, exists bool) {
	v := m.is_intercompany
	if v == nil {
		return
	}
	return *v, true
}

// OldIsIntercompany returns the old "is_intercompany" field's value of the Transaction entity.
// If the Transaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransactionMutation) OldIsIntercompany(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsIntercompany is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsIntercompany requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsIntercompany: %w", err)
	}
	return oldValue.IsIntercompany, nil
}

// ResetIsIntercompany resets all changes to the "is_intercompany" field.
func (m *TransactionMutation) ResetIsIntercompany() {
	m.is_intercompany = nil
}

// SetTenantID sets the "tenant" edge to the Tenant entity by id.
func (m *TransactionMutation) SetTenantID(id int) {
	m.tenant = &id
}

// ClearTenant clears the "tenant" edge to the Tenant entity.
func (m *TransactionMutation) ClearTenant() {
	m.clearedtenant = true
}

// TenantCleared reports if the "tenant" edge to the Tenant entity was cleared.
func (m *TransactionMutation) TenantCleared() bool {
	return m.clearedtenant
}

// TenantID returns the "tenant" edge ID in the mutation.
func (m *TransactionMutation) TenantID() (id int, exists bool) {
	if m.tenant != nil {
		return *m.tenant, true
	}
	return
}

// TenantIDs returns the "tenant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TenantID instead. It exists only for internal usage by the builders.
func (m *TransactionMutation) TenantIDs() (ids []int) {
	if id := m.tenant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTenant resets all changes to the "tenant" edge.
func (m *TransactionMutation) ResetTenant() {
	m.tenant = nil
	m.clearedtenant = false
}

// AddLedgerEntryIDs adds the "ledger_entries" edge to the LedgerEntry entity by ids.
func (m *TransactionMutation) AddLedgerEntryIDs(ids ...int) {
	if m.ledger_entries == nil {
		m.ledger_entries = make(map[int]struct{})
	}
	for i := range ids {
		m.ledger_entries[ids[i]] = struct{}{}
	}
}

// ClearLedgerEntries clears the "ledger_entries" edge to the LedgerEntry entity.
func (m *TransactionMutation) ClearLedgerEntries() {
	m.clearedledger_entries = true
}

// LedgerEntriesCleared reports if the "ledger_entries" edge to the LedgerEntry entity was cleared.
func (m *TransactionMutation) LedgerEntriesCleared() bool {
	return m.clearedledger_entries
}

// RemoveLedgerEntryIDs removes the "ledger_entries" edge to the LedgerEntry entity by IDs.
func (m *TransactionMutation) RemoveLedgerEntryIDs(ids ...int) {
	if m.removedledger_entries == nil {
		m.removedledger_entries = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.ledger_entries, ids[i])
		m.removedledger_entries[ids[i]] = struct{}{}
	}
}

// RemovedLedgerEntries returns the removed IDs of the "ledger_entries" edge to the LedgerEntry entity.
func (m *TransactionMutation) RemovedLedgerEntriesIDs() (ids []int) {
	for id := range m.removedledger_entries {
		ids = append(ids, id)
	}
	return
}

// LedgerEntriesIDs returns the "ledger_entries" edge IDs in the mutation.
func (m *TransactionMutation) LedgerEntriesIDs() (ids []int) {
	for id := range m.ledger_entries {
		ids = append(ids, id)
	}
	return
}

// ResetLedgerEntries resets all changes to the "ledger_entries" edge.
func (m *TransactionMutation) ResetLedgerEntries() {
	m.ledger_entries = nil
	m.clearedledger_entries = false
	m.removedledger_entries = nil
}

// AddJournalEntryIDs adds the "journal_entries" edge to the JournalEntry entity by ids.
func (m *TransactionMutation) AddJournalEntryIDs(ids ...int) {
	if m.journal_entries == nil {
		m.journal_entries = make(map[int]struct{})
	}
	for i := range ids {
		m.journal_entries[ids[i]] = struct{}{}
	}
}

// ClearJournalEntries clears the "journal_entries" edge to the JournalEntry entity.
func (m *TransactionMutation) ClearJournalEntries() {
	m.clearedjournal_entries = true
}

// JournalEntriesCleared reports if the "journal_entries" edge to the JournalEntry entity was cleared.
func (m *TransactionMutation) JournalEntriesCleared() bool {
	return m.clearedjournal_entries
}

// RemoveJournalEntryIDs removes the "journal_entries" edge to the JournalEntry entity by IDs.
func (m *TransactionMutation) RemoveJournalEntryIDs(ids ...int) {
	if m.removedjournal_entries == nil {
		m.removedjournal_entries = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.journal_entries, ids[i])
		m.removedjournal_entries[ids[i]] = struct{}{}
	}
}

// RemovedJournalEntries returns the removed IDs of the "journal_entries" edge to the JournalEntry entity.
func (m *TransactionMutation) RemovedJournalEntriesIDs() (ids []int) {
	for id := range m.removedjournal_entries {
		ids = append(ids, id)
	}
	return
}

// JournalEntriesIDs returns the "journal_entries" edge IDs in the mutation.
func (m *TransactionMutation) JournalEntriesIDs() (ids []int) {
	for id := range m.journal_entries {
		ids = append(ids, id)
	}
	return
}

// ResetJournalEntries resets all changes to the "journal_entries" edge.
func (m *TransactionMutation) ResetJournalEntries() {
	m.journal_entries = nil
	m.clearedjournal_entries = false
	m.removedjournal_entries = nil
}

// ClearRecording clears the "recording" edge to the Recording entity.
func (m *TransactionMutation) ClearRecording() {
	m.clearedrecording = true
	m.clearedFields[transaction.FieldRecordingID] = struct{}{}
}

// RecordingCleared reports if the "recording" edge to the Recording entity was cleared.
func (m *TransactionMutation) RecordingCleared() bool {
	return m.RecordingIDCleared() || m.clearedrecording
}

// RecordingIDs returns the "recording" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RecordingID instead. It exists only for internal usage by the builders.
func (m *TransactionMutation) RecordingIDs() (ids []int) {
	if id := m.recording; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRecording resets all changes to the "recording" edge.
func (m *TransactionMutation) ResetRecording() {
	m.recording = nil
	m.clearedrecording = false
}

// SetApprovedByID sets the "approved_by" edge to the User entity by id.
func (m *TransactionMutation) SetApprovedByID(id int) {
	m.approved_by = &id
}

// ClearApprovedBy clears the "approved_by" edge to the User entity.
func (m *TransactionMutation) ClearApprovedBy() {
	m.clearedapproved_by = true
}

// ApprovedByCleared reports if the "approved_by" edge to the User entity was cleared.
func (m *TransactionMutation) ApprovedByCleared() bool {
	return m.clearedapproved_by
}

// ApprovedByID returns the "approved_by" edge ID in the mutation.
func (m *TransactionMutation) ApprovedByID() (id int, exists bool) {
	if m.approved_by != nil {
		return *m.approved_by, true
	}
	return
}

// ApprovedByIDs returns the "approved_by" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ApprovedByID instead. It exists only for internal usage by the builders.
func (m *TransactionMutation) ApprovedByIDs() (ids []int) {
	if id := m.approved_by; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetApprovedBy resets all changes to the "approved_by" edge.
func (m *TransactionMutation) ResetApprovedBy() {
	m.approved_by = nil
	m.clearedapproved_by = false
}

// Where appends a list predicates to the TransactionMutation builder.
func (m *TransactionMutation) Where(ps ...predicate.Transaction) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TransactionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TransactionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Transaction, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TransactionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TransactionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Transaction).
func (m *TransactionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TransactionMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.description != nil {
		fields = append(fields, transaction.FieldDescription)
	}
	if m.date != nil {
		fields = append(fields, transaction.FieldDate)
	}
	if m.total_amount != nil {
		fields = append(fields, transaction.FieldTotalAmount)
	}
	if m.tax_amount != nil {
		fields = append(fields, transaction.FieldTaxAmount)
	}
	if m._type != nil {
		fields = append(fields, transaction.FieldType)
	}
	if m.reference != nil {
		fields = append(fields, transaction.FieldReference)
	}
	if m.uuid != nil {
		fields = append(fields, transaction.FieldUUID)
	}
	if m.recording != nil {
		fields = append(fields, transaction.FieldRecordingID)
	}
	if m.approval_status != nil {
		fields = append(fields, transaction.FieldApprovalStatus)
	}
	if m.is_intercompany != nil {
		fields = append(fields, transaction.FieldIsIntercompany)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TransactionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case transaction.FieldDescription:
		return m.Description()
	case transaction.FieldDate:
		return m.Date()
	case transaction.FieldTotalAmount:
		return m.TotalAmount()
	case transaction.FieldTaxAmount:
		return m.TaxAmount()
	case transaction.FieldType:
		return m.GetType()
	case transaction.FieldReference:
		return m.Reference()
	case transaction.FieldUUID:
		return m.UUID()
	case transaction.FieldRecordingID:
		return m.RecordingID()
	case transaction.FieldApprovalStatus:
		return m.ApprovalStatus()
	case transaction.FieldIsIntercompany:
		return m.IsIntercompany()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TransactionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case transaction.FieldDescription:
		return m.OldDescription(ctx)
	case transaction.FieldDate:
		return m.OldDate(ctx)
	case transaction.FieldTotalAmount:
		return m.OldTotalAmount(ctx)
	case transaction.FieldTaxAmount:
		return m.OldTaxAmount(ctx)
	case transaction.FieldType:
		return m.OldType(ctx)
	case transaction.FieldReference:
		return m.OldReference(ctx)
	case transaction.FieldUUID:
		return m.OldUUID(ctx)
	case transaction.FieldRecordingID:
		return m.OldRecordingID(ctx)
	case transaction.FieldApprovalStatus:
		return m.OldApprovalStatus(ctx)
	case transaction.FieldIsIntercompany:
		return m.OldIsIntercompany(ctx)
	}
	return nil, fmt.Errorf("unknown Transaction field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TransactionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case transaction.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case transaction.FieldDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDate(v)
		return nil
	case transaction.FieldTotalAmount:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTotalAmount(v)
		return nil
	case transaction.FieldTaxAmount:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTaxAmount(v)
		return nil
	case transaction.FieldType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case transaction.FieldReference:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReference(v)
		return nil
	case transaction.FieldUUID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUUID(v)
		return nil
	case transaction.FieldRecordingID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRecordingID(v)
		return nil
	case transaction.FieldApprovalStatus:
		v, ok := value.(transaction.ApprovalStatus)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetApprovalStatus(v)
		return nil
	case transaction.FieldIsIntercompany:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsIntercompany(v)
		return nil
	}
	return fmt.Errorf("unknown Transaction field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TransactionMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TransactionMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TransactionMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Transaction numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TransactionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(transaction.FieldType) {
		fields = append(fields, transaction.FieldType)
	}
	if m.FieldCleared(transaction.FieldReference) {
		fields = append(fields, transaction.FieldReference)
	}
	if m.FieldCleared(transaction.FieldRecordingID) {
		fields = append(fields, transaction.FieldRecordingID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TransactionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TransactionMutation) ClearField(name string) error {
	switch name {
	case transaction.FieldType:
		m.ClearType()
		return nil
	case transaction.FieldReference:
		m.ClearReference()
		return nil
	case transaction.FieldRecordingID:
		m.ClearRecordingID()
		return nil
	}
	return fmt.Errorf("unknown Transaction nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TransactionMutation) ResetField(name string) error {
	switch name {
	case transaction.FieldDescription:
		m.ResetDescription()
		return nil
	case transaction.FieldDate:
		m.ResetDate()
		return nil
	case transaction.FieldTotalAmount:
		m.ResetTotalAmount()
		return nil
	case transaction.FieldTaxAmount:
		m.ResetTaxAmount()
		return nil
	case transaction.FieldType:
		m.ResetType()
		return nil
	case transaction.FieldReference:
		m.ResetReference()
		return nil
	case transaction.FieldUUID:
		m.ResetUUID()
		return nil
	case transaction.FieldRecordingID:
		m.ResetRecordingID()
		return nil
	case transaction.FieldApprovalStatus:
		m.ResetApprovalStatus()
		return nil
	case transaction.FieldIsIntercompany:
		m.ResetIsIntercompany()
		return nil
	}
	return fmt.Errorf("unknown Transaction field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TransactionMutation) AddedEdges() []string {
	edges := make([]string, 0, 5)
	if m.tenant != nil {
		edges = append(edges, transaction.EdgeTenant)
	}
	if m.ledger_entries != nil {
		edges = append(edges, transaction.EdgeLedgerEntries)
	}
	if m.journal_entries != nil {
		edges = append(edges, transaction.EdgeJournalEntries)
	}
	if m.recording != nil {
		edges = append(edges, transaction.EdgeRecording)
	}
	if m.approved_by != nil {
		edges = append(edges, transaction.EdgeApprovedBy)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TransactionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case transaction.EdgeTenant:
		if id := m.tenant; id != nil {
			return []ent.Value{*id}
		}
	case transaction.EdgeLedgerEntries:
		ids := make([]ent.Value, 0, len(m.ledger_entries))
		for id := range m.ledger_entries {
			ids = append(ids, id)
		}
		return ids
	case transaction.EdgeJournalEntries:
		ids := make([]ent.Value, 0, len(m.journal_entries))
		for id := range m.journal_entries {
			ids = append(ids, id)
		}
		return ids
	case transaction.EdgeRecording:
		if id := m.recording; id != nil {
			return []ent.Value{*id}
		}
	case transaction.EdgeApprovedBy:
		if id := m.approved_by; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TransactionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 5)
	if m.removedledger_entries != nil {
		edges = append(edges, transaction.EdgeLedgerEntries)
	}
	if m.removedjournal_entries != nil {
		edges = append(edges, transaction.EdgeJournalEntries)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TransactionMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case transaction.EdgeLedgerEntries:
		ids := make([]ent.Value, 0, len(m.removedledger_entries))
		for id := range m.removedledger_entries {
			ids = append(ids, id)
		}
		return ids
	case transaction.EdgeJournalEntries:
		ids := make([]ent.Value, 0, len(m.removedjournal_entries))
		for id := range m.removedjournal_entries {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TransactionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 5)
	if m.clearedtenant {
		edges = append(edges, transaction.EdgeTenant)
	}
	if m.clearedledger_entries {
		edges = append(edges, transaction.EdgeLedgerEntries)
	}
	if m.clearedjournal_entries {
		edges = append(edges, transaction.EdgeJournalEntries)
	}
	if m.clearedrecording {
		edges = append(edges, transaction.EdgeRecording)
	}
	if m.clearedapproved_by {
		edges = append(edges, transaction.EdgeApprovedBy)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TransactionMutation) EdgeCleared(name string) bool {
	switch name {
	case transaction.EdgeTenant:
		return m.clearedtenant
	case transaction.EdgeLedgerEntries:
		return m.clearedledger_entries
	case transaction.EdgeJournalEntries:
		return m.clearedjournal_entries
	case transaction.EdgeRecording:
		return m.clearedrecording
	case transaction.EdgeApprovedBy:
		return m.clearedapproved_by
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TransactionMutation) ClearEdge(name string) error {
	switch name {
	case transaction.EdgeTenant:
		m.ClearTenant()
		return nil
	case transaction.EdgeRecording:
		m.ClearRecording()
		return nil
	case transaction.EdgeApprovedBy:
		m.ClearApprovedBy()
		return nil
	}
	return fmt.Errorf("unknown Transaction unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TransactionMutation) ResetEdge(name string) error {
	switch name {
	case transaction.EdgeTenant:
		m.ResetTenant()
		return nil
	case transaction.EdgeLedgerEntries:
		m.ResetLedgerEntries()
		return nil
	case transaction.EdgeJournalEntries:
		m.ResetJournalEntries()
		return nil
	case transaction.EdgeRecording:
		m.ResetRecording()
		return nil
	case transaction.EdgeApprovedBy:
		m.ResetApprovedBy()
		return nil
	}
	return fmt.Errorf("unknown Transaction edge %s", name)
}

// UserMutation represents an operation that mutates the User nodes in the graph.
type UserMutation struct {
	config
	op                         Op
	typ                        string
	id                         *int
	zitadel_id                 *string
	email                      *string
	first_name                 *string
	last_name                  *string
	job_title                  *string
	department                 *string
	external_mappings          *map[string]interface{}
	created_at                 *time.Time
	role                       *string
	seniority                  *user.Seniority
	max_wip                    *int
	addmax_wip                 *int
	clearedFields              map[string]struct{}
	tenant                     *int
	clearedtenant              bool
	permissions                map[int]struct{}
	removedpermissions         map[int]struct{}
	clearedpermissions         bool
	requested_tickets          map[int]struct{}
	removedrequested_tickets   map[int]struct{}
	clearedrequested_tickets   bool
	assigned_tickets           map[int]struct{}
	removedassigned_tickets    map[int]struct{}
	clearedassigned_tickets    bool
	work_logs                  map[int]struct{}
	removedwork_logs           map[int]struct{}
	clearedwork_logs           bool
	owned_assets               map[int]struct{}
	removedowned_assets        map[int]struct{}
	clearedowned_assets        bool
	authored_sops              map[int]struct{}
	removedauthored_sops       map[int]struct{}
	clearedauthored_sops       bool
	call_logs                  map[int]struct{}
	removedcall_logs           map[int]struct{}
	clearedcall_logs           bool
	voicemails                 map[int]struct{}
	removedvoicemails          map[int]struct{}
	clearedvoicemails          bool
	saas_identities            map[int]struct{}
	removedsaas_identities     map[int]struct{}
	clearedsaas_identities     bool
	favorites                  map[int]struct{}
	removedfavorites           map[int]struct{}
	clearedfavorites           bool
	vault_comments             map[int]struct{}
	removedvault_comments      map[int]struct{}
	clearedvault_comments      bool
	created_versions           map[int]struct{}
	removedcreated_versions    map[int]struct{}
	clearedcreated_versions    bool
	created_legal_holds        map[int]struct{}
	removedcreated_legal_holds map[int]struct{}
	clearedcreated_legal_holds bool
	created_templates          map[int]struct{}
	removedcreated_templates   map[int]struct{}
	clearedcreated_templates   bool
	done                       bool
	oldValue                   func(context.Context) (*User, error)
	predicates                 []predicate.User
}

var _ ent.Mutation = (*UserMutation)(nil)

// userOption allows management of the mutation configuration using functional options.
type userOption func(*UserMutation)

// newUserMutation creates new mutation for the User entity.
func newUserMutation(c config, op Op, opts ...userOption) *UserMutation {
	m := &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserID sets the ID field of the mutation.
func withUserID(id int) userOption {
	return func(m *UserMutation) {
		var (
			err   error
			once  sync.Once
			value *User
		)
		m.oldValue = func(ctx context.Context) (*User, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().User.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUser sets the old User of the mutation.
func withUser(node *User) userOption {
	return func(m *UserMutation) {
		m.oldValue = func(context.Context) (*User, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().User.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetZitadelID sets the "zitadel_id" field.
func (m *UserMutation) SetZitadelID(s string) {
	m.zitadel_id = &s
}

// ZitadelID returns the value of the "zitadel_id" field in the mutation.
func (m *UserMutation) ZitadelID() (r string, exists bool) {
	v := m.zitadel_id
	if v == nil {
		return
	}
	return *v, true
}

// OldZitadelID returns the old "zitadel_id" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldZitadelID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldZitadelID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldZitadelID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldZitadelID: %w", err)
	}
	return oldValue.ZitadelID, nil
}

// ResetZitadelID resets all changes to the "zitadel_id" field.
func (m *UserMutation) ResetZitadelID() {
	m.zitadel_id = nil
}

// SetEmail sets the "email" field.
func (m *UserMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *UserMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail resets all changes to the "email" field.
func (m *UserMutation) ResetEmail() {
	m.email = nil
}

// SetFirstName sets the "first_name" field.
func (m *UserMutation) SetFirstName(s string) {
	m.first_name = &s
}

// FirstName returns the value of the "first_name" field in the mutation.
func (m *UserMutation) FirstName() (r string, exists bool) {
	v := m.first_name
	if v == nil {
		return
	}
	return *v, true
}

// OldFirstName returns the old "first_name" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldFirstName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFirstName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFirstName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFirstName: %w", err)
	}
	return oldValue.FirstName, nil
}

// ClearFirstName clears the value of the "first_name" field.
func (m *UserMutation) ClearFirstName() {
	m.first_name = nil
	m.clearedFields[user.FieldFirstName] = struct{}{}
}

// FirstNameCleared returns if the "first_name" field was cleared in this mutation.
func (m *UserMutation) FirstNameCleared() bool {
	_, ok := m.clearedFields[user.FieldFirstName]
	return ok
}

// ResetFirstName resets all changes to the "first_name" field.
func (m *UserMutation) ResetFirstName() {
	m.first_name = nil
	delete(m.clearedFields, user.FieldFirstName)
}

// SetLastName sets the "last_name" field.
func (m *UserMutation) SetLastName(s string) {
	m.last_name = &s
}

// LastName returns the value of the "last_name" field in the mutation.
func (m *UserMutation) LastName() (r string, exists bool) {
	v := m.last_name
	if v == nil {
		return
	}
	return *v, true
}

// OldLastName returns the old "last_name" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldLastName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastName: %w", err)
	}
	return oldValue.LastName, nil
}

// ClearLastName clears the value of the "last_name" field.
func (m *UserMutation) ClearLastName() {
	m.last_name = nil
	m.clearedFields[user.FieldLastName] = struct{}{}
}

// LastNameCleared returns if the "last_name" field was cleared in this mutation.
func (m *UserMutation) LastNameCleared() bool {
	_, ok := m.clearedFields[user.FieldLastName]
	return ok
}

// ResetLastName resets all changes to the "last_name" field.
func (m *UserMutation) ResetLastName() {
	m.last_name = nil
	delete(m.clearedFields, user.FieldLastName)
}

// SetJobTitle sets the "job_title" field.
func (m *UserMutation) SetJobTitle(s string) {
	m.job_title = &s
}

// JobTitle returns the value of the "job_title" field in the mutation.
func (m *UserMutation) JobTitle() (r string, exists bool) {
	v := m.job_title
	if v == nil {
		return
	}
	return *v, true
}

// OldJobTitle returns the old "job_title" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldJobTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldJobTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldJobTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldJobTitle: %w", err)
	}
	return oldValue.JobTitle, nil
}

// ClearJobTitle clears the value of the "job_title" field.
func (m *UserMutation) ClearJobTitle() {
	m.job_title = nil
	m.clearedFields[user.FieldJobTitle] = struct{}{}
}

// JobTitleCleared returns if the "job_title" field was cleared in this mutation.
func (m *UserMutation) JobTitleCleared() bool {
	_, ok := m.clearedFields[user.FieldJobTitle]
	return ok
}

// ResetJobTitle resets all changes to the "job_title" field.
func (m *UserMutation) ResetJobTitle() {
	m.job_title = nil
	delete(m.clearedFields, user.FieldJobTitle)
}

// SetDepartment sets the "department" field.
func (m *UserMutation) SetDepartment(s string) {
	m.department = &s
}

// Department returns the value of the "department" field in the mutation.
func (m *UserMutation) Department() (r string, exists bool) {
	v := m.department
	if v == nil {
		return
	}
	return *v, true
}

// OldDepartment returns the old "department" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldDepartment(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDepartment is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDepartment requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDepartment: %w", err)
	}
	return oldValue.Department, nil
}

// ClearDepartment clears the value of the "department" field.
func (m *UserMutation) ClearDepartment() {
	m.department = nil
	m.clearedFields[user.FieldDepartment] = struct{}{}
}

// DepartmentCleared returns if the "department" field was cleared in this mutation.
func (m *UserMutation) DepartmentCleared() bool {
	_, ok := m.clearedFields[user.FieldDepartment]
	return ok
}

// ResetDepartment resets all changes to the "department" field.
func (m *UserMutation) ResetDepartment() {
	m.department = nil
	delete(m.clearedFields, user.FieldDepartment)
}

// SetExternalMappings sets the "external_mappings" field.
func (m *UserMutation) SetExternalMappings(value map[string]interface{}) {
	m.external_mappings = &value
}

// ExternalMappings returns the value of the "external_mappings" field in the mutation.
func (m *UserMutation) ExternalMappings() (r map[string]interface{}, exists bool) {
	v := m.external_mappings
	if v == nil {
		return
	}
	return *v, true
}

// OldExternalMappings returns the old "external_mappings" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldExternalMappings(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExternalMappings is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExternalMappings requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExternalMappings: %w", err)
	}
	return oldValue.ExternalMappings, nil
}

// ClearExternalMappings clears the value of the "external_mappings" field.
func (m *UserMutation) ClearExternalMappings() {
	m.external_mappings = nil
	m.clearedFields[user.FieldExternalMappings] = struct{}{}
}

// ExternalMappingsCleared returns if the "external_mappings" field was cleared in this mutation.
func (m *UserMutation) ExternalMappingsCleared() bool {
	_, ok := m.clearedFields[user.FieldExternalMappings]
	return ok
}

// ResetExternalMappings resets all changes to the "external_mappings" field.
func (m *UserMutation) ResetExternalMappings() {
	m.external_mappings = nil
	delete(m.clearedFields, user.FieldExternalMappings)
}

// SetCreatedAt sets the "created_at" field.
func (m *UserMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UserMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UserMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetRole sets the "role" field.
func (m *UserMutation) SetRole(s string) {
	m.role = &s
}

// Role returns the value of the "role" field in the mutation.
func (m *UserMutation) Role() (r string, exists bool) {
	v := m.role
	if v == nil {
		return
	}
	return *v, true
}

// OldRole returns the old "role" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldRole(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRole is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRole requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRole: %w", err)
	}
	return oldValue.Role, nil
}

// ResetRole resets all changes to the "role" field.
func (m *UserMutation) ResetRole() {
	m.role = nil
}

// SetSeniority sets the "seniority" field.
func (m *UserMutation) SetSeniority(u user.Seniority) {
	m.seniority = &u
}

// Seniority returns the value of the "seniority" field in the mutation.
func (m *UserMutation) Seniority() (r user.Seniority, exists bool) {
	v := m.seniority
	if v == nil {
		return
	}
	return *v, true
}

// OldSeniority returns the old "seniority" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldSeniority(ctx context.Context) (v user.Seniority, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSeniority is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSeniority requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSeniority: %w", err)
	}
	return oldValue.Seniority, nil
}

// ResetSeniority resets all changes to the "seniority" field.
func (m *UserMutation) ResetSeniority() {
	m.seniority = nil
}

// SetMaxWip sets the "max_wip" field.
func (m *UserMutation) SetMaxWip(i int) {
	m.max_wip = &i
	m.addmax_wip = nil
}

// MaxWip returns the value of the "max_wip" field in the mutation.
func (m *UserMutation) MaxWip() (r int, exists bool) {
	v := m.max_wip
	if v == nil {
		return
	}
	return *v, true
}

// OldMaxWip returns the old "max_wip" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldMaxWip(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMaxWip is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMaxWip requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMaxWip: %w", err)
	}
	return oldValue.MaxWip, nil
}

// AddMaxWip adds i to the "max_wip" field.
func (m *UserMutation) AddMaxWip(i int) {
	if m.addmax_wip != nil {
		*m.addmax_wip += i
	} else {
		m.addmax_wip = &i
	}
}

// AddedMaxWip returns the value that was added to the "max_wip" field in this mutation.
func (m *UserMutation) AddedMaxWip() (r int, exists bool) {
	v := m.addmax_wip
	if v == nil {
		return
	}
	return *v, true
}

// ResetMaxWip resets all changes to the "max_wip" field.
func (m *UserMutation) ResetMaxWip() {
	m.max_wip = nil
	m.addmax_wip = nil
}

// SetTenantID sets the "tenant" edge to the Tenant entity by id.
func (m *UserMutation) SetTenantID(id int) {
	m.tenant = &id
}

// ClearTenant clears the "tenant" edge to the Tenant entity.
func (m *UserMutation) ClearTenant() {
	m.clearedtenant = true
}

// TenantCleared reports if the "tenant" edge to the Tenant entity was cleared.
func (m *UserMutation) TenantCleared() bool {
	return m.clearedtenant
}

// TenantID returns the "tenant" edge ID in the mutation.
func (m *UserMutation) TenantID() (id int, exists bool) {
	if m.tenant != nil {
		return *m.tenant, true
	}
	return
}

// TenantIDs returns the "tenant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TenantID instead. It exists only for internal usage by the builders.
func (m *UserMutation) TenantIDs() (ids []int) {
	if id := m.tenant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTenant resets all changes to the "tenant" edge.
func (m *UserMutation) ResetTenant() {
	m.tenant = nil
	m.clearedtenant = false
}

// AddPermissionIDs adds the "permissions" edge to the Permission entity by ids.
func (m *UserMutation) AddPermissionIDs(ids ...int) {
	if m.permissions == nil {
		m.permissions = make(map[int]struct{})
	}
	for i := range ids {
		m.permissions[ids[i]] = struct{}{}
	}
}

// ClearPermissions clears the "permissions" edge to the Permission entity.
func (m *UserMutation) ClearPermissions() {
	m.clearedpermissions = true
}

// PermissionsCleared reports if the "permissions" edge to the Permission entity was cleared.
func (m *UserMutation) PermissionsCleared() bool {
	return m.clearedpermissions
}

// RemovePermissionIDs removes the "permissions" edge to the Permission entity by IDs.
func (m *UserMutation) RemovePermissionIDs(ids ...int) {
	if m.removedpermissions == nil {
		m.removedpermissions = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.permissions, ids[i])
		m.removedpermissions[ids[i]] = struct{}{}
	}
}

// RemovedPermissions returns the removed IDs of the "permissions" edge to the Permission entity.
func (m *UserMutation) RemovedPermissionsIDs() (ids []int) {
	for id := range m.removedpermissions {
		ids = append(ids, id)
	}
	return
}

// PermissionsIDs returns the "permissions" edge IDs in the mutation.
func (m *UserMutation) PermissionsIDs() (ids []int) {
	for id := range m.permissions {
		ids = append(ids, id)
	}
	return
}

// ResetPermissions resets all changes to the "permissions" edge.
func (m *UserMutation) ResetPermissions() {
	m.permissions = nil
	m.clearedpermissions = false
	m.removedpermissions = nil
}

// AddRequestedTicketIDs adds the "requested_tickets" edge to the Ticket entity by ids.
func (m *UserMutation) AddRequestedTicketIDs(ids ...int) {
	if m.requested_tickets == nil {
		m.requested_tickets = make(map[int]struct{})
	}
	for i := range ids {
		m.requested_tickets[ids[i]] = struct{}{}
	}
}

// ClearRequestedTickets clears the "requested_tickets" edge to the Ticket entity.
func (m *UserMutation) ClearRequestedTickets() {
	m.clearedrequested_tickets = true
}

// RequestedTicketsCleared reports if the "requested_tickets" edge to the Ticket entity was cleared.
func (m *UserMutation) RequestedTicketsCleared() bool {
	return m.clearedrequested_tickets
}

// RemoveRequestedTicketIDs removes the "requested_tickets" edge to the Ticket entity by IDs.
func (m *UserMutation) RemoveRequestedTicketIDs(ids ...int) {
	if m.removedrequested_tickets == nil {
		m.removedrequested_tickets = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.requested_tickets, ids[i])
		m.removedrequested_tickets[ids[i]] = struct{}{}
	}
}

// RemovedRequestedTickets returns the removed IDs of the "requested_tickets" edge to the Ticket entity.
func (m *UserMutation) RemovedRequestedTicketsIDs() (ids []int) {
	for id := range m.removedrequested_tickets {
		ids = append(ids, id)
	}
	return
}

// RequestedTicketsIDs returns the "requested_tickets" edge IDs in the mutation.
func (m *UserMutation) RequestedTicketsIDs() (ids []int) {
	for id := range m.requested_tickets {
		ids = append(ids, id)
	}
	return
}

// ResetRequestedTickets resets all changes to the "requested_tickets" edge.
func (m *UserMutation) ResetRequestedTickets() {
	m.requested_tickets = nil
	m.clearedrequested_tickets = false
	m.removedrequested_tickets = nil
}

// AddAssignedTicketIDs adds the "assigned_tickets" edge to the Ticket entity by ids.
func (m *UserMutation) AddAssignedTicketIDs(ids ...int) {
	if m.assigned_tickets == nil {
		m.assigned_tickets = make(map[int]struct{})
	}
	for i := range ids {
		m.assigned_tickets[ids[i]] = struct{}{}
	}
}

// ClearAssignedTickets clears the "assigned_tickets" edge to the Ticket entity.
func (m *UserMutation) ClearAssignedTickets() {
	m.clearedassigned_tickets = true
}

// AssignedTicketsCleared reports if the "assigned_tickets" edge to the Ticket entity was cleared.
func (m *UserMutation) AssignedTicketsCleared() bool {
	return m.clearedassigned_tickets
}

// RemoveAssignedTicketIDs removes the "assigned_tickets" edge to the Ticket entity by IDs.
func (m *UserMutation) RemoveAssignedTicketIDs(ids ...int) {
	if m.removedassigned_tickets == nil {
		m.removedassigned_tickets = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.assigned_tickets, ids[i])
		m.removedassigned_tickets[ids[i]] = struct{}{}
	}
}

// RemovedAssignedTickets returns the removed IDs of the "assigned_tickets" edge to the Ticket entity.
func (m *UserMutation) RemovedAssignedTicketsIDs() (ids []int) {
	for id := range m.removedassigned_tickets {
		ids = append(ids, id)
	}
	return
}

// AssignedTicketsIDs returns the "assigned_tickets" edge IDs in the mutation.
func (m *UserMutation) AssignedTicketsIDs() (ids []int) {
	for id := range m.assigned_tickets {
		ids = append(ids, id)
	}
	return
}

// ResetAssignedTickets resets all changes to the "assigned_tickets" edge.
func (m *UserMutation) ResetAssignedTickets() {
	m.assigned_tickets = nil
	m.clearedassigned_tickets = false
	m.removedassigned_tickets = nil
}

// AddWorkLogIDs adds the "work_logs" edge to the WorkLog entity by ids.
func (m *UserMutation) AddWorkLogIDs(ids ...int) {
	if m.work_logs == nil {
		m.work_logs = make(map[int]struct{})
	}
	for i := range ids {
		m.work_logs[ids[i]] = struct{}{}
	}
}

// ClearWorkLogs clears the "work_logs" edge to the WorkLog entity.
func (m *UserMutation) ClearWorkLogs() {
	m.clearedwork_logs = true
}

// WorkLogsCleared reports if the "work_logs" edge to the WorkLog entity was cleared.
func (m *UserMutation) WorkLogsCleared() bool {
	return m.clearedwork_logs
}

// RemoveWorkLogIDs removes the "work_logs" edge to the WorkLog entity by IDs.
func (m *UserMutation) RemoveWorkLogIDs(ids ...int) {
	if m.removedwork_logs == nil {
		m.removedwork_logs = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.work_logs, ids[i])
		m.removedwork_logs[ids[i]] = struct{}{}
	}
}

// RemovedWorkLogs returns the removed IDs of the "work_logs" edge to the WorkLog entity.
func (m *UserMutation) RemovedWorkLogsIDs() (ids []int) {
	for id := range m.removedwork_logs {
		ids = append(ids, id)
	}
	return
}

// WorkLogsIDs returns the "work_logs" edge IDs in the mutation.
func (m *UserMutation) WorkLogsIDs() (ids []int) {
	for id := range m.work_logs {
		ids = append(ids, id)
	}
	return
}

// ResetWorkLogs resets all changes to the "work_logs" edge.
func (m *UserMutation) ResetWorkLogs() {
	m.work_logs = nil
	m.clearedwork_logs = false
	m.removedwork_logs = nil
}

// AddOwnedAssetIDs adds the "owned_assets" edge to the Asset entity by ids.
func (m *UserMutation) AddOwnedAssetIDs(ids ...int) {
	if m.owned_assets == nil {
		m.owned_assets = make(map[int]struct{})
	}
	for i := range ids {
		m.owned_assets[ids[i]] = struct{}{}
	}
}

// ClearOwnedAssets clears the "owned_assets" edge to the Asset entity.
func (m *UserMutation) ClearOwnedAssets() {
	m.clearedowned_assets = true
}

// OwnedAssetsCleared reports if the "owned_assets" edge to the Asset entity was cleared.
func (m *UserMutation) OwnedAssetsCleared() bool {
	return m.clearedowned_assets
}

// RemoveOwnedAssetIDs removes the "owned_assets" edge to the Asset entity by IDs.
func (m *UserMutation) RemoveOwnedAssetIDs(ids ...int) {
	if m.removedowned_assets == nil {
		m.removedowned_assets = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.owned_assets, ids[i])
		m.removedowned_assets[ids[i]] = struct{}{}
	}
}

// RemovedOwnedAssets returns the removed IDs of the "owned_assets" edge to the Asset entity.
func (m *UserMutation) RemovedOwnedAssetsIDs() (ids []int) {
	for id := range m.removedowned_assets {
		ids = append(ids, id)
	}
	return
}

// OwnedAssetsIDs returns the "owned_assets" edge IDs in the mutation.
func (m *UserMutation) OwnedAssetsIDs() (ids []int) {
	for id := range m.owned_assets {
		ids = append(ids, id)
	}
	return
}

// ResetOwnedAssets resets all changes to the "owned_assets" edge.
func (m *UserMutation) ResetOwnedAssets() {
	m.owned_assets = nil
	m.clearedowned_assets = false
	m.removedowned_assets = nil
}

// AddAuthoredSopIDs adds the "authored_sops" edge to the SOP entity by ids.
func (m *UserMutation) AddAuthoredSopIDs(ids ...int) {
	if m.authored_sops == nil {
		m.authored_sops = make(map[int]struct{})
	}
	for i := range ids {
		m.authored_sops[ids[i]] = struct{}{}
	}
}

// ClearAuthoredSops clears the "authored_sops" edge to the SOP entity.
func (m *UserMutation) ClearAuthoredSops() {
	m.clearedauthored_sops = true
}

// AuthoredSopsCleared reports if the "authored_sops" edge to the SOP entity was cleared.
func (m *UserMutation) AuthoredSopsCleared() bool {
	return m.clearedauthored_sops
}

// RemoveAuthoredSopIDs removes the "authored_sops" edge to the SOP entity by IDs.
func (m *UserMutation) RemoveAuthoredSopIDs(ids ...int) {
	if m.removedauthored_sops == nil {
		m.removedauthored_sops = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.authored_sops, ids[i])
		m.removedauthored_sops[ids[i]] = struct{}{}
	}
}

// RemovedAuthoredSops returns the removed IDs of the "authored_sops" edge to the SOP entity.
func (m *UserMutation) RemovedAuthoredSopsIDs() (ids []int) {
	for id := range m.removedauthored_sops {
		ids = append(ids, id)
	}
	return
}

// AuthoredSopsIDs returns the "authored_sops" edge IDs in the mutation.
func (m *UserMutation) AuthoredSopsIDs() (ids []int) {
	for id := range m.authored_sops {
		ids = append(ids, id)
	}
	return
}

// ResetAuthoredSops resets all changes to the "authored_sops" edge.
func (m *UserMutation) ResetAuthoredSops() {
	m.authored_sops = nil
	m.clearedauthored_sops = false
	m.removedauthored_sops = nil
}

// AddCallLogIDs adds the "call_logs" edge to the CallLog entity by ids.
func (m *UserMutation) AddCallLogIDs(ids ...int) {
	if m.call_logs == nil {
		m.call_logs = make(map[int]struct{})
	}
	for i := range ids {
		m.call_logs[ids[i]] = struct{}{}
	}
}

// ClearCallLogs clears the "call_logs" edge to the CallLog entity.
func (m *UserMutation) ClearCallLogs() {
	m.clearedcall_logs = true
}

// CallLogsCleared reports if the "call_logs" edge to the CallLog entity was cleared.
func (m *UserMutation) CallLogsCleared() bool {
	return m.clearedcall_logs
}

// RemoveCallLogIDs removes the "call_logs" edge to the CallLog entity by IDs.
func (m *UserMutation) RemoveCallLogIDs(ids ...int) {
	if m.removedcall_logs == nil {
		m.removedcall_logs = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.call_logs, ids[i])
		m.removedcall_logs[ids[i]] = struct{}{}
	}
}

// RemovedCallLogs returns the removed IDs of the "call_logs" edge to the CallLog entity.
func (m *UserMutation) RemovedCallLogsIDs() (ids []int) {
	for id := range m.removedcall_logs {
		ids = append(ids, id)
	}
	return
}

// CallLogsIDs returns the "call_logs" edge IDs in the mutation.
func (m *UserMutation) CallLogsIDs() (ids []int) {
	for id := range m.call_logs {
		ids = append(ids, id)
	}
	return
}

// ResetCallLogs resets all changes to the "call_logs" edge.
func (m *UserMutation) ResetCallLogs() {
	m.call_logs = nil
	m.clearedcall_logs = false
	m.removedcall_logs = nil
}

// AddVoicemailIDs adds the "voicemails" edge to the Voicemail entity by ids.
func (m *UserMutation) AddVoicemailIDs(ids ...int) {
	if m.voicemails == nil {
		m.voicemails = make(map[int]struct{})
	}
	for i := range ids {
		m.voicemails[ids[i]] = struct{}{}
	}
}

// ClearVoicemails clears the "voicemails" edge to the Voicemail entity.
func (m *UserMutation) ClearVoicemails() {
	m.clearedvoicemails = true
}

// VoicemailsCleared reports if the "voicemails" edge to the Voicemail entity was cleared.
func (m *UserMutation) VoicemailsCleared() bool {
	return m.clearedvoicemails
}

// RemoveVoicemailIDs removes the "voicemails" edge to the Voicemail entity by IDs.
func (m *UserMutation) RemoveVoicemailIDs(ids ...int) {
	if m.removedvoicemails == nil {
		m.removedvoicemails = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.voicemails, ids[i])
		m.removedvoicemails[ids[i]] = struct{}{}
	}
}

// RemovedVoicemails returns the removed IDs of the "voicemails" edge to the Voicemail entity.
func (m *UserMutation) RemovedVoicemailsIDs() (ids []int) {
	for id := range m.removedvoicemails {
		ids = append(ids, id)
	}
	return
}

// VoicemailsIDs returns the "voicemails" edge IDs in the mutation.
func (m *UserMutation) VoicemailsIDs() (ids []int) {
	for id := range m.voicemails {
		ids = append(ids, id)
	}
	return
}

// ResetVoicemails resets all changes to the "voicemails" edge.
func (m *UserMutation) ResetVoicemails() {
	m.voicemails = nil
	m.clearedvoicemails = false
	m.removedvoicemails = nil
}

// AddSaasIdentityIDs adds the "saas_identities" edge to the SaaSIdentity entity by ids.
func (m *UserMutation) AddSaasIdentityIDs(ids ...int) {
	if m.saas_identities == nil {
		m.saas_identities = make(map[int]struct{})
	}
	for i := range ids {
		m.saas_identities[ids[i]] = struct{}{}
	}
}

// ClearSaasIdentities clears the "saas_identities" edge to the SaaSIdentity entity.
func (m *UserMutation) ClearSaasIdentities() {
	m.clearedsaas_identities = true
}

// SaasIdentitiesCleared reports if the "saas_identities" edge to the SaaSIdentity entity was cleared.
func (m *UserMutation) SaasIdentitiesCleared() bool {
	return m.clearedsaas_identities
}

// RemoveSaasIdentityIDs removes the "saas_identities" edge to the SaaSIdentity entity by IDs.
func (m *UserMutation) RemoveSaasIdentityIDs(ids ...int) {
	if m.removedsaas_identities == nil {
		m.removedsaas_identities = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.saas_identities, ids[i])
		m.removedsaas_identities[ids[i]] = struct{}{}
	}
}

// RemovedSaasIdentities returns the removed IDs of the "saas_identities" edge to the SaaSIdentity entity.
func (m *UserMutation) RemovedSaasIdentitiesIDs() (ids []int) {
	for id := range m.removedsaas_identities {
		ids = append(ids, id)
	}
	return
}

// SaasIdentitiesIDs returns the "saas_identities" edge IDs in the mutation.
func (m *UserMutation) SaasIdentitiesIDs() (ids []int) {
	for id := range m.saas_identities {
		ids = append(ids, id)
	}
	return
}

// ResetSaasIdentities resets all changes to the "saas_identities" edge.
func (m *UserMutation) ResetSaasIdentities() {
	m.saas_identities = nil
	m.clearedsaas_identities = false
	m.removedsaas_identities = nil
}

// AddFavoriteIDs adds the "favorites" edge to the VaultFavorite entity by ids.
func (m *UserMutation) AddFavoriteIDs(ids ...int) {
	if m.favorites == nil {
		m.favorites = make(map[int]struct{})
	}
	for i := range ids {
		m.favorites[ids[i]] = struct{}{}
	}
}

// ClearFavorites clears the "favorites" edge to the VaultFavorite entity.
func (m *UserMutation) ClearFavorites() {
	m.clearedfavorites = true
}

// FavoritesCleared reports if the "favorites" edge to the VaultFavorite entity was cleared.
func (m *UserMutation) FavoritesCleared() bool {
	return m.clearedfavorites
}

// RemoveFavoriteIDs removes the "favorites" edge to the VaultFavorite entity by IDs.
func (m *UserMutation) RemoveFavoriteIDs(ids ...int) {
	if m.removedfavorites == nil {
		m.removedfavorites = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.favorites, ids[i])
		m.removedfavorites[ids[i]] = struct{}{}
	}
}

// RemovedFavorites returns the removed IDs of the "favorites" edge to the VaultFavorite entity.
func (m *UserMutation) RemovedFavoritesIDs() (ids []int) {
	for id := range m.removedfavorites {
		ids = append(ids, id)
	}
	return
}

// FavoritesIDs returns the "favorites" edge IDs in the mutation.
func (m *UserMutation) FavoritesIDs() (ids []int) {
	for id := range m.favorites {
		ids = append(ids, id)
	}
	return
}

// ResetFavorites resets all changes to the "favorites" edge.
func (m *UserMutation) ResetFavorites() {
	m.favorites = nil
	m.clearedfavorites = false
	m.removedfavorites = nil
}

// AddVaultCommentIDs adds the "vault_comments" edge to the VaultComment entity by ids.
func (m *UserMutation) AddVaultCommentIDs(ids ...int) {
	if m.vault_comments == nil {
		m.vault_comments = make(map[int]struct{})
	}
	for i := range ids {
		m.vault_comments[ids[i]] = struct{}{}
	}
}

// ClearVaultComments clears the "vault_comments" edge to the VaultComment entity.
func (m *UserMutation) ClearVaultComments() {
	m.clearedvault_comments = true
}

// VaultCommentsCleared reports if the "vault_comments" edge to the VaultComment entity was cleared.
func (m *UserMutation) VaultCommentsCleared() bool {
	return m.clearedvault_comments
}

// RemoveVaultCommentIDs removes the "vault_comments" edge to the VaultComment entity by IDs.
func (m *UserMutation) RemoveVaultCommentIDs(ids ...int) {
	if m.removedvault_comments == nil {
		m.removedvault_comments = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.vault_comments, ids[i])
		m.removedvault_comments[ids[i]] = struct{}{}
	}
}

// RemovedVaultComments returns the removed IDs of the "vault_comments" edge to the VaultComment entity.
func (m *UserMutation) RemovedVaultCommentsIDs() (ids []int) {
	for id := range m.removedvault_comments {
		ids = append(ids, id)
	}
	return
}

// VaultCommentsIDs returns the "vault_comments" edge IDs in the mutation.
func (m *UserMutation) VaultCommentsIDs() (ids []int) {
	for id := range m.vault_comments {
		ids = append(ids, id)
	}
	return
}

// ResetVaultComments resets all changes to the "vault_comments" edge.
func (m *UserMutation) ResetVaultComments() {
	m.vault_comments = nil
	m.clearedvault_comments = false
	m.removedvault_comments = nil
}

// AddCreatedVersionIDs adds the "created_versions" edge to the VaultVersion entity by ids.
func (m *UserMutation) AddCreatedVersionIDs(ids ...int) {
	if m.created_versions == nil {
		m.created_versions = make(map[int]struct{})
	}
	for i := range ids {
		m.created_versions[ids[i]] = struct{}{}
	}
}

// ClearCreatedVersions clears the "created_versions" edge to the VaultVersion entity.
func (m *UserMutation) ClearCreatedVersions() {
	m.clearedcreated_versions = true
}

// CreatedVersionsCleared reports if the "created_versions" edge to the VaultVersion entity was cleared.
func (m *UserMutation) CreatedVersionsCleared() bool {
	return m.clearedcreated_versions
}

// RemoveCreatedVersionIDs removes the "created_versions" edge to the VaultVersion entity by IDs.
func (m *UserMutation) RemoveCreatedVersionIDs(ids ...int) {
	if m.removedcreated_versions == nil {
		m.removedcreated_versions = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.created_versions, ids[i])
		m.removedcreated_versions[ids[i]] = struct{}{}
	}
}

// RemovedCreatedVersions returns the removed IDs of the "created_versions" edge to the VaultVersion entity.
func (m *UserMutation) RemovedCreatedVersionsIDs() (ids []int) {
	for id := range m.removedcreated_versions {
		ids = append(ids, id)
	}
	return
}

// CreatedVersionsIDs returns the "created_versions" edge IDs in the mutation.
func (m *UserMutation) CreatedVersionsIDs() (ids []int) {
	for id := range m.created_versions {
		ids = append(ids, id)
	}
	return
}

// ResetCreatedVersions resets all changes to the "created_versions" edge.
func (m *UserMutation) ResetCreatedVersions() {
	m.created_versions = nil
	m.clearedcreated_versions = false
	m.removedcreated_versions = nil
}

// AddCreatedLegalHoldIDs adds the "created_legal_holds" edge to the LegalHold entity by ids.
func (m *UserMutation) AddCreatedLegalHoldIDs(ids ...int) {
	if m.created_legal_holds == nil {
		m.created_legal_holds = make(map[int]struct{})
	}
	for i := range ids {
		m.created_legal_holds[ids[i]] = struct{}{}
	}
}

// ClearCreatedLegalHolds clears the "created_legal_holds" edge to the LegalHold entity.
func (m *UserMutation) ClearCreatedLegalHolds() {
	m.clearedcreated_legal_holds = true
}

// CreatedLegalHoldsCleared reports if the "created_legal_holds" edge to the LegalHold entity was cleared.
func (m *UserMutation) CreatedLegalHoldsCleared() bool {
	return m.clearedcreated_legal_holds
}

// RemoveCreatedLegalHoldIDs removes the "created_legal_holds" edge to the LegalHold entity by IDs.
func (m *UserMutation) RemoveCreatedLegalHoldIDs(ids ...int) {
	if m.removedcreated_legal_holds == nil {
		m.removedcreated_legal_holds = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.created_legal_holds, ids[i])
		m.removedcreated_legal_holds[ids[i]] = struct{}{}
	}
}

// RemovedCreatedLegalHolds returns the removed IDs of the "created_legal_holds" edge to the LegalHold entity.
func (m *UserMutation) RemovedCreatedLegalHoldsIDs() (ids []int) {
	for id := range m.removedcreated_legal_holds {
		ids = append(ids, id)
	}
	return
}

// CreatedLegalHoldsIDs returns the "created_legal_holds" edge IDs in the mutation.
func (m *UserMutation) CreatedLegalHoldsIDs() (ids []int) {
	for id := range m.created_legal_holds {
		ids = append(ids, id)
	}
	return
}

// ResetCreatedLegalHolds resets all changes to the "created_legal_holds" edge.
func (m *UserMutation) ResetCreatedLegalHolds() {
	m.created_legal_holds = nil
	m.clearedcreated_legal_holds = false
	m.removedcreated_legal_holds = nil
}

// AddCreatedTemplateIDs adds the "created_templates" edge to the VaultTemplate entity by ids.
func (m *UserMutation) AddCreatedTemplateIDs(ids ...int) {
	if m.created_templates == nil {
		m.created_templates = make(map[int]struct{})
	}
	for i := range ids {
		m.created_templates[ids[i]] = struct{}{}
	}
}

// ClearCreatedTemplates clears the "created_templates" edge to the VaultTemplate entity.
func (m *UserMutation) ClearCreatedTemplates() {
	m.clearedcreated_templates = true
}

// CreatedTemplatesCleared reports if the "created_templates" edge to the VaultTemplate entity was cleared.
func (m *UserMutation) CreatedTemplatesCleared() bool {
	return m.clearedcreated_templates
}

// RemoveCreatedTemplateIDs removes the "created_templates" edge to the VaultTemplate entity by IDs.
func (m *UserMutation) RemoveCreatedTemplateIDs(ids ...int) {
	if m.removedcreated_templates == nil {
		m.removedcreated_templates = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.created_templates, ids[i])
		m.removedcreated_templates[ids[i]] = struct{}{}
	}
}

// RemovedCreatedTemplates returns the removed IDs of the "created_templates" edge to the VaultTemplate entity.
func (m *UserMutation) RemovedCreatedTemplatesIDs() (ids []int) {
	for id := range m.removedcreated_templates {
		ids = append(ids, id)
	}
	return
}

// CreatedTemplatesIDs returns the "created_templates" edge IDs in the mutation.
func (m *UserMutation) CreatedTemplatesIDs() (ids []int) {
	for id := range m.created_templates {
		ids = append(ids, id)
	}
	return
}

// ResetCreatedTemplates resets all changes to the "created_templates" edge.
func (m *UserMutation) ResetCreatedTemplates() {
	m.created_templates = nil
	m.clearedcreated_templates = false
	m.removedcreated_templates = nil
}

// Where appends a list predicates to the UserMutation builder.
func (m *UserMutation) Where(ps ...predicate.User) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.User, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.zitadel_id != nil {
		fields = append(fields, user.FieldZitadelID)
	}
	if m.email != nil {
		fields = append(fields, user.FieldEmail)
	}
	if m.first_name != nil {
		fields = append(fields, user.FieldFirstName)
	}
	if m.last_name != nil {
		fields = append(fields, user.FieldLastName)
	}
	if m.job_title != nil {
		fields = append(fields, user.FieldJobTitle)
	}
	if m.department != nil {
		fields = append(fields, user.FieldDepartment)
	}
	if m.external_mappings != nil {
		fields = append(fields, user.FieldExternalMappings)
	}
	if m.created_at != nil {
		fields = append(fields, user.FieldCreatedAt)
	}
	if m.role != nil {
		fields = append(fields, user.FieldRole)
	}
	if m.seniority != nil {
		fields = append(fields, user.FieldSeniority)
	}
	if m.max_wip != nil {
		fields = append(fields, user.FieldMaxWip)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user.FieldZitadelID:
		return m.ZitadelID()
	case user.FieldEmail:
		return m.Email()
	case user.FieldFirstName:
		return m.FirstName()
	case user.FieldLastName:
		return m.LastName()
	case user.FieldJobTitle:
		return m.JobTitle()
	case user.FieldDepartment:
		return m.Department()
	case user.FieldExternalMappings:
		return m.ExternalMappings()
	case user.FieldCreatedAt:
		return m.CreatedAt()
	case user.FieldRole:
		return m.Role()
	case user.FieldSeniority:
		return m.Seniority()
	case user.FieldMaxWip:
		return m.MaxWip()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case user.FieldZitadelID:
		return m.OldZitadelID(ctx)
	case user.FieldEmail:
		return m.OldEmail(ctx)
	case user.FieldFirstName:
		return m.OldFirstName(ctx)
	case user.FieldLastName:
		return m.OldLastName(ctx)
	case user.FieldJobTitle:
		return m.OldJobTitle(ctx)
	case user.FieldDepartment:
		return m.OldDepartment(ctx)
	case user.FieldExternalMappings:
		return m.OldExternalMappings(ctx)
	case user.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case user.FieldRole:
		return m.OldRole(ctx)
	case user.FieldSeniority:
		return m.OldSeniority(ctx)
	case user.FieldMaxWip:
		return m.OldMaxWip(ctx)
	}
	return nil, fmt.Errorf("unknown User field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user.FieldZitadelID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetZitadelID(v)
		return nil
	case user.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case user.FieldFirstName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFirstName(v)
		return nil
	case user.FieldLastName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastName(v)
		return nil
	case user.FieldJobTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetJobTitle(v)
		return nil
	case user.FieldDepartment:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDepartment(v)
		return nil
	case user.FieldExternalMappings:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExternalMappings(v)
		return nil
	case user.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case user.FieldRole:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRole(v)
		return nil
	case user.FieldSeniority:
		v, ok := value.(user.Seniority)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSeniority(v)
		return nil
	case user.FieldMaxWip:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMaxWip(v)
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserMutation) AddedFields() []string {
	var fields []string
	if m.addmax_wip != nil {
		fields = append(fields, user.FieldMaxWip)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case user.FieldMaxWip:
		return m.AddedMaxWip()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	switch name {
	case user.FieldMaxWip:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMaxWip(v)
		return nil
	}
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(user.FieldFirstName) {
		fields = append(fields, user.FieldFirstName)
	}
	if m.FieldCleared(user.FieldLastName) {
		fields = append(fields, user.FieldLastName)
	}
	if m.FieldCleared(user.FieldJobTitle) {
		fields = append(fields, user.FieldJobTitle)
	}
	if m.FieldCleared(user.FieldDepartment) {
		fields = append(fields, user.FieldDepartment)
	}
	if m.FieldCleared(user.FieldExternalMappings) {
		fields = append(fields, user.FieldExternalMappings)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	switch name {
	case user.FieldFirstName:
		m.ClearFirstName()
		return nil
	case user.FieldLastName:
		m.ClearLastName()
		return nil
	case user.FieldJobTitle:
		m.ClearJobTitle()
		return nil
	case user.FieldDepartment:
		m.ClearDepartment()
		return nil
	case user.FieldExternalMappings:
		m.ClearExternalMappings()
		return nil
	}
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	switch name {
	case user.FieldZitadelID:
		m.ResetZitadelID()
		return nil
	case user.FieldEmail:
		m.ResetEmail()
		return nil
	case user.FieldFirstName:
		m.ResetFirstName()
		return nil
	case user.FieldLastName:
		m.ResetLastName()
		return nil
	case user.FieldJobTitle:
		m.ResetJobTitle()
		return nil
	case user.FieldDepartment:
		m.ResetDepartment()
		return nil
	case user.FieldExternalMappings:
		m.ResetExternalMappings()
		return nil
	case user.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case user.FieldRole:
		m.ResetRole()
		return nil
	case user.FieldSeniority:
		m.ResetSeniority()
		return nil
	case user.FieldMaxWip:
		m.ResetMaxWip()
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 15)
	if m.tenant != nil {
		edges = append(edges, user.EdgeTenant)
	}
	if m.permissions != nil {
		edges = append(edges, user.EdgePermissions)
	}
	if m.requested_tickets != nil {
		edges = append(edges, user.EdgeRequestedTickets)
	}
	if m.assigned_tickets != nil {
		edges = append(edges, user.EdgeAssignedTickets)
	}
	if m.work_logs != nil {
		edges = append(edges, user.EdgeWorkLogs)
	}
	if m.owned_assets != nil {
		edges = append(edges, user.EdgeOwnedAssets)
	}
	if m.authored_sops != nil {
		edges = append(edges, user.EdgeAuthoredSops)
	}
	if m.call_logs != nil {
		edges = append(edges, user.EdgeCallLogs)
	}
	if m.voicemails != nil {
		edges = append(edges, user.EdgeVoicemails)
	}
	if m.saas_identities != nil {
		edges = append(edges, user.EdgeSaasIdentities)
	}
	if m.favorites != nil {
		edges = append(edges, user.EdgeFavorites)
	}
	if m.vault_comments != nil {
		edges = append(edges, user.EdgeVaultComments)
	}
	if m.created_versions != nil {
		edges = append(edges, user.EdgeCreatedVersions)
	}
	if m.created_legal_holds != nil {
		edges = append(edges, user.EdgeCreatedLegalHolds)
	}
	if m.created_templates != nil {
		edges = append(edges, user.EdgeCreatedTemplates)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeTenant:
		if id := m.tenant; id != nil {
			return []ent.Value{*id}
		}
	case user.EdgePermissions:
		ids := make([]ent.Value, 0, len(m.permissions))
		for id := range m.permissions {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeRequestedTickets:
		ids := make([]ent.Value, 0, len(m.requested_tickets))
		for id := range m.requested_tickets {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeAssignedTickets:
		ids := make([]ent.Value, 0, len(m.assigned_tickets))
		for id := range m.assigned_tickets {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeWorkLogs:
		ids := make([]ent.Value, 0, len(m.work_logs))
		for id := range m.work_logs {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeOwnedAssets:
		ids := make([]ent.Value, 0, len(m.owned_assets))
		for id := range m.owned_assets {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeAuthoredSops:
		ids := make([]ent.Value, 0, len(m.authored_sops))
		for id := range m.authored_sops {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeCallLogs:
		ids := make([]ent.Value, 0, len(m.call_logs))
		for id := range m.call_logs {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeVoicemails:
		ids := make([]ent.Value, 0, len(m.voicemails))
		for id := range m.voicemails {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeSaasIdentities:
		ids := make([]ent.Value, 0, len(m.saas_identities))
		for id := range m.saas_identities {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeFavorites:
		ids := make([]ent.Value, 0, len(m.favorites))
		for id := range m.favorites {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeVaultComments:
		ids := make([]ent.Value, 0, len(m.vault_comments))
		for id := range m.vault_comments {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeCreatedVersions:
		ids := make([]ent.Value, 0, len(m.created_versions))
		for id := range m.created_versions {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeCreatedLegalHolds:
		ids := make([]ent.Value, 0, len(m.created_legal_holds))
		for id := range m.created_legal_holds {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeCreatedTemplates:
		ids := make([]ent.Value, 0, len(m.created_templates))
		for id := range m.created_templates {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 15)
	if m.removedpermissions != nil {
		edges = append(edges, user.EdgePermissions)
	}
	if m.removedrequested_tickets != nil {
		edges = append(edges, user.EdgeRequestedTickets)
	}
	if m.removedassigned_tickets != nil {
		edges = append(edges, user.EdgeAssignedTickets)
	}
	if m.removedwork_logs != nil {
		edges = append(edges, user.EdgeWorkLogs)
	}
	if m.removedowned_assets != nil {
		edges = append(edges, user.EdgeOwnedAssets)
	}
	if m.removedauthored_sops != nil {
		edges = append(edges, user.EdgeAuthoredSops)
	}
	if m.removedcall_logs != nil {
		edges = append(edges, user.EdgeCallLogs)
	}
	if m.removedvoicemails != nil {
		edges = append(edges, user.EdgeVoicemails)
	}
	if m.removedsaas_identities != nil {
		edges = append(edges, user.EdgeSaasIdentities)
	}
	if m.removedfavorites != nil {
		edges = append(edges, user.EdgeFavorites)
	}
	if m.removedvault_comments != nil {
		edges = append(edges, user.EdgeVaultComments)
	}
	if m.removedcreated_versions != nil {
		edges = append(edges, user.EdgeCreatedVersions)
	}
	if m.removedcreated_legal_holds != nil {
		edges = append(edges, user.EdgeCreatedLegalHolds)
	}
	if m.removedcreated_templates != nil {
		edges = append(edges, user.EdgeCreatedTemplates)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case user.EdgePermissions:
		ids := make([]ent.Value, 0, len(m.removedpermissions))
		for id := range m.removedpermissions {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeRequestedTickets:
		ids := make([]ent.Value, 0, len(m.removedrequested_tickets))
		for id := range m.removedrequested_tickets {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeAssignedTickets:
		ids := make([]ent.Value, 0, len(m.removedassigned_tickets))
		for id := range m.removedassigned_tickets {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeWorkLogs:
		ids := make([]ent.Value, 0, len(m.removedwork_logs))
		for id := range m.removedwork_logs {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeOwnedAssets:
		ids := make([]ent.Value, 0, len(m.removedowned_assets))
		for id := range m.removedowned_assets {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeAuthoredSops:
		ids := make([]ent.Value, 0, len(m.removedauthored_sops))
		for id := range m.removedauthored_sops {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeCallLogs:
		ids := make([]ent.Value, 0, len(m.removedcall_logs))
		for id := range m.removedcall_logs {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeVoicemails:
		ids := make([]ent.Value, 0, len(m.removedvoicemails))
		for id := range m.removedvoicemails {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeSaasIdentities:
		ids := make([]ent.Value, 0, len(m.removedsaas_identities))
		for id := range m.removedsaas_identities {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeFavorites:
		ids := make([]ent.Value, 0, len(m.removedfavorites))
		for id := range m.removedfavorites {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeVaultComments:
		ids := make([]ent.Value, 0, len(m.removedvault_comments))
		for id := range m.removedvault_comments {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeCreatedVersions:
		ids := make([]ent.Value, 0, len(m.removedcreated_versions))
		for id := range m.removedcreated_versions {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeCreatedLegalHolds:
		ids := make([]ent.Value, 0, len(m.removedcreated_legal_holds))
		for id := range m.removedcreated_legal_holds {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeCreatedTemplates:
		ids := make([]ent.Value, 0, len(m.removedcreated_templates))
		for id := range m.removedcreated_templates {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 15)
	if m.clearedtenant {
		edges = append(edges, user.EdgeTenant)
	}
	if m.clearedpermissions {
		edges = append(edges, user.EdgePermissions)
	}
	if m.clearedrequested_tickets {
		edges = append(edges, user.EdgeRequestedTickets)
	}
	if m.clearedassigned_tickets {
		edges = append(edges, user.EdgeAssignedTickets)
	}
	if m.clearedwork_logs {
		edges = append(edges, user.EdgeWorkLogs)
	}
	if m.clearedowned_assets {
		edges = append(edges, user.EdgeOwnedAssets)
	}
	if m.clearedauthored_sops {
		edges = append(edges, user.EdgeAuthoredSops)
	}
	if m.clearedcall_logs {
		edges = append(edges, user.EdgeCallLogs)
	}
	if m.clearedvoicemails {
		edges = append(edges, user.EdgeVoicemails)
	}
	if m.clearedsaas_identities {
		edges = append(edges, user.EdgeSaasIdentities)
	}
	if m.clearedfavorites {
		edges = append(edges, user.EdgeFavorites)
	}
	if m.clearedvault_comments {
		edges = append(edges, user.EdgeVaultComments)
	}
	if m.clearedcreated_versions {
		edges = append(edges, user.EdgeCreatedVersions)
	}
	if m.clearedcreated_legal_holds {
		edges = append(edges, user.EdgeCreatedLegalHolds)
	}
	if m.clearedcreated_templates {
		edges = append(edges, user.EdgeCreatedTemplates)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	switch name {
	case user.EdgeTenant:
		return m.clearedtenant
	case user.EdgePermissions:
		return m.clearedpermissions
	case user.EdgeRequestedTickets:
		return m.clearedrequested_tickets
	case user.EdgeAssignedTickets:
		return m.clearedassigned_tickets
	case user.EdgeWorkLogs:
		return m.clearedwork_logs
	case user.EdgeOwnedAssets:
		return m.clearedowned_assets
	case user.EdgeAuthoredSops:
		return m.clearedauthored_sops
	case user.EdgeCallLogs:
		return m.clearedcall_logs
	case user.EdgeVoicemails:
		return m.clearedvoicemails
	case user.EdgeSaasIdentities:
		return m.clearedsaas_identities
	case user.EdgeFavorites:
		return m.clearedfavorites
	case user.EdgeVaultComments:
		return m.clearedvault_comments
	case user.EdgeCreatedVersions:
		return m.clearedcreated_versions
	case user.EdgeCreatedLegalHolds:
		return m.clearedcreated_legal_holds
	case user.EdgeCreatedTemplates:
		return m.clearedcreated_templates
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	switch name {
	case user.EdgeTenant:
		m.ClearTenant()
		return nil
	}
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	switch name {
	case user.EdgeTenant:
		m.ResetTenant()
		return nil
	case user.EdgePermissions:
		m.ResetPermissions()
		return nil
	case user.EdgeRequestedTickets:
		m.ResetRequestedTickets()
		return nil
	case user.EdgeAssignedTickets:
		m.ResetAssignedTickets()
		return nil
	case user.EdgeWorkLogs:
		m.ResetWorkLogs()
		return nil
	case user.EdgeOwnedAssets:
		m.ResetOwnedAssets()
		return nil
	case user.EdgeAuthoredSops:
		m.ResetAuthoredSops()
		return nil
	case user.EdgeCallLogs:
		m.ResetCallLogs()
		return nil
	case user.EdgeVoicemails:
		m.ResetVoicemails()
		return nil
	case user.EdgeSaasIdentities:
		m.ResetSaasIdentities()
		return nil
	case user.EdgeFavorites:
		m.ResetFavorites()
		return nil
	case user.EdgeVaultComments:
		m.ResetVaultComments()
		return nil
	case user.EdgeCreatedVersions:
		m.ResetCreatedVersions()
		return nil
	case user.EdgeCreatedLegalHolds:
		m.ResetCreatedLegalHolds()
		return nil
	case user.EdgeCreatedTemplates:
		m.ResetCreatedTemplates()
		return nil
	}
	return fmt.Errorf("unknown User edge %s", name)
}

// VaultCommentMutation represents an operation that mutates the VaultComment nodes in the graph.
type VaultCommentMutation struct {
	config
	op            Op
	typ           string
	id            *int
	content       *string
	page          *int
	addpage       *int
	x             *float64
	addx          *float64
	y             *float64
	addy          *float64
	created_at    *time.Time
	updated_at    *time.Time
	clearedFields map[string]struct{}
	item          *int
	cleareditem   bool
	author        *int
	clearedauthor bool
	done          bool
	oldValue      func(context.Context) (*VaultComment, error)
	predicates    []predicate.VaultComment
}

var _ ent.Mutation = (*VaultCommentMutation)(nil)

// vaultcommentOption allows management of the mutation configuration using functional options.
type vaultcommentOption func(*VaultCommentMutation)

// newVaultCommentMutation creates new mutation for the VaultComment entity.
func newVaultCommentMutation(c config, op Op, opts ...vaultcommentOption) *VaultCommentMutation {
	m := &VaultCommentMutation{
		config:        c,
		op:            op,
		typ:           TypeVaultComment,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withVaultCommentID sets the ID field of the mutation.
func withVaultCommentID(id int) vaultcommentOption {
	return func(m *VaultCommentMutation) {
		var (
			err   error
			once  sync.Once
			value *VaultComment
		)
		m.oldValue = func(ctx context.Context) (*VaultComment, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().VaultComment.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withVaultComment sets the old VaultComment of the mutation.
func withVaultComment(node *VaultComment) vaultcommentOption {
	return func(m *VaultCommentMutation) {
		m.oldValue = func(context.Context) (*VaultComment, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m VaultCommentMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m VaultCommentMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *VaultCommentMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *VaultCommentMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().VaultComment.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetContent sets the "content" field.
func (m *VaultCommentMutation) SetContent(s string) {
	m.content = &s
}

// Content returns the value of the "content" field in the mutation.
func (m *VaultCommentMutation) Content() (r string, exists bool) {
	v := m.content
	if v == nil {
		return
	}
	return *v, true
}

// OldContent returns the old "content" field's value of the VaultComment entity.
// If the VaultComment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VaultCommentMutation) OldContent(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContent: %w", err)
	}
	return oldValue.Content, nil
}

// ResetContent resets all changes to the "content" field.
func (m *VaultCommentMutation) ResetContent() {
	m.content = nil
}

// SetPage sets the "page" field.
func (m *VaultCommentMutation) SetPage(i int) {
	m.page = &i
	m.addpage = nil
}

// Page returns the value of the "page" field in the mutation.
func (m *VaultCommentMutation) Page() (r int, exists bool) {
	v := m.page
	if v == nil {
		return
	}
	return *v, true
}

// OldPage returns the old "page" field's value of the VaultComment entity.
// If the VaultComment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VaultCommentMutation) OldPage(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPage: %w", err)
	}
	return oldValue.Page, nil
}

// AddPage adds i to the "page" field.
func (m *VaultCommentMutation) AddPage(i int) {
	if m.addpage != nil {
		*m.addpage += i
	} else {
		m.addpage = &i
	}
}

// AddedPage returns the value that was added to the "page" field in this mutation.
func (m *VaultCommentMutation) AddedPage() (r int, exists bool) {
	v := m.addpage
	if v == nil {
		return
	}
	return *v, true
}

// ClearPage clears the value of the "page" field.
func (m *VaultCommentMutation) ClearPage() {
	m.page = nil
	m.addpage = nil
	m.clearedFields[vaultcomment.FieldPage] = struct{}{}
}

// PageCleared returns if the "page" field was cleared in this mutation.
func (m *VaultCommentMutation) PageCleared() bool {
	_, ok := m.clearedFields[vaultcomment.FieldPage]
	return ok
}

// ResetPage resets all changes to the "page" field.
func (m *VaultCommentMutation) ResetPage() {
	m.page = nil
	m.addpage = nil
	delete(m.clearedFields, vaultcomment.FieldPage)
}

// SetX sets the "x" field.
func (m *VaultCommentMutation) SetX(f float64) {
	m.x = &f
	m.addx = nil
}

// X returns the value of the "x" field in the mutation.
func (m *VaultCommentMutation) X() (r float64, exists bool) {
	v := m.x
	if v == nil {
		return
	}
	return *v, true
}

// OldX returns the old "x" field's value of the VaultComment entity.
// If the VaultComment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VaultCommentMutation) OldX(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldX is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldX requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldX: %w", err)
	}
	return oldValue.X, nil
}

// AddX adds f to the "x" field.
func (m *VaultCommentMutation) AddX(f float64) {
	if m.addx != nil {
		*m.addx += f
	} else {
		m.addx = &f
	}
}

// AddedX returns the value that was added to the "x" field in this mutation.
func (m *VaultCommentMutation) AddedX() (r float64, exists bool) {
	v := m.addx
	if v == nil {
		return
	}
	return *v, true
}

// ClearX clears the value of the "x" field.
func (m *VaultCommentMutation) ClearX() {
	m.x = nil
	m.addx = nil
	m.clearedFields[vaultcomment.FieldX] = struct{}{}
}

// XCleared returns if the "x" field was cleared in this mutation.
func (m *VaultCommentMutation) XCleared() bool {
	_, ok := m.clearedFields[vaultcomment.FieldX]
	return ok
}

// ResetX resets all changes to the "x" field.
func (m *VaultCommentMutation) ResetX() {
	m.x = nil
	m.addx = nil
	delete(m.clearedFields, vaultcomment.FieldX)
}

// SetY sets the "y" field.
func (m *VaultCommentMutation) SetY(f float64) {
	m.y = &f
	m.addy = nil
}

// Y returns the value of the "y" field in the mutation.
func (m *VaultCommentMutation) Y() (r float64, exists bool) {
	v := m.y
	if v == nil {
		return
	}
	return *v, true
}

// OldY returns the old "y" field's value of the VaultComment entity.
// If the VaultComment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VaultCommentMutation) OldY(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldY is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldY requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldY: %w", err)
	}
	return oldValue.Y, nil
}

// AddY adds f to the "y" field.
func (m *VaultCommentMutation) AddY(f float64) {
	if m.addy != nil {
		*m.addy += f
	} else {
		m.addy = &f
	}
}

// AddedY returns the value that was added to the "y" field in this mutation.
func (m *VaultCommentMutation) AddedY() (r float64, exists bool) {
	v := m.addy
	if v == nil {
		return
	}
	return *v, true
}

// ClearY clears the value of the "y" field.
func (m *VaultCommentMutation) ClearY() {
	m.y = nil
	m.addy = nil
	m.clearedFields[vaultcomment.FieldY] = struct{}{}
}

// YCleared returns if the "y" field was cleared in this mutation.
func (m *VaultCommentMutation) YCleared() bool {
	_, ok := m.clearedFields[vaultcomment.FieldY]
	return ok
}

// ResetY resets all changes to the "y" field.
func (m *VaultCommentMutation) ResetY() {
	m.y = nil
	m.addy = nil
	delete(m.clearedFields, vaultcomment.FieldY)
}

// SetCreatedAt sets the "created_at" field.
func (m *VaultCommentMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *VaultCommentMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the VaultComment entity.
// If the VaultComment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VaultCommentMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *VaultCommentMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *VaultCommentMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *VaultCommentMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the VaultComment entity.
// If the VaultComment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VaultCommentMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *VaultCommentMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetItemID sets the "item" edge to the VaultItem entity by id.
func (m *VaultCommentMutation) SetItemID(id int) {
	m.item = &id
}

// ClearItem clears the "item" edge to the VaultItem entity.
func (m *VaultCommentMutation) ClearItem() {
	m.cleareditem = true
}

// ItemCleared reports if the "item" edge to the VaultItem entity was cleared.
func (m *VaultCommentMutation) ItemCleared() bool {
	return m.cleareditem
}

// ItemID returns the "item" edge ID in the mutation.
func (m *VaultCommentMutation) ItemID() (id int, exists bool) {
	if m.item != nil {
		return *m.item, true
	}
	return
}

// ItemIDs returns the "item" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ItemID instead. It exists only for internal usage by the builders.
func (m *VaultCommentMutation) ItemIDs() (ids []int) {
	if id := m.item; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetItem resets all changes to the "item" edge.
func (m *VaultCommentMutation) ResetItem() {
	m.item = nil
	m.cleareditem = false
}

// SetAuthorID sets the "author" edge to the User entity by id.
func (m *VaultCommentMutation) SetAuthorID(id int) {
	m.author = &id
}

// ClearAuthor clears the "author" edge to the User entity.
func (m *VaultCommentMutation) ClearAuthor() {
	m.clearedauthor = true
}

// AuthorCleared reports if the "author" edge to the User entity was cleared.
func (m *VaultCommentMutation) AuthorCleared() bool {
	return m.clearedauthor
}

// AuthorID returns the "author" edge ID in the mutation.
func (m *VaultCommentMutation) AuthorID() (id int, exists bool) {
	if m.author != nil {
		return *m.author, true
	}
	return
}

// AuthorIDs returns the "author" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AuthorID instead. It exists only for internal usage by the builders.
func (m *VaultCommentMutation) AuthorIDs() (ids []int) {
	if id := m.author; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAuthor resets all changes to the "author" edge.
func (m *VaultCommentMutation) ResetAuthor() {
	m.author = nil
	m.clearedauthor = false
}

// Where appends a list predicates to the VaultCommentMutation builder.
func (m *VaultCommentMutation) Where(ps ...predicate.VaultComment) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the VaultCommentMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *VaultCommentMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.VaultComment, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *VaultCommentMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *VaultCommentMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (VaultComment).
func (m *VaultCommentMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *VaultCommentMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.content != nil {
		fields = append(fields, vaultcomment.FieldContent)
	}
	if m.page != nil {
		fields = append(fields, vaultcomment.FieldPage)
	}
	if m.x != nil {
		fields = append(fields, vaultcomment.FieldX)
	}
	if m.y != nil {
		fields = append(fields, vaultcomment.FieldY)
	}
	if m.created_at != nil {
		fields = append(fields, vaultcomment.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, vaultcomment.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *VaultCommentMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case vaultcomment.FieldContent:
		return m.Content()
	case vaultcomment.FieldPage:
		return m.Page()
	case vaultcomment.FieldX:
		return m.X()
	case vaultcomment.FieldY:
		return m.Y()
	case vaultcomment.FieldCreatedAt:
		return m.CreatedAt()
	case vaultcomment.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *VaultCommentMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case vaultcomment.FieldContent:
		return m.OldContent(ctx)
	case vaultcomment.FieldPage:
		return m.OldPage(ctx)
	case vaultcomment.FieldX:
		return m.OldX(ctx)
	case vaultcomment.FieldY:
		return m.OldY(ctx)
	case vaultcomment.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case vaultcomment.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown VaultComment field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *VaultCommentMutation) SetField(name string, value ent.Value) error {
	switch name {
	case vaultcomment.FieldContent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContent(v)
		return nil
	case vaultcomment.FieldPage:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPage(v)
		return nil
	case vaultcomment.FieldX:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetX(v)
		return nil
	case vaultcomment.FieldY:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetY(v)
		return nil
	case vaultcomment.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case vaultcomment.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown VaultComment field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *VaultCommentMutation) AddedFields() []string {
	var fields []string
	if m.addpage != nil {
		fields = append(fields, vaultcomment.FieldPage)
	}
	if m.addx != nil {
		fields = append(fields, vaultcomment.FieldX)
	}
	if m.addy != nil {
		fields = append(fields, vaultcomment.FieldY)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *VaultCommentMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case vaultcomment.FieldPage:
		return m.AddedPage()
	case vaultcomment.FieldX:
		return m.AddedX()
	case vaultcomment.FieldY:
		return m.AddedY()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *VaultCommentMutation) AddField(name string, value ent.Value) error {
	switch name {
	case vaultcomment.FieldPage:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPage(v)
		return nil
	case vaultcomment.FieldX:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddX(v)
		return nil
	case vaultcomment.FieldY:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddY(v)
		return nil
	}
	return fmt.Errorf("unknown VaultComment numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *VaultCommentMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(vaultcomment.FieldPage) {
		fields = append(fields, vaultcomment.FieldPage)
	}
	if m.FieldCleared(vaultcomment.FieldX) {
		fields = append(fields, vaultcomment.FieldX)
	}
	if m.FieldCleared(vaultcomment.FieldY) {
		fields = append(fields, vaultcomment.FieldY)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *VaultCommentMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *VaultCommentMutation) ClearField(name string) error {
	switch name {
	case vaultcomment.FieldPage:
		m.ClearPage()
		return nil
	case vaultcomment.FieldX:
		m.ClearX()
		return nil
	case vaultcomment.FieldY:
		m.ClearY()
		return nil
	}
	return fmt.Errorf("unknown VaultComment nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *VaultCommentMutation) ResetField(name string) error {
	switch name {
	case vaultcomment.FieldContent:
		m.ResetContent()
		return nil
	case vaultcomment.FieldPage:
		m.ResetPage()
		return nil
	case vaultcomment.FieldX:
		m.ResetX()
		return nil
	case vaultcomment.FieldY:
		m.ResetY()
		return nil
	case vaultcomment.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case vaultcomment.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown VaultComment field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *VaultCommentMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.item != nil {
		edges = append(edges, vaultcomment.EdgeItem)
	}
	if m.author != nil {
		edges = append(edges, vaultcomment.EdgeAuthor)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *VaultCommentMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case vaultcomment.EdgeItem:
		if id := m.item; id != nil {
			return []ent.Value{*id}
		}
	case vaultcomment.EdgeAuthor:
		if id := m.author; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *VaultCommentMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *VaultCommentMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *VaultCommentMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleareditem {
		edges = append(edges, vaultcomment.EdgeItem)
	}
	if m.clearedauthor {
		edges = append(edges, vaultcomment.EdgeAuthor)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *VaultCommentMutation) EdgeCleared(name string) bool {
	switch name {
	case vaultcomment.EdgeItem:
		return m.cleareditem
	case vaultcomment.EdgeAuthor:
		return m.clearedauthor
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *VaultCommentMutation) ClearEdge(name string) error {
	switch name {
	case vaultcomment.EdgeItem:
		m.ClearItem()
		return nil
	case vaultcomment.EdgeAuthor:
		m.ClearAuthor()
		return nil
	}
	return fmt.Errorf("unknown VaultComment unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *VaultCommentMutation) ResetEdge(name string) error {
	switch name {
	case vaultcomment.EdgeItem:
		m.ResetItem()
		return nil
	case vaultcomment.EdgeAuthor:
		m.ResetAuthor()
		return nil
	}
	return fmt.Errorf("unknown VaultComment edge %s", name)
}

// VaultFavoriteMutation represents an operation that mutates the VaultFavorite nodes in the graph.
type VaultFavoriteMutation struct {
	config
	op            Op
	typ           string
	id            *int
	created_at    *time.Time
	clearedFields map[string]struct{}
	user          *int
	cleareduser   bool
	item          *int
	cleareditem   bool
	done          bool
	oldValue      func(context.Context) (*VaultFavorite, error)
	predicates    []predicate.VaultFavorite
}

var _ ent.Mutation = (*VaultFavoriteMutation)(nil)

// vaultfavoriteOption allows management of the mutation configuration using functional options.
type vaultfavoriteOption func(*VaultFavoriteMutation)

// newVaultFavoriteMutation creates new mutation for the VaultFavorite entity.
func newVaultFavoriteMutation(c config, op Op, opts ...vaultfavoriteOption) *VaultFavoriteMutation {
	m := &VaultFavoriteMutation{
		config:        c,
		op:            op,
		typ:           TypeVaultFavorite,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withVaultFavoriteID sets the ID field of the mutation.
func withVaultFavoriteID(id int) vaultfavoriteOption {
	return func(m *VaultFavoriteMutation) {
		var (
			err   error
			once  sync.Once
			value *VaultFavorite
		)
		m.oldValue = func(ctx context.Context) (*VaultFavorite, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().VaultFavorite.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withVaultFavorite sets the old VaultFavorite of the mutation.
func withVaultFavorite(node *VaultFavorite) vaultfavoriteOption {
	return func(m *VaultFavoriteMutation) {
		m.oldValue = func(context.Context) (*VaultFavorite, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m VaultFavoriteMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m VaultFavoriteMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *VaultFavoriteMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *VaultFavoriteMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().VaultFavorite.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *VaultFavoriteMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *VaultFavoriteMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the VaultFavorite entity.
// If the VaultFavorite object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VaultFavoriteMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *VaultFavoriteMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUserID sets the "user" edge to the User entity by id.
func (m *VaultFavoriteMutation) SetUserID(id int) {
	m.user = &id
}

// ClearUser clears the "user" edge to the User entity.
func (m *VaultFavoriteMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *VaultFavoriteMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *VaultFavoriteMutation) UserID() (id int, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *VaultFavoriteMutation) UserIDs() (ids []int) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *VaultFavoriteMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// SetItemID sets the "item" edge to the VaultItem entity by id.
func (m *VaultFavoriteMutation) SetItemID(id int) {
	m.item = &id
}

// ClearItem clears the "item" edge to the VaultItem entity.
func (m *VaultFavoriteMutation) ClearItem() {
	m.cleareditem = true
}

// ItemCleared reports if the "item" edge to the VaultItem entity was cleared.
func (m *VaultFavoriteMutation) ItemCleared() bool {
	return m.cleareditem
}

// ItemID returns the "item" edge ID in the mutation.
func (m *VaultFavoriteMutation) ItemID() (id int, exists bool) {
	if m.item != nil {
		return *m.item, true
	}
	return
}

// ItemIDs returns the "item" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ItemID instead. It exists only for internal usage by the builders.
func (m *VaultFavoriteMutation) ItemIDs() (ids []int) {
	if id := m.item; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetItem resets all changes to the "item" edge.
func (m *VaultFavoriteMutation) ResetItem() {
	m.item = nil
	m.cleareditem = false
}

// Where appends a list predicates to the VaultFavoriteMutation builder.
func (m *VaultFavoriteMutation) Where(ps ...predicate.VaultFavorite) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the VaultFavoriteMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *VaultFavoriteMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.VaultFavorite, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *VaultFavoriteMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *VaultFavoriteMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (VaultFavorite).
func (m *VaultFavoriteMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *VaultFavoriteMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.created_at != nil {
		fields = append(fields, vaultfavorite.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *VaultFavoriteMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case vaultfavorite.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *VaultFavoriteMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case vaultfavorite.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown VaultFavorite field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *VaultFavoriteMutation) SetField(name string, value ent.Value) error {
	switch name {
	case vaultfavorite.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown VaultFavorite field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *VaultFavoriteMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *VaultFavoriteMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *VaultFavoriteMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown VaultFavorite numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *VaultFavoriteMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *VaultFavoriteMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *VaultFavoriteMutation) ClearField(name string) error {
	return fmt.Errorf("unknown VaultFavorite nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *VaultFavoriteMutation) ResetField(name string) error {
	switch name {
	case vaultfavorite.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown VaultFavorite field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *VaultFavoriteMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.user != nil {
		edges = append(edges, vaultfavorite.EdgeUser)
	}
	if m.item != nil {
		edges = append(edges, vaultfavorite.EdgeItem)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *VaultFavoriteMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case vaultfavorite.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case vaultfavorite.EdgeItem:
		if id := m.item; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *VaultFavoriteMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *VaultFavoriteMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *VaultFavoriteMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleareduser {
		edges = append(edges, vaultfavorite.EdgeUser)
	}
	if m.cleareditem {
		edges = append(edges, vaultfavorite.EdgeItem)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *VaultFavoriteMutation) EdgeCleared(name string) bool {
	switch name {
	case vaultfavorite.EdgeUser:
		return m.cleareduser
	case vaultfavorite.EdgeItem:
		return m.cleareditem
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *VaultFavoriteMutation) ClearEdge(name string) error {
	switch name {
	case vaultfavorite.EdgeUser:
		m.ClearUser()
		return nil
	case vaultfavorite.EdgeItem:
		m.ClearItem()
		return nil
	}
	return fmt.Errorf("unknown VaultFavorite unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *VaultFavoriteMutation) ResetEdge(name string) error {
	switch name {
	case vaultfavorite.EdgeUser:
		m.ResetUser()
		return nil
	case vaultfavorite.EdgeItem:
		m.ResetItem()
		return nil
	}
	return fmt.Errorf("unknown VaultFavorite edge %s", name)
}

// VaultItemMutation represents an operation that mutates the VaultItem nodes in the graph.
type VaultItemMutation struct {
	config
	op                  Op
	typ                 string
	id                  *int
	_path               *string
	name                *string
	size                *int64
	addsize             *int64
	hash                *string
	file_type           *string
	encrypted           *bool
	metadata            *map[string]interface{}
	content             *string
	is_dir              *bool
	created_at          *time.Time
	updated_at          *time.Time
	deleted_at          *time.Time
	clearedFields       map[string]struct{}
	tenant              *int
	clearedtenant       bool
	share_links         map[int]struct{}
	removedshare_links  map[int]struct{}
	clearedshare_links  bool
	versions            map[int]struct{}
	removedversions     map[int]struct{}
	clearedversions     bool
	comments            map[int]struct{}
	removedcomments     map[int]struct{}
	clearedcomments     bool
	favorited_by        map[int]struct{}
	removedfavorited_by map[int]struct{}
	clearedfavorited_by bool
	legal_holds         map[int]struct{}
	removedlegal_holds  map[int]struct{}
	clearedlegal_holds  bool
	done                bool
	oldValue            func(context.Context) (*VaultItem, error)
	predicates          []predicate.VaultItem
}

var _ ent.Mutation = (*VaultItemMutation)(nil)

// vaultitemOption allows management of the mutation configuration using functional options.
type vaultitemOption func(*VaultItemMutation)

// newVaultItemMutation creates new mutation for the VaultItem entity.
func newVaultItemMutation(c config, op Op, opts ...vaultitemOption) *VaultItemMutation {
	m := &VaultItemMutation{
		config:        c,
		op:            op,
		typ:           TypeVaultItem,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withVaultItemID sets the ID field of the mutation.
func withVaultItemID(id int) vaultitemOption {
	return func(m *VaultItemMutation) {
		var (
			err   error
			once  sync.Once
			value *VaultItem
		)
		m.oldValue = func(ctx context.Context) (*VaultItem, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().VaultItem.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withVaultItem sets the old VaultItem of the mutation.
func withVaultItem(node *VaultItem) vaultitemOption {
	return func(m *VaultItemMutation) {
		m.oldValue = func(context.Context) (*VaultItem, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m VaultItemMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m VaultItemMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *VaultItemMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *VaultItemMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().VaultItem.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetPath sets the "path" field.
func (m *VaultItemMutation) SetPath(s string) {
	m._path = &s
}

// Path returns the value of the "path" field in the mutation.
func (m *VaultItemMutation) Path() (r string, exists bool) {
	v := m._path
	if v == nil {
		return
	}
	return *v, true
}

// OldPath returns the old "path" field's value of the VaultItem entity.
// If the VaultItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VaultItemMutation) OldPath(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPath is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPath requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPath: %w", err)
	}
	return oldValue.Path, nil
}

// ResetPath resets all changes to the "path" field.
func (m *VaultItemMutation) ResetPath() {
	m._path = nil
}

// SetName sets the "name" field.
func (m *VaultItemMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *VaultItemMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the VaultItem entity.
// If the VaultItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VaultItemMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *VaultItemMutation) ResetName() {
	m.name = nil
}

// SetSize sets the "size" field.
func (m *VaultItemMutation) SetSize(i int64) {
	m.size = &i
	m.addsize = nil
}

// Size returns the value of the "size" field in the mutation.
func (m *VaultItemMutation) Size() (r int64, exists bool) {
	v := m.size
	if v == nil {
		return
	}
	return *v, true
}

// OldSize returns the old "size" field's value of the VaultItem entity.
// If the VaultItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VaultItemMutation) OldSize(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSize is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSize requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSize: %w", err)
	}
	return oldValue.Size, nil
}

// AddSize adds i to the "size" field.
func (m *VaultItemMutation) AddSize(i int64) {
	if m.addsize != nil {
		*m.addsize += i
	} else {
		m.addsize = &i
	}
}

// AddedSize returns the value that was added to the "size" field in this mutation.
func (m *VaultItemMutation) AddedSize() (r int64, exists bool) {
	v := m.addsize
	if v == nil {
		return
	}
	return *v, true
}

// ResetSize resets all changes to the "size" field.
func (m *VaultItemMutation) ResetSize() {
	m.size = nil
	m.addsize = nil
}

// SetHash sets the "hash" field.
func (m *VaultItemMutation) SetHash(s string) {
	m.hash = &s
}

// Hash returns the value of the "hash" field in the mutation.
func (m *VaultItemMutation) Hash() (r string, exists bool) {
	v := m.hash
	if v == nil {
		return
	}
	return *v, true
}

// OldHash returns the old "hash" field's value of the VaultItem entity.
// If the VaultItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VaultItemMutation) OldHash(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHash is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHash requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHash: %w", err)
	}
	return oldValue.Hash, nil
}

// ResetHash resets all changes to the "hash" field.
func (m *VaultItemMutation) ResetHash() {
	m.hash = nil
}

// SetFileType sets the "file_type" field.
func (m *VaultItemMutation) SetFileType(s string) {
	m.file_type = &s
}

// FileType returns the value of the "file_type" field in the mutation.
func (m *VaultItemMutation) FileType() (r string, exists bool) {
	v := m.file_type
	if v == nil {
		return
	}
	return *v, true
}

// OldFileType returns the old "file_type" field's value of the VaultItem entity.
// If the VaultItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VaultItemMutation) OldFileType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFileType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFileType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFileType: %w", err)
	}
	return oldValue.FileType, nil
}

// ClearFileType clears the value of the "file_type" field.
func (m *VaultItemMutation) ClearFileType() {
	m.file_type = nil
	m.clearedFields[vaultitem.FieldFileType] = struct{}{}
}

// FileTypeCleared returns if the "file_type" field was cleared in this mutation.
func (m *VaultItemMutation) FileTypeCleared() bool {
	_, ok := m.clearedFields[vaultitem.FieldFileType]
	return ok
}

// ResetFileType resets all changes to the "file_type" field.
func (m *VaultItemMutation) ResetFileType() {
	m.file_type = nil
	delete(m.clearedFields, vaultitem.FieldFileType)
}

// SetEncrypted sets the "encrypted" field.
func (m *VaultItemMutation) SetEncrypted(b bool) {
	m.encrypted = &b
}

// Encrypted returns the value of the "encrypted" field in the mutation.
func (m *VaultItemMutation) Encrypted() (r bool, exists bool) {
	v := m.encrypted
	if v == nil {
		return
	}
	return *v, true
}

// OldEncrypted returns the old "encrypted" field's value of the VaultItem entity.
// If the VaultItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VaultItemMutation) OldEncrypted(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEncrypted is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEncrypted requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEncrypted: %w", err)
	}
	return oldValue.Encrypted, nil
}

// ResetEncrypted resets all changes to the "encrypted" field.
func (m *VaultItemMutation) ResetEncrypted() {
	m.encrypted = nil
}

// SetMetadata sets the "metadata" field.
func (m *VaultItemMutation) SetMetadata(value map[string]interface{}) {
	m.metadata = &value
}

// Metadata returns the value of the "metadata" field in the mutation.
func (m *VaultItemMutation) Metadata() (r map[string]interface{}, exists bool) {
	v := m.metadata
	if v == nil {
		return
	}
	return *v, true
}

// OldMetadata returns the old "metadata" field's value of the VaultItem entity.
// If the VaultItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VaultItemMutation) OldMetadata(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMetadata is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMetadata requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetadata: %w", err)
	}
	return oldValue.Metadata, nil
}

// ClearMetadata clears the value of the "metadata" field.
func (m *VaultItemMutation) ClearMetadata() {
	m.metadata = nil
	m.clearedFields[vaultitem.FieldMetadata] = struct{}{}
}

// MetadataCleared returns if the "metadata" field was cleared in this mutation.
func (m *VaultItemMutation) MetadataCleared() bool {
	_, ok := m.clearedFields[vaultitem.FieldMetadata]
	return ok
}

// ResetMetadata resets all changes to the "metadata" field.
func (m *VaultItemMutation) ResetMetadata() {
	m.metadata = nil
	delete(m.clearedFields, vaultitem.FieldMetadata)
}

// SetContent sets the "content" field.
func (m *VaultItemMutation) SetContent(s string) {
	m.content = &s
}

// Content returns the value of the "content" field in the mutation.
func (m *VaultItemMutation) Content() (r string, exists bool) {
	v := m.content
	if v == nil {
		return
	}
	return *v, true
}

// OldContent returns the old "content" field's value of the VaultItem entity.
// If the VaultItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VaultItemMutation) OldContent(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContent: %w", err)
	}
	return oldValue.Content, nil
}

// ClearContent clears the value of the "content" field.
func (m *VaultItemMutation) ClearContent() {
	m.content = nil
	m.clearedFields[vaultitem.FieldContent] = struct{}{}
}

// ContentCleared returns if the "content" field was cleared in this mutation.
func (m *VaultItemMutation) ContentCleared() bool {
	_, ok := m.clearedFields[vaultitem.FieldContent]
	return ok
}

// ResetContent resets all changes to the "content" field.
func (m *VaultItemMutation) ResetContent() {
	m.content = nil
	delete(m.clearedFields, vaultitem.FieldContent)
}

// SetIsDir sets the "is_dir" field.
func (m *VaultItemMutation) SetIsDir(b bool) {
	m.is_dir = &b
}

// IsDir returns the value of the "is_dir" field in the mutation.
func (m *VaultItemMutation) IsDir() (r bool, exists bool) {
	v := m.is_dir
	if v == nil {
		return
	}
	return *v, true
}

// OldIsDir returns the old "is_dir" field's value of the VaultItem entity.
// If the VaultItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VaultItemMutation) OldIsDir(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsDir is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsDir requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsDir: %w", err)
	}
	return oldValue.IsDir, nil
}

// ResetIsDir resets all changes to the "is_dir" field.
func (m *VaultItemMutation) ResetIsDir() {
	m.is_dir = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *VaultItemMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *VaultItemMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the VaultItem entity.
// If the VaultItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VaultItemMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *VaultItemMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *VaultItemMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *VaultItemMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the VaultItem entity.
// If the VaultItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VaultItemMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *VaultItemMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *VaultItemMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *VaultItemMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the VaultItem entity.
// If the VaultItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VaultItemMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *VaultItemMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[vaultitem.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *VaultItemMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[vaultitem.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *VaultItemMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, vaultitem.FieldDeletedAt)
}

// SetTenantID sets the "tenant" edge to the Tenant entity by id.
func (m *VaultItemMutation) SetTenantID(id int) {
	m.tenant = &id
}

// ClearTenant clears the "tenant" edge to the Tenant entity.
func (m *VaultItemMutation) ClearTenant() {
	m.clearedtenant = true
}

// TenantCleared reports if the "tenant" edge to the Tenant entity was cleared.
func (m *VaultItemMutation) TenantCleared() bool {
	return m.clearedtenant
}

// TenantID returns the "tenant" edge ID in the mutation.
func (m *VaultItemMutation) TenantID() (id int, exists bool) {
	if m.tenant != nil {
		return *m.tenant, true
	}
	return
}

// TenantIDs returns the "tenant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TenantID instead. It exists only for internal usage by the builders.
func (m *VaultItemMutation) TenantIDs() (ids []int) {
	if id := m.tenant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTenant resets all changes to the "tenant" edge.
func (m *VaultItemMutation) ResetTenant() {
	m.tenant = nil
	m.clearedtenant = false
}

// AddShareLinkIDs adds the "share_links" edge to the VaultShareLink entity by ids.
func (m *VaultItemMutation) AddShareLinkIDs(ids ...int) {
	if m.share_links == nil {
		m.share_links = make(map[int]struct{})
	}
	for i := range ids {
		m.share_links[ids[i]] = struct{}{}
	}
}

// ClearShareLinks clears the "share_links" edge to the VaultShareLink entity.
func (m *VaultItemMutation) ClearShareLinks() {
	m.clearedshare_links = true
}

// ShareLinksCleared reports if the "share_links" edge to the VaultShareLink entity was cleared.
func (m *VaultItemMutation) ShareLinksCleared() bool {
	return m.clearedshare_links
}

// RemoveShareLinkIDs removes the "share_links" edge to the VaultShareLink entity by IDs.
func (m *VaultItemMutation) RemoveShareLinkIDs(ids ...int) {
	if m.removedshare_links == nil {
		m.removedshare_links = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.share_links, ids[i])
		m.removedshare_links[ids[i]] = struct{}{}
	}
}

// RemovedShareLinks returns the removed IDs of the "share_links" edge to the VaultShareLink entity.
func (m *VaultItemMutation) RemovedShareLinksIDs() (ids []int) {
	for id := range m.removedshare_links {
		ids = append(ids, id)
	}
	return
}

// ShareLinksIDs returns the "share_links" edge IDs in the mutation.
func (m *VaultItemMutation) ShareLinksIDs() (ids []int) {
	for id := range m.share_links {
		ids = append(ids, id)
	}
	return
}

// ResetShareLinks resets all changes to the "share_links" edge.
func (m *VaultItemMutation) ResetShareLinks() {
	m.share_links = nil
	m.clearedshare_links = false
	m.removedshare_links = nil
}

// AddVersionIDs adds the "versions" edge to the VaultVersion entity by ids.
func (m *VaultItemMutation) AddVersionIDs(ids ...int) {
	if m.versions == nil {
		m.versions = make(map[int]struct{})
	}
	for i := range ids {
		m.versions[ids[i]] = struct{}{}
	}
}

// ClearVersions clears the "versions" edge to the VaultVersion entity.
func (m *VaultItemMutation) ClearVersions() {
	m.clearedversions = true
}

// VersionsCleared reports if the "versions" edge to the VaultVersion entity was cleared.
func (m *VaultItemMutation) VersionsCleared() bool {
	return m.clearedversions
}

// RemoveVersionIDs removes the "versions" edge to the VaultVersion entity by IDs.
func (m *VaultItemMutation) RemoveVersionIDs(ids ...int) {
	if m.removedversions == nil {
		m.removedversions = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.versions, ids[i])
		m.removedversions[ids[i]] = struct{}{}
	}
}

// RemovedVersions returns the removed IDs of the "versions" edge to the VaultVersion entity.
func (m *VaultItemMutation) RemovedVersionsIDs() (ids []int) {
	for id := range m.removedversions {
		ids = append(ids, id)
	}
	return
}

// VersionsIDs returns the "versions" edge IDs in the mutation.
func (m *VaultItemMutation) VersionsIDs() (ids []int) {
	for id := range m.versions {
		ids = append(ids, id)
	}
	return
}

// ResetVersions resets all changes to the "versions" edge.
func (m *VaultItemMutation) ResetVersions() {
	m.versions = nil
	m.clearedversions = false
	m.removedversions = nil
}

// AddCommentIDs adds the "comments" edge to the VaultComment entity by ids.
func (m *VaultItemMutation) AddCommentIDs(ids ...int) {
	if m.comments == nil {
		m.comments = make(map[int]struct{})
	}
	for i := range ids {
		m.comments[ids[i]] = struct{}{}
	}
}

// ClearComments clears the "comments" edge to the VaultComment entity.
func (m *VaultItemMutation) ClearComments() {
	m.clearedcomments = true
}

// CommentsCleared reports if the "comments" edge to the VaultComment entity was cleared.
func (m *VaultItemMutation) CommentsCleared() bool {
	return m.clearedcomments
}

// RemoveCommentIDs removes the "comments" edge to the VaultComment entity by IDs.
func (m *VaultItemMutation) RemoveCommentIDs(ids ...int) {
	if m.removedcomments == nil {
		m.removedcomments = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.comments, ids[i])
		m.removedcomments[ids[i]] = struct{}{}
	}
}

// RemovedComments returns the removed IDs of the "comments" edge to the VaultComment entity.
func (m *VaultItemMutation) RemovedCommentsIDs() (ids []int) {
	for id := range m.removedcomments {
		ids = append(ids, id)
	}
	return
}

// CommentsIDs returns the "comments" edge IDs in the mutation.
func (m *VaultItemMutation) CommentsIDs() (ids []int) {
	for id := range m.comments {
		ids = append(ids, id)
	}
	return
}

// ResetComments resets all changes to the "comments" edge.
func (m *VaultItemMutation) ResetComments() {
	m.comments = nil
	m.clearedcomments = false
	m.removedcomments = nil
}

// AddFavoritedByIDs adds the "favorited_by" edge to the VaultFavorite entity by ids.
func (m *VaultItemMutation) AddFavoritedByIDs(ids ...int) {
	if m.favorited_by == nil {
		m.favorited_by = make(map[int]struct{})
	}
	for i := range ids {
		m.favorited_by[ids[i]] = struct{}{}
	}
}

// ClearFavoritedBy clears the "favorited_by" edge to the VaultFavorite entity.
func (m *VaultItemMutation) ClearFavoritedBy() {
	m.clearedfavorited_by = true
}

// FavoritedByCleared reports if the "favorited_by" edge to the VaultFavorite entity was cleared.
func (m *VaultItemMutation) FavoritedByCleared() bool {
	return m.clearedfavorited_by
}

// RemoveFavoritedByIDs removes the "favorited_by" edge to the VaultFavorite entity by IDs.
func (m *VaultItemMutation) RemoveFavoritedByIDs(ids ...int) {
	if m.removedfavorited_by == nil {
		m.removedfavorited_by = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.favorited_by, ids[i])
		m.removedfavorited_by[ids[i]] = struct{}{}
	}
}

// RemovedFavoritedBy returns the removed IDs of the "favorited_by" edge to the VaultFavorite entity.
func (m *VaultItemMutation) RemovedFavoritedByIDs() (ids []int) {
	for id := range m.removedfavorited_by {
		ids = append(ids, id)
	}
	return
}

// FavoritedByIDs returns the "favorited_by" edge IDs in the mutation.
func (m *VaultItemMutation) FavoritedByIDs() (ids []int) {
	for id := range m.favorited_by {
		ids = append(ids, id)
	}
	return
}

// ResetFavoritedBy resets all changes to the "favorited_by" edge.
func (m *VaultItemMutation) ResetFavoritedBy() {
	m.favorited_by = nil
	m.clearedfavorited_by = false
	m.removedfavorited_by = nil
}

// AddLegalHoldIDs adds the "legal_holds" edge to the LegalHold entity by ids.
func (m *VaultItemMutation) AddLegalHoldIDs(ids ...int) {
	if m.legal_holds == nil {
		m.legal_holds = make(map[int]struct{})
	}
	for i := range ids {
		m.legal_holds[ids[i]] = struct{}{}
	}
}

// ClearLegalHolds clears the "legal_holds" edge to the LegalHold entity.
func (m *VaultItemMutation) ClearLegalHolds() {
	m.clearedlegal_holds = true
}

// LegalHoldsCleared reports if the "legal_holds" edge to the LegalHold entity was cleared.
func (m *VaultItemMutation) LegalHoldsCleared() bool {
	return m.clearedlegal_holds
}

// RemoveLegalHoldIDs removes the "legal_holds" edge to the LegalHold entity by IDs.
func (m *VaultItemMutation) RemoveLegalHoldIDs(ids ...int) {
	if m.removedlegal_holds == nil {
		m.removedlegal_holds = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.legal_holds, ids[i])
		m.removedlegal_holds[ids[i]] = struct{}{}
	}
}

// RemovedLegalHolds returns the removed IDs of the "legal_holds" edge to the LegalHold entity.
func (m *VaultItemMutation) RemovedLegalHoldsIDs() (ids []int) {
	for id := range m.removedlegal_holds {
		ids = append(ids, id)
	}
	return
}

// LegalHoldsIDs returns the "legal_holds" edge IDs in the mutation.
func (m *VaultItemMutation) LegalHoldsIDs() (ids []int) {
	for id := range m.legal_holds {
		ids = append(ids, id)
	}
	return
}

// ResetLegalHolds resets all changes to the "legal_holds" edge.
func (m *VaultItemMutation) ResetLegalHolds() {
	m.legal_holds = nil
	m.clearedlegal_holds = false
	m.removedlegal_holds = nil
}

// Where appends a list predicates to the VaultItemMutation builder.
func (m *VaultItemMutation) Where(ps ...predicate.VaultItem) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the VaultItemMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *VaultItemMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.VaultItem, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *VaultItemMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *VaultItemMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (VaultItem).
func (m *VaultItemMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *VaultItemMutation) Fields() []string {
	fields := make([]string, 0, 12)
	if m._path != nil {
		fields = append(fields, vaultitem.FieldPath)
	}
	if m.name != nil {
		fields = append(fields, vaultitem.FieldName)
	}
	if m.size != nil {
		fields = append(fields, vaultitem.FieldSize)
	}
	if m.hash != nil {
		fields = append(fields, vaultitem.FieldHash)
	}
	if m.file_type != nil {
		fields = append(fields, vaultitem.FieldFileType)
	}
	if m.encrypted != nil {
		fields = append(fields, vaultitem.FieldEncrypted)
	}
	if m.metadata != nil {
		fields = append(fields, vaultitem.FieldMetadata)
	}
	if m.content != nil {
		fields = append(fields, vaultitem.FieldContent)
	}
	if m.is_dir != nil {
		fields = append(fields, vaultitem.FieldIsDir)
	}
	if m.created_at != nil {
		fields = append(fields, vaultitem.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, vaultitem.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, vaultitem.FieldDeletedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *VaultItemMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case vaultitem.FieldPath:
		return m.Path()
	case vaultitem.FieldName:
		return m.Name()
	case vaultitem.FieldSize:
		return m.Size()
	case vaultitem.FieldHash:
		return m.Hash()
	case vaultitem.FieldFileType:
		return m.FileType()
	case vaultitem.FieldEncrypted:
		return m.Encrypted()
	case vaultitem.FieldMetadata:
		return m.Metadata()
	case vaultitem.FieldContent:
		return m.Content()
	case vaultitem.FieldIsDir:
		return m.IsDir()
	case vaultitem.FieldCreatedAt:
		return m.CreatedAt()
	case vaultitem.FieldUpdatedAt:
		return m.UpdatedAt()
	case vaultitem.FieldDeletedAt:
		return m.DeletedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *VaultItemMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case vaultitem.FieldPath:
		return m.OldPath(ctx)
	case vaultitem.FieldName:
		return m.OldName(ctx)
	case vaultitem.FieldSize:
		return m.OldSize(ctx)
	case vaultitem.FieldHash:
		return m.OldHash(ctx)
	case vaultitem.FieldFileType:
		return m.OldFileType(ctx)
	case vaultitem.FieldEncrypted:
		return m.OldEncrypted(ctx)
	case vaultitem.FieldMetadata:
		return m.OldMetadata(ctx)
	case vaultitem.FieldContent:
		return m.OldContent(ctx)
	case vaultitem.FieldIsDir:
		return m.OldIsDir(ctx)
	case vaultitem.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case vaultitem.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case vaultitem.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	}
	return nil, fmt.Errorf("unknown VaultItem field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *VaultItemMutation) SetField(name string, value ent.Value) error {
	switch name {
	case vaultitem.FieldPath:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPath(v)
		return nil
	case vaultitem.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case vaultitem.FieldSize:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSize(v)
		return nil
	case vaultitem.FieldHash:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHash(v)
		return nil
	case vaultitem.FieldFileType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFileType(v)
		return nil
	case vaultitem.FieldEncrypted:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEncrypted(v)
		return nil
	case vaultitem.FieldMetadata:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetadata(v)
		return nil
	case vaultitem.FieldContent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContent(v)
		return nil
	case vaultitem.FieldIsDir:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsDir(v)
		return nil
	case vaultitem.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case vaultitem.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case vaultitem.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	}
	return fmt.Errorf("unknown VaultItem field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *VaultItemMutation) AddedFields() []string {
	var fields []string
	if m.addsize != nil {
		fields = append(fields, vaultitem.FieldSize)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *VaultItemMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case vaultitem.FieldSize:
		return m.AddedSize()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *VaultItemMutation) AddField(name string, value ent.Value) error {
	switch name {
	case vaultitem.FieldSize:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSize(v)
		return nil
	}
	return fmt.Errorf("unknown VaultItem numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *VaultItemMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(vaultitem.FieldFileType) {
		fields = append(fields, vaultitem.FieldFileType)
	}
	if m.FieldCleared(vaultitem.FieldMetadata) {
		fields = append(fields, vaultitem.FieldMetadata)
	}
	if m.FieldCleared(vaultitem.FieldContent) {
		fields = append(fields, vaultitem.FieldContent)
	}
	if m.FieldCleared(vaultitem.FieldDeletedAt) {
		fields = append(fields, vaultitem.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *VaultItemMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *VaultItemMutation) ClearField(name string) error {
	switch name {
	case vaultitem.FieldFileType:
		m.ClearFileType()
		return nil
	case vaultitem.FieldMetadata:
		m.ClearMetadata()
		return nil
	case vaultitem.FieldContent:
		m.ClearContent()
		return nil
	case vaultitem.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown VaultItem nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *VaultItemMutation) ResetField(name string) error {
	switch name {
	case vaultitem.FieldPath:
		m.ResetPath()
		return nil
	case vaultitem.FieldName:
		m.ResetName()
		return nil
	case vaultitem.FieldSize:
		m.ResetSize()
		return nil
	case vaultitem.FieldHash:
		m.ResetHash()
		return nil
	case vaultitem.FieldFileType:
		m.ResetFileType()
		return nil
	case vaultitem.FieldEncrypted:
		m.ResetEncrypted()
		return nil
	case vaultitem.FieldMetadata:
		m.ResetMetadata()
		return nil
	case vaultitem.FieldContent:
		m.ResetContent()
		return nil
	case vaultitem.FieldIsDir:
		m.ResetIsDir()
		return nil
	case vaultitem.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case vaultitem.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case vaultitem.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown VaultItem field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *VaultItemMutation) AddedEdges() []string {
	edges := make([]string, 0, 6)
	if m.tenant != nil {
		edges = append(edges, vaultitem.EdgeTenant)
	}
	if m.share_links != nil {
		edges = append(edges, vaultitem.EdgeShareLinks)
	}
	if m.versions != nil {
		edges = append(edges, vaultitem.EdgeVersions)
	}
	if m.comments != nil {
		edges = append(edges, vaultitem.EdgeComments)
	}
	if m.favorited_by != nil {
		edges = append(edges, vaultitem.EdgeFavoritedBy)
	}
	if m.legal_holds != nil {
		edges = append(edges, vaultitem.EdgeLegalHolds)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *VaultItemMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case vaultitem.EdgeTenant:
		if id := m.tenant; id != nil {
			return []ent.Value{*id}
		}
	case vaultitem.EdgeShareLinks:
		ids := make([]ent.Value, 0, len(m.share_links))
		for id := range m.share_links {
			ids = append(ids, id)
		}
		return ids
	case vaultitem.EdgeVersions:
		ids := make([]ent.Value, 0, len(m.versions))
		for id := range m.versions {
			ids = append(ids, id)
		}
		return ids
	case vaultitem.EdgeComments:
		ids := make([]ent.Value, 0, len(m.comments))
		for id := range m.comments {
			ids = append(ids, id)
		}
		return ids
	case vaultitem.EdgeFavoritedBy:
		ids := make([]ent.Value, 0, len(m.favorited_by))
		for id := range m.favorited_by {
			ids = append(ids, id)
		}
		return ids
	case vaultitem.EdgeLegalHolds:
		ids := make([]ent.Value, 0, len(m.legal_holds))
		for id := range m.legal_holds {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *VaultItemMutation) RemovedEdges() []string {
	edges := make([]string, 0, 6)
	if m.removedshare_links != nil {
		edges = append(edges, vaultitem.EdgeShareLinks)
	}
	if m.removedversions != nil {
		edges = append(edges, vaultitem.EdgeVersions)
	}
	if m.removedcomments != nil {
		edges = append(edges, vaultitem.EdgeComments)
	}
	if m.removedfavorited_by != nil {
		edges = append(edges, vaultitem.EdgeFavoritedBy)
	}
	if m.removedlegal_holds != nil {
		edges = append(edges, vaultitem.EdgeLegalHolds)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *VaultItemMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case vaultitem.EdgeShareLinks:
		ids := make([]ent.Value, 0, len(m.removedshare_links))
		for id := range m.removedshare_links {
			ids = append(ids, id)
		}
		return ids
	case vaultitem.EdgeVersions:
		ids := make([]ent.Value, 0, len(m.removedversions))
		for id := range m.removedversions {
			ids = append(ids, id)
		}
		return ids
	case vaultitem.EdgeComments:
		ids := make([]ent.Value, 0, len(m.removedcomments))
		for id := range m.removedcomments {
			ids = append(ids, id)
		}
		return ids
	case vaultitem.EdgeFavoritedBy:
		ids := make([]ent.Value, 0, len(m.removedfavorited_by))
		for id := range m.removedfavorited_by {
			ids = append(ids, id)
		}
		return ids
	case vaultitem.EdgeLegalHolds:
		ids := make([]ent.Value, 0, len(m.removedlegal_holds))
		for id := range m.removedlegal_holds {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *VaultItemMutation) ClearedEdges() []string {
	edges := make([]string, 0, 6)
	if m.clearedtenant {
		edges = append(edges, vaultitem.EdgeTenant)
	}
	if m.clearedshare_links {
		edges = append(edges, vaultitem.EdgeShareLinks)
	}
	if m.clearedversions {
		edges = append(edges, vaultitem.EdgeVersions)
	}
	if m.clearedcomments {
		edges = append(edges, vaultitem.EdgeComments)
	}
	if m.clearedfavorited_by {
		edges = append(edges, vaultitem.EdgeFavoritedBy)
	}
	if m.clearedlegal_holds {
		edges = append(edges, vaultitem.EdgeLegalHolds)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *VaultItemMutation) EdgeCleared(name string) bool {
	switch name {
	case vaultitem.EdgeTenant:
		return m.clearedtenant
	case vaultitem.EdgeShareLinks:
		return m.clearedshare_links
	case vaultitem.EdgeVersions:
		return m.clearedversions
	case vaultitem.EdgeComments:
		return m.clearedcomments
	case vaultitem.EdgeFavoritedBy:
		return m.clearedfavorited_by
	case vaultitem.EdgeLegalHolds:
		return m.clearedlegal_holds
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *VaultItemMutation) ClearEdge(name string) error {
	switch name {
	case vaultitem.EdgeTenant:
		m.ClearTenant()
		return nil
	}
	return fmt.Errorf("unknown VaultItem unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *VaultItemMutation) ResetEdge(name string) error {
	switch name {
	case vaultitem.EdgeTenant:
		m.ResetTenant()
		return nil
	case vaultitem.EdgeShareLinks:
		m.ResetShareLinks()
		return nil
	case vaultitem.EdgeVersions:
		m.ResetVersions()
		return nil
	case vaultitem.EdgeComments:
		m.ResetComments()
		return nil
	case vaultitem.EdgeFavoritedBy:
		m.ResetFavoritedBy()
		return nil
	case vaultitem.EdgeLegalHolds:
		m.ResetLegalHolds()
		return nil
	}
	return fmt.Errorf("unknown VaultItem edge %s", name)
}

// VaultShareLinkMutation represents an operation that mutates the VaultShareLink nodes in the graph.
type VaultShareLinkMutation struct {
	config
	op            Op
	typ           string
	id            *int
	token         *string
	name          *string
	password_hash *string
	expires_at    *time.Time
	max_views     *int
	addmax_views  *int
	view_count    *int
	addview_count *int
	created_at    *time.Time
	clearedFields map[string]struct{}
	item          *int
	cleareditem   bool
	tenant        *int
	clearedtenant bool
	done          bool
	oldValue      func(context.Context) (*VaultShareLink, error)
	predicates    []predicate.VaultShareLink
}

var _ ent.Mutation = (*VaultShareLinkMutation)(nil)

// vaultsharelinkOption allows management of the mutation configuration using functional options.
type vaultsharelinkOption func(*VaultShareLinkMutation)

// newVaultShareLinkMutation creates new mutation for the VaultShareLink entity.
func newVaultShareLinkMutation(c config, op Op, opts ...vaultsharelinkOption) *VaultShareLinkMutation {
	m := &VaultShareLinkMutation{
		config:        c,
		op:            op,
		typ:           TypeVaultShareLink,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withVaultShareLinkID sets the ID field of the mutation.
func withVaultShareLinkID(id int) vaultsharelinkOption {
	return func(m *VaultShareLinkMutation) {
		var (
			err   error
			once  sync.Once
			value *VaultShareLink
		)
		m.oldValue = func(ctx context.Context) (*VaultShareLink, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().VaultShareLink.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withVaultShareLink sets the old VaultShareLink of the mutation.
func withVaultShareLink(node *VaultShareLink) vaultsharelinkOption {
	return func(m *VaultShareLinkMutation) {
		m.oldValue = func(context.Context) (*VaultShareLink, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m VaultShareLinkMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m VaultShareLinkMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *VaultShareLinkMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *VaultShareLinkMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().VaultShareLink.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetToken sets the "token" field.
func (m *VaultShareLinkMutation) SetToken(s string) {
	m.token = &s
}

// Token returns the value of the "token" field in the mutation.
func (m *VaultShareLinkMutation) Token() (r string, exists bool) {
	v := m.token
	if v == nil {
		return
	}
	return *v, true
}

// OldToken returns the old "token" field's value of the VaultShareLink entity.
// If the VaultShareLink object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VaultShareLinkMutation) OldToken(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldToken is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldToken requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldToken: %w", err)
	}
	return oldValue.Token, nil
}

// ResetToken resets all changes to the "token" field.
func (m *VaultShareLinkMutation) ResetToken() {
	m.token = nil
}

// SetName sets the "name" field.
func (m *VaultShareLinkMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *VaultShareLinkMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the VaultShareLink entity.
// If the VaultShareLink object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VaultShareLinkMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ClearName clears the value of the "name" field.
func (m *VaultShareLinkMutation) ClearName() {
	m.name = nil
	m.clearedFields[vaultsharelink.FieldName] = struct{}{}
}

// NameCleared returns if the "name" field was cleared in this mutation.
func (m *VaultShareLinkMutation) NameCleared() bool {
	_, ok := m.clearedFields[vaultsharelink.FieldName]
	return ok
}

// ResetName resets all changes to the "name" field.
func (m *VaultShareLinkMutation) ResetName() {
	m.name = nil
	delete(m.clearedFields, vaultsharelink.FieldName)
}

// SetPasswordHash sets the "password_hash" field.
func (m *VaultShareLinkMutation) SetPasswordHash(s string) {
	m.password_hash = &s
}

// PasswordHash returns the value of the "password_hash" field in the mutation.
func (m *VaultShareLinkMutation) PasswordHash() (r string, exists bool) {
	v := m.password_hash
	if v == nil {
		return
	}
	return *v, true
}

// OldPasswordHash returns the old "password_hash" field's value of the VaultShareLink entity.
// If the VaultShareLink object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VaultShareLinkMutation) OldPasswordHash(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPasswordHash is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPasswordHash requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPasswordHash: %w", err)
	}
	return oldValue.PasswordHash, nil
}

// ClearPasswordHash clears the value of the "password_hash" field.
func (m *VaultShareLinkMutation) ClearPasswordHash() {
	m.password_hash = nil
	m.clearedFields[vaultsharelink.FieldPasswordHash] = struct{}{}
}

// PasswordHashCleared returns if the "password_hash" field was cleared in this mutation.
func (m *VaultShareLinkMutation) PasswordHashCleared() bool {
	_, ok := m.clearedFields[vaultsharelink.FieldPasswordHash]
	return ok
}

// ResetPasswordHash resets all changes to the "password_hash" field.
func (m *VaultShareLinkMutation) ResetPasswordHash() {
	m.password_hash = nil
	delete(m.clearedFields, vaultsharelink.FieldPasswordHash)
}

// SetExpiresAt sets the "expires_at" field.
func (m *VaultShareLinkMutation) SetExpiresAt(t time.Time) {
	m.expires_at = &t
}

// ExpiresAt returns the value of the "expires_at" field in the mutation.
func (m *VaultShareLinkMutation) ExpiresAt() (r time.Time, exists bool) {
	v := m.expires_at
	if v == nil {
		return
	}
	return *v, true
}

// OldExpiresAt returns the old "expires_at" field's value of the VaultShareLink entity.
// If the VaultShareLink object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VaultShareLinkMutation) OldExpiresAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpiresAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpiresAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpiresAt: %w", err)
	}
	return oldValue.ExpiresAt, nil
}

// ResetExpiresAt resets all changes to the "expires_at" field.
func (m *VaultShareLinkMutation) ResetExpiresAt() {
	m.expires_at = nil
}

// SetMaxViews sets the "max_views" field.
func (m *VaultShareLinkMutation) SetMaxViews(i int) {
	m.max_views = &i
	m.addmax_views = nil
}

// MaxViews returns the value of the "max_views" field in the mutation.
func (m *VaultShareLinkMutation) MaxViews() (r int, exists bool) {
	v := m.max_views
	if v == nil {
		return
	}
	return *v, true
}

// OldMaxViews returns the old "max_views" field's value of the VaultShareLink entity.
// If the VaultShareLink object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VaultShareLinkMutation) OldMaxViews(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMaxViews is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMaxViews requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMaxViews: %w", err)
	}
	return oldValue.MaxViews, nil
}

// AddMaxViews adds i to the "max_views" field.
func (m *VaultShareLinkMutation) AddMaxViews(i int) {
	if m.addmax_views != nil {
		*m.addmax_views += i
	} else {
		m.addmax_views = &i
	}
}

// AddedMaxViews returns the value that was added to the "max_views" field in this mutation.
func (m *VaultShareLinkMutation) AddedMaxViews() (r int, exists bool) {
	v := m.addmax_views
	if v == nil {
		return
	}
	return *v, true
}

// ResetMaxViews resets all changes to the "max_views" field.
func (m *VaultShareLinkMutation) ResetMaxViews() {
	m.max_views = nil
	m.addmax_views = nil
}

// SetViewCount sets the "view_count" field.
func (m *VaultShareLinkMutation) SetViewCount(i int) {
	m.view_count = &i
	m.addview_count = nil
}

// ViewCount returns the value of the "view_count" field in the mutation.
func (m *VaultShareLinkMutation) ViewCount() (r int, exists bool) {
	v := m.view_count
	if v == nil {
		return
	}
	return *v, true
}

// OldViewCount returns the old "view_count" field's value of the VaultShareLink entity.
// If the VaultShareLink object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VaultShareLinkMutation) OldViewCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldViewCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldViewCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldViewCount: %w", err)
	}
	return oldValue.ViewCount, nil
}

// AddViewCount adds i to the "view_count" field.
func (m *VaultShareLinkMutation) AddViewCount(i int) {
	if m.addview_count != nil {
		*m.addview_count += i
	} else {
		m.addview_count = &i
	}
}

// AddedViewCount returns the value that was added to the "view_count" field in this mutation.
func (m *VaultShareLinkMutation) AddedViewCount() (r int, exists bool) {
	v := m.addview_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetViewCount resets all changes to the "view_count" field.
func (m *VaultShareLinkMutation) ResetViewCount() {
	m.view_count = nil
	m.addview_count = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *VaultShareLinkMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *VaultShareLinkMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the VaultShareLink entity.
// If the VaultShareLink object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VaultShareLinkMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *VaultShareLinkMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetItemID sets the "item" edge to the VaultItem entity by id.
func (m *VaultShareLinkMutation) SetItemID(id int) {
	m.item = &id
}

// ClearItem clears the "item" edge to the VaultItem entity.
func (m *VaultShareLinkMutation) ClearItem() {
	m.cleareditem = true
}

// ItemCleared reports if the "item" edge to the VaultItem entity was cleared.
func (m *VaultShareLinkMutation) ItemCleared() bool {
	return m.cleareditem
}

// ItemID returns the "item" edge ID in the mutation.
func (m *VaultShareLinkMutation) ItemID() (id int, exists bool) {
	if m.item != nil {
		return *m.item, true
	}
	return
}

// ItemIDs returns the "item" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ItemID instead. It exists only for internal usage by the builders.
func (m *VaultShareLinkMutation) ItemIDs() (ids []int) {
	if id := m.item; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetItem resets all changes to the "item" edge.
func (m *VaultShareLinkMutation) ResetItem() {
	m.item = nil
	m.cleareditem = false
}

// SetTenantID sets the "tenant" edge to the Tenant entity by id.
func (m *VaultShareLinkMutation) SetTenantID(id int) {
	m.tenant = &id
}

// ClearTenant clears the "tenant" edge to the Tenant entity.
func (m *VaultShareLinkMutation) ClearTenant() {
	m.clearedtenant = true
}

// TenantCleared reports if the "tenant" edge to the Tenant entity was cleared.
func (m *VaultShareLinkMutation) TenantCleared() bool {
	return m.clearedtenant
}

// TenantID returns the "tenant" edge ID in the mutation.
func (m *VaultShareLinkMutation) TenantID() (id int, exists bool) {
	if m.tenant != nil {
		return *m.tenant, true
	}
	return
}

// TenantIDs returns the "tenant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TenantID instead. It exists only for internal usage by the builders.
func (m *VaultShareLinkMutation) TenantIDs() (ids []int) {
	if id := m.tenant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTenant resets all changes to the "tenant" edge.
func (m *VaultShareLinkMutation) ResetTenant() {
	m.tenant = nil
	m.clearedtenant = false
}

// Where appends a list predicates to the VaultShareLinkMutation builder.
func (m *VaultShareLinkMutation) Where(ps ...predicate.VaultShareLink) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the VaultShareLinkMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *VaultShareLinkMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.VaultShareLink, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *VaultShareLinkMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *VaultShareLinkMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (VaultShareLink).
func (m *VaultShareLinkMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *VaultShareLinkMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.token != nil {
		fields = append(fields, vaultsharelink.FieldToken)
	}
	if m.name != nil {
		fields = append(fields, vaultsharelink.FieldName)
	}
	if m.password_hash != nil {
		fields = append(fields, vaultsharelink.FieldPasswordHash)
	}
	if m.expires_at != nil {
		fields = append(fields, vaultsharelink.FieldExpiresAt)
	}
	if m.max_views != nil {
		fields = append(fields, vaultsharelink.FieldMaxViews)
	}
	if m.view_count != nil {
		fields = append(fields, vaultsharelink.FieldViewCount)
	}
	if m.created_at != nil {
		fields = append(fields, vaultsharelink.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *VaultShareLinkMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case vaultsharelink.FieldToken:
		return m.Token()
	case vaultsharelink.FieldName:
		return m.Name()
	case vaultsharelink.FieldPasswordHash:
		return m.PasswordHash()
	case vaultsharelink.FieldExpiresAt:
		return m.ExpiresAt()
	case vaultsharelink.FieldMaxViews:
		return m.MaxViews()
	case vaultsharelink.FieldViewCount:
		return m.ViewCount()
	case vaultsharelink.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *VaultShareLinkMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case vaultsharelink.FieldToken:
		return m.OldToken(ctx)
	case vaultsharelink.FieldName:
		return m.OldName(ctx)
	case vaultsharelink.FieldPasswordHash:
		return m.OldPasswordHash(ctx)
	case vaultsharelink.FieldExpiresAt:
		return m.OldExpiresAt(ctx)
	case vaultsharelink.FieldMaxViews:
		return m.OldMaxViews(ctx)
	case vaultsharelink.FieldViewCount:
		return m.OldViewCount(ctx)
	case vaultsharelink.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown VaultShareLink field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *VaultShareLinkMutation) SetField(name string, value ent.Value) error {
	switch name {
	case vaultsharelink.FieldToken:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetToken(v)
		return nil
	case vaultsharelink.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case vaultsharelink.FieldPasswordHash:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPasswordHash(v)
		return nil
	case vaultsharelink.FieldExpiresAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpiresAt(v)
		return nil
	case vaultsharelink.FieldMaxViews:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMaxViews(v)
		return nil
	case vaultsharelink.FieldViewCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetViewCount(v)
		return nil
	case vaultsharelink.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown VaultShareLink field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *VaultShareLinkMutation) AddedFields() []string {
	var fields []string
	if m.addmax_views != nil {
		fields = append(fields, vaultsharelink.FieldMaxViews)
	}
	if m.addview_count != nil {
		fields = append(fields, vaultsharelink.FieldViewCount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *VaultShareLinkMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case vaultsharelink.FieldMaxViews:
		return m.AddedMaxViews()
	case vaultsharelink.FieldViewCount:
		return m.AddedViewCount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *VaultShareLinkMutation) AddField(name string, value ent.Value) error {
	switch name {
	case vaultsharelink.FieldMaxViews:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMaxViews(v)
		return nil
	case vaultsharelink.FieldViewCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddViewCount(v)
		return nil
	}
	return fmt.Errorf("unknown VaultShareLink numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *VaultShareLinkMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(vaultsharelink.FieldName) {
		fields = append(fields, vaultsharelink.FieldName)
	}
	if m.FieldCleared(vaultsharelink.FieldPasswordHash) {
		fields = append(fields, vaultsharelink.FieldPasswordHash)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *VaultShareLinkMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *VaultShareLinkMutation) ClearField(name string) error {
	switch name {
	case vaultsharelink.FieldName:
		m.ClearName()
		return nil
	case vaultsharelink.FieldPasswordHash:
		m.ClearPasswordHash()
		return nil
	}
	return fmt.Errorf("unknown VaultShareLink nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *VaultShareLinkMutation) ResetField(name string) error {
	switch name {
	case vaultsharelink.FieldToken:
		m.ResetToken()
		return nil
	case vaultsharelink.FieldName:
		m.ResetName()
		return nil
	case vaultsharelink.FieldPasswordHash:
		m.ResetPasswordHash()
		return nil
	case vaultsharelink.FieldExpiresAt:
		m.ResetExpiresAt()
		return nil
	case vaultsharelink.FieldMaxViews:
		m.ResetMaxViews()
		return nil
	case vaultsharelink.FieldViewCount:
		m.ResetViewCount()
		return nil
	case vaultsharelink.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown VaultShareLink field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *VaultShareLinkMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.item != nil {
		edges = append(edges, vaultsharelink.EdgeItem)
	}
	if m.tenant != nil {
		edges = append(edges, vaultsharelink.EdgeTenant)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *VaultShareLinkMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case vaultsharelink.EdgeItem:
		if id := m.item; id != nil {
			return []ent.Value{*id}
		}
	case vaultsharelink.EdgeTenant:
		if id := m.tenant; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *VaultShareLinkMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *VaultShareLinkMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *VaultShareLinkMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleareditem {
		edges = append(edges, vaultsharelink.EdgeItem)
	}
	if m.clearedtenant {
		edges = append(edges, vaultsharelink.EdgeTenant)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *VaultShareLinkMutation) EdgeCleared(name string) bool {
	switch name {
	case vaultsharelink.EdgeItem:
		return m.cleareditem
	case vaultsharelink.EdgeTenant:
		return m.clearedtenant
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *VaultShareLinkMutation) ClearEdge(name string) error {
	switch name {
	case vaultsharelink.EdgeItem:
		m.ClearItem()
		return nil
	case vaultsharelink.EdgeTenant:
		m.ClearTenant()
		return nil
	}
	return fmt.Errorf("unknown VaultShareLink unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *VaultShareLinkMutation) ResetEdge(name string) error {
	switch name {
	case vaultsharelink.EdgeItem:
		m.ResetItem()
		return nil
	case vaultsharelink.EdgeTenant:
		m.ResetTenant()
		return nil
	}
	return fmt.Errorf("unknown VaultShareLink edge %s", name)
}

// VaultTemplateMutation represents an operation that mutates the VaultTemplate nodes in the graph.
type VaultTemplateMutation struct {
	config
	op                Op
	typ               string
	id                *int
	name              *string
	description       *string
	content_hash      *string
	file_extension    *string
	created_at        *time.Time
	clearedFields     map[string]struct{}
	tenant            *int
	clearedtenant     bool
	created_by        *int
	clearedcreated_by bool
	done              bool
	oldValue          func(context.Context) (*VaultTemplate, error)
	predicates        []predicate.VaultTemplate
}

var _ ent.Mutation = (*VaultTemplateMutation)(nil)

// vaulttemplateOption allows management of the mutation configuration using functional options.
type vaulttemplateOption func(*VaultTemplateMutation)

// newVaultTemplateMutation creates new mutation for the VaultTemplate entity.
func newVaultTemplateMutation(c config, op Op, opts ...vaulttemplateOption) *VaultTemplateMutation {
	m := &VaultTemplateMutation{
		config:        c,
		op:            op,
		typ:           TypeVaultTemplate,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withVaultTemplateID sets the ID field of the mutation.
func withVaultTemplateID(id int) vaulttemplateOption {
	return func(m *VaultTemplateMutation) {
		var (
			err   error
			once  sync.Once
			value *VaultTemplate
		)
		m.oldValue = func(ctx context.Context) (*VaultTemplate, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().VaultTemplate.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withVaultTemplate sets the old VaultTemplate of the mutation.
func withVaultTemplate(node *VaultTemplate) vaulttemplateOption {
	return func(m *VaultTemplateMutation) {
		m.oldValue = func(context.Context) (*VaultTemplate, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m VaultTemplateMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m VaultTemplateMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *VaultTemplateMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *VaultTemplateMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().VaultTemplate.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *VaultTemplateMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *VaultTemplateMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the VaultTemplate entity.
// If the VaultTemplate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VaultTemplateMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *VaultTemplateMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *VaultTemplateMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *VaultTemplateMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the VaultTemplate entity.
// If the VaultTemplate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VaultTemplateMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *VaultTemplateMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[vaulttemplate.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *VaultTemplateMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[vaulttemplate.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *VaultTemplateMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, vaulttemplate.FieldDescription)
}

// SetContentHash sets the "content_hash" field.
func (m *VaultTemplateMutation) SetContentHash(s string) {
	m.content_hash = &s
}

// ContentHash returns the value of the "content_hash" field in the mutation.
func (m *VaultTemplateMutation) ContentHash() (r string, exists bool) {
	v := m.content_hash
	if v == nil {
		return
	}
	return *v, true
}

// OldContentHash returns the old "content_hash" field's value of the VaultTemplate entity.
// If the VaultTemplate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VaultTemplateMutation) OldContentHash(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContentHash is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContentHash requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContentHash: %w", err)
	}
	return oldValue.ContentHash, nil
}

// ResetContentHash resets all changes to the "content_hash" field.
func (m *VaultTemplateMutation) ResetContentHash() {
	m.content_hash = nil
}

// SetFileExtension sets the "file_extension" field.
func (m *VaultTemplateMutation) SetFileExtension(s string) {
	m.file_extension = &s
}

// FileExtension returns the value of the "file_extension" field in the mutation.
func (m *VaultTemplateMutation) FileExtension() (r string, exists bool) {
	v := m.file_extension
	if v == nil {
		return
	}
	return *v, true
}

// OldFileExtension returns the old "file_extension" field's value of the VaultTemplate entity.
// If the VaultTemplate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VaultTemplateMutation) OldFileExtension(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFileExtension is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFileExtension requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFileExtension: %w", err)
	}
	return oldValue.FileExtension, nil
}

// ResetFileExtension resets all changes to the "file_extension" field.
func (m *VaultTemplateMutation) ResetFileExtension() {
	m.file_extension = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *VaultTemplateMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *VaultTemplateMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the VaultTemplate entity.
// If the VaultTemplate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VaultTemplateMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *VaultTemplateMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetTenantID sets the "tenant" edge to the Tenant entity by id.
func (m *VaultTemplateMutation) SetTenantID(id int) {
	m.tenant = &id
}

// ClearTenant clears the "tenant" edge to the Tenant entity.
func (m *VaultTemplateMutation) ClearTenant() {
	m.clearedtenant = true
}

// TenantCleared reports if the "tenant" edge to the Tenant entity was cleared.
func (m *VaultTemplateMutation) TenantCleared() bool {
	return m.clearedtenant
}

// TenantID returns the "tenant" edge ID in the mutation.
func (m *VaultTemplateMutation) TenantID() (id int, exists bool) {
	if m.tenant != nil {
		return *m.tenant, true
	}
	return
}

// TenantIDs returns the "tenant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TenantID instead. It exists only for internal usage by the builders.
func (m *VaultTemplateMutation) TenantIDs() (ids []int) {
	if id := m.tenant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTenant resets all changes to the "tenant" edge.
func (m *VaultTemplateMutation) ResetTenant() {
	m.tenant = nil
	m.clearedtenant = false
}

// SetCreatedByID sets the "created_by" edge to the User entity by id.
func (m *VaultTemplateMutation) SetCreatedByID(id int) {
	m.created_by = &id
}

// ClearCreatedBy clears the "created_by" edge to the User entity.
func (m *VaultTemplateMutation) ClearCreatedBy() {
	m.clearedcreated_by = true
}

// CreatedByCleared reports if the "created_by" edge to the User entity was cleared.
func (m *VaultTemplateMutation) CreatedByCleared() bool {
	return m.clearedcreated_by
}

// CreatedByID returns the "created_by" edge ID in the mutation.
func (m *VaultTemplateMutation) CreatedByID() (id int, exists bool) {
	if m.created_by != nil {
		return *m.created_by, true
	}
	return
}

// CreatedByIDs returns the "created_by" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CreatedByID instead. It exists only for internal usage by the builders.
func (m *VaultTemplateMutation) CreatedByIDs() (ids []int) {
	if id := m.created_by; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCreatedBy resets all changes to the "created_by" edge.
func (m *VaultTemplateMutation) ResetCreatedBy() {
	m.created_by = nil
	m.clearedcreated_by = false
}

// Where appends a list predicates to the VaultTemplateMutation builder.
func (m *VaultTemplateMutation) Where(ps ...predicate.VaultTemplate) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the VaultTemplateMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *VaultTemplateMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.VaultTemplate, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *VaultTemplateMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *VaultTemplateMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (VaultTemplate).
func (m *VaultTemplateMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *VaultTemplateMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.name != nil {
		fields = append(fields, vaulttemplate.FieldName)
	}
	if m.description != nil {
		fields = append(fields, vaulttemplate.FieldDescription)
	}
	if m.content_hash != nil {
		fields = append(fields, vaulttemplate.FieldContentHash)
	}
	if m.file_extension != nil {
		fields = append(fields, vaulttemplate.FieldFileExtension)
	}
	if m.created_at != nil {
		fields = append(fields, vaulttemplate.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *VaultTemplateMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case vaulttemplate.FieldName:
		return m.Name()
	case vaulttemplate.FieldDescription:
		return m.Description()
	case vaulttemplate.FieldContentHash:
		return m.ContentHash()
	case vaulttemplate.FieldFileExtension:
		return m.FileExtension()
	case vaulttemplate.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *VaultTemplateMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case vaulttemplate.FieldName:
		return m.OldName(ctx)
	case vaulttemplate.FieldDescription:
		return m.OldDescription(ctx)
	case vaulttemplate.FieldContentHash:
		return m.OldContentHash(ctx)
	case vaulttemplate.FieldFileExtension:
		return m.OldFileExtension(ctx)
	case vaulttemplate.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown VaultTemplate field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *VaultTemplateMutation) SetField(name string, value ent.Value) error {
	switch name {
	case vaulttemplate.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case vaulttemplate.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case vaulttemplate.FieldContentHash:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContentHash(v)
		return nil
	case vaulttemplate.FieldFileExtension:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFileExtension(v)
		return nil
	case vaulttemplate.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown VaultTemplate field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *VaultTemplateMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *VaultTemplateMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *VaultTemplateMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown VaultTemplate numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *VaultTemplateMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(vaulttemplate.FieldDescription) {
		fields = append(fields, vaulttemplate.FieldDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *VaultTemplateMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *VaultTemplateMutation) ClearField(name string) error {
	switch name {
	case vaulttemplate.FieldDescription:
		m.ClearDescription()
		return nil
	}
	return fmt.Errorf("unknown VaultTemplate nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *VaultTemplateMutation) ResetField(name string) error {
	switch name {
	case vaulttemplate.FieldName:
		m.ResetName()
		return nil
	case vaulttemplate.FieldDescription:
		m.ResetDescription()
		return nil
	case vaulttemplate.FieldContentHash:
		m.ResetContentHash()
		return nil
	case vaulttemplate.FieldFileExtension:
		m.ResetFileExtension()
		return nil
	case vaulttemplate.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown VaultTemplate field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *VaultTemplateMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.tenant != nil {
		edges = append(edges, vaulttemplate.EdgeTenant)
	}
	if m.created_by != nil {
		edges = append(edges, vaulttemplate.EdgeCreatedBy)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *VaultTemplateMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case vaulttemplate.EdgeTenant:
		if id := m.tenant; id != nil {
			return []ent.Value{*id}
		}
	case vaulttemplate.EdgeCreatedBy:
		if id := m.created_by; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *VaultTemplateMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *VaultTemplateMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *VaultTemplateMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedtenant {
		edges = append(edges, vaulttemplate.EdgeTenant)
	}
	if m.clearedcreated_by {
		edges = append(edges, vaulttemplate.EdgeCreatedBy)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *VaultTemplateMutation) EdgeCleared(name string) bool {
	switch name {
	case vaulttemplate.EdgeTenant:
		return m.clearedtenant
	case vaulttemplate.EdgeCreatedBy:
		return m.clearedcreated_by
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *VaultTemplateMutation) ClearEdge(name string) error {
	switch name {
	case vaulttemplate.EdgeTenant:
		m.ClearTenant()
		return nil
	case vaulttemplate.EdgeCreatedBy:
		m.ClearCreatedBy()
		return nil
	}
	return fmt.Errorf("unknown VaultTemplate unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *VaultTemplateMutation) ResetEdge(name string) error {
	switch name {
	case vaulttemplate.EdgeTenant:
		m.ResetTenant()
		return nil
	case vaulttemplate.EdgeCreatedBy:
		m.ResetCreatedBy()
		return nil
	}
	return fmt.Errorf("unknown VaultTemplate edge %s", name)
}

// VaultVersionMutation represents an operation that mutates the VaultVersion nodes in the graph.
type VaultVersionMutation struct {
	config
	op                Op
	typ               string
	id                *int
	version_number    *int
	addversion_number *int
	hash              *string
	size              *int64
	addsize           *int64
	comment           *string
	created_at        *time.Time
	clearedFields     map[string]struct{}
	item              *int
	cleareditem       bool
	created_by        *int
	clearedcreated_by bool
	done              bool
	oldValue          func(context.Context) (*VaultVersion, error)
	predicates        []predicate.VaultVersion
}

var _ ent.Mutation = (*VaultVersionMutation)(nil)

// vaultversionOption allows management of the mutation configuration using functional options.
type vaultversionOption func(*VaultVersionMutation)

// newVaultVersionMutation creates new mutation for the VaultVersion entity.
func newVaultVersionMutation(c config, op Op, opts ...vaultversionOption) *VaultVersionMutation {
	m := &VaultVersionMutation{
		config:        c,
		op:            op,
		typ:           TypeVaultVersion,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withVaultVersionID sets the ID field of the mutation.
func withVaultVersionID(id int) vaultversionOption {
	return func(m *VaultVersionMutation) {
		var (
			err   error
			once  sync.Once
			value *VaultVersion
		)
		m.oldValue = func(ctx context.Context) (*VaultVersion, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().VaultVersion.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withVaultVersion sets the old VaultVersion of the mutation.
func withVaultVersion(node *VaultVersion) vaultversionOption {
	return func(m *VaultVersionMutation) {
		m.oldValue = func(context.Context) (*VaultVersion, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m VaultVersionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m VaultVersionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *VaultVersionMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *VaultVersionMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().VaultVersion.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetVersionNumber sets the "version_number" field.
func (m *VaultVersionMutation) SetVersionNumber(i int) {
	m.version_number = &i
	m.addversion_number = nil
}

// VersionNumber returns the value of the "version_number" field in the mutation.
func (m *VaultVersionMutation) VersionNumber() (r int, exists bool) {
	v := m.version_number
	if v == nil {
		return
	}
	return *v, true
}

// OldVersionNumber returns the old "version_number" field's value of the VaultVersion entity.
// If the VaultVersion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VaultVersionMutation) OldVersionNumber(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVersionNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVersionNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVersionNumber: %w", err)
	}
	return oldValue.VersionNumber, nil
}

// AddVersionNumber adds i to the "version_number" field.
func (m *VaultVersionMutation) AddVersionNumber(i int) {
	if m.addversion_number != nil {
		*m.addversion_number += i
	} else {
		m.addversion_number = &i
	}
}

// AddedVersionNumber returns the value that was added to the "version_number" field in this mutation.
func (m *VaultVersionMutation) AddedVersionNumber() (r int, exists bool) {
	v := m.addversion_number
	if v == nil {
		return
	}
	return *v, true
}

// ResetVersionNumber resets all changes to the "version_number" field.
func (m *VaultVersionMutation) ResetVersionNumber() {
	m.version_number = nil
	m.addversion_number = nil
}

// SetHash sets the "hash" field.
func (m *VaultVersionMutation) SetHash(s string) {
	m.hash = &s
}

// Hash returns the value of the "hash" field in the mutation.
func (m *VaultVersionMutation) Hash() (r string, exists bool) {
	v := m.hash
	if v == nil {
		return
	}
	return *v, true
}

// OldHash returns the old "hash" field's value of the VaultVersion entity.
// If the VaultVersion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VaultVersionMutation) OldHash(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHash is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHash requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHash: %w", err)
	}
	return oldValue.Hash, nil
}

// ResetHash resets all changes to the "hash" field.
func (m *VaultVersionMutation) ResetHash() {
	m.hash = nil
}

// SetSize sets the "size" field.
func (m *VaultVersionMutation) SetSize(i int64) {
	m.size = &i
	m.addsize = nil
}

// Size returns the value of the "size" field in the mutation.
func (m *VaultVersionMutation) Size() (r int64, exists bool) {
	v := m.size
	if v == nil {
		return
	}
	return *v, true
}

// OldSize returns the old "size" field's value of the VaultVersion entity.
// If the VaultVersion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VaultVersionMutation) OldSize(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSize is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSize requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSize: %w", err)
	}
	return oldValue.Size, nil
}

// AddSize adds i to the "size" field.
func (m *VaultVersionMutation) AddSize(i int64) {
	if m.addsize != nil {
		*m.addsize += i
	} else {
		m.addsize = &i
	}
}

// AddedSize returns the value that was added to the "size" field in this mutation.
func (m *VaultVersionMutation) AddedSize() (r int64, exists bool) {
	v := m.addsize
	if v == nil {
		return
	}
	return *v, true
}

// ResetSize resets all changes to the "size" field.
func (m *VaultVersionMutation) ResetSize() {
	m.size = nil
	m.addsize = nil
}

// SetComment sets the "comment" field.
func (m *VaultVersionMutation) SetComment(s string) {
	m.comment = &s
}

// Comment returns the value of the "comment" field in the mutation.
func (m *VaultVersionMutation) Comment() (r string, exists bool) {
	v := m.comment
	if v == nil {
		return
	}
	return *v, true
}

// OldComment returns the old "comment" field's value of the VaultVersion entity.
// If the VaultVersion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VaultVersionMutation) OldComment(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldComment is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldComment requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldComment: %w", err)
	}
	return oldValue.Comment, nil
}

// ClearComment clears the value of the "comment" field.
func (m *VaultVersionMutation) ClearComment() {
	m.comment = nil
	m.clearedFields[vaultversion.FieldComment] = struct{}{}
}

// CommentCleared returns if the "comment" field was cleared in this mutation.
func (m *VaultVersionMutation) CommentCleared() bool {
	_, ok := m.clearedFields[vaultversion.FieldComment]
	return ok
}

// ResetComment resets all changes to the "comment" field.
func (m *VaultVersionMutation) ResetComment() {
	m.comment = nil
	delete(m.clearedFields, vaultversion.FieldComment)
}

// SetCreatedAt sets the "created_at" field.
func (m *VaultVersionMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *VaultVersionMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the VaultVersion entity.
// If the VaultVersion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VaultVersionMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *VaultVersionMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetItemID sets the "item" edge to the VaultItem entity by id.
func (m *VaultVersionMutation) SetItemID(id int) {
	m.item = &id
}

// ClearItem clears the "item" edge to the VaultItem entity.
func (m *VaultVersionMutation) ClearItem() {
	m.cleareditem = true
}

// ItemCleared reports if the "item" edge to the VaultItem entity was cleared.
func (m *VaultVersionMutation) ItemCleared() bool {
	return m.cleareditem
}

// ItemID returns the "item" edge ID in the mutation.
func (m *VaultVersionMutation) ItemID() (id int, exists bool) {
	if m.item != nil {
		return *m.item, true
	}
	return
}

// ItemIDs returns the "item" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ItemID instead. It exists only for internal usage by the builders.
func (m *VaultVersionMutation) ItemIDs() (ids []int) {
	if id := m.item; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetItem resets all changes to the "item" edge.
func (m *VaultVersionMutation) ResetItem() {
	m.item = nil
	m.cleareditem = false
}

// SetCreatedByID sets the "created_by" edge to the User entity by id.
func (m *VaultVersionMutation) SetCreatedByID(id int) {
	m.created_by = &id
}

// ClearCreatedBy clears the "created_by" edge to the User entity.
func (m *VaultVersionMutation) ClearCreatedBy() {
	m.clearedcreated_by = true
}

// CreatedByCleared reports if the "created_by" edge to the User entity was cleared.
func (m *VaultVersionMutation) CreatedByCleared() bool {
	return m.clearedcreated_by
}

// CreatedByID returns the "created_by" edge ID in the mutation.
func (m *VaultVersionMutation) CreatedByID() (id int, exists bool) {
	if m.created_by != nil {
		return *m.created_by, true
	}
	return
}

// CreatedByIDs returns the "created_by" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CreatedByID instead. It exists only for internal usage by the builders.
func (m *VaultVersionMutation) CreatedByIDs() (ids []int) {
	if id := m.created_by; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCreatedBy resets all changes to the "created_by" edge.
func (m *VaultVersionMutation) ResetCreatedBy() {
	m.created_by = nil
	m.clearedcreated_by = false
}

// Where appends a list predicates to the VaultVersionMutation builder.
func (m *VaultVersionMutation) Where(ps ...predicate.VaultVersion) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the VaultVersionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *VaultVersionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.VaultVersion, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *VaultVersionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *VaultVersionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (VaultVersion).
func (m *VaultVersionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *VaultVersionMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.version_number != nil {
		fields = append(fields, vaultversion.FieldVersionNumber)
	}
	if m.hash != nil {
		fields = append(fields, vaultversion.FieldHash)
	}
	if m.size != nil {
		fields = append(fields, vaultversion.FieldSize)
	}
	if m.comment != nil {
		fields = append(fields, vaultversion.FieldComment)
	}
	if m.created_at != nil {
		fields = append(fields, vaultversion.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *VaultVersionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case vaultversion.FieldVersionNumber:
		return m.VersionNumber()
	case vaultversion.FieldHash:
		return m.Hash()
	case vaultversion.FieldSize:
		return m.Size()
	case vaultversion.FieldComment:
		return m.Comment()
	case vaultversion.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *VaultVersionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case vaultversion.FieldVersionNumber:
		return m.OldVersionNumber(ctx)
	case vaultversion.FieldHash:
		return m.OldHash(ctx)
	case vaultversion.FieldSize:
		return m.OldSize(ctx)
	case vaultversion.FieldComment:
		return m.OldComment(ctx)
	case vaultversion.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown VaultVersion field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *VaultVersionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case vaultversion.FieldVersionNumber:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVersionNumber(v)
		return nil
	case vaultversion.FieldHash:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHash(v)
		return nil
	case vaultversion.FieldSize:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSize(v)
		return nil
	case vaultversion.FieldComment:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetComment(v)
		return nil
	case vaultversion.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown VaultVersion field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *VaultVersionMutation) AddedFields() []string {
	var fields []string
	if m.addversion_number != nil {
		fields = append(fields, vaultversion.FieldVersionNumber)
	}
	if m.addsize != nil {
		fields = append(fields, vaultversion.FieldSize)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *VaultVersionMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case vaultversion.FieldVersionNumber:
		return m.AddedVersionNumber()
	case vaultversion.FieldSize:
		return m.AddedSize()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *VaultVersionMutation) AddField(name string, value ent.Value) error {
	switch name {
	case vaultversion.FieldVersionNumber:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddVersionNumber(v)
		return nil
	case vaultversion.FieldSize:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSize(v)
		return nil
	}
	return fmt.Errorf("unknown VaultVersion numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *VaultVersionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(vaultversion.FieldComment) {
		fields = append(fields, vaultversion.FieldComment)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *VaultVersionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *VaultVersionMutation) ClearField(name string) error {
	switch name {
	case vaultversion.FieldComment:
		m.ClearComment()
		return nil
	}
	return fmt.Errorf("unknown VaultVersion nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *VaultVersionMutation) ResetField(name string) error {
	switch name {
	case vaultversion.FieldVersionNumber:
		m.ResetVersionNumber()
		return nil
	case vaultversion.FieldHash:
		m.ResetHash()
		return nil
	case vaultversion.FieldSize:
		m.ResetSize()
		return nil
	case vaultversion.FieldComment:
		m.ResetComment()
		return nil
	case vaultversion.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown VaultVersion field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *VaultVersionMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.item != nil {
		edges = append(edges, vaultversion.EdgeItem)
	}
	if m.created_by != nil {
		edges = append(edges, vaultversion.EdgeCreatedBy)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *VaultVersionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case vaultversion.EdgeItem:
		if id := m.item; id != nil {
			return []ent.Value{*id}
		}
	case vaultversion.EdgeCreatedBy:
		if id := m.created_by; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *VaultVersionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *VaultVersionMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *VaultVersionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleareditem {
		edges = append(edges, vaultversion.EdgeItem)
	}
	if m.clearedcreated_by {
		edges = append(edges, vaultversion.EdgeCreatedBy)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *VaultVersionMutation) EdgeCleared(name string) bool {
	switch name {
	case vaultversion.EdgeItem:
		return m.cleareditem
	case vaultversion.EdgeCreatedBy:
		return m.clearedcreated_by
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *VaultVersionMutation) ClearEdge(name string) error {
	switch name {
	case vaultversion.EdgeItem:
		m.ClearItem()
		return nil
	case vaultversion.EdgeCreatedBy:
		m.ClearCreatedBy()
		return nil
	}
	return fmt.Errorf("unknown VaultVersion unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *VaultVersionMutation) ResetEdge(name string) error {
	switch name {
	case vaultversion.EdgeItem:
		m.ResetItem()
		return nil
	case vaultversion.EdgeCreatedBy:
		m.ResetCreatedBy()
		return nil
	}
	return fmt.Errorf("unknown VaultVersion edge %s", name)
}

// VoicemailMutation represents an operation that mutates the Voicemail nodes in the graph.
type VoicemailMutation struct {
	config
	op            Op
	typ           string
	id            *int
	caller        *string
	audio_path    *string
	transcription *string
	created_at    *time.Time
	duration      *int
	addduration   *int
	read_at       *time.Time
	clearedFields map[string]struct{}
	tenant        *int
	clearedtenant bool
	user          *int
	cleareduser   bool
	done          bool
	oldValue      func(context.Context) (*Voicemail, error)
	predicates    []predicate.Voicemail
}

var _ ent.Mutation = (*VoicemailMutation)(nil)

// voicemailOption allows management of the mutation configuration using functional options.
type voicemailOption func(*VoicemailMutation)

// newVoicemailMutation creates new mutation for the Voicemail entity.
func newVoicemailMutation(c config, op Op, opts ...voicemailOption) *VoicemailMutation {
	m := &VoicemailMutation{
		config:        c,
		op:            op,
		typ:           TypeVoicemail,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withVoicemailID sets the ID field of the mutation.
func withVoicemailID(id int) voicemailOption {
	return func(m *VoicemailMutation) {
		var (
			err   error
			once  sync.Once
			value *Voicemail
		)
		m.oldValue = func(ctx context.Context) (*Voicemail, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Voicemail.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withVoicemail sets the old Voicemail of the mutation.
func withVoicemail(node *Voicemail) voicemailOption {
	return func(m *VoicemailMutation) {
		m.oldValue = func(context.Context) (*Voicemail, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m VoicemailMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m VoicemailMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *VoicemailMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *VoicemailMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Voicemail.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCaller sets the "caller" field.
func (m *VoicemailMutation) SetCaller(s string) {
	m.caller = &s
}

// Caller returns the value of the "caller" field in the mutation.
func (m *VoicemailMutation) Caller() (r string, exists bool) {
	v := m.caller
	if v == nil {
		return
	}
	return *v, true
}

// OldCaller returns the old "caller" field's value of the Voicemail entity.
// If the Voicemail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VoicemailMutation) OldCaller(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCaller is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCaller requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCaller: %w", err)
	}
	return oldValue.Caller, nil
}

// ResetCaller resets all changes to the "caller" field.
func (m *VoicemailMutation) ResetCaller() {
	m.caller = nil
}

// SetAudioPath sets the "audio_path" field.
func (m *VoicemailMutation) SetAudioPath(s string) {
	m.audio_path = &s
}

// AudioPath returns the value of the "audio_path" field in the mutation.
func (m *VoicemailMutation) AudioPath() (r string, exists bool) {
	v := m.audio_path
	if v == nil {
		return
	}
	return *v, true
}

// OldAudioPath returns the old "audio_path" field's value of the Voicemail entity.
// If the Voicemail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VoicemailMutation) OldAudioPath(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAudioPath is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAudioPath requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAudioPath: %w", err)
	}
	return oldValue.AudioPath, nil
}

// ResetAudioPath resets all changes to the "audio_path" field.
func (m *VoicemailMutation) ResetAudioPath() {
	m.audio_path = nil
}

// SetTranscription sets the "transcription" field.
func (m *VoicemailMutation) SetTranscription(s string) {
	m.transcription = &s
}

// Transcription returns the value of the "transcription" field in the mutation.
func (m *VoicemailMutation) Transcription() (r string, exists bool) {
	v := m.transcription
	if v == nil {
		return
	}
	return *v, true
}

// OldTranscription returns the old "transcription" field's value of the Voicemail entity.
// If the Voicemail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VoicemailMutation) OldTranscription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTranscription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTranscription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTranscription: %w", err)
	}
	return oldValue.Transcription, nil
}

// ClearTranscription clears the value of the "transcription" field.
func (m *VoicemailMutation) ClearTranscription() {
	m.transcription = nil
	m.clearedFields[voicemail.FieldTranscription] = struct{}{}
}

// TranscriptionCleared returns if the "transcription" field was cleared in this mutation.
func (m *VoicemailMutation) TranscriptionCleared() bool {
	_, ok := m.clearedFields[voicemail.FieldTranscription]
	return ok
}

// ResetTranscription resets all changes to the "transcription" field.
func (m *VoicemailMutation) ResetTranscription() {
	m.transcription = nil
	delete(m.clearedFields, voicemail.FieldTranscription)
}

// SetCreatedAt sets the "created_at" field.
func (m *VoicemailMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *VoicemailMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Voicemail entity.
// If the Voicemail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VoicemailMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *VoicemailMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetDuration sets the "duration" field.
func (m *VoicemailMutation) SetDuration(i int) {
	m.duration = &i
	m.addduration = nil
}

// Duration returns the value of the "duration" field in the mutation.
func (m *VoicemailMutation) Duration() (r int, exists bool) {
	v := m.duration
	if v == nil {
		return
	}
	return *v, true
}

// OldDuration returns the old "duration" field's value of the Voicemail entity.
// If the Voicemail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VoicemailMutation) OldDuration(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDuration is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDuration requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDuration: %w", err)
	}
	return oldValue.Duration, nil
}

// AddDuration adds i to the "duration" field.
func (m *VoicemailMutation) AddDuration(i int) {
	if m.addduration != nil {
		*m.addduration += i
	} else {
		m.addduration = &i
	}
}

// AddedDuration returns the value that was added to the "duration" field in this mutation.
func (m *VoicemailMutation) AddedDuration() (r int, exists bool) {
	v := m.addduration
	if v == nil {
		return
	}
	return *v, true
}

// ResetDuration resets all changes to the "duration" field.
func (m *VoicemailMutation) ResetDuration() {
	m.duration = nil
	m.addduration = nil
}

// SetReadAt sets the "read_at" field.
func (m *VoicemailMutation) SetReadAt(t time.Time) {
	m.read_at = &t
}

// ReadAt returns the value of the "read_at" field in the mutation.
func (m *VoicemailMutation) ReadAt() (r time.Time, exists bool) {
	v := m.read_at
	if v == nil {
		return
	}
	return *v, true
}

// OldReadAt returns the old "read_at" field's value of the Voicemail entity.
// If the Voicemail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VoicemailMutation) OldReadAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReadAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReadAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReadAt: %w", err)
	}
	return oldValue.ReadAt, nil
}

// ClearReadAt clears the value of the "read_at" field.
func (m *VoicemailMutation) ClearReadAt() {
	m.read_at = nil
	m.clearedFields[voicemail.FieldReadAt] = struct{}{}
}

// ReadAtCleared returns if the "read_at" field was cleared in this mutation.
func (m *VoicemailMutation) ReadAtCleared() bool {
	_, ok := m.clearedFields[voicemail.FieldReadAt]
	return ok
}

// ResetReadAt resets all changes to the "read_at" field.
func (m *VoicemailMutation) ResetReadAt() {
	m.read_at = nil
	delete(m.clearedFields, voicemail.FieldReadAt)
}

// SetTenantID sets the "tenant" edge to the Tenant entity by id.
func (m *VoicemailMutation) SetTenantID(id int) {
	m.tenant = &id
}

// ClearTenant clears the "tenant" edge to the Tenant entity.
func (m *VoicemailMutation) ClearTenant() {
	m.clearedtenant = true
}

// TenantCleared reports if the "tenant" edge to the Tenant entity was cleared.
func (m *VoicemailMutation) TenantCleared() bool {
	return m.clearedtenant
}

// TenantID returns the "tenant" edge ID in the mutation.
func (m *VoicemailMutation) TenantID() (id int, exists bool) {
	if m.tenant != nil {
		return *m.tenant, true
	}
	return
}

// TenantIDs returns the "tenant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TenantID instead. It exists only for internal usage by the builders.
func (m *VoicemailMutation) TenantIDs() (ids []int) {
	if id := m.tenant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTenant resets all changes to the "tenant" edge.
func (m *VoicemailMutation) ResetTenant() {
	m.tenant = nil
	m.clearedtenant = false
}

// SetUserID sets the "user" edge to the User entity by id.
func (m *VoicemailMutation) SetUserID(id int) {
	m.user = &id
}

// ClearUser clears the "user" edge to the User entity.
func (m *VoicemailMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *VoicemailMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *VoicemailMutation) UserID() (id int, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *VoicemailMutation) UserIDs() (ids []int) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *VoicemailMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the VoicemailMutation builder.
func (m *VoicemailMutation) Where(ps ...predicate.Voicemail) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the VoicemailMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *VoicemailMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Voicemail, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *VoicemailMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *VoicemailMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Voicemail).
func (m *VoicemailMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *VoicemailMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.caller != nil {
		fields = append(fields, voicemail.FieldCaller)
	}
	if m.audio_path != nil {
		fields = append(fields, voicemail.FieldAudioPath)
	}
	if m.transcription != nil {
		fields = append(fields, voicemail.FieldTranscription)
	}
	if m.created_at != nil {
		fields = append(fields, voicemail.FieldCreatedAt)
	}
	if m.duration != nil {
		fields = append(fields, voicemail.FieldDuration)
	}
	if m.read_at != nil {
		fields = append(fields, voicemail.FieldReadAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *VoicemailMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case voicemail.FieldCaller:
		return m.Caller()
	case voicemail.FieldAudioPath:
		return m.AudioPath()
	case voicemail.FieldTranscription:
		return m.Transcription()
	case voicemail.FieldCreatedAt:
		return m.CreatedAt()
	case voicemail.FieldDuration:
		return m.Duration()
	case voicemail.FieldReadAt:
		return m.ReadAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *VoicemailMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case voicemail.FieldCaller:
		return m.OldCaller(ctx)
	case voicemail.FieldAudioPath:
		return m.OldAudioPath(ctx)
	case voicemail.FieldTranscription:
		return m.OldTranscription(ctx)
	case voicemail.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case voicemail.FieldDuration:
		return m.OldDuration(ctx)
	case voicemail.FieldReadAt:
		return m.OldReadAt(ctx)
	}
	return nil, fmt.Errorf("unknown Voicemail field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *VoicemailMutation) SetField(name string, value ent.Value) error {
	switch name {
	case voicemail.FieldCaller:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCaller(v)
		return nil
	case voicemail.FieldAudioPath:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAudioPath(v)
		return nil
	case voicemail.FieldTranscription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTranscription(v)
		return nil
	case voicemail.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case voicemail.FieldDuration:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDuration(v)
		return nil
	case voicemail.FieldReadAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReadAt(v)
		return nil
	}
	return fmt.Errorf("unknown Voicemail field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *VoicemailMutation) AddedFields() []string {
	var fields []string
	if m.addduration != nil {
		fields = append(fields, voicemail.FieldDuration)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *VoicemailMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case voicemail.FieldDuration:
		return m.AddedDuration()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *VoicemailMutation) AddField(name string, value ent.Value) error {
	switch name {
	case voicemail.FieldDuration:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDuration(v)
		return nil
	}
	return fmt.Errorf("unknown Voicemail numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *VoicemailMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(voicemail.FieldTranscription) {
		fields = append(fields, voicemail.FieldTranscription)
	}
	if m.FieldCleared(voicemail.FieldReadAt) {
		fields = append(fields, voicemail.FieldReadAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *VoicemailMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *VoicemailMutation) ClearField(name string) error {
	switch name {
	case voicemail.FieldTranscription:
		m.ClearTranscription()
		return nil
	case voicemail.FieldReadAt:
		m.ClearReadAt()
		return nil
	}
	return fmt.Errorf("unknown Voicemail nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *VoicemailMutation) ResetField(name string) error {
	switch name {
	case voicemail.FieldCaller:
		m.ResetCaller()
		return nil
	case voicemail.FieldAudioPath:
		m.ResetAudioPath()
		return nil
	case voicemail.FieldTranscription:
		m.ResetTranscription()
		return nil
	case voicemail.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case voicemail.FieldDuration:
		m.ResetDuration()
		return nil
	case voicemail.FieldReadAt:
		m.ResetReadAt()
		return nil
	}
	return fmt.Errorf("unknown Voicemail field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *VoicemailMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.tenant != nil {
		edges = append(edges, voicemail.EdgeTenant)
	}
	if m.user != nil {
		edges = append(edges, voicemail.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *VoicemailMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case voicemail.EdgeTenant:
		if id := m.tenant; id != nil {
			return []ent.Value{*id}
		}
	case voicemail.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *VoicemailMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *VoicemailMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *VoicemailMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedtenant {
		edges = append(edges, voicemail.EdgeTenant)
	}
	if m.cleareduser {
		edges = append(edges, voicemail.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *VoicemailMutation) EdgeCleared(name string) bool {
	switch name {
	case voicemail.EdgeTenant:
		return m.clearedtenant
	case voicemail.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *VoicemailMutation) ClearEdge(name string) error {
	switch name {
	case voicemail.EdgeTenant:
		m.ClearTenant()
		return nil
	case voicemail.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown Voicemail unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *VoicemailMutation) ResetEdge(name string) error {
	switch name {
	case voicemail.EdgeTenant:
		m.ResetTenant()
		return nil
	case voicemail.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown Voicemail edge %s", name)
}

// WarehouseMutation represents an operation that mutates the Warehouse nodes in the graph.
type WarehouseMutation struct {
	config
	op              Op
	typ             string
	id              *int
	name            *string
	location_code   *string
	address         *string
	is_active       *bool
	clearedFields   map[string]struct{}
	tenant          *int
	clearedtenant   bool
	products        map[int]struct{}
	removedproducts map[int]struct{}
	clearedproducts bool
	done            bool
	oldValue        func(context.Context) (*Warehouse, error)
	predicates      []predicate.Warehouse
}

var _ ent.Mutation = (*WarehouseMutation)(nil)

// warehouseOption allows management of the mutation configuration using functional options.
type warehouseOption func(*WarehouseMutation)

// newWarehouseMutation creates new mutation for the Warehouse entity.
func newWarehouseMutation(c config, op Op, opts ...warehouseOption) *WarehouseMutation {
	m := &WarehouseMutation{
		config:        c,
		op:            op,
		typ:           TypeWarehouse,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withWarehouseID sets the ID field of the mutation.
func withWarehouseID(id int) warehouseOption {
	return func(m *WarehouseMutation) {
		var (
			err   error
			once  sync.Once
			value *Warehouse
		)
		m.oldValue = func(ctx context.Context) (*Warehouse, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Warehouse.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withWarehouse sets the old Warehouse of the mutation.
func withWarehouse(node *Warehouse) warehouseOption {
	return func(m *WarehouseMutation) {
		m.oldValue = func(context.Context) (*Warehouse, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m WarehouseMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m WarehouseMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *WarehouseMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *WarehouseMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Warehouse.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *WarehouseMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *WarehouseMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Warehouse entity.
// If the Warehouse object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WarehouseMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *WarehouseMutation) ResetName() {
	m.name = nil
}

// SetLocationCode sets the "location_code" field.
func (m *WarehouseMutation) SetLocationCode(s string) {
	m.location_code = &s
}

// LocationCode returns the value of the "location_code" field in the mutation.
func (m *WarehouseMutation) LocationCode() (r string, exists bool) {
	v := m.location_code
	if v == nil {
		return
	}
	return *v, true
}

// OldLocationCode returns the old "location_code" field's value of the Warehouse entity.
// If the Warehouse object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WarehouseMutation) OldLocationCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLocationCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLocationCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLocationCode: %w", err)
	}
	return oldValue.LocationCode, nil
}

// ResetLocationCode resets all changes to the "location_code" field.
func (m *WarehouseMutation) ResetLocationCode() {
	m.location_code = nil
}

// SetAddress sets the "address" field.
func (m *WarehouseMutation) SetAddress(s string) {
	m.address = &s
}

// Address returns the value of the "address" field in the mutation.
func (m *WarehouseMutation) Address() (r string, exists bool) {
	v := m.address
	if v == nil {
		return
	}
	return *v, true
}

// OldAddress returns the old "address" field's value of the Warehouse entity.
// If the Warehouse object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WarehouseMutation) OldAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAddress: %w", err)
	}
	return oldValue.Address, nil
}

// ClearAddress clears the value of the "address" field.
func (m *WarehouseMutation) ClearAddress() {
	m.address = nil
	m.clearedFields[warehouse.FieldAddress] = struct{}{}
}

// AddressCleared returns if the "address" field was cleared in this mutation.
func (m *WarehouseMutation) AddressCleared() bool {
	_, ok := m.clearedFields[warehouse.FieldAddress]
	return ok
}

// ResetAddress resets all changes to the "address" field.
func (m *WarehouseMutation) ResetAddress() {
	m.address = nil
	delete(m.clearedFields, warehouse.FieldAddress)
}

// SetIsActive sets the "is_active" field.
func (m *WarehouseMutation) SetIsActive(b bool) {
	m.is_active = &b
}

// IsActive returns the value of the "is_active" field in the mutation.
func (m *WarehouseMutation) IsActive() (r bool, exists bool) {
	v := m.is_active
	if v == nil {
		return
	}
	return *v, true
}

// OldIsActive returns the old "is_active" field's value of the Warehouse entity.
// If the Warehouse object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WarehouseMutation) OldIsActive(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsActive is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsActive requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsActive: %w", err)
	}
	return oldValue.IsActive, nil
}

// ResetIsActive resets all changes to the "is_active" field.
func (m *WarehouseMutation) ResetIsActive() {
	m.is_active = nil
}

// SetTenantID sets the "tenant" edge to the Tenant entity by id.
func (m *WarehouseMutation) SetTenantID(id int) {
	m.tenant = &id
}

// ClearTenant clears the "tenant" edge to the Tenant entity.
func (m *WarehouseMutation) ClearTenant() {
	m.clearedtenant = true
}

// TenantCleared reports if the "tenant" edge to the Tenant entity was cleared.
func (m *WarehouseMutation) TenantCleared() bool {
	return m.clearedtenant
}

// TenantID returns the "tenant" edge ID in the mutation.
func (m *WarehouseMutation) TenantID() (id int, exists bool) {
	if m.tenant != nil {
		return *m.tenant, true
	}
	return
}

// TenantIDs returns the "tenant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TenantID instead. It exists only for internal usage by the builders.
func (m *WarehouseMutation) TenantIDs() (ids []int) {
	if id := m.tenant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTenant resets all changes to the "tenant" edge.
func (m *WarehouseMutation) ResetTenant() {
	m.tenant = nil
	m.clearedtenant = false
}

// AddProductIDs adds the "products" edge to the Product entity by ids.
func (m *WarehouseMutation) AddProductIDs(ids ...int) {
	if m.products == nil {
		m.products = make(map[int]struct{})
	}
	for i := range ids {
		m.products[ids[i]] = struct{}{}
	}
}

// ClearProducts clears the "products" edge to the Product entity.
func (m *WarehouseMutation) ClearProducts() {
	m.clearedproducts = true
}

// ProductsCleared reports if the "products" edge to the Product entity was cleared.
func (m *WarehouseMutation) ProductsCleared() bool {
	return m.clearedproducts
}

// RemoveProductIDs removes the "products" edge to the Product entity by IDs.
func (m *WarehouseMutation) RemoveProductIDs(ids ...int) {
	if m.removedproducts == nil {
		m.removedproducts = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.products, ids[i])
		m.removedproducts[ids[i]] = struct{}{}
	}
}

// RemovedProducts returns the removed IDs of the "products" edge to the Product entity.
func (m *WarehouseMutation) RemovedProductsIDs() (ids []int) {
	for id := range m.removedproducts {
		ids = append(ids, id)
	}
	return
}

// ProductsIDs returns the "products" edge IDs in the mutation.
func (m *WarehouseMutation) ProductsIDs() (ids []int) {
	for id := range m.products {
		ids = append(ids, id)
	}
	return
}

// ResetProducts resets all changes to the "products" edge.
func (m *WarehouseMutation) ResetProducts() {
	m.products = nil
	m.clearedproducts = false
	m.removedproducts = nil
}

// Where appends a list predicates to the WarehouseMutation builder.
func (m *WarehouseMutation) Where(ps ...predicate.Warehouse) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the WarehouseMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *WarehouseMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Warehouse, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *WarehouseMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *WarehouseMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Warehouse).
func (m *WarehouseMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *WarehouseMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.name != nil {
		fields = append(fields, warehouse.FieldName)
	}
	if m.location_code != nil {
		fields = append(fields, warehouse.FieldLocationCode)
	}
	if m.address != nil {
		fields = append(fields, warehouse.FieldAddress)
	}
	if m.is_active != nil {
		fields = append(fields, warehouse.FieldIsActive)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *WarehouseMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case warehouse.FieldName:
		return m.Name()
	case warehouse.FieldLocationCode:
		return m.LocationCode()
	case warehouse.FieldAddress:
		return m.Address()
	case warehouse.FieldIsActive:
		return m.IsActive()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *WarehouseMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case warehouse.FieldName:
		return m.OldName(ctx)
	case warehouse.FieldLocationCode:
		return m.OldLocationCode(ctx)
	case warehouse.FieldAddress:
		return m.OldAddress(ctx)
	case warehouse.FieldIsActive:
		return m.OldIsActive(ctx)
	}
	return nil, fmt.Errorf("unknown Warehouse field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WarehouseMutation) SetField(name string, value ent.Value) error {
	switch name {
	case warehouse.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case warehouse.FieldLocationCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLocationCode(v)
		return nil
	case warehouse.FieldAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAddress(v)
		return nil
	case warehouse.FieldIsActive:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsActive(v)
		return nil
	}
	return fmt.Errorf("unknown Warehouse field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *WarehouseMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *WarehouseMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WarehouseMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Warehouse numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *WarehouseMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(warehouse.FieldAddress) {
		fields = append(fields, warehouse.FieldAddress)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *WarehouseMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *WarehouseMutation) ClearField(name string) error {
	switch name {
	case warehouse.FieldAddress:
		m.ClearAddress()
		return nil
	}
	return fmt.Errorf("unknown Warehouse nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *WarehouseMutation) ResetField(name string) error {
	switch name {
	case warehouse.FieldName:
		m.ResetName()
		return nil
	case warehouse.FieldLocationCode:
		m.ResetLocationCode()
		return nil
	case warehouse.FieldAddress:
		m.ResetAddress()
		return nil
	case warehouse.FieldIsActive:
		m.ResetIsActive()
		return nil
	}
	return fmt.Errorf("unknown Warehouse field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *WarehouseMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.tenant != nil {
		edges = append(edges, warehouse.EdgeTenant)
	}
	if m.products != nil {
		edges = append(edges, warehouse.EdgeProducts)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *WarehouseMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case warehouse.EdgeTenant:
		if id := m.tenant; id != nil {
			return []ent.Value{*id}
		}
	case warehouse.EdgeProducts:
		ids := make([]ent.Value, 0, len(m.products))
		for id := range m.products {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *WarehouseMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedproducts != nil {
		edges = append(edges, warehouse.EdgeProducts)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *WarehouseMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case warehouse.EdgeProducts:
		ids := make([]ent.Value, 0, len(m.removedproducts))
		for id := range m.removedproducts {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *WarehouseMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedtenant {
		edges = append(edges, warehouse.EdgeTenant)
	}
	if m.clearedproducts {
		edges = append(edges, warehouse.EdgeProducts)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *WarehouseMutation) EdgeCleared(name string) bool {
	switch name {
	case warehouse.EdgeTenant:
		return m.clearedtenant
	case warehouse.EdgeProducts:
		return m.clearedproducts
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *WarehouseMutation) ClearEdge(name string) error {
	switch name {
	case warehouse.EdgeTenant:
		m.ClearTenant()
		return nil
	}
	return fmt.Errorf("unknown Warehouse unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *WarehouseMutation) ResetEdge(name string) error {
	switch name {
	case warehouse.EdgeTenant:
		m.ResetTenant()
		return nil
	case warehouse.EdgeProducts:
		m.ResetProducts()
		return nil
	}
	return fmt.Errorf("unknown Warehouse edge %s", name)
}

// WorkLogMutation represents an operation that mutates the WorkLog nodes in the graph.
type WorkLogMutation struct {
	config
	op                Op
	typ               string
	id                *int
	duration_hours    *float64
	addduration_hours *float64
	note              *string
	started_at        *time.Time
	is_billable       *bool
	status            *worklog.Status
	work_type         *string
	invoice_id        *int
	addinvoice_id     *int
	clearedFields     map[string]struct{}
	ticket            *int
	clearedticket     bool
	technician        *int
	clearedtechnician bool
	done              bool
	oldValue          func(context.Context) (*WorkLog, error)
	predicates        []predicate.WorkLog
}

var _ ent.Mutation = (*WorkLogMutation)(nil)

// worklogOption allows management of the mutation configuration using functional options.
type worklogOption func(*WorkLogMutation)

// newWorkLogMutation creates new mutation for the WorkLog entity.
func newWorkLogMutation(c config, op Op, opts ...worklogOption) *WorkLogMutation {
	m := &WorkLogMutation{
		config:        c,
		op:            op,
		typ:           TypeWorkLog,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withWorkLogID sets the ID field of the mutation.
func withWorkLogID(id int) worklogOption {
	return func(m *WorkLogMutation) {
		var (
			err   error
			once  sync.Once
			value *WorkLog
		)
		m.oldValue = func(ctx context.Context) (*WorkLog, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().WorkLog.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withWorkLog sets the old WorkLog of the mutation.
func withWorkLog(node *WorkLog) worklogOption {
	return func(m *WorkLogMutation) {
		m.oldValue = func(context.Context) (*WorkLog, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m WorkLogMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m WorkLogMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *WorkLogMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *WorkLogMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().WorkLog.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetDurationHours sets the "duration_hours" field.
func (m *WorkLogMutation) SetDurationHours(f float64) {
	m.duration_hours = &f
	m.addduration_hours = nil
}

// DurationHours returns the value of the "duration_hours" field in the mutation.
func (m *WorkLogMutation) DurationHours() (r float64, exists bool) {
	v := m.duration_hours
	if v == nil {
		return
	}
	return *v, true
}

// OldDurationHours returns the old "duration_hours" field's value of the WorkLog entity.
// If the WorkLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkLogMutation) OldDurationHours(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDurationHours is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDurationHours requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDurationHours: %w", err)
	}
	return oldValue.DurationHours, nil
}

// AddDurationHours adds f to the "duration_hours" field.
func (m *WorkLogMutation) AddDurationHours(f float64) {
	if m.addduration_hours != nil {
		*m.addduration_hours += f
	} else {
		m.addduration_hours = &f
	}
}

// AddedDurationHours returns the value that was added to the "duration_hours" field in this mutation.
func (m *WorkLogMutation) AddedDurationHours() (r float64, exists bool) {
	v := m.addduration_hours
	if v == nil {
		return
	}
	return *v, true
}

// ResetDurationHours resets all changes to the "duration_hours" field.
func (m *WorkLogMutation) ResetDurationHours() {
	m.duration_hours = nil
	m.addduration_hours = nil
}

// SetNote sets the "note" field.
func (m *WorkLogMutation) SetNote(s string) {
	m.note = &s
}

// Note returns the value of the "note" field in the mutation.
func (m *WorkLogMutation) Note() (r string, exists bool) {
	v := m.note
	if v == nil {
		return
	}
	return *v, true
}

// OldNote returns the old "note" field's value of the WorkLog entity.
// If the WorkLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkLogMutation) OldNote(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNote is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNote requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNote: %w", err)
	}
	return oldValue.Note, nil
}

// ResetNote resets all changes to the "note" field.
func (m *WorkLogMutation) ResetNote() {
	m.note = nil
}

// SetStartedAt sets the "started_at" field.
func (m *WorkLogMutation) SetStartedAt(t time.Time) {
	m.started_at = &t
}

// StartedAt returns the value of the "started_at" field in the mutation.
func (m *WorkLogMutation) StartedAt() (r time.Time, exists bool) {
	v := m.started_at
	if v == nil {
		return
	}
	return *v, true
}

// OldStartedAt returns the old "started_at" field's value of the WorkLog entity.
// If the WorkLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkLogMutation) OldStartedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartedAt: %w", err)
	}
	return oldValue.StartedAt, nil
}

// ResetStartedAt resets all changes to the "started_at" field.
func (m *WorkLogMutation) ResetStartedAt() {
	m.started_at = nil
}

// SetIsBillable sets the "is_billable" field.
func (m *WorkLogMutation) SetIsBillable(b bool) {
	m.is_billable = &b
}

// IsBillable returns the value of the "is_billable" field in the mutation.
func (m *WorkLogMutation) IsBillable() (r bool, exists bool) {
	v := m.is_billable
	if v == nil {
		return
	}
	return *v, true
}

// OldIsBillable returns the old "is_billable" field's value of the WorkLog entity.
// If the WorkLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkLogMutation) OldIsBillable(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsBillable is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsBillable requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsBillable: %w", err)
	}
	return oldValue.IsBillable, nil
}

// ResetIsBillable resets all changes to the "is_billable" field.
func (m *WorkLogMutation) ResetIsBillable() {
	m.is_billable = nil
}

// SetStatus sets the "status" field.
func (m *WorkLogMutation) SetStatus(w worklog.Status) {
	m.status = &w
}

// Status returns the value of the "status" field in the mutation.
func (m *WorkLogMutation) Status() (r worklog.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the WorkLog entity.
// If the WorkLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkLogMutation) OldStatus(ctx context.Context) (v worklog.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *WorkLogMutation) ResetStatus() {
	m.status = nil
}

// SetWorkType sets the "work_type" field.
func (m *WorkLogMutation) SetWorkType(s string) {
	m.work_type = &s
}

// WorkType returns the value of the "work_type" field in the mutation.
func (m *WorkLogMutation) WorkType() (r string, exists bool) {
	v := m.work_type
	if v == nil {
		return
	}
	return *v, true
}

// OldWorkType returns the old "work_type" field's value of the WorkLog entity.
// If the WorkLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkLogMutation) OldWorkType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWorkType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWorkType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWorkType: %w", err)
	}
	return oldValue.WorkType, nil
}

// ResetWorkType resets all changes to the "work_type" field.
func (m *WorkLogMutation) ResetWorkType() {
	m.work_type = nil
}

// SetInvoiceID sets the "invoice_id" field.
func (m *WorkLogMutation) SetInvoiceID(i int) {
	m.invoice_id = &i
	m.addinvoice_id = nil
}

// InvoiceID returns the value of the "invoice_id" field in the mutation.
func (m *WorkLogMutation) InvoiceID() (r int, exists bool) {
	v := m.invoice_id
	if v == nil {
		return
	}
	return *v, true
}

// OldInvoiceID returns the old "invoice_id" field's value of the WorkLog entity.
// If the WorkLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkLogMutation) OldInvoiceID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInvoiceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInvoiceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInvoiceID: %w", err)
	}
	return oldValue.InvoiceID, nil
}

// AddInvoiceID adds i to the "invoice_id" field.
func (m *WorkLogMutation) AddInvoiceID(i int) {
	if m.addinvoice_id != nil {
		*m.addinvoice_id += i
	} else {
		m.addinvoice_id = &i
	}
}

// AddedInvoiceID returns the value that was added to the "invoice_id" field in this mutation.
func (m *WorkLogMutation) AddedInvoiceID() (r int, exists bool) {
	v := m.addinvoice_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearInvoiceID clears the value of the "invoice_id" field.
func (m *WorkLogMutation) ClearInvoiceID() {
	m.invoice_id = nil
	m.addinvoice_id = nil
	m.clearedFields[worklog.FieldInvoiceID] = struct{}{}
}

// InvoiceIDCleared returns if the "invoice_id" field was cleared in this mutation.
func (m *WorkLogMutation) InvoiceIDCleared() bool {
	_, ok := m.clearedFields[worklog.FieldInvoiceID]
	return ok
}

// ResetInvoiceID resets all changes to the "invoice_id" field.
func (m *WorkLogMutation) ResetInvoiceID() {
	m.invoice_id = nil
	m.addinvoice_id = nil
	delete(m.clearedFields, worklog.FieldInvoiceID)
}

// SetTicketID sets the "ticket" edge to the Ticket entity by id.
func (m *WorkLogMutation) SetTicketID(id int) {
	m.ticket = &id
}

// ClearTicket clears the "ticket" edge to the Ticket entity.
func (m *WorkLogMutation) ClearTicket() {
	m.clearedticket = true
}

// TicketCleared reports if the "ticket" edge to the Ticket entity was cleared.
func (m *WorkLogMutation) TicketCleared() bool {
	return m.clearedticket
}

// TicketID returns the "ticket" edge ID in the mutation.
func (m *WorkLogMutation) TicketID() (id int, exists bool) {
	if m.ticket != nil {
		return *m.ticket, true
	}
	return
}

// TicketIDs returns the "ticket" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TicketID instead. It exists only for internal usage by the builders.
func (m *WorkLogMutation) TicketIDs() (ids []int) {
	if id := m.ticket; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTicket resets all changes to the "ticket" edge.
func (m *WorkLogMutation) ResetTicket() {
	m.ticket = nil
	m.clearedticket = false
}

// SetTechnicianID sets the "technician" edge to the User entity by id.
func (m *WorkLogMutation) SetTechnicianID(id int) {
	m.technician = &id
}

// ClearTechnician clears the "technician" edge to the User entity.
func (m *WorkLogMutation) ClearTechnician() {
	m.clearedtechnician = true
}

// TechnicianCleared reports if the "technician" edge to the User entity was cleared.
func (m *WorkLogMutation) TechnicianCleared() bool {
	return m.clearedtechnician
}

// TechnicianID returns the "technician" edge ID in the mutation.
func (m *WorkLogMutation) TechnicianID() (id int, exists bool) {
	if m.technician != nil {
		return *m.technician, true
	}
	return
}

// TechnicianIDs returns the "technician" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TechnicianID instead. It exists only for internal usage by the builders.
func (m *WorkLogMutation) TechnicianIDs() (ids []int) {
	if id := m.technician; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTechnician resets all changes to the "technician" edge.
func (m *WorkLogMutation) ResetTechnician() {
	m.technician = nil
	m.clearedtechnician = false
}

// Where appends a list predicates to the WorkLogMutation builder.
func (m *WorkLogMutation) Where(ps ...predicate.WorkLog) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the WorkLogMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *WorkLogMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.WorkLog, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *WorkLogMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *WorkLogMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (WorkLog).
func (m *WorkLogMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *WorkLogMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.duration_hours != nil {
		fields = append(fields, worklog.FieldDurationHours)
	}
	if m.note != nil {
		fields = append(fields, worklog.FieldNote)
	}
	if m.started_at != nil {
		fields = append(fields, worklog.FieldStartedAt)
	}
	if m.is_billable != nil {
		fields = append(fields, worklog.FieldIsBillable)
	}
	if m.status != nil {
		fields = append(fields, worklog.FieldStatus)
	}
	if m.work_type != nil {
		fields = append(fields, worklog.FieldWorkType)
	}
	if m.invoice_id != nil {
		fields = append(fields, worklog.FieldInvoiceID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *WorkLogMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case worklog.FieldDurationHours:
		return m.DurationHours()
	case worklog.FieldNote:
		return m.Note()
	case worklog.FieldStartedAt:
		return m.StartedAt()
	case worklog.FieldIsBillable:
		return m.IsBillable()
	case worklog.FieldStatus:
		return m.Status()
	case worklog.FieldWorkType:
		return m.WorkType()
	case worklog.FieldInvoiceID:
		return m.InvoiceID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *WorkLogMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case worklog.FieldDurationHours:
		return m.OldDurationHours(ctx)
	case worklog.FieldNote:
		return m.OldNote(ctx)
	case worklog.FieldStartedAt:
		return m.OldStartedAt(ctx)
	case worklog.FieldIsBillable:
		return m.OldIsBillable(ctx)
	case worklog.FieldStatus:
		return m.OldStatus(ctx)
	case worklog.FieldWorkType:
		return m.OldWorkType(ctx)
	case worklog.FieldInvoiceID:
		return m.OldInvoiceID(ctx)
	}
	return nil, fmt.Errorf("unknown WorkLog field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WorkLogMutation) SetField(name string, value ent.Value) error {
	switch name {
	case worklog.FieldDurationHours:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDurationHours(v)
		return nil
	case worklog.FieldNote:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNote(v)
		return nil
	case worklog.FieldStartedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartedAt(v)
		return nil
	case worklog.FieldIsBillable:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsBillable(v)
		return nil
	case worklog.FieldStatus:
		v, ok := value.(worklog.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case worklog.FieldWorkType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWorkType(v)
		return nil
	case worklog.FieldInvoiceID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInvoiceID(v)
		return nil
	}
	return fmt.Errorf("unknown WorkLog field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *WorkLogMutation) AddedFields() []string {
	var fields []string
	if m.addduration_hours != nil {
		fields = append(fields, worklog.FieldDurationHours)
	}
	if m.addinvoice_id != nil {
		fields = append(fields, worklog.FieldInvoiceID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *WorkLogMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case worklog.FieldDurationHours:
		return m.AddedDurationHours()
	case worklog.FieldInvoiceID:
		return m.AddedInvoiceID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WorkLogMutation) AddField(name string, value ent.Value) error {
	switch name {
	case worklog.FieldDurationHours:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDurationHours(v)
		return nil
	case worklog.FieldInvoiceID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddInvoiceID(v)
		return nil
	}
	return fmt.Errorf("unknown WorkLog numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *WorkLogMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(worklog.FieldInvoiceID) {
		fields = append(fields, worklog.FieldInvoiceID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *WorkLogMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *WorkLogMutation) ClearField(name string) error {
	switch name {
	case worklog.FieldInvoiceID:
		m.ClearInvoiceID()
		return nil
	}
	return fmt.Errorf("unknown WorkLog nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *WorkLogMutation) ResetField(name string) error {
	switch name {
	case worklog.FieldDurationHours:
		m.ResetDurationHours()
		return nil
	case worklog.FieldNote:
		m.ResetNote()
		return nil
	case worklog.FieldStartedAt:
		m.ResetStartedAt()
		return nil
	case worklog.FieldIsBillable:
		m.ResetIsBillable()
		return nil
	case worklog.FieldStatus:
		m.ResetStatus()
		return nil
	case worklog.FieldWorkType:
		m.ResetWorkType()
		return nil
	case worklog.FieldInvoiceID:
		m.ResetInvoiceID()
		return nil
	}
	return fmt.Errorf("unknown WorkLog field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *WorkLogMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.ticket != nil {
		edges = append(edges, worklog.EdgeTicket)
	}
	if m.technician != nil {
		edges = append(edges, worklog.EdgeTechnician)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *WorkLogMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case worklog.EdgeTicket:
		if id := m.ticket; id != nil {
			return []ent.Value{*id}
		}
	case worklog.EdgeTechnician:
		if id := m.technician; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *WorkLogMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *WorkLogMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *WorkLogMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedticket {
		edges = append(edges, worklog.EdgeTicket)
	}
	if m.clearedtechnician {
		edges = append(edges, worklog.EdgeTechnician)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *WorkLogMutation) EdgeCleared(name string) bool {
	switch name {
	case worklog.EdgeTicket:
		return m.clearedticket
	case worklog.EdgeTechnician:
		return m.clearedtechnician
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *WorkLogMutation) ClearEdge(name string) error {
	switch name {
	case worklog.EdgeTicket:
		m.ClearTicket()
		return nil
	case worklog.EdgeTechnician:
		m.ClearTechnician()
		return nil
	}
	return fmt.Errorf("unknown WorkLog unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *WorkLogMutation) ResetEdge(name string) error {
	switch name {
	case worklog.EdgeTicket:
		m.ResetTicket()
		return nil
	case worklog.EdgeTechnician:
		m.ResetTechnician()
		return nil
	}
	return fmt.Errorf("unknown WorkLog edge %s", name)
}
