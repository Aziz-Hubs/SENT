// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"log"
	"reflect"

	"sent/ent/migrate"

	"sent/ent/account"
	"sent/ent/agent"
	"sent/ent/asset"
	"sent/ent/assettype"
	"sent/ent/auditlog"
	"sent/ent/budgetforecast"
	"sent/ent/calllog"
	"sent/ent/camera"
	"sent/ent/compensationagreement"
	"sent/ent/contract"
	"sent/ent/credential"
	"sent/ent/department"
	"sent/ent/detectionevent"
	"sent/ent/discoveryentry"
	"sent/ent/employee"
	"sent/ent/goal"
	"sent/ent/healthscoresnapshot"
	"sent/ent/inventoryreservation"
	"sent/ent/ivrflow"
	"sent/ent/job"
	"sent/ent/jobexecution"
	"sent/ent/journalentry"
	"sent/ent/ledgerentry"
	"sent/ent/networkbackup"
	"sent/ent/networkdevice"
	"sent/ent/networklink"
	"sent/ent/networkport"
	"sent/ent/nexusaudit"
	"sent/ent/onetimelink"
	"sent/ent/performancereview"
	"sent/ent/permission"
	"sent/ent/product"
	"sent/ent/recording"
	"sent/ent/recurringinvoice"
	"sent/ent/remediationstep"
	"sent/ent/reviewcycle"
	"sent/ent/saasapp"
	"sent/ent/saasfilter"
	"sent/ent/saasidentity"
	"sent/ent/saasusage"
	"sent/ent/script"
	"sent/ent/servicerate"
	"sent/ent/sop"
	"sent/ent/stockmovement"
	"sent/ent/strategicroadmap"
	"sent/ent/successionmap"
	"sent/ent/tenant"
	"sent/ent/ticket"
	"sent/ent/timeentry"
	"sent/ent/timeoffbalance"
	"sent/ent/timeoffpolicy"
	"sent/ent/timeoffrequest"
	"sent/ent/transaction"
	"sent/ent/user"
	"sent/ent/vaultitem"
	"sent/ent/voicemail"

	"entgo.io/ent"
	"entgo.io/ent/dialect"
	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
)

// Client is the client that holds all ent builders.
type Client struct {
	config
	// Schema is the client for creating, migrating and dropping schema.
	Schema *migrate.Schema
	// Account is the client for interacting with the Account builders.
	Account *AccountClient
	// Agent is the client for interacting with the Agent builders.
	Agent *AgentClient
	// Asset is the client for interacting with the Asset builders.
	Asset *AssetClient
	// AssetType is the client for interacting with the AssetType builders.
	AssetType *AssetTypeClient
	// AuditLog is the client for interacting with the AuditLog builders.
	AuditLog *AuditLogClient
	// BudgetForecast is the client for interacting with the BudgetForecast builders.
	BudgetForecast *BudgetForecastClient
	// CallLog is the client for interacting with the CallLog builders.
	CallLog *CallLogClient
	// Camera is the client for interacting with the Camera builders.
	Camera *CameraClient
	// CompensationAgreement is the client for interacting with the CompensationAgreement builders.
	CompensationAgreement *CompensationAgreementClient
	// Contract is the client for interacting with the Contract builders.
	Contract *ContractClient
	// Credential is the client for interacting with the Credential builders.
	Credential *CredentialClient
	// Department is the client for interacting with the Department builders.
	Department *DepartmentClient
	// DetectionEvent is the client for interacting with the DetectionEvent builders.
	DetectionEvent *DetectionEventClient
	// DiscoveryEntry is the client for interacting with the DiscoveryEntry builders.
	DiscoveryEntry *DiscoveryEntryClient
	// Employee is the client for interacting with the Employee builders.
	Employee *EmployeeClient
	// Goal is the client for interacting with the Goal builders.
	Goal *GoalClient
	// HealthScoreSnapshot is the client for interacting with the HealthScoreSnapshot builders.
	HealthScoreSnapshot *HealthScoreSnapshotClient
	// IVRFlow is the client for interacting with the IVRFlow builders.
	IVRFlow *IVRFlowClient
	// InventoryReservation is the client for interacting with the InventoryReservation builders.
	InventoryReservation *InventoryReservationClient
	// Job is the client for interacting with the Job builders.
	Job *JobClient
	// JobExecution is the client for interacting with the JobExecution builders.
	JobExecution *JobExecutionClient
	// JournalEntry is the client for interacting with the JournalEntry builders.
	JournalEntry *JournalEntryClient
	// LedgerEntry is the client for interacting with the LedgerEntry builders.
	LedgerEntry *LedgerEntryClient
	// NetworkBackup is the client for interacting with the NetworkBackup builders.
	NetworkBackup *NetworkBackupClient
	// NetworkDevice is the client for interacting with the NetworkDevice builders.
	NetworkDevice *NetworkDeviceClient
	// NetworkLink is the client for interacting with the NetworkLink builders.
	NetworkLink *NetworkLinkClient
	// NetworkPort is the client for interacting with the NetworkPort builders.
	NetworkPort *NetworkPortClient
	// NexusAudit is the client for interacting with the NexusAudit builders.
	NexusAudit *NexusAuditClient
	// OneTimeLink is the client for interacting with the OneTimeLink builders.
	OneTimeLink *OneTimeLinkClient
	// PerformanceReview is the client for interacting with the PerformanceReview builders.
	PerformanceReview *PerformanceReviewClient
	// Permission is the client for interacting with the Permission builders.
	Permission *PermissionClient
	// Product is the client for interacting with the Product builders.
	Product *ProductClient
	// Recording is the client for interacting with the Recording builders.
	Recording *RecordingClient
	// RecurringInvoice is the client for interacting with the RecurringInvoice builders.
	RecurringInvoice *RecurringInvoiceClient
	// RemediationStep is the client for interacting with the RemediationStep builders.
	RemediationStep *RemediationStepClient
	// ReviewCycle is the client for interacting with the ReviewCycle builders.
	ReviewCycle *ReviewCycleClient
	// SOP is the client for interacting with the SOP builders.
	SOP *SOPClient
	// SaaSApp is the client for interacting with the SaaSApp builders.
	SaaSApp *SaaSAppClient
	// SaaSFilter is the client for interacting with the SaaSFilter builders.
	SaaSFilter *SaaSFilterClient
	// SaaSIdentity is the client for interacting with the SaaSIdentity builders.
	SaaSIdentity *SaaSIdentityClient
	// SaaSUsage is the client for interacting with the SaaSUsage builders.
	SaaSUsage *SaaSUsageClient
	// Script is the client for interacting with the Script builders.
	Script *ScriptClient
	// ServiceRate is the client for interacting with the ServiceRate builders.
	ServiceRate *ServiceRateClient
	// StockMovement is the client for interacting with the StockMovement builders.
	StockMovement *StockMovementClient
	// StrategicRoadmap is the client for interacting with the StrategicRoadmap builders.
	StrategicRoadmap *StrategicRoadmapClient
	// SuccessionMap is the client for interacting with the SuccessionMap builders.
	SuccessionMap *SuccessionMapClient
	// Tenant is the client for interacting with the Tenant builders.
	Tenant *TenantClient
	// Ticket is the client for interacting with the Ticket builders.
	Ticket *TicketClient
	// TimeEntry is the client for interacting with the TimeEntry builders.
	TimeEntry *TimeEntryClient
	// TimeOffBalance is the client for interacting with the TimeOffBalance builders.
	TimeOffBalance *TimeOffBalanceClient
	// TimeOffPolicy is the client for interacting with the TimeOffPolicy builders.
	TimeOffPolicy *TimeOffPolicyClient
	// TimeOffRequest is the client for interacting with the TimeOffRequest builders.
	TimeOffRequest *TimeOffRequestClient
	// Transaction is the client for interacting with the Transaction builders.
	Transaction *TransactionClient
	// User is the client for interacting with the User builders.
	User *UserClient
	// VaultItem is the client for interacting with the VaultItem builders.
	VaultItem *VaultItemClient
	// Voicemail is the client for interacting with the Voicemail builders.
	Voicemail *VoicemailClient
}

// NewClient creates a new client configured with the given options.
func NewClient(opts ...Option) *Client {
	client := &Client{config: newConfig(opts...)}
	client.init()
	return client
}

func (c *Client) init() {
	c.Schema = migrate.NewSchema(c.driver)
	c.Account = NewAccountClient(c.config)
	c.Agent = NewAgentClient(c.config)
	c.Asset = NewAssetClient(c.config)
	c.AssetType = NewAssetTypeClient(c.config)
	c.AuditLog = NewAuditLogClient(c.config)
	c.BudgetForecast = NewBudgetForecastClient(c.config)
	c.CallLog = NewCallLogClient(c.config)
	c.Camera = NewCameraClient(c.config)
	c.CompensationAgreement = NewCompensationAgreementClient(c.config)
	c.Contract = NewContractClient(c.config)
	c.Credential = NewCredentialClient(c.config)
	c.Department = NewDepartmentClient(c.config)
	c.DetectionEvent = NewDetectionEventClient(c.config)
	c.DiscoveryEntry = NewDiscoveryEntryClient(c.config)
	c.Employee = NewEmployeeClient(c.config)
	c.Goal = NewGoalClient(c.config)
	c.HealthScoreSnapshot = NewHealthScoreSnapshotClient(c.config)
	c.IVRFlow = NewIVRFlowClient(c.config)
	c.InventoryReservation = NewInventoryReservationClient(c.config)
	c.Job = NewJobClient(c.config)
	c.JobExecution = NewJobExecutionClient(c.config)
	c.JournalEntry = NewJournalEntryClient(c.config)
	c.LedgerEntry = NewLedgerEntryClient(c.config)
	c.NetworkBackup = NewNetworkBackupClient(c.config)
	c.NetworkDevice = NewNetworkDeviceClient(c.config)
	c.NetworkLink = NewNetworkLinkClient(c.config)
	c.NetworkPort = NewNetworkPortClient(c.config)
	c.NexusAudit = NewNexusAuditClient(c.config)
	c.OneTimeLink = NewOneTimeLinkClient(c.config)
	c.PerformanceReview = NewPerformanceReviewClient(c.config)
	c.Permission = NewPermissionClient(c.config)
	c.Product = NewProductClient(c.config)
	c.Recording = NewRecordingClient(c.config)
	c.RecurringInvoice = NewRecurringInvoiceClient(c.config)
	c.RemediationStep = NewRemediationStepClient(c.config)
	c.ReviewCycle = NewReviewCycleClient(c.config)
	c.SOP = NewSOPClient(c.config)
	c.SaaSApp = NewSaaSAppClient(c.config)
	c.SaaSFilter = NewSaaSFilterClient(c.config)
	c.SaaSIdentity = NewSaaSIdentityClient(c.config)
	c.SaaSUsage = NewSaaSUsageClient(c.config)
	c.Script = NewScriptClient(c.config)
	c.ServiceRate = NewServiceRateClient(c.config)
	c.StockMovement = NewStockMovementClient(c.config)
	c.StrategicRoadmap = NewStrategicRoadmapClient(c.config)
	c.SuccessionMap = NewSuccessionMapClient(c.config)
	c.Tenant = NewTenantClient(c.config)
	c.Ticket = NewTicketClient(c.config)
	c.TimeEntry = NewTimeEntryClient(c.config)
	c.TimeOffBalance = NewTimeOffBalanceClient(c.config)
	c.TimeOffPolicy = NewTimeOffPolicyClient(c.config)
	c.TimeOffRequest = NewTimeOffRequestClient(c.config)
	c.Transaction = NewTransactionClient(c.config)
	c.User = NewUserClient(c.config)
	c.VaultItem = NewVaultItemClient(c.config)
	c.Voicemail = NewVoicemailClient(c.config)
}

type (
	// config is the configuration for the client and its builder.
	config struct {
		// driver used for executing database requests.
		driver dialect.Driver
		// debug enable a debug logging.
		debug bool
		// log used for logging on debug mode.
		log func(...any)
		// hooks to execute on mutations.
		hooks *hooks
		// interceptors to execute on queries.
		inters *inters
	}
	// Option function to configure the client.
	Option func(*config)
)

// newConfig creates a new config for the client.
func newConfig(opts ...Option) config {
	cfg := config{log: log.Println, hooks: &hooks{}, inters: &inters{}}
	cfg.options(opts...)
	return cfg
}

// options applies the options on the config object.
func (c *config) options(opts ...Option) {
	for _, opt := range opts {
		opt(c)
	}
	if c.debug {
		c.driver = dialect.Debug(c.driver, c.log)
	}
}

// Debug enables debug logging on the ent.Driver.
func Debug() Option {
	return func(c *config) {
		c.debug = true
	}
}

// Log sets the logging function for debug mode.
func Log(fn func(...any)) Option {
	return func(c *config) {
		c.log = fn
	}
}

// Driver configures the client driver.
func Driver(driver dialect.Driver) Option {
	return func(c *config) {
		c.driver = driver
	}
}

// Open opens a database/sql.DB specified by the driver name and
// the data source name, and returns a new client attached to it.
// Optional parameters can be added for configuring the client.
func Open(driverName, dataSourceName string, options ...Option) (*Client, error) {
	switch driverName {
	case dialect.MySQL, dialect.Postgres, dialect.SQLite:
		drv, err := sql.Open(driverName, dataSourceName)
		if err != nil {
			return nil, err
		}
		return NewClient(append(options, Driver(drv))...), nil
	default:
		return nil, fmt.Errorf("unsupported driver: %q", driverName)
	}
}

// ErrTxStarted is returned when trying to start a new transaction from a transactional client.
var ErrTxStarted = errors.New("ent: cannot start a transaction within a transaction")

// Tx returns a new transactional client. The provided context
// is used until the transaction is committed or rolled back.
func (c *Client) Tx(ctx context.Context) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, ErrTxStarted
	}
	tx, err := newTx(ctx, c.driver)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = tx
	return &Tx{
		ctx:                   ctx,
		config:                cfg,
		Account:               NewAccountClient(cfg),
		Agent:                 NewAgentClient(cfg),
		Asset:                 NewAssetClient(cfg),
		AssetType:             NewAssetTypeClient(cfg),
		AuditLog:              NewAuditLogClient(cfg),
		BudgetForecast:        NewBudgetForecastClient(cfg),
		CallLog:               NewCallLogClient(cfg),
		Camera:                NewCameraClient(cfg),
		CompensationAgreement: NewCompensationAgreementClient(cfg),
		Contract:              NewContractClient(cfg),
		Credential:            NewCredentialClient(cfg),
		Department:            NewDepartmentClient(cfg),
		DetectionEvent:        NewDetectionEventClient(cfg),
		DiscoveryEntry:        NewDiscoveryEntryClient(cfg),
		Employee:              NewEmployeeClient(cfg),
		Goal:                  NewGoalClient(cfg),
		HealthScoreSnapshot:   NewHealthScoreSnapshotClient(cfg),
		IVRFlow:               NewIVRFlowClient(cfg),
		InventoryReservation:  NewInventoryReservationClient(cfg),
		Job:                   NewJobClient(cfg),
		JobExecution:          NewJobExecutionClient(cfg),
		JournalEntry:          NewJournalEntryClient(cfg),
		LedgerEntry:           NewLedgerEntryClient(cfg),
		NetworkBackup:         NewNetworkBackupClient(cfg),
		NetworkDevice:         NewNetworkDeviceClient(cfg),
		NetworkLink:           NewNetworkLinkClient(cfg),
		NetworkPort:           NewNetworkPortClient(cfg),
		NexusAudit:            NewNexusAuditClient(cfg),
		OneTimeLink:           NewOneTimeLinkClient(cfg),
		PerformanceReview:     NewPerformanceReviewClient(cfg),
		Permission:            NewPermissionClient(cfg),
		Product:               NewProductClient(cfg),
		Recording:             NewRecordingClient(cfg),
		RecurringInvoice:      NewRecurringInvoiceClient(cfg),
		RemediationStep:       NewRemediationStepClient(cfg),
		ReviewCycle:           NewReviewCycleClient(cfg),
		SOP:                   NewSOPClient(cfg),
		SaaSApp:               NewSaaSAppClient(cfg),
		SaaSFilter:            NewSaaSFilterClient(cfg),
		SaaSIdentity:          NewSaaSIdentityClient(cfg),
		SaaSUsage:             NewSaaSUsageClient(cfg),
		Script:                NewScriptClient(cfg),
		ServiceRate:           NewServiceRateClient(cfg),
		StockMovement:         NewStockMovementClient(cfg),
		StrategicRoadmap:      NewStrategicRoadmapClient(cfg),
		SuccessionMap:         NewSuccessionMapClient(cfg),
		Tenant:                NewTenantClient(cfg),
		Ticket:                NewTicketClient(cfg),
		TimeEntry:             NewTimeEntryClient(cfg),
		TimeOffBalance:        NewTimeOffBalanceClient(cfg),
		TimeOffPolicy:         NewTimeOffPolicyClient(cfg),
		TimeOffRequest:        NewTimeOffRequestClient(cfg),
		Transaction:           NewTransactionClient(cfg),
		User:                  NewUserClient(cfg),
		VaultItem:             NewVaultItemClient(cfg),
		Voicemail:             NewVoicemailClient(cfg),
	}, nil
}

// BeginTx returns a transactional client with specified options.
func (c *Client) BeginTx(ctx context.Context, opts *sql.TxOptions) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, errors.New("ent: cannot start a transaction within a transaction")
	}
	tx, err := c.driver.(interface {
		BeginTx(context.Context, *sql.TxOptions) (dialect.Tx, error)
	}).BeginTx(ctx, opts)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = &txDriver{tx: tx, drv: c.driver}
	return &Tx{
		ctx:                   ctx,
		config:                cfg,
		Account:               NewAccountClient(cfg),
		Agent:                 NewAgentClient(cfg),
		Asset:                 NewAssetClient(cfg),
		AssetType:             NewAssetTypeClient(cfg),
		AuditLog:              NewAuditLogClient(cfg),
		BudgetForecast:        NewBudgetForecastClient(cfg),
		CallLog:               NewCallLogClient(cfg),
		Camera:                NewCameraClient(cfg),
		CompensationAgreement: NewCompensationAgreementClient(cfg),
		Contract:              NewContractClient(cfg),
		Credential:            NewCredentialClient(cfg),
		Department:            NewDepartmentClient(cfg),
		DetectionEvent:        NewDetectionEventClient(cfg),
		DiscoveryEntry:        NewDiscoveryEntryClient(cfg),
		Employee:              NewEmployeeClient(cfg),
		Goal:                  NewGoalClient(cfg),
		HealthScoreSnapshot:   NewHealthScoreSnapshotClient(cfg),
		IVRFlow:               NewIVRFlowClient(cfg),
		InventoryReservation:  NewInventoryReservationClient(cfg),
		Job:                   NewJobClient(cfg),
		JobExecution:          NewJobExecutionClient(cfg),
		JournalEntry:          NewJournalEntryClient(cfg),
		LedgerEntry:           NewLedgerEntryClient(cfg),
		NetworkBackup:         NewNetworkBackupClient(cfg),
		NetworkDevice:         NewNetworkDeviceClient(cfg),
		NetworkLink:           NewNetworkLinkClient(cfg),
		NetworkPort:           NewNetworkPortClient(cfg),
		NexusAudit:            NewNexusAuditClient(cfg),
		OneTimeLink:           NewOneTimeLinkClient(cfg),
		PerformanceReview:     NewPerformanceReviewClient(cfg),
		Permission:            NewPermissionClient(cfg),
		Product:               NewProductClient(cfg),
		Recording:             NewRecordingClient(cfg),
		RecurringInvoice:      NewRecurringInvoiceClient(cfg),
		RemediationStep:       NewRemediationStepClient(cfg),
		ReviewCycle:           NewReviewCycleClient(cfg),
		SOP:                   NewSOPClient(cfg),
		SaaSApp:               NewSaaSAppClient(cfg),
		SaaSFilter:            NewSaaSFilterClient(cfg),
		SaaSIdentity:          NewSaaSIdentityClient(cfg),
		SaaSUsage:             NewSaaSUsageClient(cfg),
		Script:                NewScriptClient(cfg),
		ServiceRate:           NewServiceRateClient(cfg),
		StockMovement:         NewStockMovementClient(cfg),
		StrategicRoadmap:      NewStrategicRoadmapClient(cfg),
		SuccessionMap:         NewSuccessionMapClient(cfg),
		Tenant:                NewTenantClient(cfg),
		Ticket:                NewTicketClient(cfg),
		TimeEntry:             NewTimeEntryClient(cfg),
		TimeOffBalance:        NewTimeOffBalanceClient(cfg),
		TimeOffPolicy:         NewTimeOffPolicyClient(cfg),
		TimeOffRequest:        NewTimeOffRequestClient(cfg),
		Transaction:           NewTransactionClient(cfg),
		User:                  NewUserClient(cfg),
		VaultItem:             NewVaultItemClient(cfg),
		Voicemail:             NewVoicemailClient(cfg),
	}, nil
}

// Debug returns a new debug-client. It's used to get verbose logging on specific operations.
//
//	client.Debug().
//		Account.
//		Query().
//		Count(ctx)
func (c *Client) Debug() *Client {
	if c.debug {
		return c
	}
	cfg := c.config
	cfg.driver = dialect.Debug(c.driver, c.log)
	client := &Client{config: cfg}
	client.init()
	return client
}

// Close closes the database connection and prevents new queries from starting.
func (c *Client) Close() error {
	return c.driver.Close()
}

// Use adds the mutation hooks to all the entity clients.
// In order to add hooks to a specific client, call: `client.Node.Use(...)`.
func (c *Client) Use(hooks ...Hook) {
	for _, n := range []interface{ Use(...Hook) }{
		c.Account, c.Agent, c.Asset, c.AssetType, c.AuditLog, c.BudgetForecast,
		c.CallLog, c.Camera, c.CompensationAgreement, c.Contract, c.Credential,
		c.Department, c.DetectionEvent, c.DiscoveryEntry, c.Employee, c.Goal,
		c.HealthScoreSnapshot, c.IVRFlow, c.InventoryReservation, c.Job,
		c.JobExecution, c.JournalEntry, c.LedgerEntry, c.NetworkBackup,
		c.NetworkDevice, c.NetworkLink, c.NetworkPort, c.NexusAudit, c.OneTimeLink,
		c.PerformanceReview, c.Permission, c.Product, c.Recording, c.RecurringInvoice,
		c.RemediationStep, c.ReviewCycle, c.SOP, c.SaaSApp, c.SaaSFilter,
		c.SaaSIdentity, c.SaaSUsage, c.Script, c.ServiceRate, c.StockMovement,
		c.StrategicRoadmap, c.SuccessionMap, c.Tenant, c.Ticket, c.TimeEntry,
		c.TimeOffBalance, c.TimeOffPolicy, c.TimeOffRequest, c.Transaction, c.User,
		c.VaultItem, c.Voicemail,
	} {
		n.Use(hooks...)
	}
}

// Intercept adds the query interceptors to all the entity clients.
// In order to add interceptors to a specific client, call: `client.Node.Intercept(...)`.
func (c *Client) Intercept(interceptors ...Interceptor) {
	for _, n := range []interface{ Intercept(...Interceptor) }{
		c.Account, c.Agent, c.Asset, c.AssetType, c.AuditLog, c.BudgetForecast,
		c.CallLog, c.Camera, c.CompensationAgreement, c.Contract, c.Credential,
		c.Department, c.DetectionEvent, c.DiscoveryEntry, c.Employee, c.Goal,
		c.HealthScoreSnapshot, c.IVRFlow, c.InventoryReservation, c.Job,
		c.JobExecution, c.JournalEntry, c.LedgerEntry, c.NetworkBackup,
		c.NetworkDevice, c.NetworkLink, c.NetworkPort, c.NexusAudit, c.OneTimeLink,
		c.PerformanceReview, c.Permission, c.Product, c.Recording, c.RecurringInvoice,
		c.RemediationStep, c.ReviewCycle, c.SOP, c.SaaSApp, c.SaaSFilter,
		c.SaaSIdentity, c.SaaSUsage, c.Script, c.ServiceRate, c.StockMovement,
		c.StrategicRoadmap, c.SuccessionMap, c.Tenant, c.Ticket, c.TimeEntry,
		c.TimeOffBalance, c.TimeOffPolicy, c.TimeOffRequest, c.Transaction, c.User,
		c.VaultItem, c.Voicemail,
	} {
		n.Intercept(interceptors...)
	}
}

// Mutate implements the ent.Mutator interface.
func (c *Client) Mutate(ctx context.Context, m Mutation) (Value, error) {
	switch m := m.(type) {
	case *AccountMutation:
		return c.Account.mutate(ctx, m)
	case *AgentMutation:
		return c.Agent.mutate(ctx, m)
	case *AssetMutation:
		return c.Asset.mutate(ctx, m)
	case *AssetTypeMutation:
		return c.AssetType.mutate(ctx, m)
	case *AuditLogMutation:
		return c.AuditLog.mutate(ctx, m)
	case *BudgetForecastMutation:
		return c.BudgetForecast.mutate(ctx, m)
	case *CallLogMutation:
		return c.CallLog.mutate(ctx, m)
	case *CameraMutation:
		return c.Camera.mutate(ctx, m)
	case *CompensationAgreementMutation:
		return c.CompensationAgreement.mutate(ctx, m)
	case *ContractMutation:
		return c.Contract.mutate(ctx, m)
	case *CredentialMutation:
		return c.Credential.mutate(ctx, m)
	case *DepartmentMutation:
		return c.Department.mutate(ctx, m)
	case *DetectionEventMutation:
		return c.DetectionEvent.mutate(ctx, m)
	case *DiscoveryEntryMutation:
		return c.DiscoveryEntry.mutate(ctx, m)
	case *EmployeeMutation:
		return c.Employee.mutate(ctx, m)
	case *GoalMutation:
		return c.Goal.mutate(ctx, m)
	case *HealthScoreSnapshotMutation:
		return c.HealthScoreSnapshot.mutate(ctx, m)
	case *IVRFlowMutation:
		return c.IVRFlow.mutate(ctx, m)
	case *InventoryReservationMutation:
		return c.InventoryReservation.mutate(ctx, m)
	case *JobMutation:
		return c.Job.mutate(ctx, m)
	case *JobExecutionMutation:
		return c.JobExecution.mutate(ctx, m)
	case *JournalEntryMutation:
		return c.JournalEntry.mutate(ctx, m)
	case *LedgerEntryMutation:
		return c.LedgerEntry.mutate(ctx, m)
	case *NetworkBackupMutation:
		return c.NetworkBackup.mutate(ctx, m)
	case *NetworkDeviceMutation:
		return c.NetworkDevice.mutate(ctx, m)
	case *NetworkLinkMutation:
		return c.NetworkLink.mutate(ctx, m)
	case *NetworkPortMutation:
		return c.NetworkPort.mutate(ctx, m)
	case *NexusAuditMutation:
		return c.NexusAudit.mutate(ctx, m)
	case *OneTimeLinkMutation:
		return c.OneTimeLink.mutate(ctx, m)
	case *PerformanceReviewMutation:
		return c.PerformanceReview.mutate(ctx, m)
	case *PermissionMutation:
		return c.Permission.mutate(ctx, m)
	case *ProductMutation:
		return c.Product.mutate(ctx, m)
	case *RecordingMutation:
		return c.Recording.mutate(ctx, m)
	case *RecurringInvoiceMutation:
		return c.RecurringInvoice.mutate(ctx, m)
	case *RemediationStepMutation:
		return c.RemediationStep.mutate(ctx, m)
	case *ReviewCycleMutation:
		return c.ReviewCycle.mutate(ctx, m)
	case *SOPMutation:
		return c.SOP.mutate(ctx, m)
	case *SaaSAppMutation:
		return c.SaaSApp.mutate(ctx, m)
	case *SaaSFilterMutation:
		return c.SaaSFilter.mutate(ctx, m)
	case *SaaSIdentityMutation:
		return c.SaaSIdentity.mutate(ctx, m)
	case *SaaSUsageMutation:
		return c.SaaSUsage.mutate(ctx, m)
	case *ScriptMutation:
		return c.Script.mutate(ctx, m)
	case *ServiceRateMutation:
		return c.ServiceRate.mutate(ctx, m)
	case *StockMovementMutation:
		return c.StockMovement.mutate(ctx, m)
	case *StrategicRoadmapMutation:
		return c.StrategicRoadmap.mutate(ctx, m)
	case *SuccessionMapMutation:
		return c.SuccessionMap.mutate(ctx, m)
	case *TenantMutation:
		return c.Tenant.mutate(ctx, m)
	case *TicketMutation:
		return c.Ticket.mutate(ctx, m)
	case *TimeEntryMutation:
		return c.TimeEntry.mutate(ctx, m)
	case *TimeOffBalanceMutation:
		return c.TimeOffBalance.mutate(ctx, m)
	case *TimeOffPolicyMutation:
		return c.TimeOffPolicy.mutate(ctx, m)
	case *TimeOffRequestMutation:
		return c.TimeOffRequest.mutate(ctx, m)
	case *TransactionMutation:
		return c.Transaction.mutate(ctx, m)
	case *UserMutation:
		return c.User.mutate(ctx, m)
	case *VaultItemMutation:
		return c.VaultItem.mutate(ctx, m)
	case *VoicemailMutation:
		return c.Voicemail.mutate(ctx, m)
	default:
		return nil, fmt.Errorf("ent: unknown mutation type %T", m)
	}
}

// AccountClient is a client for the Account schema.
type AccountClient struct {
	config
}

// NewAccountClient returns a client for the Account from the given config.
func NewAccountClient(c config) *AccountClient {
	return &AccountClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `account.Hooks(f(g(h())))`.
func (c *AccountClient) Use(hooks ...Hook) {
	c.hooks.Account = append(c.hooks.Account, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `account.Intercept(f(g(h())))`.
func (c *AccountClient) Intercept(interceptors ...Interceptor) {
	c.inters.Account = append(c.inters.Account, interceptors...)
}

// Create returns a builder for creating a Account entity.
func (c *AccountClient) Create() *AccountCreate {
	mutation := newAccountMutation(c.config, OpCreate)
	return &AccountCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Account entities.
func (c *AccountClient) CreateBulk(builders ...*AccountCreate) *AccountCreateBulk {
	return &AccountCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *AccountClient) MapCreateBulk(slice any, setFunc func(*AccountCreate, int)) *AccountCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &AccountCreateBulk{err: fmt.Errorf("calling to AccountClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*AccountCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &AccountCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Account.
func (c *AccountClient) Update() *AccountUpdate {
	mutation := newAccountMutation(c.config, OpUpdate)
	return &AccountUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *AccountClient) UpdateOne(_m *Account) *AccountUpdateOne {
	mutation := newAccountMutation(c.config, OpUpdateOne, withAccount(_m))
	return &AccountUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *AccountClient) UpdateOneID(id int) *AccountUpdateOne {
	mutation := newAccountMutation(c.config, OpUpdateOne, withAccountID(id))
	return &AccountUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Account.
func (c *AccountClient) Delete() *AccountDelete {
	mutation := newAccountMutation(c.config, OpDelete)
	return &AccountDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *AccountClient) DeleteOne(_m *Account) *AccountDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *AccountClient) DeleteOneID(id int) *AccountDeleteOne {
	builder := c.Delete().Where(account.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &AccountDeleteOne{builder}
}

// Query returns a query builder for Account.
func (c *AccountClient) Query() *AccountQuery {
	return &AccountQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeAccount},
		inters: c.Interceptors(),
	}
}

// Get returns a Account entity by its id.
func (c *AccountClient) Get(ctx context.Context, id int) (*Account, error) {
	return c.Query().Where(account.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *AccountClient) GetX(ctx context.Context, id int) *Account {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryTenant queries the tenant edge of a Account.
func (c *AccountClient) QueryTenant(_m *Account) *TenantQuery {
	query := (&TenantClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(account.Table, account.FieldID, id),
			sqlgraph.To(tenant.Table, tenant.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, account.TenantTable, account.TenantColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryEntries queries the entries edge of a Account.
func (c *AccountClient) QueryEntries(_m *Account) *LedgerEntryQuery {
	query := (&LedgerEntryClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(account.Table, account.FieldID, id),
			sqlgraph.To(ledgerentry.Table, ledgerentry.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, account.EntriesTable, account.EntriesColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryJournalEntries queries the journal_entries edge of a Account.
func (c *AccountClient) QueryJournalEntries(_m *Account) *JournalEntryQuery {
	query := (&JournalEntryClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(account.Table, account.FieldID, id),
			sqlgraph.To(journalentry.Table, journalentry.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, account.JournalEntriesTable, account.JournalEntriesColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryRecurringInvoices queries the recurring_invoices edge of a Account.
func (c *AccountClient) QueryRecurringInvoices(_m *Account) *RecurringInvoiceQuery {
	query := (&RecurringInvoiceClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(account.Table, account.FieldID, id),
			sqlgraph.To(recurringinvoice.Table, recurringinvoice.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, account.RecurringInvoicesTable, account.RecurringInvoicesColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *AccountClient) Hooks() []Hook {
	return c.hooks.Account
}

// Interceptors returns the client interceptors.
func (c *AccountClient) Interceptors() []Interceptor {
	return c.inters.Account
}

func (c *AccountClient) mutate(ctx context.Context, m *AccountMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&AccountCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&AccountUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&AccountUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&AccountDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Account mutation op: %q", m.Op())
	}
}

// AgentClient is a client for the Agent schema.
type AgentClient struct {
	config
}

// NewAgentClient returns a client for the Agent from the given config.
func NewAgentClient(c config) *AgentClient {
	return &AgentClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `agent.Hooks(f(g(h())))`.
func (c *AgentClient) Use(hooks ...Hook) {
	c.hooks.Agent = append(c.hooks.Agent, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `agent.Intercept(f(g(h())))`.
func (c *AgentClient) Intercept(interceptors ...Interceptor) {
	c.inters.Agent = append(c.inters.Agent, interceptors...)
}

// Create returns a builder for creating a Agent entity.
func (c *AgentClient) Create() *AgentCreate {
	mutation := newAgentMutation(c.config, OpCreate)
	return &AgentCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Agent entities.
func (c *AgentClient) CreateBulk(builders ...*AgentCreate) *AgentCreateBulk {
	return &AgentCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *AgentClient) MapCreateBulk(slice any, setFunc func(*AgentCreate, int)) *AgentCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &AgentCreateBulk{err: fmt.Errorf("calling to AgentClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*AgentCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &AgentCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Agent.
func (c *AgentClient) Update() *AgentUpdate {
	mutation := newAgentMutation(c.config, OpUpdate)
	return &AgentUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *AgentClient) UpdateOne(_m *Agent) *AgentUpdateOne {
	mutation := newAgentMutation(c.config, OpUpdateOne, withAgent(_m))
	return &AgentUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *AgentClient) UpdateOneID(id int) *AgentUpdateOne {
	mutation := newAgentMutation(c.config, OpUpdateOne, withAgentID(id))
	return &AgentUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Agent.
func (c *AgentClient) Delete() *AgentDelete {
	mutation := newAgentMutation(c.config, OpDelete)
	return &AgentDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *AgentClient) DeleteOne(_m *Agent) *AgentDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *AgentClient) DeleteOneID(id int) *AgentDeleteOne {
	builder := c.Delete().Where(agent.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &AgentDeleteOne{builder}
}

// Query returns a query builder for Agent.
func (c *AgentClient) Query() *AgentQuery {
	return &AgentQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeAgent},
		inters: c.Interceptors(),
	}
}

// Get returns a Agent entity by its id.
func (c *AgentClient) Get(ctx context.Context, id int) (*Agent, error) {
	return c.Query().Where(agent.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *AgentClient) GetX(ctx context.Context, id int) *Agent {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryTenant queries the tenant edge of a Agent.
func (c *AgentClient) QueryTenant(_m *Agent) *TenantQuery {
	query := (&TenantClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(agent.Table, agent.FieldID, id),
			sqlgraph.To(tenant.Table, tenant.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, agent.TenantTable, agent.TenantColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryJobExecutions queries the job_executions edge of a Agent.
func (c *AgentClient) QueryJobExecutions(_m *Agent) *JobExecutionQuery {
	query := (&JobExecutionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(agent.Table, agent.FieldID, id),
			sqlgraph.To(jobexecution.Table, jobexecution.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, agent.JobExecutionsTable, agent.JobExecutionsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *AgentClient) Hooks() []Hook {
	return c.hooks.Agent
}

// Interceptors returns the client interceptors.
func (c *AgentClient) Interceptors() []Interceptor {
	return c.inters.Agent
}

func (c *AgentClient) mutate(ctx context.Context, m *AgentMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&AgentCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&AgentUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&AgentUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&AgentDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Agent mutation op: %q", m.Op())
	}
}

// AssetClient is a client for the Asset schema.
type AssetClient struct {
	config
}

// NewAssetClient returns a client for the Asset from the given config.
func NewAssetClient(c config) *AssetClient {
	return &AssetClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `asset.Hooks(f(g(h())))`.
func (c *AssetClient) Use(hooks ...Hook) {
	c.hooks.Asset = append(c.hooks.Asset, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `asset.Intercept(f(g(h())))`.
func (c *AssetClient) Intercept(interceptors ...Interceptor) {
	c.inters.Asset = append(c.inters.Asset, interceptors...)
}

// Create returns a builder for creating a Asset entity.
func (c *AssetClient) Create() *AssetCreate {
	mutation := newAssetMutation(c.config, OpCreate)
	return &AssetCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Asset entities.
func (c *AssetClient) CreateBulk(builders ...*AssetCreate) *AssetCreateBulk {
	return &AssetCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *AssetClient) MapCreateBulk(slice any, setFunc func(*AssetCreate, int)) *AssetCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &AssetCreateBulk{err: fmt.Errorf("calling to AssetClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*AssetCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &AssetCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Asset.
func (c *AssetClient) Update() *AssetUpdate {
	mutation := newAssetMutation(c.config, OpUpdate)
	return &AssetUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *AssetClient) UpdateOne(_m *Asset) *AssetUpdateOne {
	mutation := newAssetMutation(c.config, OpUpdateOne, withAsset(_m))
	return &AssetUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *AssetClient) UpdateOneID(id int) *AssetUpdateOne {
	mutation := newAssetMutation(c.config, OpUpdateOne, withAssetID(id))
	return &AssetUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Asset.
func (c *AssetClient) Delete() *AssetDelete {
	mutation := newAssetMutation(c.config, OpDelete)
	return &AssetDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *AssetClient) DeleteOne(_m *Asset) *AssetDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *AssetClient) DeleteOneID(id int) *AssetDeleteOne {
	builder := c.Delete().Where(asset.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &AssetDeleteOne{builder}
}

// Query returns a query builder for Asset.
func (c *AssetClient) Query() *AssetQuery {
	return &AssetQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeAsset},
		inters: c.Interceptors(),
	}
}

// Get returns a Asset entity by its id.
func (c *AssetClient) Get(ctx context.Context, id int) (*Asset, error) {
	return c.Query().Where(asset.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *AssetClient) GetX(ctx context.Context, id int) *Asset {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryTenant queries the tenant edge of a Asset.
func (c *AssetClient) QueryTenant(_m *Asset) *TenantQuery {
	query := (&TenantClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(asset.Table, asset.FieldID, id),
			sqlgraph.To(tenant.Table, tenant.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, asset.TenantTable, asset.TenantColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryType queries the type edge of a Asset.
func (c *AssetClient) QueryType(_m *Asset) *AssetTypeQuery {
	query := (&AssetTypeClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(asset.Table, asset.FieldID, id),
			sqlgraph.To(assettype.Table, assettype.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, asset.TypeTable, asset.TypeColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryHostedAt queries the hosted_at edge of a Asset.
func (c *AssetClient) QueryHostedAt(_m *Asset) *AssetQuery {
	query := (&AssetClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(asset.Table, asset.FieldID, id),
			sqlgraph.To(asset.Table, asset.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, asset.HostedAtTable, asset.HostedAtColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryHostedAssets queries the hosted_assets edge of a Asset.
func (c *AssetClient) QueryHostedAssets(_m *Asset) *AssetQuery {
	query := (&AssetClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(asset.Table, asset.FieldID, id),
			sqlgraph.To(asset.Table, asset.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, asset.HostedAssetsTable, asset.HostedAssetsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryDependencyOf queries the dependency_of edge of a Asset.
func (c *AssetClient) QueryDependencyOf(_m *Asset) *AssetQuery {
	query := (&AssetClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(asset.Table, asset.FieldID, id),
			sqlgraph.To(asset.Table, asset.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, asset.DependencyOfTable, asset.DependencyOfPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryDependsOn queries the depends_on edge of a Asset.
func (c *AssetClient) QueryDependsOn(_m *Asset) *AssetQuery {
	query := (&AssetClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(asset.Table, asset.FieldID, id),
			sqlgraph.To(asset.Table, asset.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, asset.DependsOnTable, asset.DependsOnPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryOwner queries the owner edge of a Asset.
func (c *AssetClient) QueryOwner(_m *Asset) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(asset.Table, asset.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, asset.OwnerTable, asset.OwnerColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCredentials queries the credentials edge of a Asset.
func (c *AssetClient) QueryCredentials(_m *Asset) *CredentialQuery {
	query := (&CredentialClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(asset.Table, asset.FieldID, id),
			sqlgraph.To(credential.Table, credential.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, asset.CredentialsTable, asset.CredentialsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QuerySops queries the sops edge of a Asset.
func (c *AssetClient) QuerySops(_m *Asset) *SOPQuery {
	query := (&SOPClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(asset.Table, asset.FieldID, id),
			sqlgraph.To(sop.Table, sop.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, asset.SopsTable, asset.SopsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTickets queries the tickets edge of a Asset.
func (c *AssetClient) QueryTickets(_m *Asset) *TicketQuery {
	query := (&TicketClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(asset.Table, asset.FieldID, id),
			sqlgraph.To(ticket.Table, ticket.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, asset.TicketsTable, asset.TicketsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryProduct queries the product edge of a Asset.
func (c *AssetClient) QueryProduct(_m *Asset) *ProductQuery {
	query := (&ProductClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(asset.Table, asset.FieldID, id),
			sqlgraph.To(product.Table, product.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, asset.ProductTable, asset.ProductColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *AssetClient) Hooks() []Hook {
	return c.hooks.Asset
}

// Interceptors returns the client interceptors.
func (c *AssetClient) Interceptors() []Interceptor {
	return c.inters.Asset
}

func (c *AssetClient) mutate(ctx context.Context, m *AssetMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&AssetCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&AssetUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&AssetUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&AssetDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Asset mutation op: %q", m.Op())
	}
}

// AssetTypeClient is a client for the AssetType schema.
type AssetTypeClient struct {
	config
}

// NewAssetTypeClient returns a client for the AssetType from the given config.
func NewAssetTypeClient(c config) *AssetTypeClient {
	return &AssetTypeClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `assettype.Hooks(f(g(h())))`.
func (c *AssetTypeClient) Use(hooks ...Hook) {
	c.hooks.AssetType = append(c.hooks.AssetType, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `assettype.Intercept(f(g(h())))`.
func (c *AssetTypeClient) Intercept(interceptors ...Interceptor) {
	c.inters.AssetType = append(c.inters.AssetType, interceptors...)
}

// Create returns a builder for creating a AssetType entity.
func (c *AssetTypeClient) Create() *AssetTypeCreate {
	mutation := newAssetTypeMutation(c.config, OpCreate)
	return &AssetTypeCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of AssetType entities.
func (c *AssetTypeClient) CreateBulk(builders ...*AssetTypeCreate) *AssetTypeCreateBulk {
	return &AssetTypeCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *AssetTypeClient) MapCreateBulk(slice any, setFunc func(*AssetTypeCreate, int)) *AssetTypeCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &AssetTypeCreateBulk{err: fmt.Errorf("calling to AssetTypeClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*AssetTypeCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &AssetTypeCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for AssetType.
func (c *AssetTypeClient) Update() *AssetTypeUpdate {
	mutation := newAssetTypeMutation(c.config, OpUpdate)
	return &AssetTypeUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *AssetTypeClient) UpdateOne(_m *AssetType) *AssetTypeUpdateOne {
	mutation := newAssetTypeMutation(c.config, OpUpdateOne, withAssetType(_m))
	return &AssetTypeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *AssetTypeClient) UpdateOneID(id int) *AssetTypeUpdateOne {
	mutation := newAssetTypeMutation(c.config, OpUpdateOne, withAssetTypeID(id))
	return &AssetTypeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for AssetType.
func (c *AssetTypeClient) Delete() *AssetTypeDelete {
	mutation := newAssetTypeMutation(c.config, OpDelete)
	return &AssetTypeDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *AssetTypeClient) DeleteOne(_m *AssetType) *AssetTypeDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *AssetTypeClient) DeleteOneID(id int) *AssetTypeDeleteOne {
	builder := c.Delete().Where(assettype.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &AssetTypeDeleteOne{builder}
}

// Query returns a query builder for AssetType.
func (c *AssetTypeClient) Query() *AssetTypeQuery {
	return &AssetTypeQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeAssetType},
		inters: c.Interceptors(),
	}
}

// Get returns a AssetType entity by its id.
func (c *AssetTypeClient) Get(ctx context.Context, id int) (*AssetType, error) {
	return c.Query().Where(assettype.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *AssetTypeClient) GetX(ctx context.Context, id int) *AssetType {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryAssets queries the assets edge of a AssetType.
func (c *AssetTypeClient) QueryAssets(_m *AssetType) *AssetQuery {
	query := (&AssetClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(assettype.Table, assettype.FieldID, id),
			sqlgraph.To(asset.Table, asset.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, assettype.AssetsTable, assettype.AssetsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTenant queries the tenant edge of a AssetType.
func (c *AssetTypeClient) QueryTenant(_m *AssetType) *TenantQuery {
	query := (&TenantClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(assettype.Table, assettype.FieldID, id),
			sqlgraph.To(tenant.Table, tenant.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, assettype.TenantTable, assettype.TenantColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *AssetTypeClient) Hooks() []Hook {
	return c.hooks.AssetType
}

// Interceptors returns the client interceptors.
func (c *AssetTypeClient) Interceptors() []Interceptor {
	return c.inters.AssetType
}

func (c *AssetTypeClient) mutate(ctx context.Context, m *AssetTypeMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&AssetTypeCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&AssetTypeUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&AssetTypeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&AssetTypeDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown AssetType mutation op: %q", m.Op())
	}
}

// AuditLogClient is a client for the AuditLog schema.
type AuditLogClient struct {
	config
}

// NewAuditLogClient returns a client for the AuditLog from the given config.
func NewAuditLogClient(c config) *AuditLogClient {
	return &AuditLogClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `auditlog.Hooks(f(g(h())))`.
func (c *AuditLogClient) Use(hooks ...Hook) {
	c.hooks.AuditLog = append(c.hooks.AuditLog, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `auditlog.Intercept(f(g(h())))`.
func (c *AuditLogClient) Intercept(interceptors ...Interceptor) {
	c.inters.AuditLog = append(c.inters.AuditLog, interceptors...)
}

// Create returns a builder for creating a AuditLog entity.
func (c *AuditLogClient) Create() *AuditLogCreate {
	mutation := newAuditLogMutation(c.config, OpCreate)
	return &AuditLogCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of AuditLog entities.
func (c *AuditLogClient) CreateBulk(builders ...*AuditLogCreate) *AuditLogCreateBulk {
	return &AuditLogCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *AuditLogClient) MapCreateBulk(slice any, setFunc func(*AuditLogCreate, int)) *AuditLogCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &AuditLogCreateBulk{err: fmt.Errorf("calling to AuditLogClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*AuditLogCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &AuditLogCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for AuditLog.
func (c *AuditLogClient) Update() *AuditLogUpdate {
	mutation := newAuditLogMutation(c.config, OpUpdate)
	return &AuditLogUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *AuditLogClient) UpdateOne(_m *AuditLog) *AuditLogUpdateOne {
	mutation := newAuditLogMutation(c.config, OpUpdateOne, withAuditLog(_m))
	return &AuditLogUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *AuditLogClient) UpdateOneID(id int) *AuditLogUpdateOne {
	mutation := newAuditLogMutation(c.config, OpUpdateOne, withAuditLogID(id))
	return &AuditLogUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for AuditLog.
func (c *AuditLogClient) Delete() *AuditLogDelete {
	mutation := newAuditLogMutation(c.config, OpDelete)
	return &AuditLogDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *AuditLogClient) DeleteOne(_m *AuditLog) *AuditLogDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *AuditLogClient) DeleteOneID(id int) *AuditLogDeleteOne {
	builder := c.Delete().Where(auditlog.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &AuditLogDeleteOne{builder}
}

// Query returns a query builder for AuditLog.
func (c *AuditLogClient) Query() *AuditLogQuery {
	return &AuditLogQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeAuditLog},
		inters: c.Interceptors(),
	}
}

// Get returns a AuditLog entity by its id.
func (c *AuditLogClient) Get(ctx context.Context, id int) (*AuditLog, error) {
	return c.Query().Where(auditlog.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *AuditLogClient) GetX(ctx context.Context, id int) *AuditLog {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryTenant queries the tenant edge of a AuditLog.
func (c *AuditLogClient) QueryTenant(_m *AuditLog) *TenantQuery {
	query := (&TenantClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(auditlog.Table, auditlog.FieldID, id),
			sqlgraph.To(tenant.Table, tenant.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, auditlog.TenantTable, auditlog.TenantColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *AuditLogClient) Hooks() []Hook {
	return c.hooks.AuditLog
}

// Interceptors returns the client interceptors.
func (c *AuditLogClient) Interceptors() []Interceptor {
	return c.inters.AuditLog
}

func (c *AuditLogClient) mutate(ctx context.Context, m *AuditLogMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&AuditLogCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&AuditLogUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&AuditLogUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&AuditLogDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown AuditLog mutation op: %q", m.Op())
	}
}

// BudgetForecastClient is a client for the BudgetForecast schema.
type BudgetForecastClient struct {
	config
}

// NewBudgetForecastClient returns a client for the BudgetForecast from the given config.
func NewBudgetForecastClient(c config) *BudgetForecastClient {
	return &BudgetForecastClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `budgetforecast.Hooks(f(g(h())))`.
func (c *BudgetForecastClient) Use(hooks ...Hook) {
	c.hooks.BudgetForecast = append(c.hooks.BudgetForecast, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `budgetforecast.Intercept(f(g(h())))`.
func (c *BudgetForecastClient) Intercept(interceptors ...Interceptor) {
	c.inters.BudgetForecast = append(c.inters.BudgetForecast, interceptors...)
}

// Create returns a builder for creating a BudgetForecast entity.
func (c *BudgetForecastClient) Create() *BudgetForecastCreate {
	mutation := newBudgetForecastMutation(c.config, OpCreate)
	return &BudgetForecastCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of BudgetForecast entities.
func (c *BudgetForecastClient) CreateBulk(builders ...*BudgetForecastCreate) *BudgetForecastCreateBulk {
	return &BudgetForecastCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *BudgetForecastClient) MapCreateBulk(slice any, setFunc func(*BudgetForecastCreate, int)) *BudgetForecastCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &BudgetForecastCreateBulk{err: fmt.Errorf("calling to BudgetForecastClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*BudgetForecastCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &BudgetForecastCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for BudgetForecast.
func (c *BudgetForecastClient) Update() *BudgetForecastUpdate {
	mutation := newBudgetForecastMutation(c.config, OpUpdate)
	return &BudgetForecastUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *BudgetForecastClient) UpdateOne(_m *BudgetForecast) *BudgetForecastUpdateOne {
	mutation := newBudgetForecastMutation(c.config, OpUpdateOne, withBudgetForecast(_m))
	return &BudgetForecastUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *BudgetForecastClient) UpdateOneID(id int) *BudgetForecastUpdateOne {
	mutation := newBudgetForecastMutation(c.config, OpUpdateOne, withBudgetForecastID(id))
	return &BudgetForecastUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for BudgetForecast.
func (c *BudgetForecastClient) Delete() *BudgetForecastDelete {
	mutation := newBudgetForecastMutation(c.config, OpDelete)
	return &BudgetForecastDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *BudgetForecastClient) DeleteOne(_m *BudgetForecast) *BudgetForecastDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *BudgetForecastClient) DeleteOneID(id int) *BudgetForecastDeleteOne {
	builder := c.Delete().Where(budgetforecast.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &BudgetForecastDeleteOne{builder}
}

// Query returns a query builder for BudgetForecast.
func (c *BudgetForecastClient) Query() *BudgetForecastQuery {
	return &BudgetForecastQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeBudgetForecast},
		inters: c.Interceptors(),
	}
}

// Get returns a BudgetForecast entity by its id.
func (c *BudgetForecastClient) Get(ctx context.Context, id int) (*BudgetForecast, error) {
	return c.Query().Where(budgetforecast.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *BudgetForecastClient) GetX(ctx context.Context, id int) *BudgetForecast {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryTenant queries the tenant edge of a BudgetForecast.
func (c *BudgetForecastClient) QueryTenant(_m *BudgetForecast) *TenantQuery {
	query := (&TenantClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(budgetforecast.Table, budgetforecast.FieldID, id),
			sqlgraph.To(tenant.Table, tenant.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, budgetforecast.TenantTable, budgetforecast.TenantColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *BudgetForecastClient) Hooks() []Hook {
	return c.hooks.BudgetForecast
}

// Interceptors returns the client interceptors.
func (c *BudgetForecastClient) Interceptors() []Interceptor {
	return c.inters.BudgetForecast
}

func (c *BudgetForecastClient) mutate(ctx context.Context, m *BudgetForecastMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&BudgetForecastCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&BudgetForecastUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&BudgetForecastUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&BudgetForecastDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown BudgetForecast mutation op: %q", m.Op())
	}
}

// CallLogClient is a client for the CallLog schema.
type CallLogClient struct {
	config
}

// NewCallLogClient returns a client for the CallLog from the given config.
func NewCallLogClient(c config) *CallLogClient {
	return &CallLogClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `calllog.Hooks(f(g(h())))`.
func (c *CallLogClient) Use(hooks ...Hook) {
	c.hooks.CallLog = append(c.hooks.CallLog, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `calllog.Intercept(f(g(h())))`.
func (c *CallLogClient) Intercept(interceptors ...Interceptor) {
	c.inters.CallLog = append(c.inters.CallLog, interceptors...)
}

// Create returns a builder for creating a CallLog entity.
func (c *CallLogClient) Create() *CallLogCreate {
	mutation := newCallLogMutation(c.config, OpCreate)
	return &CallLogCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of CallLog entities.
func (c *CallLogClient) CreateBulk(builders ...*CallLogCreate) *CallLogCreateBulk {
	return &CallLogCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *CallLogClient) MapCreateBulk(slice any, setFunc func(*CallLogCreate, int)) *CallLogCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &CallLogCreateBulk{err: fmt.Errorf("calling to CallLogClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*CallLogCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &CallLogCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for CallLog.
func (c *CallLogClient) Update() *CallLogUpdate {
	mutation := newCallLogMutation(c.config, OpUpdate)
	return &CallLogUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *CallLogClient) UpdateOne(_m *CallLog) *CallLogUpdateOne {
	mutation := newCallLogMutation(c.config, OpUpdateOne, withCallLog(_m))
	return &CallLogUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *CallLogClient) UpdateOneID(id int) *CallLogUpdateOne {
	mutation := newCallLogMutation(c.config, OpUpdateOne, withCallLogID(id))
	return &CallLogUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for CallLog.
func (c *CallLogClient) Delete() *CallLogDelete {
	mutation := newCallLogMutation(c.config, OpDelete)
	return &CallLogDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *CallLogClient) DeleteOne(_m *CallLog) *CallLogDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *CallLogClient) DeleteOneID(id int) *CallLogDeleteOne {
	builder := c.Delete().Where(calllog.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &CallLogDeleteOne{builder}
}

// Query returns a query builder for CallLog.
func (c *CallLogClient) Query() *CallLogQuery {
	return &CallLogQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeCallLog},
		inters: c.Interceptors(),
	}
}

// Get returns a CallLog entity by its id.
func (c *CallLogClient) Get(ctx context.Context, id int) (*CallLog, error) {
	return c.Query().Where(calllog.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *CallLogClient) GetX(ctx context.Context, id int) *CallLog {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryTenant queries the tenant edge of a CallLog.
func (c *CallLogClient) QueryTenant(_m *CallLog) *TenantQuery {
	query := (&TenantClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(calllog.Table, calllog.FieldID, id),
			sqlgraph.To(tenant.Table, tenant.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, calllog.TenantTable, calllog.TenantColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryUser queries the user edge of a CallLog.
func (c *CallLogClient) QueryUser(_m *CallLog) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(calllog.Table, calllog.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, calllog.UserTable, calllog.UserColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *CallLogClient) Hooks() []Hook {
	return c.hooks.CallLog
}

// Interceptors returns the client interceptors.
func (c *CallLogClient) Interceptors() []Interceptor {
	return c.inters.CallLog
}

func (c *CallLogClient) mutate(ctx context.Context, m *CallLogMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&CallLogCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&CallLogUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&CallLogUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&CallLogDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown CallLog mutation op: %q", m.Op())
	}
}

// CameraClient is a client for the Camera schema.
type CameraClient struct {
	config
}

// NewCameraClient returns a client for the Camera from the given config.
func NewCameraClient(c config) *CameraClient {
	return &CameraClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `camera.Hooks(f(g(h())))`.
func (c *CameraClient) Use(hooks ...Hook) {
	c.hooks.Camera = append(c.hooks.Camera, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `camera.Intercept(f(g(h())))`.
func (c *CameraClient) Intercept(interceptors ...Interceptor) {
	c.inters.Camera = append(c.inters.Camera, interceptors...)
}

// Create returns a builder for creating a Camera entity.
func (c *CameraClient) Create() *CameraCreate {
	mutation := newCameraMutation(c.config, OpCreate)
	return &CameraCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Camera entities.
func (c *CameraClient) CreateBulk(builders ...*CameraCreate) *CameraCreateBulk {
	return &CameraCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *CameraClient) MapCreateBulk(slice any, setFunc func(*CameraCreate, int)) *CameraCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &CameraCreateBulk{err: fmt.Errorf("calling to CameraClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*CameraCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &CameraCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Camera.
func (c *CameraClient) Update() *CameraUpdate {
	mutation := newCameraMutation(c.config, OpUpdate)
	return &CameraUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *CameraClient) UpdateOne(_m *Camera) *CameraUpdateOne {
	mutation := newCameraMutation(c.config, OpUpdateOne, withCamera(_m))
	return &CameraUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *CameraClient) UpdateOneID(id int) *CameraUpdateOne {
	mutation := newCameraMutation(c.config, OpUpdateOne, withCameraID(id))
	return &CameraUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Camera.
func (c *CameraClient) Delete() *CameraDelete {
	mutation := newCameraMutation(c.config, OpDelete)
	return &CameraDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *CameraClient) DeleteOne(_m *Camera) *CameraDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *CameraClient) DeleteOneID(id int) *CameraDeleteOne {
	builder := c.Delete().Where(camera.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &CameraDeleteOne{builder}
}

// Query returns a query builder for Camera.
func (c *CameraClient) Query() *CameraQuery {
	return &CameraQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeCamera},
		inters: c.Interceptors(),
	}
}

// Get returns a Camera entity by its id.
func (c *CameraClient) Get(ctx context.Context, id int) (*Camera, error) {
	return c.Query().Where(camera.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *CameraClient) GetX(ctx context.Context, id int) *Camera {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryTenant queries the tenant edge of a Camera.
func (c *CameraClient) QueryTenant(_m *Camera) *TenantQuery {
	query := (&TenantClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(camera.Table, camera.FieldID, id),
			sqlgraph.To(tenant.Table, tenant.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, camera.TenantTable, camera.TenantColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryRecordings queries the recordings edge of a Camera.
func (c *CameraClient) QueryRecordings(_m *Camera) *RecordingQuery {
	query := (&RecordingClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(camera.Table, camera.FieldID, id),
			sqlgraph.To(recording.Table, recording.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, camera.RecordingsTable, camera.RecordingsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryDetections queries the detections edge of a Camera.
func (c *CameraClient) QueryDetections(_m *Camera) *DetectionEventQuery {
	query := (&DetectionEventClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(camera.Table, camera.FieldID, id),
			sqlgraph.To(detectionevent.Table, detectionevent.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, camera.DetectionsTable, camera.DetectionsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *CameraClient) Hooks() []Hook {
	return c.hooks.Camera
}

// Interceptors returns the client interceptors.
func (c *CameraClient) Interceptors() []Interceptor {
	return c.inters.Camera
}

func (c *CameraClient) mutate(ctx context.Context, m *CameraMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&CameraCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&CameraUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&CameraUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&CameraDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Camera mutation op: %q", m.Op())
	}
}

// CompensationAgreementClient is a client for the CompensationAgreement schema.
type CompensationAgreementClient struct {
	config
}

// NewCompensationAgreementClient returns a client for the CompensationAgreement from the given config.
func NewCompensationAgreementClient(c config) *CompensationAgreementClient {
	return &CompensationAgreementClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `compensationagreement.Hooks(f(g(h())))`.
func (c *CompensationAgreementClient) Use(hooks ...Hook) {
	c.hooks.CompensationAgreement = append(c.hooks.CompensationAgreement, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `compensationagreement.Intercept(f(g(h())))`.
func (c *CompensationAgreementClient) Intercept(interceptors ...Interceptor) {
	c.inters.CompensationAgreement = append(c.inters.CompensationAgreement, interceptors...)
}

// Create returns a builder for creating a CompensationAgreement entity.
func (c *CompensationAgreementClient) Create() *CompensationAgreementCreate {
	mutation := newCompensationAgreementMutation(c.config, OpCreate)
	return &CompensationAgreementCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of CompensationAgreement entities.
func (c *CompensationAgreementClient) CreateBulk(builders ...*CompensationAgreementCreate) *CompensationAgreementCreateBulk {
	return &CompensationAgreementCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *CompensationAgreementClient) MapCreateBulk(slice any, setFunc func(*CompensationAgreementCreate, int)) *CompensationAgreementCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &CompensationAgreementCreateBulk{err: fmt.Errorf("calling to CompensationAgreementClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*CompensationAgreementCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &CompensationAgreementCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for CompensationAgreement.
func (c *CompensationAgreementClient) Update() *CompensationAgreementUpdate {
	mutation := newCompensationAgreementMutation(c.config, OpUpdate)
	return &CompensationAgreementUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *CompensationAgreementClient) UpdateOne(_m *CompensationAgreement) *CompensationAgreementUpdateOne {
	mutation := newCompensationAgreementMutation(c.config, OpUpdateOne, withCompensationAgreement(_m))
	return &CompensationAgreementUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *CompensationAgreementClient) UpdateOneID(id int) *CompensationAgreementUpdateOne {
	mutation := newCompensationAgreementMutation(c.config, OpUpdateOne, withCompensationAgreementID(id))
	return &CompensationAgreementUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for CompensationAgreement.
func (c *CompensationAgreementClient) Delete() *CompensationAgreementDelete {
	mutation := newCompensationAgreementMutation(c.config, OpDelete)
	return &CompensationAgreementDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *CompensationAgreementClient) DeleteOne(_m *CompensationAgreement) *CompensationAgreementDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *CompensationAgreementClient) DeleteOneID(id int) *CompensationAgreementDeleteOne {
	builder := c.Delete().Where(compensationagreement.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &CompensationAgreementDeleteOne{builder}
}

// Query returns a query builder for CompensationAgreement.
func (c *CompensationAgreementClient) Query() *CompensationAgreementQuery {
	return &CompensationAgreementQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeCompensationAgreement},
		inters: c.Interceptors(),
	}
}

// Get returns a CompensationAgreement entity by its id.
func (c *CompensationAgreementClient) Get(ctx context.Context, id int) (*CompensationAgreement, error) {
	return c.Query().Where(compensationagreement.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *CompensationAgreementClient) GetX(ctx context.Context, id int) *CompensationAgreement {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryTenant queries the tenant edge of a CompensationAgreement.
func (c *CompensationAgreementClient) QueryTenant(_m *CompensationAgreement) *TenantQuery {
	query := (&TenantClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(compensationagreement.Table, compensationagreement.FieldID, id),
			sqlgraph.To(tenant.Table, tenant.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, compensationagreement.TenantTable, compensationagreement.TenantColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryEmployee queries the employee edge of a CompensationAgreement.
func (c *CompensationAgreementClient) QueryEmployee(_m *CompensationAgreement) *EmployeeQuery {
	query := (&EmployeeClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(compensationagreement.Table, compensationagreement.FieldID, id),
			sqlgraph.To(employee.Table, employee.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, compensationagreement.EmployeeTable, compensationagreement.EmployeeColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *CompensationAgreementClient) Hooks() []Hook {
	return c.hooks.CompensationAgreement
}

// Interceptors returns the client interceptors.
func (c *CompensationAgreementClient) Interceptors() []Interceptor {
	return c.inters.CompensationAgreement
}

func (c *CompensationAgreementClient) mutate(ctx context.Context, m *CompensationAgreementMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&CompensationAgreementCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&CompensationAgreementUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&CompensationAgreementUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&CompensationAgreementDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown CompensationAgreement mutation op: %q", m.Op())
	}
}

// ContractClient is a client for the Contract schema.
type ContractClient struct {
	config
}

// NewContractClient returns a client for the Contract from the given config.
func NewContractClient(c config) *ContractClient {
	return &ContractClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `contract.Hooks(f(g(h())))`.
func (c *ContractClient) Use(hooks ...Hook) {
	c.hooks.Contract = append(c.hooks.Contract, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `contract.Intercept(f(g(h())))`.
func (c *ContractClient) Intercept(interceptors ...Interceptor) {
	c.inters.Contract = append(c.inters.Contract, interceptors...)
}

// Create returns a builder for creating a Contract entity.
func (c *ContractClient) Create() *ContractCreate {
	mutation := newContractMutation(c.config, OpCreate)
	return &ContractCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Contract entities.
func (c *ContractClient) CreateBulk(builders ...*ContractCreate) *ContractCreateBulk {
	return &ContractCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ContractClient) MapCreateBulk(slice any, setFunc func(*ContractCreate, int)) *ContractCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ContractCreateBulk{err: fmt.Errorf("calling to ContractClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ContractCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ContractCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Contract.
func (c *ContractClient) Update() *ContractUpdate {
	mutation := newContractMutation(c.config, OpUpdate)
	return &ContractUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ContractClient) UpdateOne(_m *Contract) *ContractUpdateOne {
	mutation := newContractMutation(c.config, OpUpdateOne, withContract(_m))
	return &ContractUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ContractClient) UpdateOneID(id int) *ContractUpdateOne {
	mutation := newContractMutation(c.config, OpUpdateOne, withContractID(id))
	return &ContractUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Contract.
func (c *ContractClient) Delete() *ContractDelete {
	mutation := newContractMutation(c.config, OpDelete)
	return &ContractDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ContractClient) DeleteOne(_m *Contract) *ContractDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ContractClient) DeleteOneID(id int) *ContractDeleteOne {
	builder := c.Delete().Where(contract.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ContractDeleteOne{builder}
}

// Query returns a query builder for Contract.
func (c *ContractClient) Query() *ContractQuery {
	return &ContractQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeContract},
		inters: c.Interceptors(),
	}
}

// Get returns a Contract entity by its id.
func (c *ContractClient) Get(ctx context.Context, id int) (*Contract, error) {
	return c.Query().Where(contract.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ContractClient) GetX(ctx context.Context, id int) *Contract {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryTenant queries the tenant edge of a Contract.
func (c *ContractClient) QueryTenant(_m *Contract) *TenantQuery {
	query := (&TenantClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(contract.Table, contract.FieldID, id),
			sqlgraph.To(tenant.Table, tenant.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, contract.TenantTable, contract.TenantColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ContractClient) Hooks() []Hook {
	return c.hooks.Contract
}

// Interceptors returns the client interceptors.
func (c *ContractClient) Interceptors() []Interceptor {
	return c.inters.Contract
}

func (c *ContractClient) mutate(ctx context.Context, m *ContractMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ContractCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ContractUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ContractUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ContractDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Contract mutation op: %q", m.Op())
	}
}

// CredentialClient is a client for the Credential schema.
type CredentialClient struct {
	config
}

// NewCredentialClient returns a client for the Credential from the given config.
func NewCredentialClient(c config) *CredentialClient {
	return &CredentialClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `credential.Hooks(f(g(h())))`.
func (c *CredentialClient) Use(hooks ...Hook) {
	c.hooks.Credential = append(c.hooks.Credential, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `credential.Intercept(f(g(h())))`.
func (c *CredentialClient) Intercept(interceptors ...Interceptor) {
	c.inters.Credential = append(c.inters.Credential, interceptors...)
}

// Create returns a builder for creating a Credential entity.
func (c *CredentialClient) Create() *CredentialCreate {
	mutation := newCredentialMutation(c.config, OpCreate)
	return &CredentialCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Credential entities.
func (c *CredentialClient) CreateBulk(builders ...*CredentialCreate) *CredentialCreateBulk {
	return &CredentialCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *CredentialClient) MapCreateBulk(slice any, setFunc func(*CredentialCreate, int)) *CredentialCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &CredentialCreateBulk{err: fmt.Errorf("calling to CredentialClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*CredentialCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &CredentialCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Credential.
func (c *CredentialClient) Update() *CredentialUpdate {
	mutation := newCredentialMutation(c.config, OpUpdate)
	return &CredentialUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *CredentialClient) UpdateOne(_m *Credential) *CredentialUpdateOne {
	mutation := newCredentialMutation(c.config, OpUpdateOne, withCredential(_m))
	return &CredentialUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *CredentialClient) UpdateOneID(id int) *CredentialUpdateOne {
	mutation := newCredentialMutation(c.config, OpUpdateOne, withCredentialID(id))
	return &CredentialUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Credential.
func (c *CredentialClient) Delete() *CredentialDelete {
	mutation := newCredentialMutation(c.config, OpDelete)
	return &CredentialDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *CredentialClient) DeleteOne(_m *Credential) *CredentialDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *CredentialClient) DeleteOneID(id int) *CredentialDeleteOne {
	builder := c.Delete().Where(credential.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &CredentialDeleteOne{builder}
}

// Query returns a query builder for Credential.
func (c *CredentialClient) Query() *CredentialQuery {
	return &CredentialQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeCredential},
		inters: c.Interceptors(),
	}
}

// Get returns a Credential entity by its id.
func (c *CredentialClient) Get(ctx context.Context, id int) (*Credential, error) {
	return c.Query().Where(credential.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *CredentialClient) GetX(ctx context.Context, id int) *Credential {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryTenant queries the tenant edge of a Credential.
func (c *CredentialClient) QueryTenant(_m *Credential) *TenantQuery {
	query := (&TenantClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(credential.Table, credential.FieldID, id),
			sqlgraph.To(tenant.Table, tenant.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, credential.TenantTable, credential.TenantColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryAsset queries the asset edge of a Credential.
func (c *CredentialClient) QueryAsset(_m *Credential) *AssetQuery {
	query := (&AssetClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(credential.Table, credential.FieldID, id),
			sqlgraph.To(asset.Table, asset.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, credential.AssetTable, credential.AssetColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryOneTimeLinks queries the one_time_links edge of a Credential.
func (c *CredentialClient) QueryOneTimeLinks(_m *Credential) *OneTimeLinkQuery {
	query := (&OneTimeLinkClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(credential.Table, credential.FieldID, id),
			sqlgraph.To(onetimelink.Table, onetimelink.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, credential.OneTimeLinksTable, credential.OneTimeLinksColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *CredentialClient) Hooks() []Hook {
	return c.hooks.Credential
}

// Interceptors returns the client interceptors.
func (c *CredentialClient) Interceptors() []Interceptor {
	return c.inters.Credential
}

func (c *CredentialClient) mutate(ctx context.Context, m *CredentialMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&CredentialCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&CredentialUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&CredentialUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&CredentialDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Credential mutation op: %q", m.Op())
	}
}

// DepartmentClient is a client for the Department schema.
type DepartmentClient struct {
	config
}

// NewDepartmentClient returns a client for the Department from the given config.
func NewDepartmentClient(c config) *DepartmentClient {
	return &DepartmentClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `department.Hooks(f(g(h())))`.
func (c *DepartmentClient) Use(hooks ...Hook) {
	c.hooks.Department = append(c.hooks.Department, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `department.Intercept(f(g(h())))`.
func (c *DepartmentClient) Intercept(interceptors ...Interceptor) {
	c.inters.Department = append(c.inters.Department, interceptors...)
}

// Create returns a builder for creating a Department entity.
func (c *DepartmentClient) Create() *DepartmentCreate {
	mutation := newDepartmentMutation(c.config, OpCreate)
	return &DepartmentCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Department entities.
func (c *DepartmentClient) CreateBulk(builders ...*DepartmentCreate) *DepartmentCreateBulk {
	return &DepartmentCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *DepartmentClient) MapCreateBulk(slice any, setFunc func(*DepartmentCreate, int)) *DepartmentCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &DepartmentCreateBulk{err: fmt.Errorf("calling to DepartmentClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*DepartmentCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &DepartmentCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Department.
func (c *DepartmentClient) Update() *DepartmentUpdate {
	mutation := newDepartmentMutation(c.config, OpUpdate)
	return &DepartmentUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *DepartmentClient) UpdateOne(_m *Department) *DepartmentUpdateOne {
	mutation := newDepartmentMutation(c.config, OpUpdateOne, withDepartment(_m))
	return &DepartmentUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *DepartmentClient) UpdateOneID(id int) *DepartmentUpdateOne {
	mutation := newDepartmentMutation(c.config, OpUpdateOne, withDepartmentID(id))
	return &DepartmentUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Department.
func (c *DepartmentClient) Delete() *DepartmentDelete {
	mutation := newDepartmentMutation(c.config, OpDelete)
	return &DepartmentDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *DepartmentClient) DeleteOne(_m *Department) *DepartmentDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *DepartmentClient) DeleteOneID(id int) *DepartmentDeleteOne {
	builder := c.Delete().Where(department.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &DepartmentDeleteOne{builder}
}

// Query returns a query builder for Department.
func (c *DepartmentClient) Query() *DepartmentQuery {
	return &DepartmentQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeDepartment},
		inters: c.Interceptors(),
	}
}

// Get returns a Department entity by its id.
func (c *DepartmentClient) Get(ctx context.Context, id int) (*Department, error) {
	return c.Query().Where(department.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *DepartmentClient) GetX(ctx context.Context, id int) *Department {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryParent queries the parent edge of a Department.
func (c *DepartmentClient) QueryParent(_m *Department) *DepartmentQuery {
	query := (&DepartmentClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(department.Table, department.FieldID, id),
			sqlgraph.To(department.Table, department.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, department.ParentTable, department.ParentColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryChildren queries the children edge of a Department.
func (c *DepartmentClient) QueryChildren(_m *Department) *DepartmentQuery {
	query := (&DepartmentClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(department.Table, department.FieldID, id),
			sqlgraph.To(department.Table, department.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, department.ChildrenTable, department.ChildrenColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryMembers queries the members edge of a Department.
func (c *DepartmentClient) QueryMembers(_m *Department) *EmployeeQuery {
	query := (&EmployeeClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(department.Table, department.FieldID, id),
			sqlgraph.To(employee.Table, employee.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, department.MembersTable, department.MembersColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryHead queries the head edge of a Department.
func (c *DepartmentClient) QueryHead(_m *Department) *EmployeeQuery {
	query := (&EmployeeClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(department.Table, department.FieldID, id),
			sqlgraph.To(employee.Table, employee.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, department.HeadTable, department.HeadColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTenant queries the tenant edge of a Department.
func (c *DepartmentClient) QueryTenant(_m *Department) *TenantQuery {
	query := (&TenantClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(department.Table, department.FieldID, id),
			sqlgraph.To(tenant.Table, tenant.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, department.TenantTable, department.TenantColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *DepartmentClient) Hooks() []Hook {
	return c.hooks.Department
}

// Interceptors returns the client interceptors.
func (c *DepartmentClient) Interceptors() []Interceptor {
	return c.inters.Department
}

func (c *DepartmentClient) mutate(ctx context.Context, m *DepartmentMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&DepartmentCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&DepartmentUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&DepartmentUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&DepartmentDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Department mutation op: %q", m.Op())
	}
}

// DetectionEventClient is a client for the DetectionEvent schema.
type DetectionEventClient struct {
	config
}

// NewDetectionEventClient returns a client for the DetectionEvent from the given config.
func NewDetectionEventClient(c config) *DetectionEventClient {
	return &DetectionEventClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `detectionevent.Hooks(f(g(h())))`.
func (c *DetectionEventClient) Use(hooks ...Hook) {
	c.hooks.DetectionEvent = append(c.hooks.DetectionEvent, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `detectionevent.Intercept(f(g(h())))`.
func (c *DetectionEventClient) Intercept(interceptors ...Interceptor) {
	c.inters.DetectionEvent = append(c.inters.DetectionEvent, interceptors...)
}

// Create returns a builder for creating a DetectionEvent entity.
func (c *DetectionEventClient) Create() *DetectionEventCreate {
	mutation := newDetectionEventMutation(c.config, OpCreate)
	return &DetectionEventCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of DetectionEvent entities.
func (c *DetectionEventClient) CreateBulk(builders ...*DetectionEventCreate) *DetectionEventCreateBulk {
	return &DetectionEventCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *DetectionEventClient) MapCreateBulk(slice any, setFunc func(*DetectionEventCreate, int)) *DetectionEventCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &DetectionEventCreateBulk{err: fmt.Errorf("calling to DetectionEventClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*DetectionEventCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &DetectionEventCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for DetectionEvent.
func (c *DetectionEventClient) Update() *DetectionEventUpdate {
	mutation := newDetectionEventMutation(c.config, OpUpdate)
	return &DetectionEventUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *DetectionEventClient) UpdateOne(_m *DetectionEvent) *DetectionEventUpdateOne {
	mutation := newDetectionEventMutation(c.config, OpUpdateOne, withDetectionEvent(_m))
	return &DetectionEventUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *DetectionEventClient) UpdateOneID(id int) *DetectionEventUpdateOne {
	mutation := newDetectionEventMutation(c.config, OpUpdateOne, withDetectionEventID(id))
	return &DetectionEventUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for DetectionEvent.
func (c *DetectionEventClient) Delete() *DetectionEventDelete {
	mutation := newDetectionEventMutation(c.config, OpDelete)
	return &DetectionEventDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *DetectionEventClient) DeleteOne(_m *DetectionEvent) *DetectionEventDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *DetectionEventClient) DeleteOneID(id int) *DetectionEventDeleteOne {
	builder := c.Delete().Where(detectionevent.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &DetectionEventDeleteOne{builder}
}

// Query returns a query builder for DetectionEvent.
func (c *DetectionEventClient) Query() *DetectionEventQuery {
	return &DetectionEventQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeDetectionEvent},
		inters: c.Interceptors(),
	}
}

// Get returns a DetectionEvent entity by its id.
func (c *DetectionEventClient) Get(ctx context.Context, id int) (*DetectionEvent, error) {
	return c.Query().Where(detectionevent.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *DetectionEventClient) GetX(ctx context.Context, id int) *DetectionEvent {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryCamera queries the camera edge of a DetectionEvent.
func (c *DetectionEventClient) QueryCamera(_m *DetectionEvent) *CameraQuery {
	query := (&CameraClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(detectionevent.Table, detectionevent.FieldID, id),
			sqlgraph.To(camera.Table, camera.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, detectionevent.CameraTable, detectionevent.CameraColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTenant queries the tenant edge of a DetectionEvent.
func (c *DetectionEventClient) QueryTenant(_m *DetectionEvent) *TenantQuery {
	query := (&TenantClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(detectionevent.Table, detectionevent.FieldID, id),
			sqlgraph.To(tenant.Table, tenant.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, detectionevent.TenantTable, detectionevent.TenantColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *DetectionEventClient) Hooks() []Hook {
	return c.hooks.DetectionEvent
}

// Interceptors returns the client interceptors.
func (c *DetectionEventClient) Interceptors() []Interceptor {
	return c.inters.DetectionEvent
}

func (c *DetectionEventClient) mutate(ctx context.Context, m *DetectionEventMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&DetectionEventCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&DetectionEventUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&DetectionEventUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&DetectionEventDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown DetectionEvent mutation op: %q", m.Op())
	}
}

// DiscoveryEntryClient is a client for the DiscoveryEntry schema.
type DiscoveryEntryClient struct {
	config
}

// NewDiscoveryEntryClient returns a client for the DiscoveryEntry from the given config.
func NewDiscoveryEntryClient(c config) *DiscoveryEntryClient {
	return &DiscoveryEntryClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `discoveryentry.Hooks(f(g(h())))`.
func (c *DiscoveryEntryClient) Use(hooks ...Hook) {
	c.hooks.DiscoveryEntry = append(c.hooks.DiscoveryEntry, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `discoveryentry.Intercept(f(g(h())))`.
func (c *DiscoveryEntryClient) Intercept(interceptors ...Interceptor) {
	c.inters.DiscoveryEntry = append(c.inters.DiscoveryEntry, interceptors...)
}

// Create returns a builder for creating a DiscoveryEntry entity.
func (c *DiscoveryEntryClient) Create() *DiscoveryEntryCreate {
	mutation := newDiscoveryEntryMutation(c.config, OpCreate)
	return &DiscoveryEntryCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of DiscoveryEntry entities.
func (c *DiscoveryEntryClient) CreateBulk(builders ...*DiscoveryEntryCreate) *DiscoveryEntryCreateBulk {
	return &DiscoveryEntryCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *DiscoveryEntryClient) MapCreateBulk(slice any, setFunc func(*DiscoveryEntryCreate, int)) *DiscoveryEntryCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &DiscoveryEntryCreateBulk{err: fmt.Errorf("calling to DiscoveryEntryClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*DiscoveryEntryCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &DiscoveryEntryCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for DiscoveryEntry.
func (c *DiscoveryEntryClient) Update() *DiscoveryEntryUpdate {
	mutation := newDiscoveryEntryMutation(c.config, OpUpdate)
	return &DiscoveryEntryUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *DiscoveryEntryClient) UpdateOne(_m *DiscoveryEntry) *DiscoveryEntryUpdateOne {
	mutation := newDiscoveryEntryMutation(c.config, OpUpdateOne, withDiscoveryEntry(_m))
	return &DiscoveryEntryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *DiscoveryEntryClient) UpdateOneID(id int) *DiscoveryEntryUpdateOne {
	mutation := newDiscoveryEntryMutation(c.config, OpUpdateOne, withDiscoveryEntryID(id))
	return &DiscoveryEntryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for DiscoveryEntry.
func (c *DiscoveryEntryClient) Delete() *DiscoveryEntryDelete {
	mutation := newDiscoveryEntryMutation(c.config, OpDelete)
	return &DiscoveryEntryDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *DiscoveryEntryClient) DeleteOne(_m *DiscoveryEntry) *DiscoveryEntryDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *DiscoveryEntryClient) DeleteOneID(id int) *DiscoveryEntryDeleteOne {
	builder := c.Delete().Where(discoveryentry.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &DiscoveryEntryDeleteOne{builder}
}

// Query returns a query builder for DiscoveryEntry.
func (c *DiscoveryEntryClient) Query() *DiscoveryEntryQuery {
	return &DiscoveryEntryQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeDiscoveryEntry},
		inters: c.Interceptors(),
	}
}

// Get returns a DiscoveryEntry entity by its id.
func (c *DiscoveryEntryClient) Get(ctx context.Context, id int) (*DiscoveryEntry, error) {
	return c.Query().Where(discoveryentry.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *DiscoveryEntryClient) GetX(ctx context.Context, id int) *DiscoveryEntry {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryTenant queries the tenant edge of a DiscoveryEntry.
func (c *DiscoveryEntryClient) QueryTenant(_m *DiscoveryEntry) *TenantQuery {
	query := (&TenantClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(discoveryentry.Table, discoveryentry.FieldID, id),
			sqlgraph.To(tenant.Table, tenant.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, discoveryentry.TenantTable, discoveryentry.TenantColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *DiscoveryEntryClient) Hooks() []Hook {
	return c.hooks.DiscoveryEntry
}

// Interceptors returns the client interceptors.
func (c *DiscoveryEntryClient) Interceptors() []Interceptor {
	return c.inters.DiscoveryEntry
}

func (c *DiscoveryEntryClient) mutate(ctx context.Context, m *DiscoveryEntryMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&DiscoveryEntryCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&DiscoveryEntryUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&DiscoveryEntryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&DiscoveryEntryDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown DiscoveryEntry mutation op: %q", m.Op())
	}
}

// EmployeeClient is a client for the Employee schema.
type EmployeeClient struct {
	config
}

// NewEmployeeClient returns a client for the Employee from the given config.
func NewEmployeeClient(c config) *EmployeeClient {
	return &EmployeeClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `employee.Hooks(f(g(h())))`.
func (c *EmployeeClient) Use(hooks ...Hook) {
	c.hooks.Employee = append(c.hooks.Employee, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `employee.Intercept(f(g(h())))`.
func (c *EmployeeClient) Intercept(interceptors ...Interceptor) {
	c.inters.Employee = append(c.inters.Employee, interceptors...)
}

// Create returns a builder for creating a Employee entity.
func (c *EmployeeClient) Create() *EmployeeCreate {
	mutation := newEmployeeMutation(c.config, OpCreate)
	return &EmployeeCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Employee entities.
func (c *EmployeeClient) CreateBulk(builders ...*EmployeeCreate) *EmployeeCreateBulk {
	return &EmployeeCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *EmployeeClient) MapCreateBulk(slice any, setFunc func(*EmployeeCreate, int)) *EmployeeCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &EmployeeCreateBulk{err: fmt.Errorf("calling to EmployeeClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*EmployeeCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &EmployeeCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Employee.
func (c *EmployeeClient) Update() *EmployeeUpdate {
	mutation := newEmployeeMutation(c.config, OpUpdate)
	return &EmployeeUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *EmployeeClient) UpdateOne(_m *Employee) *EmployeeUpdateOne {
	mutation := newEmployeeMutation(c.config, OpUpdateOne, withEmployee(_m))
	return &EmployeeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *EmployeeClient) UpdateOneID(id int) *EmployeeUpdateOne {
	mutation := newEmployeeMutation(c.config, OpUpdateOne, withEmployeeID(id))
	return &EmployeeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Employee.
func (c *EmployeeClient) Delete() *EmployeeDelete {
	mutation := newEmployeeMutation(c.config, OpDelete)
	return &EmployeeDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *EmployeeClient) DeleteOne(_m *Employee) *EmployeeDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *EmployeeClient) DeleteOneID(id int) *EmployeeDeleteOne {
	builder := c.Delete().Where(employee.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &EmployeeDeleteOne{builder}
}

// Query returns a query builder for Employee.
func (c *EmployeeClient) Query() *EmployeeQuery {
	return &EmployeeQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeEmployee},
		inters: c.Interceptors(),
	}
}

// Get returns a Employee entity by its id.
func (c *EmployeeClient) Get(ctx context.Context, id int) (*Employee, error) {
	return c.Query().Where(employee.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *EmployeeClient) GetX(ctx context.Context, id int) *Employee {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryTenant queries the tenant edge of a Employee.
func (c *EmployeeClient) QueryTenant(_m *Employee) *TenantQuery {
	query := (&TenantClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(employee.Table, employee.FieldID, id),
			sqlgraph.To(tenant.Table, tenant.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, employee.TenantTable, employee.TenantColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryDepartment queries the department edge of a Employee.
func (c *EmployeeClient) QueryDepartment(_m *Employee) *DepartmentQuery {
	query := (&DepartmentClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(employee.Table, employee.FieldID, id),
			sqlgraph.To(department.Table, department.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, employee.DepartmentTable, employee.DepartmentColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryManager queries the manager edge of a Employee.
func (c *EmployeeClient) QueryManager(_m *Employee) *EmployeeQuery {
	query := (&EmployeeClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(employee.Table, employee.FieldID, id),
			sqlgraph.To(employee.Table, employee.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, employee.ManagerTable, employee.ManagerColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QuerySubordinates queries the subordinates edge of a Employee.
func (c *EmployeeClient) QuerySubordinates(_m *Employee) *EmployeeQuery {
	query := (&EmployeeClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(employee.Table, employee.FieldID, id),
			sqlgraph.To(employee.Table, employee.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, employee.SubordinatesTable, employee.SubordinatesColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCompensationAgreements queries the compensation_agreements edge of a Employee.
func (c *EmployeeClient) QueryCompensationAgreements(_m *Employee) *CompensationAgreementQuery {
	query := (&CompensationAgreementClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(employee.Table, employee.FieldID, id),
			sqlgraph.To(compensationagreement.Table, compensationagreement.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, employee.CompensationAgreementsTable, employee.CompensationAgreementsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QuerySuccessionPlans queries the succession_plans edge of a Employee.
func (c *EmployeeClient) QuerySuccessionPlans(_m *Employee) *SuccessionMapQuery {
	query := (&SuccessionMapClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(employee.Table, employee.FieldID, id),
			sqlgraph.To(successionmap.Table, successionmap.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, employee.SuccessionPlansTable, employee.SuccessionPlansColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryBackupFor queries the backup_for edge of a Employee.
func (c *EmployeeClient) QueryBackupFor(_m *Employee) *SuccessionMapQuery {
	query := (&SuccessionMapClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(employee.Table, employee.FieldID, id),
			sqlgraph.To(successionmap.Table, successionmap.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, employee.BackupForTable, employee.BackupForColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryExpenseAccount queries the expense_account edge of a Employee.
func (c *EmployeeClient) QueryExpenseAccount(_m *Employee) *AccountQuery {
	query := (&AccountClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(employee.Table, employee.FieldID, id),
			sqlgraph.To(account.Table, account.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, employee.ExpenseAccountTable, employee.ExpenseAccountColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTimeOffRequests queries the time_off_requests edge of a Employee.
func (c *EmployeeClient) QueryTimeOffRequests(_m *Employee) *TimeOffRequestQuery {
	query := (&TimeOffRequestClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(employee.Table, employee.FieldID, id),
			sqlgraph.To(timeoffrequest.Table, timeoffrequest.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, employee.TimeOffRequestsTable, employee.TimeOffRequestsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryApprovedTimeOff queries the approved_time_off edge of a Employee.
func (c *EmployeeClient) QueryApprovedTimeOff(_m *Employee) *TimeOffRequestQuery {
	query := (&TimeOffRequestClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(employee.Table, employee.FieldID, id),
			sqlgraph.To(timeoffrequest.Table, timeoffrequest.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, employee.ApprovedTimeOffTable, employee.ApprovedTimeOffColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTimeOffBalances queries the time_off_balances edge of a Employee.
func (c *EmployeeClient) QueryTimeOffBalances(_m *Employee) *TimeOffBalanceQuery {
	query := (&TimeOffBalanceClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(employee.Table, employee.FieldID, id),
			sqlgraph.To(timeoffbalance.Table, timeoffbalance.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, employee.TimeOffBalancesTable, employee.TimeOffBalancesColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryPerformanceReviews queries the performance_reviews edge of a Employee.
func (c *EmployeeClient) QueryPerformanceReviews(_m *Employee) *PerformanceReviewQuery {
	query := (&PerformanceReviewClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(employee.Table, employee.FieldID, id),
			sqlgraph.To(performancereview.Table, performancereview.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, employee.PerformanceReviewsTable, employee.PerformanceReviewsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryConductedReviews queries the conducted_reviews edge of a Employee.
func (c *EmployeeClient) QueryConductedReviews(_m *Employee) *PerformanceReviewQuery {
	query := (&PerformanceReviewClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(employee.Table, employee.FieldID, id),
			sqlgraph.To(performancereview.Table, performancereview.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, employee.ConductedReviewsTable, employee.ConductedReviewsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryGoals queries the goals edge of a Employee.
func (c *EmployeeClient) QueryGoals(_m *Employee) *GoalQuery {
	query := (&GoalClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(employee.Table, employee.FieldID, id),
			sqlgraph.To(goal.Table, goal.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, employee.GoalsTable, employee.GoalsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *EmployeeClient) Hooks() []Hook {
	return c.hooks.Employee
}

// Interceptors returns the client interceptors.
func (c *EmployeeClient) Interceptors() []Interceptor {
	return c.inters.Employee
}

func (c *EmployeeClient) mutate(ctx context.Context, m *EmployeeMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&EmployeeCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&EmployeeUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&EmployeeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&EmployeeDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Employee mutation op: %q", m.Op())
	}
}

// GoalClient is a client for the Goal schema.
type GoalClient struct {
	config
}

// NewGoalClient returns a client for the Goal from the given config.
func NewGoalClient(c config) *GoalClient {
	return &GoalClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `goal.Hooks(f(g(h())))`.
func (c *GoalClient) Use(hooks ...Hook) {
	c.hooks.Goal = append(c.hooks.Goal, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `goal.Intercept(f(g(h())))`.
func (c *GoalClient) Intercept(interceptors ...Interceptor) {
	c.inters.Goal = append(c.inters.Goal, interceptors...)
}

// Create returns a builder for creating a Goal entity.
func (c *GoalClient) Create() *GoalCreate {
	mutation := newGoalMutation(c.config, OpCreate)
	return &GoalCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Goal entities.
func (c *GoalClient) CreateBulk(builders ...*GoalCreate) *GoalCreateBulk {
	return &GoalCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *GoalClient) MapCreateBulk(slice any, setFunc func(*GoalCreate, int)) *GoalCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &GoalCreateBulk{err: fmt.Errorf("calling to GoalClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*GoalCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &GoalCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Goal.
func (c *GoalClient) Update() *GoalUpdate {
	mutation := newGoalMutation(c.config, OpUpdate)
	return &GoalUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *GoalClient) UpdateOne(_m *Goal) *GoalUpdateOne {
	mutation := newGoalMutation(c.config, OpUpdateOne, withGoal(_m))
	return &GoalUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *GoalClient) UpdateOneID(id int) *GoalUpdateOne {
	mutation := newGoalMutation(c.config, OpUpdateOne, withGoalID(id))
	return &GoalUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Goal.
func (c *GoalClient) Delete() *GoalDelete {
	mutation := newGoalMutation(c.config, OpDelete)
	return &GoalDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *GoalClient) DeleteOne(_m *Goal) *GoalDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *GoalClient) DeleteOneID(id int) *GoalDeleteOne {
	builder := c.Delete().Where(goal.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &GoalDeleteOne{builder}
}

// Query returns a query builder for Goal.
func (c *GoalClient) Query() *GoalQuery {
	return &GoalQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeGoal},
		inters: c.Interceptors(),
	}
}

// Get returns a Goal entity by its id.
func (c *GoalClient) Get(ctx context.Context, id int) (*Goal, error) {
	return c.Query().Where(goal.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *GoalClient) GetX(ctx context.Context, id int) *Goal {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryTenant queries the tenant edge of a Goal.
func (c *GoalClient) QueryTenant(_m *Goal) *TenantQuery {
	query := (&TenantClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(goal.Table, goal.FieldID, id),
			sqlgraph.To(tenant.Table, tenant.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, goal.TenantTable, goal.TenantColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryEmployee queries the employee edge of a Goal.
func (c *GoalClient) QueryEmployee(_m *Goal) *EmployeeQuery {
	query := (&EmployeeClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(goal.Table, goal.FieldID, id),
			sqlgraph.To(employee.Table, employee.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, goal.EmployeeTable, goal.EmployeeColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *GoalClient) Hooks() []Hook {
	return c.hooks.Goal
}

// Interceptors returns the client interceptors.
func (c *GoalClient) Interceptors() []Interceptor {
	return c.inters.Goal
}

func (c *GoalClient) mutate(ctx context.Context, m *GoalMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&GoalCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&GoalUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&GoalUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&GoalDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Goal mutation op: %q", m.Op())
	}
}

// HealthScoreSnapshotClient is a client for the HealthScoreSnapshot schema.
type HealthScoreSnapshotClient struct {
	config
}

// NewHealthScoreSnapshotClient returns a client for the HealthScoreSnapshot from the given config.
func NewHealthScoreSnapshotClient(c config) *HealthScoreSnapshotClient {
	return &HealthScoreSnapshotClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `healthscoresnapshot.Hooks(f(g(h())))`.
func (c *HealthScoreSnapshotClient) Use(hooks ...Hook) {
	c.hooks.HealthScoreSnapshot = append(c.hooks.HealthScoreSnapshot, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `healthscoresnapshot.Intercept(f(g(h())))`.
func (c *HealthScoreSnapshotClient) Intercept(interceptors ...Interceptor) {
	c.inters.HealthScoreSnapshot = append(c.inters.HealthScoreSnapshot, interceptors...)
}

// Create returns a builder for creating a HealthScoreSnapshot entity.
func (c *HealthScoreSnapshotClient) Create() *HealthScoreSnapshotCreate {
	mutation := newHealthScoreSnapshotMutation(c.config, OpCreate)
	return &HealthScoreSnapshotCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of HealthScoreSnapshot entities.
func (c *HealthScoreSnapshotClient) CreateBulk(builders ...*HealthScoreSnapshotCreate) *HealthScoreSnapshotCreateBulk {
	return &HealthScoreSnapshotCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *HealthScoreSnapshotClient) MapCreateBulk(slice any, setFunc func(*HealthScoreSnapshotCreate, int)) *HealthScoreSnapshotCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &HealthScoreSnapshotCreateBulk{err: fmt.Errorf("calling to HealthScoreSnapshotClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*HealthScoreSnapshotCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &HealthScoreSnapshotCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for HealthScoreSnapshot.
func (c *HealthScoreSnapshotClient) Update() *HealthScoreSnapshotUpdate {
	mutation := newHealthScoreSnapshotMutation(c.config, OpUpdate)
	return &HealthScoreSnapshotUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *HealthScoreSnapshotClient) UpdateOne(_m *HealthScoreSnapshot) *HealthScoreSnapshotUpdateOne {
	mutation := newHealthScoreSnapshotMutation(c.config, OpUpdateOne, withHealthScoreSnapshot(_m))
	return &HealthScoreSnapshotUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *HealthScoreSnapshotClient) UpdateOneID(id int) *HealthScoreSnapshotUpdateOne {
	mutation := newHealthScoreSnapshotMutation(c.config, OpUpdateOne, withHealthScoreSnapshotID(id))
	return &HealthScoreSnapshotUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for HealthScoreSnapshot.
func (c *HealthScoreSnapshotClient) Delete() *HealthScoreSnapshotDelete {
	mutation := newHealthScoreSnapshotMutation(c.config, OpDelete)
	return &HealthScoreSnapshotDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *HealthScoreSnapshotClient) DeleteOne(_m *HealthScoreSnapshot) *HealthScoreSnapshotDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *HealthScoreSnapshotClient) DeleteOneID(id int) *HealthScoreSnapshotDeleteOne {
	builder := c.Delete().Where(healthscoresnapshot.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &HealthScoreSnapshotDeleteOne{builder}
}

// Query returns a query builder for HealthScoreSnapshot.
func (c *HealthScoreSnapshotClient) Query() *HealthScoreSnapshotQuery {
	return &HealthScoreSnapshotQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeHealthScoreSnapshot},
		inters: c.Interceptors(),
	}
}

// Get returns a HealthScoreSnapshot entity by its id.
func (c *HealthScoreSnapshotClient) Get(ctx context.Context, id int) (*HealthScoreSnapshot, error) {
	return c.Query().Where(healthscoresnapshot.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *HealthScoreSnapshotClient) GetX(ctx context.Context, id int) *HealthScoreSnapshot {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryTenant queries the tenant edge of a HealthScoreSnapshot.
func (c *HealthScoreSnapshotClient) QueryTenant(_m *HealthScoreSnapshot) *TenantQuery {
	query := (&TenantClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(healthscoresnapshot.Table, healthscoresnapshot.FieldID, id),
			sqlgraph.To(tenant.Table, tenant.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, healthscoresnapshot.TenantTable, healthscoresnapshot.TenantColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *HealthScoreSnapshotClient) Hooks() []Hook {
	return c.hooks.HealthScoreSnapshot
}

// Interceptors returns the client interceptors.
func (c *HealthScoreSnapshotClient) Interceptors() []Interceptor {
	return c.inters.HealthScoreSnapshot
}

func (c *HealthScoreSnapshotClient) mutate(ctx context.Context, m *HealthScoreSnapshotMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&HealthScoreSnapshotCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&HealthScoreSnapshotUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&HealthScoreSnapshotUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&HealthScoreSnapshotDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown HealthScoreSnapshot mutation op: %q", m.Op())
	}
}

// IVRFlowClient is a client for the IVRFlow schema.
type IVRFlowClient struct {
	config
}

// NewIVRFlowClient returns a client for the IVRFlow from the given config.
func NewIVRFlowClient(c config) *IVRFlowClient {
	return &IVRFlowClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `ivrflow.Hooks(f(g(h())))`.
func (c *IVRFlowClient) Use(hooks ...Hook) {
	c.hooks.IVRFlow = append(c.hooks.IVRFlow, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `ivrflow.Intercept(f(g(h())))`.
func (c *IVRFlowClient) Intercept(interceptors ...Interceptor) {
	c.inters.IVRFlow = append(c.inters.IVRFlow, interceptors...)
}

// Create returns a builder for creating a IVRFlow entity.
func (c *IVRFlowClient) Create() *IVRFlowCreate {
	mutation := newIVRFlowMutation(c.config, OpCreate)
	return &IVRFlowCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of IVRFlow entities.
func (c *IVRFlowClient) CreateBulk(builders ...*IVRFlowCreate) *IVRFlowCreateBulk {
	return &IVRFlowCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *IVRFlowClient) MapCreateBulk(slice any, setFunc func(*IVRFlowCreate, int)) *IVRFlowCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &IVRFlowCreateBulk{err: fmt.Errorf("calling to IVRFlowClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*IVRFlowCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &IVRFlowCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for IVRFlow.
func (c *IVRFlowClient) Update() *IVRFlowUpdate {
	mutation := newIVRFlowMutation(c.config, OpUpdate)
	return &IVRFlowUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *IVRFlowClient) UpdateOne(_m *IVRFlow) *IVRFlowUpdateOne {
	mutation := newIVRFlowMutation(c.config, OpUpdateOne, withIVRFlow(_m))
	return &IVRFlowUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *IVRFlowClient) UpdateOneID(id int) *IVRFlowUpdateOne {
	mutation := newIVRFlowMutation(c.config, OpUpdateOne, withIVRFlowID(id))
	return &IVRFlowUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for IVRFlow.
func (c *IVRFlowClient) Delete() *IVRFlowDelete {
	mutation := newIVRFlowMutation(c.config, OpDelete)
	return &IVRFlowDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *IVRFlowClient) DeleteOne(_m *IVRFlow) *IVRFlowDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *IVRFlowClient) DeleteOneID(id int) *IVRFlowDeleteOne {
	builder := c.Delete().Where(ivrflow.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &IVRFlowDeleteOne{builder}
}

// Query returns a query builder for IVRFlow.
func (c *IVRFlowClient) Query() *IVRFlowQuery {
	return &IVRFlowQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeIVRFlow},
		inters: c.Interceptors(),
	}
}

// Get returns a IVRFlow entity by its id.
func (c *IVRFlowClient) Get(ctx context.Context, id int) (*IVRFlow, error) {
	return c.Query().Where(ivrflow.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *IVRFlowClient) GetX(ctx context.Context, id int) *IVRFlow {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryTenant queries the tenant edge of a IVRFlow.
func (c *IVRFlowClient) QueryTenant(_m *IVRFlow) *TenantQuery {
	query := (&TenantClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(ivrflow.Table, ivrflow.FieldID, id),
			sqlgraph.To(tenant.Table, tenant.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, ivrflow.TenantTable, ivrflow.TenantColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *IVRFlowClient) Hooks() []Hook {
	return c.hooks.IVRFlow
}

// Interceptors returns the client interceptors.
func (c *IVRFlowClient) Interceptors() []Interceptor {
	return c.inters.IVRFlow
}

func (c *IVRFlowClient) mutate(ctx context.Context, m *IVRFlowMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&IVRFlowCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&IVRFlowUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&IVRFlowUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&IVRFlowDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown IVRFlow mutation op: %q", m.Op())
	}
}

// InventoryReservationClient is a client for the InventoryReservation schema.
type InventoryReservationClient struct {
	config
}

// NewInventoryReservationClient returns a client for the InventoryReservation from the given config.
func NewInventoryReservationClient(c config) *InventoryReservationClient {
	return &InventoryReservationClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `inventoryreservation.Hooks(f(g(h())))`.
func (c *InventoryReservationClient) Use(hooks ...Hook) {
	c.hooks.InventoryReservation = append(c.hooks.InventoryReservation, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `inventoryreservation.Intercept(f(g(h())))`.
func (c *InventoryReservationClient) Intercept(interceptors ...Interceptor) {
	c.inters.InventoryReservation = append(c.inters.InventoryReservation, interceptors...)
}

// Create returns a builder for creating a InventoryReservation entity.
func (c *InventoryReservationClient) Create() *InventoryReservationCreate {
	mutation := newInventoryReservationMutation(c.config, OpCreate)
	return &InventoryReservationCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of InventoryReservation entities.
func (c *InventoryReservationClient) CreateBulk(builders ...*InventoryReservationCreate) *InventoryReservationCreateBulk {
	return &InventoryReservationCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *InventoryReservationClient) MapCreateBulk(slice any, setFunc func(*InventoryReservationCreate, int)) *InventoryReservationCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &InventoryReservationCreateBulk{err: fmt.Errorf("calling to InventoryReservationClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*InventoryReservationCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &InventoryReservationCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for InventoryReservation.
func (c *InventoryReservationClient) Update() *InventoryReservationUpdate {
	mutation := newInventoryReservationMutation(c.config, OpUpdate)
	return &InventoryReservationUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *InventoryReservationClient) UpdateOne(_m *InventoryReservation) *InventoryReservationUpdateOne {
	mutation := newInventoryReservationMutation(c.config, OpUpdateOne, withInventoryReservation(_m))
	return &InventoryReservationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *InventoryReservationClient) UpdateOneID(id int) *InventoryReservationUpdateOne {
	mutation := newInventoryReservationMutation(c.config, OpUpdateOne, withInventoryReservationID(id))
	return &InventoryReservationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for InventoryReservation.
func (c *InventoryReservationClient) Delete() *InventoryReservationDelete {
	mutation := newInventoryReservationMutation(c.config, OpDelete)
	return &InventoryReservationDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *InventoryReservationClient) DeleteOne(_m *InventoryReservation) *InventoryReservationDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *InventoryReservationClient) DeleteOneID(id int) *InventoryReservationDeleteOne {
	builder := c.Delete().Where(inventoryreservation.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &InventoryReservationDeleteOne{builder}
}

// Query returns a query builder for InventoryReservation.
func (c *InventoryReservationClient) Query() *InventoryReservationQuery {
	return &InventoryReservationQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeInventoryReservation},
		inters: c.Interceptors(),
	}
}

// Get returns a InventoryReservation entity by its id.
func (c *InventoryReservationClient) Get(ctx context.Context, id int) (*InventoryReservation, error) {
	return c.Query().Where(inventoryreservation.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *InventoryReservationClient) GetX(ctx context.Context, id int) *InventoryReservation {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryProduct queries the product edge of a InventoryReservation.
func (c *InventoryReservationClient) QueryProduct(_m *InventoryReservation) *ProductQuery {
	query := (&ProductClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(inventoryreservation.Table, inventoryreservation.FieldID, id),
			sqlgraph.To(product.Table, product.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, inventoryreservation.ProductTable, inventoryreservation.ProductColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTenant queries the tenant edge of a InventoryReservation.
func (c *InventoryReservationClient) QueryTenant(_m *InventoryReservation) *TenantQuery {
	query := (&TenantClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(inventoryreservation.Table, inventoryreservation.FieldID, id),
			sqlgraph.To(tenant.Table, tenant.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, inventoryreservation.TenantTable, inventoryreservation.TenantColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *InventoryReservationClient) Hooks() []Hook {
	return c.hooks.InventoryReservation
}

// Interceptors returns the client interceptors.
func (c *InventoryReservationClient) Interceptors() []Interceptor {
	return c.inters.InventoryReservation
}

func (c *InventoryReservationClient) mutate(ctx context.Context, m *InventoryReservationMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&InventoryReservationCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&InventoryReservationUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&InventoryReservationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&InventoryReservationDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown InventoryReservation mutation op: %q", m.Op())
	}
}

// JobClient is a client for the Job schema.
type JobClient struct {
	config
}

// NewJobClient returns a client for the Job from the given config.
func NewJobClient(c config) *JobClient {
	return &JobClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `job.Hooks(f(g(h())))`.
func (c *JobClient) Use(hooks ...Hook) {
	c.hooks.Job = append(c.hooks.Job, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `job.Intercept(f(g(h())))`.
func (c *JobClient) Intercept(interceptors ...Interceptor) {
	c.inters.Job = append(c.inters.Job, interceptors...)
}

// Create returns a builder for creating a Job entity.
func (c *JobClient) Create() *JobCreate {
	mutation := newJobMutation(c.config, OpCreate)
	return &JobCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Job entities.
func (c *JobClient) CreateBulk(builders ...*JobCreate) *JobCreateBulk {
	return &JobCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *JobClient) MapCreateBulk(slice any, setFunc func(*JobCreate, int)) *JobCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &JobCreateBulk{err: fmt.Errorf("calling to JobClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*JobCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &JobCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Job.
func (c *JobClient) Update() *JobUpdate {
	mutation := newJobMutation(c.config, OpUpdate)
	return &JobUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *JobClient) UpdateOne(_m *Job) *JobUpdateOne {
	mutation := newJobMutation(c.config, OpUpdateOne, withJob(_m))
	return &JobUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *JobClient) UpdateOneID(id int) *JobUpdateOne {
	mutation := newJobMutation(c.config, OpUpdateOne, withJobID(id))
	return &JobUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Job.
func (c *JobClient) Delete() *JobDelete {
	mutation := newJobMutation(c.config, OpDelete)
	return &JobDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *JobClient) DeleteOne(_m *Job) *JobDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *JobClient) DeleteOneID(id int) *JobDeleteOne {
	builder := c.Delete().Where(job.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &JobDeleteOne{builder}
}

// Query returns a query builder for Job.
func (c *JobClient) Query() *JobQuery {
	return &JobQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeJob},
		inters: c.Interceptors(),
	}
}

// Get returns a Job entity by its id.
func (c *JobClient) Get(ctx context.Context, id int) (*Job, error) {
	return c.Query().Where(job.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *JobClient) GetX(ctx context.Context, id int) *Job {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryTenant queries the tenant edge of a Job.
func (c *JobClient) QueryTenant(_m *Job) *TenantQuery {
	query := (&TenantClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(job.Table, job.FieldID, id),
			sqlgraph.To(tenant.Table, tenant.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, job.TenantTable, job.TenantColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryScript queries the script edge of a Job.
func (c *JobClient) QueryScript(_m *Job) *ScriptQuery {
	query := (&ScriptClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(job.Table, job.FieldID, id),
			sqlgraph.To(script.Table, script.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, job.ScriptTable, job.ScriptColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryExecutions queries the executions edge of a Job.
func (c *JobClient) QueryExecutions(_m *Job) *JobExecutionQuery {
	query := (&JobExecutionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(job.Table, job.FieldID, id),
			sqlgraph.To(jobexecution.Table, jobexecution.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, job.ExecutionsTable, job.ExecutionsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *JobClient) Hooks() []Hook {
	return c.hooks.Job
}

// Interceptors returns the client interceptors.
func (c *JobClient) Interceptors() []Interceptor {
	return c.inters.Job
}

func (c *JobClient) mutate(ctx context.Context, m *JobMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&JobCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&JobUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&JobUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&JobDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Job mutation op: %q", m.Op())
	}
}

// JobExecutionClient is a client for the JobExecution schema.
type JobExecutionClient struct {
	config
}

// NewJobExecutionClient returns a client for the JobExecution from the given config.
func NewJobExecutionClient(c config) *JobExecutionClient {
	return &JobExecutionClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `jobexecution.Hooks(f(g(h())))`.
func (c *JobExecutionClient) Use(hooks ...Hook) {
	c.hooks.JobExecution = append(c.hooks.JobExecution, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `jobexecution.Intercept(f(g(h())))`.
func (c *JobExecutionClient) Intercept(interceptors ...Interceptor) {
	c.inters.JobExecution = append(c.inters.JobExecution, interceptors...)
}

// Create returns a builder for creating a JobExecution entity.
func (c *JobExecutionClient) Create() *JobExecutionCreate {
	mutation := newJobExecutionMutation(c.config, OpCreate)
	return &JobExecutionCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of JobExecution entities.
func (c *JobExecutionClient) CreateBulk(builders ...*JobExecutionCreate) *JobExecutionCreateBulk {
	return &JobExecutionCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *JobExecutionClient) MapCreateBulk(slice any, setFunc func(*JobExecutionCreate, int)) *JobExecutionCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &JobExecutionCreateBulk{err: fmt.Errorf("calling to JobExecutionClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*JobExecutionCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &JobExecutionCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for JobExecution.
func (c *JobExecutionClient) Update() *JobExecutionUpdate {
	mutation := newJobExecutionMutation(c.config, OpUpdate)
	return &JobExecutionUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *JobExecutionClient) UpdateOne(_m *JobExecution) *JobExecutionUpdateOne {
	mutation := newJobExecutionMutation(c.config, OpUpdateOne, withJobExecution(_m))
	return &JobExecutionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *JobExecutionClient) UpdateOneID(id int) *JobExecutionUpdateOne {
	mutation := newJobExecutionMutation(c.config, OpUpdateOne, withJobExecutionID(id))
	return &JobExecutionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for JobExecution.
func (c *JobExecutionClient) Delete() *JobExecutionDelete {
	mutation := newJobExecutionMutation(c.config, OpDelete)
	return &JobExecutionDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *JobExecutionClient) DeleteOne(_m *JobExecution) *JobExecutionDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *JobExecutionClient) DeleteOneID(id int) *JobExecutionDeleteOne {
	builder := c.Delete().Where(jobexecution.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &JobExecutionDeleteOne{builder}
}

// Query returns a query builder for JobExecution.
func (c *JobExecutionClient) Query() *JobExecutionQuery {
	return &JobExecutionQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeJobExecution},
		inters: c.Interceptors(),
	}
}

// Get returns a JobExecution entity by its id.
func (c *JobExecutionClient) Get(ctx context.Context, id int) (*JobExecution, error) {
	return c.Query().Where(jobexecution.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *JobExecutionClient) GetX(ctx context.Context, id int) *JobExecution {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryJob queries the job edge of a JobExecution.
func (c *JobExecutionClient) QueryJob(_m *JobExecution) *JobQuery {
	query := (&JobClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(jobexecution.Table, jobexecution.FieldID, id),
			sqlgraph.To(job.Table, job.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, jobexecution.JobTable, jobexecution.JobColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryAgent queries the agent edge of a JobExecution.
func (c *JobExecutionClient) QueryAgent(_m *JobExecution) *AgentQuery {
	query := (&AgentClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(jobexecution.Table, jobexecution.FieldID, id),
			sqlgraph.To(agent.Table, agent.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, jobexecution.AgentTable, jobexecution.AgentColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *JobExecutionClient) Hooks() []Hook {
	return c.hooks.JobExecution
}

// Interceptors returns the client interceptors.
func (c *JobExecutionClient) Interceptors() []Interceptor {
	return c.inters.JobExecution
}

func (c *JobExecutionClient) mutate(ctx context.Context, m *JobExecutionMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&JobExecutionCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&JobExecutionUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&JobExecutionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&JobExecutionDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown JobExecution mutation op: %q", m.Op())
	}
}

// JournalEntryClient is a client for the JournalEntry schema.
type JournalEntryClient struct {
	config
}

// NewJournalEntryClient returns a client for the JournalEntry from the given config.
func NewJournalEntryClient(c config) *JournalEntryClient {
	return &JournalEntryClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `journalentry.Hooks(f(g(h())))`.
func (c *JournalEntryClient) Use(hooks ...Hook) {
	c.hooks.JournalEntry = append(c.hooks.JournalEntry, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `journalentry.Intercept(f(g(h())))`.
func (c *JournalEntryClient) Intercept(interceptors ...Interceptor) {
	c.inters.JournalEntry = append(c.inters.JournalEntry, interceptors...)
}

// Create returns a builder for creating a JournalEntry entity.
func (c *JournalEntryClient) Create() *JournalEntryCreate {
	mutation := newJournalEntryMutation(c.config, OpCreate)
	return &JournalEntryCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of JournalEntry entities.
func (c *JournalEntryClient) CreateBulk(builders ...*JournalEntryCreate) *JournalEntryCreateBulk {
	return &JournalEntryCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *JournalEntryClient) MapCreateBulk(slice any, setFunc func(*JournalEntryCreate, int)) *JournalEntryCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &JournalEntryCreateBulk{err: fmt.Errorf("calling to JournalEntryClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*JournalEntryCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &JournalEntryCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for JournalEntry.
func (c *JournalEntryClient) Update() *JournalEntryUpdate {
	mutation := newJournalEntryMutation(c.config, OpUpdate)
	return &JournalEntryUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *JournalEntryClient) UpdateOne(_m *JournalEntry) *JournalEntryUpdateOne {
	mutation := newJournalEntryMutation(c.config, OpUpdateOne, withJournalEntry(_m))
	return &JournalEntryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *JournalEntryClient) UpdateOneID(id int) *JournalEntryUpdateOne {
	mutation := newJournalEntryMutation(c.config, OpUpdateOne, withJournalEntryID(id))
	return &JournalEntryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for JournalEntry.
func (c *JournalEntryClient) Delete() *JournalEntryDelete {
	mutation := newJournalEntryMutation(c.config, OpDelete)
	return &JournalEntryDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *JournalEntryClient) DeleteOne(_m *JournalEntry) *JournalEntryDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *JournalEntryClient) DeleteOneID(id int) *JournalEntryDeleteOne {
	builder := c.Delete().Where(journalentry.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &JournalEntryDeleteOne{builder}
}

// Query returns a query builder for JournalEntry.
func (c *JournalEntryClient) Query() *JournalEntryQuery {
	return &JournalEntryQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeJournalEntry},
		inters: c.Interceptors(),
	}
}

// Get returns a JournalEntry entity by its id.
func (c *JournalEntryClient) Get(ctx context.Context, id int) (*JournalEntry, error) {
	return c.Query().Where(journalentry.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *JournalEntryClient) GetX(ctx context.Context, id int) *JournalEntry {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryAccount queries the account edge of a JournalEntry.
func (c *JournalEntryClient) QueryAccount(_m *JournalEntry) *AccountQuery {
	query := (&AccountClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(journalentry.Table, journalentry.FieldID, id),
			sqlgraph.To(account.Table, account.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, journalentry.AccountTable, journalentry.AccountColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTenant queries the tenant edge of a JournalEntry.
func (c *JournalEntryClient) QueryTenant(_m *JournalEntry) *TenantQuery {
	query := (&TenantClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(journalentry.Table, journalentry.FieldID, id),
			sqlgraph.To(tenant.Table, tenant.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, journalentry.TenantTable, journalentry.TenantColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTransaction queries the transaction edge of a JournalEntry.
func (c *JournalEntryClient) QueryTransaction(_m *JournalEntry) *TransactionQuery {
	query := (&TransactionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(journalentry.Table, journalentry.FieldID, id),
			sqlgraph.To(transaction.Table, transaction.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, journalentry.TransactionTable, journalentry.TransactionColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryApprovedBy queries the approved_by edge of a JournalEntry.
func (c *JournalEntryClient) QueryApprovedBy(_m *JournalEntry) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(journalentry.Table, journalentry.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, journalentry.ApprovedByTable, journalentry.ApprovedByColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *JournalEntryClient) Hooks() []Hook {
	return c.hooks.JournalEntry
}

// Interceptors returns the client interceptors.
func (c *JournalEntryClient) Interceptors() []Interceptor {
	return c.inters.JournalEntry
}

func (c *JournalEntryClient) mutate(ctx context.Context, m *JournalEntryMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&JournalEntryCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&JournalEntryUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&JournalEntryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&JournalEntryDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown JournalEntry mutation op: %q", m.Op())
	}
}

// LedgerEntryClient is a client for the LedgerEntry schema.
type LedgerEntryClient struct {
	config
}

// NewLedgerEntryClient returns a client for the LedgerEntry from the given config.
func NewLedgerEntryClient(c config) *LedgerEntryClient {
	return &LedgerEntryClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `ledgerentry.Hooks(f(g(h())))`.
func (c *LedgerEntryClient) Use(hooks ...Hook) {
	c.hooks.LedgerEntry = append(c.hooks.LedgerEntry, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `ledgerentry.Intercept(f(g(h())))`.
func (c *LedgerEntryClient) Intercept(interceptors ...Interceptor) {
	c.inters.LedgerEntry = append(c.inters.LedgerEntry, interceptors...)
}

// Create returns a builder for creating a LedgerEntry entity.
func (c *LedgerEntryClient) Create() *LedgerEntryCreate {
	mutation := newLedgerEntryMutation(c.config, OpCreate)
	return &LedgerEntryCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of LedgerEntry entities.
func (c *LedgerEntryClient) CreateBulk(builders ...*LedgerEntryCreate) *LedgerEntryCreateBulk {
	return &LedgerEntryCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *LedgerEntryClient) MapCreateBulk(slice any, setFunc func(*LedgerEntryCreate, int)) *LedgerEntryCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &LedgerEntryCreateBulk{err: fmt.Errorf("calling to LedgerEntryClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*LedgerEntryCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &LedgerEntryCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for LedgerEntry.
func (c *LedgerEntryClient) Update() *LedgerEntryUpdate {
	mutation := newLedgerEntryMutation(c.config, OpUpdate)
	return &LedgerEntryUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *LedgerEntryClient) UpdateOne(_m *LedgerEntry) *LedgerEntryUpdateOne {
	mutation := newLedgerEntryMutation(c.config, OpUpdateOne, withLedgerEntry(_m))
	return &LedgerEntryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *LedgerEntryClient) UpdateOneID(id int) *LedgerEntryUpdateOne {
	mutation := newLedgerEntryMutation(c.config, OpUpdateOne, withLedgerEntryID(id))
	return &LedgerEntryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for LedgerEntry.
func (c *LedgerEntryClient) Delete() *LedgerEntryDelete {
	mutation := newLedgerEntryMutation(c.config, OpDelete)
	return &LedgerEntryDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *LedgerEntryClient) DeleteOne(_m *LedgerEntry) *LedgerEntryDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *LedgerEntryClient) DeleteOneID(id int) *LedgerEntryDeleteOne {
	builder := c.Delete().Where(ledgerentry.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &LedgerEntryDeleteOne{builder}
}

// Query returns a query builder for LedgerEntry.
func (c *LedgerEntryClient) Query() *LedgerEntryQuery {
	return &LedgerEntryQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeLedgerEntry},
		inters: c.Interceptors(),
	}
}

// Get returns a LedgerEntry entity by its id.
func (c *LedgerEntryClient) Get(ctx context.Context, id int) (*LedgerEntry, error) {
	return c.Query().Where(ledgerentry.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *LedgerEntryClient) GetX(ctx context.Context, id int) *LedgerEntry {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryTransaction queries the transaction edge of a LedgerEntry.
func (c *LedgerEntryClient) QueryTransaction(_m *LedgerEntry) *TransactionQuery {
	query := (&TransactionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(ledgerentry.Table, ledgerentry.FieldID, id),
			sqlgraph.To(transaction.Table, transaction.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, ledgerentry.TransactionTable, ledgerentry.TransactionColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryAccount queries the account edge of a LedgerEntry.
func (c *LedgerEntryClient) QueryAccount(_m *LedgerEntry) *AccountQuery {
	query := (&AccountClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(ledgerentry.Table, ledgerentry.FieldID, id),
			sqlgraph.To(account.Table, account.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, ledgerentry.AccountTable, ledgerentry.AccountColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTenant queries the tenant edge of a LedgerEntry.
func (c *LedgerEntryClient) QueryTenant(_m *LedgerEntry) *TenantQuery {
	query := (&TenantClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(ledgerentry.Table, ledgerentry.FieldID, id),
			sqlgraph.To(tenant.Table, tenant.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, ledgerentry.TenantTable, ledgerentry.TenantColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *LedgerEntryClient) Hooks() []Hook {
	return c.hooks.LedgerEntry
}

// Interceptors returns the client interceptors.
func (c *LedgerEntryClient) Interceptors() []Interceptor {
	return c.inters.LedgerEntry
}

func (c *LedgerEntryClient) mutate(ctx context.Context, m *LedgerEntryMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&LedgerEntryCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&LedgerEntryUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&LedgerEntryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&LedgerEntryDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown LedgerEntry mutation op: %q", m.Op())
	}
}

// NetworkBackupClient is a client for the NetworkBackup schema.
type NetworkBackupClient struct {
	config
}

// NewNetworkBackupClient returns a client for the NetworkBackup from the given config.
func NewNetworkBackupClient(c config) *NetworkBackupClient {
	return &NetworkBackupClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `networkbackup.Hooks(f(g(h())))`.
func (c *NetworkBackupClient) Use(hooks ...Hook) {
	c.hooks.NetworkBackup = append(c.hooks.NetworkBackup, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `networkbackup.Intercept(f(g(h())))`.
func (c *NetworkBackupClient) Intercept(interceptors ...Interceptor) {
	c.inters.NetworkBackup = append(c.inters.NetworkBackup, interceptors...)
}

// Create returns a builder for creating a NetworkBackup entity.
func (c *NetworkBackupClient) Create() *NetworkBackupCreate {
	mutation := newNetworkBackupMutation(c.config, OpCreate)
	return &NetworkBackupCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of NetworkBackup entities.
func (c *NetworkBackupClient) CreateBulk(builders ...*NetworkBackupCreate) *NetworkBackupCreateBulk {
	return &NetworkBackupCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *NetworkBackupClient) MapCreateBulk(slice any, setFunc func(*NetworkBackupCreate, int)) *NetworkBackupCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &NetworkBackupCreateBulk{err: fmt.Errorf("calling to NetworkBackupClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*NetworkBackupCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &NetworkBackupCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for NetworkBackup.
func (c *NetworkBackupClient) Update() *NetworkBackupUpdate {
	mutation := newNetworkBackupMutation(c.config, OpUpdate)
	return &NetworkBackupUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *NetworkBackupClient) UpdateOne(_m *NetworkBackup) *NetworkBackupUpdateOne {
	mutation := newNetworkBackupMutation(c.config, OpUpdateOne, withNetworkBackup(_m))
	return &NetworkBackupUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *NetworkBackupClient) UpdateOneID(id int) *NetworkBackupUpdateOne {
	mutation := newNetworkBackupMutation(c.config, OpUpdateOne, withNetworkBackupID(id))
	return &NetworkBackupUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for NetworkBackup.
func (c *NetworkBackupClient) Delete() *NetworkBackupDelete {
	mutation := newNetworkBackupMutation(c.config, OpDelete)
	return &NetworkBackupDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *NetworkBackupClient) DeleteOne(_m *NetworkBackup) *NetworkBackupDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *NetworkBackupClient) DeleteOneID(id int) *NetworkBackupDeleteOne {
	builder := c.Delete().Where(networkbackup.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &NetworkBackupDeleteOne{builder}
}

// Query returns a query builder for NetworkBackup.
func (c *NetworkBackupClient) Query() *NetworkBackupQuery {
	return &NetworkBackupQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeNetworkBackup},
		inters: c.Interceptors(),
	}
}

// Get returns a NetworkBackup entity by its id.
func (c *NetworkBackupClient) Get(ctx context.Context, id int) (*NetworkBackup, error) {
	return c.Query().Where(networkbackup.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *NetworkBackupClient) GetX(ctx context.Context, id int) *NetworkBackup {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryDevice queries the device edge of a NetworkBackup.
func (c *NetworkBackupClient) QueryDevice(_m *NetworkBackup) *NetworkDeviceQuery {
	query := (&NetworkDeviceClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(networkbackup.Table, networkbackup.FieldID, id),
			sqlgraph.To(networkdevice.Table, networkdevice.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, networkbackup.DeviceTable, networkbackup.DeviceColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTenant queries the tenant edge of a NetworkBackup.
func (c *NetworkBackupClient) QueryTenant(_m *NetworkBackup) *TenantQuery {
	query := (&TenantClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(networkbackup.Table, networkbackup.FieldID, id),
			sqlgraph.To(tenant.Table, tenant.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, networkbackup.TenantTable, networkbackup.TenantColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *NetworkBackupClient) Hooks() []Hook {
	return c.hooks.NetworkBackup
}

// Interceptors returns the client interceptors.
func (c *NetworkBackupClient) Interceptors() []Interceptor {
	return c.inters.NetworkBackup
}

func (c *NetworkBackupClient) mutate(ctx context.Context, m *NetworkBackupMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&NetworkBackupCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&NetworkBackupUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&NetworkBackupUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&NetworkBackupDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown NetworkBackup mutation op: %q", m.Op())
	}
}

// NetworkDeviceClient is a client for the NetworkDevice schema.
type NetworkDeviceClient struct {
	config
}

// NewNetworkDeviceClient returns a client for the NetworkDevice from the given config.
func NewNetworkDeviceClient(c config) *NetworkDeviceClient {
	return &NetworkDeviceClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `networkdevice.Hooks(f(g(h())))`.
func (c *NetworkDeviceClient) Use(hooks ...Hook) {
	c.hooks.NetworkDevice = append(c.hooks.NetworkDevice, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `networkdevice.Intercept(f(g(h())))`.
func (c *NetworkDeviceClient) Intercept(interceptors ...Interceptor) {
	c.inters.NetworkDevice = append(c.inters.NetworkDevice, interceptors...)
}

// Create returns a builder for creating a NetworkDevice entity.
func (c *NetworkDeviceClient) Create() *NetworkDeviceCreate {
	mutation := newNetworkDeviceMutation(c.config, OpCreate)
	return &NetworkDeviceCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of NetworkDevice entities.
func (c *NetworkDeviceClient) CreateBulk(builders ...*NetworkDeviceCreate) *NetworkDeviceCreateBulk {
	return &NetworkDeviceCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *NetworkDeviceClient) MapCreateBulk(slice any, setFunc func(*NetworkDeviceCreate, int)) *NetworkDeviceCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &NetworkDeviceCreateBulk{err: fmt.Errorf("calling to NetworkDeviceClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*NetworkDeviceCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &NetworkDeviceCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for NetworkDevice.
func (c *NetworkDeviceClient) Update() *NetworkDeviceUpdate {
	mutation := newNetworkDeviceMutation(c.config, OpUpdate)
	return &NetworkDeviceUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *NetworkDeviceClient) UpdateOne(_m *NetworkDevice) *NetworkDeviceUpdateOne {
	mutation := newNetworkDeviceMutation(c.config, OpUpdateOne, withNetworkDevice(_m))
	return &NetworkDeviceUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *NetworkDeviceClient) UpdateOneID(id int) *NetworkDeviceUpdateOne {
	mutation := newNetworkDeviceMutation(c.config, OpUpdateOne, withNetworkDeviceID(id))
	return &NetworkDeviceUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for NetworkDevice.
func (c *NetworkDeviceClient) Delete() *NetworkDeviceDelete {
	mutation := newNetworkDeviceMutation(c.config, OpDelete)
	return &NetworkDeviceDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *NetworkDeviceClient) DeleteOne(_m *NetworkDevice) *NetworkDeviceDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *NetworkDeviceClient) DeleteOneID(id int) *NetworkDeviceDeleteOne {
	builder := c.Delete().Where(networkdevice.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &NetworkDeviceDeleteOne{builder}
}

// Query returns a query builder for NetworkDevice.
func (c *NetworkDeviceClient) Query() *NetworkDeviceQuery {
	return &NetworkDeviceQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeNetworkDevice},
		inters: c.Interceptors(),
	}
}

// Get returns a NetworkDevice entity by its id.
func (c *NetworkDeviceClient) Get(ctx context.Context, id int) (*NetworkDevice, error) {
	return c.Query().Where(networkdevice.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *NetworkDeviceClient) GetX(ctx context.Context, id int) *NetworkDevice {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryPorts queries the ports edge of a NetworkDevice.
func (c *NetworkDeviceClient) QueryPorts(_m *NetworkDevice) *NetworkPortQuery {
	query := (&NetworkPortClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(networkdevice.Table, networkdevice.FieldID, id),
			sqlgraph.To(networkport.Table, networkport.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, networkdevice.PortsTable, networkdevice.PortsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryBackups queries the backups edge of a NetworkDevice.
func (c *NetworkDeviceClient) QueryBackups(_m *NetworkDevice) *NetworkBackupQuery {
	query := (&NetworkBackupClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(networkdevice.Table, networkdevice.FieldID, id),
			sqlgraph.To(networkbackup.Table, networkbackup.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, networkdevice.BackupsTable, networkdevice.BackupsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTenant queries the tenant edge of a NetworkDevice.
func (c *NetworkDeviceClient) QueryTenant(_m *NetworkDevice) *TenantQuery {
	query := (&TenantClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(networkdevice.Table, networkdevice.FieldID, id),
			sqlgraph.To(tenant.Table, tenant.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, networkdevice.TenantTable, networkdevice.TenantColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *NetworkDeviceClient) Hooks() []Hook {
	return c.hooks.NetworkDevice
}

// Interceptors returns the client interceptors.
func (c *NetworkDeviceClient) Interceptors() []Interceptor {
	return c.inters.NetworkDevice
}

func (c *NetworkDeviceClient) mutate(ctx context.Context, m *NetworkDeviceMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&NetworkDeviceCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&NetworkDeviceUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&NetworkDeviceUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&NetworkDeviceDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown NetworkDevice mutation op: %q", m.Op())
	}
}

// NetworkLinkClient is a client for the NetworkLink schema.
type NetworkLinkClient struct {
	config
}

// NewNetworkLinkClient returns a client for the NetworkLink from the given config.
func NewNetworkLinkClient(c config) *NetworkLinkClient {
	return &NetworkLinkClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `networklink.Hooks(f(g(h())))`.
func (c *NetworkLinkClient) Use(hooks ...Hook) {
	c.hooks.NetworkLink = append(c.hooks.NetworkLink, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `networklink.Intercept(f(g(h())))`.
func (c *NetworkLinkClient) Intercept(interceptors ...Interceptor) {
	c.inters.NetworkLink = append(c.inters.NetworkLink, interceptors...)
}

// Create returns a builder for creating a NetworkLink entity.
func (c *NetworkLinkClient) Create() *NetworkLinkCreate {
	mutation := newNetworkLinkMutation(c.config, OpCreate)
	return &NetworkLinkCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of NetworkLink entities.
func (c *NetworkLinkClient) CreateBulk(builders ...*NetworkLinkCreate) *NetworkLinkCreateBulk {
	return &NetworkLinkCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *NetworkLinkClient) MapCreateBulk(slice any, setFunc func(*NetworkLinkCreate, int)) *NetworkLinkCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &NetworkLinkCreateBulk{err: fmt.Errorf("calling to NetworkLinkClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*NetworkLinkCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &NetworkLinkCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for NetworkLink.
func (c *NetworkLinkClient) Update() *NetworkLinkUpdate {
	mutation := newNetworkLinkMutation(c.config, OpUpdate)
	return &NetworkLinkUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *NetworkLinkClient) UpdateOne(_m *NetworkLink) *NetworkLinkUpdateOne {
	mutation := newNetworkLinkMutation(c.config, OpUpdateOne, withNetworkLink(_m))
	return &NetworkLinkUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *NetworkLinkClient) UpdateOneID(id int) *NetworkLinkUpdateOne {
	mutation := newNetworkLinkMutation(c.config, OpUpdateOne, withNetworkLinkID(id))
	return &NetworkLinkUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for NetworkLink.
func (c *NetworkLinkClient) Delete() *NetworkLinkDelete {
	mutation := newNetworkLinkMutation(c.config, OpDelete)
	return &NetworkLinkDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *NetworkLinkClient) DeleteOne(_m *NetworkLink) *NetworkLinkDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *NetworkLinkClient) DeleteOneID(id int) *NetworkLinkDeleteOne {
	builder := c.Delete().Where(networklink.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &NetworkLinkDeleteOne{builder}
}

// Query returns a query builder for NetworkLink.
func (c *NetworkLinkClient) Query() *NetworkLinkQuery {
	return &NetworkLinkQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeNetworkLink},
		inters: c.Interceptors(),
	}
}

// Get returns a NetworkLink entity by its id.
func (c *NetworkLinkClient) Get(ctx context.Context, id int) (*NetworkLink, error) {
	return c.Query().Where(networklink.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *NetworkLinkClient) GetX(ctx context.Context, id int) *NetworkLink {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QuerySourcePort queries the source_port edge of a NetworkLink.
func (c *NetworkLinkClient) QuerySourcePort(_m *NetworkLink) *NetworkPortQuery {
	query := (&NetworkPortClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(networklink.Table, networklink.FieldID, id),
			sqlgraph.To(networkport.Table, networkport.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, networklink.SourcePortTable, networklink.SourcePortColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTargetPort queries the target_port edge of a NetworkLink.
func (c *NetworkLinkClient) QueryTargetPort(_m *NetworkLink) *NetworkPortQuery {
	query := (&NetworkPortClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(networklink.Table, networklink.FieldID, id),
			sqlgraph.To(networkport.Table, networkport.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, networklink.TargetPortTable, networklink.TargetPortColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTenant queries the tenant edge of a NetworkLink.
func (c *NetworkLinkClient) QueryTenant(_m *NetworkLink) *TenantQuery {
	query := (&TenantClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(networklink.Table, networklink.FieldID, id),
			sqlgraph.To(tenant.Table, tenant.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, networklink.TenantTable, networklink.TenantColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *NetworkLinkClient) Hooks() []Hook {
	return c.hooks.NetworkLink
}

// Interceptors returns the client interceptors.
func (c *NetworkLinkClient) Interceptors() []Interceptor {
	return c.inters.NetworkLink
}

func (c *NetworkLinkClient) mutate(ctx context.Context, m *NetworkLinkMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&NetworkLinkCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&NetworkLinkUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&NetworkLinkUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&NetworkLinkDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown NetworkLink mutation op: %q", m.Op())
	}
}

// NetworkPortClient is a client for the NetworkPort schema.
type NetworkPortClient struct {
	config
}

// NewNetworkPortClient returns a client for the NetworkPort from the given config.
func NewNetworkPortClient(c config) *NetworkPortClient {
	return &NetworkPortClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `networkport.Hooks(f(g(h())))`.
func (c *NetworkPortClient) Use(hooks ...Hook) {
	c.hooks.NetworkPort = append(c.hooks.NetworkPort, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `networkport.Intercept(f(g(h())))`.
func (c *NetworkPortClient) Intercept(interceptors ...Interceptor) {
	c.inters.NetworkPort = append(c.inters.NetworkPort, interceptors...)
}

// Create returns a builder for creating a NetworkPort entity.
func (c *NetworkPortClient) Create() *NetworkPortCreate {
	mutation := newNetworkPortMutation(c.config, OpCreate)
	return &NetworkPortCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of NetworkPort entities.
func (c *NetworkPortClient) CreateBulk(builders ...*NetworkPortCreate) *NetworkPortCreateBulk {
	return &NetworkPortCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *NetworkPortClient) MapCreateBulk(slice any, setFunc func(*NetworkPortCreate, int)) *NetworkPortCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &NetworkPortCreateBulk{err: fmt.Errorf("calling to NetworkPortClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*NetworkPortCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &NetworkPortCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for NetworkPort.
func (c *NetworkPortClient) Update() *NetworkPortUpdate {
	mutation := newNetworkPortMutation(c.config, OpUpdate)
	return &NetworkPortUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *NetworkPortClient) UpdateOne(_m *NetworkPort) *NetworkPortUpdateOne {
	mutation := newNetworkPortMutation(c.config, OpUpdateOne, withNetworkPort(_m))
	return &NetworkPortUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *NetworkPortClient) UpdateOneID(id int) *NetworkPortUpdateOne {
	mutation := newNetworkPortMutation(c.config, OpUpdateOne, withNetworkPortID(id))
	return &NetworkPortUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for NetworkPort.
func (c *NetworkPortClient) Delete() *NetworkPortDelete {
	mutation := newNetworkPortMutation(c.config, OpDelete)
	return &NetworkPortDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *NetworkPortClient) DeleteOne(_m *NetworkPort) *NetworkPortDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *NetworkPortClient) DeleteOneID(id int) *NetworkPortDeleteOne {
	builder := c.Delete().Where(networkport.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &NetworkPortDeleteOne{builder}
}

// Query returns a query builder for NetworkPort.
func (c *NetworkPortClient) Query() *NetworkPortQuery {
	return &NetworkPortQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeNetworkPort},
		inters: c.Interceptors(),
	}
}

// Get returns a NetworkPort entity by its id.
func (c *NetworkPortClient) Get(ctx context.Context, id int) (*NetworkPort, error) {
	return c.Query().Where(networkport.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *NetworkPortClient) GetX(ctx context.Context, id int) *NetworkPort {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryDevice queries the device edge of a NetworkPort.
func (c *NetworkPortClient) QueryDevice(_m *NetworkPort) *NetworkDeviceQuery {
	query := (&NetworkDeviceClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(networkport.Table, networkport.FieldID, id),
			sqlgraph.To(networkdevice.Table, networkdevice.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, networkport.DeviceTable, networkport.DeviceColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryConnectedTo queries the connected_to edge of a NetworkPort.
func (c *NetworkPortClient) QueryConnectedTo(_m *NetworkPort) *NetworkLinkQuery {
	query := (&NetworkLinkClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(networkport.Table, networkport.FieldID, id),
			sqlgraph.To(networklink.Table, networklink.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, networkport.ConnectedToTable, networkport.ConnectedToColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTenant queries the tenant edge of a NetworkPort.
func (c *NetworkPortClient) QueryTenant(_m *NetworkPort) *TenantQuery {
	query := (&TenantClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(networkport.Table, networkport.FieldID, id),
			sqlgraph.To(tenant.Table, tenant.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, networkport.TenantTable, networkport.TenantColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *NetworkPortClient) Hooks() []Hook {
	return c.hooks.NetworkPort
}

// Interceptors returns the client interceptors.
func (c *NetworkPortClient) Interceptors() []Interceptor {
	return c.inters.NetworkPort
}

func (c *NetworkPortClient) mutate(ctx context.Context, m *NetworkPortMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&NetworkPortCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&NetworkPortUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&NetworkPortUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&NetworkPortDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown NetworkPort mutation op: %q", m.Op())
	}
}

// NexusAuditClient is a client for the NexusAudit schema.
type NexusAuditClient struct {
	config
}

// NewNexusAuditClient returns a client for the NexusAudit from the given config.
func NewNexusAuditClient(c config) *NexusAuditClient {
	return &NexusAuditClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `nexusaudit.Hooks(f(g(h())))`.
func (c *NexusAuditClient) Use(hooks ...Hook) {
	c.hooks.NexusAudit = append(c.hooks.NexusAudit, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `nexusaudit.Intercept(f(g(h())))`.
func (c *NexusAuditClient) Intercept(interceptors ...Interceptor) {
	c.inters.NexusAudit = append(c.inters.NexusAudit, interceptors...)
}

// Create returns a builder for creating a NexusAudit entity.
func (c *NexusAuditClient) Create() *NexusAuditCreate {
	mutation := newNexusAuditMutation(c.config, OpCreate)
	return &NexusAuditCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of NexusAudit entities.
func (c *NexusAuditClient) CreateBulk(builders ...*NexusAuditCreate) *NexusAuditCreateBulk {
	return &NexusAuditCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *NexusAuditClient) MapCreateBulk(slice any, setFunc func(*NexusAuditCreate, int)) *NexusAuditCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &NexusAuditCreateBulk{err: fmt.Errorf("calling to NexusAuditClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*NexusAuditCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &NexusAuditCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for NexusAudit.
func (c *NexusAuditClient) Update() *NexusAuditUpdate {
	mutation := newNexusAuditMutation(c.config, OpUpdate)
	return &NexusAuditUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *NexusAuditClient) UpdateOne(_m *NexusAudit) *NexusAuditUpdateOne {
	mutation := newNexusAuditMutation(c.config, OpUpdateOne, withNexusAudit(_m))
	return &NexusAuditUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *NexusAuditClient) UpdateOneID(id int) *NexusAuditUpdateOne {
	mutation := newNexusAuditMutation(c.config, OpUpdateOne, withNexusAuditID(id))
	return &NexusAuditUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for NexusAudit.
func (c *NexusAuditClient) Delete() *NexusAuditDelete {
	mutation := newNexusAuditMutation(c.config, OpDelete)
	return &NexusAuditDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *NexusAuditClient) DeleteOne(_m *NexusAudit) *NexusAuditDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *NexusAuditClient) DeleteOneID(id int) *NexusAuditDeleteOne {
	builder := c.Delete().Where(nexusaudit.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &NexusAuditDeleteOne{builder}
}

// Query returns a query builder for NexusAudit.
func (c *NexusAuditClient) Query() *NexusAuditQuery {
	return &NexusAuditQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeNexusAudit},
		inters: c.Interceptors(),
	}
}

// Get returns a NexusAudit entity by its id.
func (c *NexusAuditClient) Get(ctx context.Context, id int) (*NexusAudit, error) {
	return c.Query().Where(nexusaudit.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *NexusAuditClient) GetX(ctx context.Context, id int) *NexusAudit {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryTenant queries the tenant edge of a NexusAudit.
func (c *NexusAuditClient) QueryTenant(_m *NexusAudit) *TenantQuery {
	query := (&TenantClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(nexusaudit.Table, nexusaudit.FieldID, id),
			sqlgraph.To(tenant.Table, tenant.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, nexusaudit.TenantTable, nexusaudit.TenantColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *NexusAuditClient) Hooks() []Hook {
	return c.hooks.NexusAudit
}

// Interceptors returns the client interceptors.
func (c *NexusAuditClient) Interceptors() []Interceptor {
	return c.inters.NexusAudit
}

func (c *NexusAuditClient) mutate(ctx context.Context, m *NexusAuditMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&NexusAuditCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&NexusAuditUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&NexusAuditUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&NexusAuditDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown NexusAudit mutation op: %q", m.Op())
	}
}

// OneTimeLinkClient is a client for the OneTimeLink schema.
type OneTimeLinkClient struct {
	config
}

// NewOneTimeLinkClient returns a client for the OneTimeLink from the given config.
func NewOneTimeLinkClient(c config) *OneTimeLinkClient {
	return &OneTimeLinkClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `onetimelink.Hooks(f(g(h())))`.
func (c *OneTimeLinkClient) Use(hooks ...Hook) {
	c.hooks.OneTimeLink = append(c.hooks.OneTimeLink, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `onetimelink.Intercept(f(g(h())))`.
func (c *OneTimeLinkClient) Intercept(interceptors ...Interceptor) {
	c.inters.OneTimeLink = append(c.inters.OneTimeLink, interceptors...)
}

// Create returns a builder for creating a OneTimeLink entity.
func (c *OneTimeLinkClient) Create() *OneTimeLinkCreate {
	mutation := newOneTimeLinkMutation(c.config, OpCreate)
	return &OneTimeLinkCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of OneTimeLink entities.
func (c *OneTimeLinkClient) CreateBulk(builders ...*OneTimeLinkCreate) *OneTimeLinkCreateBulk {
	return &OneTimeLinkCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *OneTimeLinkClient) MapCreateBulk(slice any, setFunc func(*OneTimeLinkCreate, int)) *OneTimeLinkCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &OneTimeLinkCreateBulk{err: fmt.Errorf("calling to OneTimeLinkClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*OneTimeLinkCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &OneTimeLinkCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for OneTimeLink.
func (c *OneTimeLinkClient) Update() *OneTimeLinkUpdate {
	mutation := newOneTimeLinkMutation(c.config, OpUpdate)
	return &OneTimeLinkUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *OneTimeLinkClient) UpdateOne(_m *OneTimeLink) *OneTimeLinkUpdateOne {
	mutation := newOneTimeLinkMutation(c.config, OpUpdateOne, withOneTimeLink(_m))
	return &OneTimeLinkUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *OneTimeLinkClient) UpdateOneID(id int) *OneTimeLinkUpdateOne {
	mutation := newOneTimeLinkMutation(c.config, OpUpdateOne, withOneTimeLinkID(id))
	return &OneTimeLinkUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for OneTimeLink.
func (c *OneTimeLinkClient) Delete() *OneTimeLinkDelete {
	mutation := newOneTimeLinkMutation(c.config, OpDelete)
	return &OneTimeLinkDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *OneTimeLinkClient) DeleteOne(_m *OneTimeLink) *OneTimeLinkDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *OneTimeLinkClient) DeleteOneID(id int) *OneTimeLinkDeleteOne {
	builder := c.Delete().Where(onetimelink.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &OneTimeLinkDeleteOne{builder}
}

// Query returns a query builder for OneTimeLink.
func (c *OneTimeLinkClient) Query() *OneTimeLinkQuery {
	return &OneTimeLinkQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeOneTimeLink},
		inters: c.Interceptors(),
	}
}

// Get returns a OneTimeLink entity by its id.
func (c *OneTimeLinkClient) Get(ctx context.Context, id int) (*OneTimeLink, error) {
	return c.Query().Where(onetimelink.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *OneTimeLinkClient) GetX(ctx context.Context, id int) *OneTimeLink {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryCredential queries the credential edge of a OneTimeLink.
func (c *OneTimeLinkClient) QueryCredential(_m *OneTimeLink) *CredentialQuery {
	query := (&CredentialClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(onetimelink.Table, onetimelink.FieldID, id),
			sqlgraph.To(credential.Table, credential.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, onetimelink.CredentialTable, onetimelink.CredentialColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTenant queries the tenant edge of a OneTimeLink.
func (c *OneTimeLinkClient) QueryTenant(_m *OneTimeLink) *TenantQuery {
	query := (&TenantClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(onetimelink.Table, onetimelink.FieldID, id),
			sqlgraph.To(tenant.Table, tenant.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, onetimelink.TenantTable, onetimelink.TenantColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *OneTimeLinkClient) Hooks() []Hook {
	return c.hooks.OneTimeLink
}

// Interceptors returns the client interceptors.
func (c *OneTimeLinkClient) Interceptors() []Interceptor {
	return c.inters.OneTimeLink
}

func (c *OneTimeLinkClient) mutate(ctx context.Context, m *OneTimeLinkMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&OneTimeLinkCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&OneTimeLinkUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&OneTimeLinkUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&OneTimeLinkDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown OneTimeLink mutation op: %q", m.Op())
	}
}

// PerformanceReviewClient is a client for the PerformanceReview schema.
type PerformanceReviewClient struct {
	config
}

// NewPerformanceReviewClient returns a client for the PerformanceReview from the given config.
func NewPerformanceReviewClient(c config) *PerformanceReviewClient {
	return &PerformanceReviewClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `performancereview.Hooks(f(g(h())))`.
func (c *PerformanceReviewClient) Use(hooks ...Hook) {
	c.hooks.PerformanceReview = append(c.hooks.PerformanceReview, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `performancereview.Intercept(f(g(h())))`.
func (c *PerformanceReviewClient) Intercept(interceptors ...Interceptor) {
	c.inters.PerformanceReview = append(c.inters.PerformanceReview, interceptors...)
}

// Create returns a builder for creating a PerformanceReview entity.
func (c *PerformanceReviewClient) Create() *PerformanceReviewCreate {
	mutation := newPerformanceReviewMutation(c.config, OpCreate)
	return &PerformanceReviewCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of PerformanceReview entities.
func (c *PerformanceReviewClient) CreateBulk(builders ...*PerformanceReviewCreate) *PerformanceReviewCreateBulk {
	return &PerformanceReviewCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *PerformanceReviewClient) MapCreateBulk(slice any, setFunc func(*PerformanceReviewCreate, int)) *PerformanceReviewCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &PerformanceReviewCreateBulk{err: fmt.Errorf("calling to PerformanceReviewClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*PerformanceReviewCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &PerformanceReviewCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for PerformanceReview.
func (c *PerformanceReviewClient) Update() *PerformanceReviewUpdate {
	mutation := newPerformanceReviewMutation(c.config, OpUpdate)
	return &PerformanceReviewUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *PerformanceReviewClient) UpdateOne(_m *PerformanceReview) *PerformanceReviewUpdateOne {
	mutation := newPerformanceReviewMutation(c.config, OpUpdateOne, withPerformanceReview(_m))
	return &PerformanceReviewUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *PerformanceReviewClient) UpdateOneID(id int) *PerformanceReviewUpdateOne {
	mutation := newPerformanceReviewMutation(c.config, OpUpdateOne, withPerformanceReviewID(id))
	return &PerformanceReviewUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for PerformanceReview.
func (c *PerformanceReviewClient) Delete() *PerformanceReviewDelete {
	mutation := newPerformanceReviewMutation(c.config, OpDelete)
	return &PerformanceReviewDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *PerformanceReviewClient) DeleteOne(_m *PerformanceReview) *PerformanceReviewDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *PerformanceReviewClient) DeleteOneID(id int) *PerformanceReviewDeleteOne {
	builder := c.Delete().Where(performancereview.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &PerformanceReviewDeleteOne{builder}
}

// Query returns a query builder for PerformanceReview.
func (c *PerformanceReviewClient) Query() *PerformanceReviewQuery {
	return &PerformanceReviewQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypePerformanceReview},
		inters: c.Interceptors(),
	}
}

// Get returns a PerformanceReview entity by its id.
func (c *PerformanceReviewClient) Get(ctx context.Context, id int) (*PerformanceReview, error) {
	return c.Query().Where(performancereview.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *PerformanceReviewClient) GetX(ctx context.Context, id int) *PerformanceReview {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryTenant queries the tenant edge of a PerformanceReview.
func (c *PerformanceReviewClient) QueryTenant(_m *PerformanceReview) *TenantQuery {
	query := (&TenantClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(performancereview.Table, performancereview.FieldID, id),
			sqlgraph.To(tenant.Table, tenant.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, performancereview.TenantTable, performancereview.TenantColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryEmployee queries the employee edge of a PerformanceReview.
func (c *PerformanceReviewClient) QueryEmployee(_m *PerformanceReview) *EmployeeQuery {
	query := (&EmployeeClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(performancereview.Table, performancereview.FieldID, id),
			sqlgraph.To(employee.Table, employee.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, performancereview.EmployeeTable, performancereview.EmployeeColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryReviewer queries the reviewer edge of a PerformanceReview.
func (c *PerformanceReviewClient) QueryReviewer(_m *PerformanceReview) *EmployeeQuery {
	query := (&EmployeeClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(performancereview.Table, performancereview.FieldID, id),
			sqlgraph.To(employee.Table, employee.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, performancereview.ReviewerTable, performancereview.ReviewerColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCycle queries the cycle edge of a PerformanceReview.
func (c *PerformanceReviewClient) QueryCycle(_m *PerformanceReview) *ReviewCycleQuery {
	query := (&ReviewCycleClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(performancereview.Table, performancereview.FieldID, id),
			sqlgraph.To(reviewcycle.Table, reviewcycle.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, performancereview.CycleTable, performancereview.CycleColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *PerformanceReviewClient) Hooks() []Hook {
	return c.hooks.PerformanceReview
}

// Interceptors returns the client interceptors.
func (c *PerformanceReviewClient) Interceptors() []Interceptor {
	return c.inters.PerformanceReview
}

func (c *PerformanceReviewClient) mutate(ctx context.Context, m *PerformanceReviewMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&PerformanceReviewCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&PerformanceReviewUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&PerformanceReviewUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&PerformanceReviewDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown PerformanceReview mutation op: %q", m.Op())
	}
}

// PermissionClient is a client for the Permission schema.
type PermissionClient struct {
	config
}

// NewPermissionClient returns a client for the Permission from the given config.
func NewPermissionClient(c config) *PermissionClient {
	return &PermissionClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `permission.Hooks(f(g(h())))`.
func (c *PermissionClient) Use(hooks ...Hook) {
	c.hooks.Permission = append(c.hooks.Permission, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `permission.Intercept(f(g(h())))`.
func (c *PermissionClient) Intercept(interceptors ...Interceptor) {
	c.inters.Permission = append(c.inters.Permission, interceptors...)
}

// Create returns a builder for creating a Permission entity.
func (c *PermissionClient) Create() *PermissionCreate {
	mutation := newPermissionMutation(c.config, OpCreate)
	return &PermissionCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Permission entities.
func (c *PermissionClient) CreateBulk(builders ...*PermissionCreate) *PermissionCreateBulk {
	return &PermissionCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *PermissionClient) MapCreateBulk(slice any, setFunc func(*PermissionCreate, int)) *PermissionCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &PermissionCreateBulk{err: fmt.Errorf("calling to PermissionClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*PermissionCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &PermissionCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Permission.
func (c *PermissionClient) Update() *PermissionUpdate {
	mutation := newPermissionMutation(c.config, OpUpdate)
	return &PermissionUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *PermissionClient) UpdateOne(_m *Permission) *PermissionUpdateOne {
	mutation := newPermissionMutation(c.config, OpUpdateOne, withPermission(_m))
	return &PermissionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *PermissionClient) UpdateOneID(id int) *PermissionUpdateOne {
	mutation := newPermissionMutation(c.config, OpUpdateOne, withPermissionID(id))
	return &PermissionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Permission.
func (c *PermissionClient) Delete() *PermissionDelete {
	mutation := newPermissionMutation(c.config, OpDelete)
	return &PermissionDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *PermissionClient) DeleteOne(_m *Permission) *PermissionDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *PermissionClient) DeleteOneID(id int) *PermissionDeleteOne {
	builder := c.Delete().Where(permission.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &PermissionDeleteOne{builder}
}

// Query returns a query builder for Permission.
func (c *PermissionClient) Query() *PermissionQuery {
	return &PermissionQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypePermission},
		inters: c.Interceptors(),
	}
}

// Get returns a Permission entity by its id.
func (c *PermissionClient) Get(ctx context.Context, id int) (*Permission, error) {
	return c.Query().Where(permission.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *PermissionClient) GetX(ctx context.Context, id int) *Permission {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryUsers queries the users edge of a Permission.
func (c *PermissionClient) QueryUsers(_m *Permission) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(permission.Table, permission.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, permission.UsersTable, permission.UsersPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTenant queries the tenant edge of a Permission.
func (c *PermissionClient) QueryTenant(_m *Permission) *TenantQuery {
	query := (&TenantClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(permission.Table, permission.FieldID, id),
			sqlgraph.To(tenant.Table, tenant.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, permission.TenantTable, permission.TenantColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *PermissionClient) Hooks() []Hook {
	return c.hooks.Permission
}

// Interceptors returns the client interceptors.
func (c *PermissionClient) Interceptors() []Interceptor {
	return c.inters.Permission
}

func (c *PermissionClient) mutate(ctx context.Context, m *PermissionMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&PermissionCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&PermissionUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&PermissionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&PermissionDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Permission mutation op: %q", m.Op())
	}
}

// ProductClient is a client for the Product schema.
type ProductClient struct {
	config
}

// NewProductClient returns a client for the Product from the given config.
func NewProductClient(c config) *ProductClient {
	return &ProductClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `product.Hooks(f(g(h())))`.
func (c *ProductClient) Use(hooks ...Hook) {
	c.hooks.Product = append(c.hooks.Product, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `product.Intercept(f(g(h())))`.
func (c *ProductClient) Intercept(interceptors ...Interceptor) {
	c.inters.Product = append(c.inters.Product, interceptors...)
}

// Create returns a builder for creating a Product entity.
func (c *ProductClient) Create() *ProductCreate {
	mutation := newProductMutation(c.config, OpCreate)
	return &ProductCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Product entities.
func (c *ProductClient) CreateBulk(builders ...*ProductCreate) *ProductCreateBulk {
	return &ProductCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ProductClient) MapCreateBulk(slice any, setFunc func(*ProductCreate, int)) *ProductCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ProductCreateBulk{err: fmt.Errorf("calling to ProductClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ProductCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ProductCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Product.
func (c *ProductClient) Update() *ProductUpdate {
	mutation := newProductMutation(c.config, OpUpdate)
	return &ProductUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ProductClient) UpdateOne(_m *Product) *ProductUpdateOne {
	mutation := newProductMutation(c.config, OpUpdateOne, withProduct(_m))
	return &ProductUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ProductClient) UpdateOneID(id int) *ProductUpdateOne {
	mutation := newProductMutation(c.config, OpUpdateOne, withProductID(id))
	return &ProductUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Product.
func (c *ProductClient) Delete() *ProductDelete {
	mutation := newProductMutation(c.config, OpDelete)
	return &ProductDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ProductClient) DeleteOne(_m *Product) *ProductDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ProductClient) DeleteOneID(id int) *ProductDeleteOne {
	builder := c.Delete().Where(product.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ProductDeleteOne{builder}
}

// Query returns a query builder for Product.
func (c *ProductClient) Query() *ProductQuery {
	return &ProductQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeProduct},
		inters: c.Interceptors(),
	}
}

// Get returns a Product entity by its id.
func (c *ProductClient) Get(ctx context.Context, id int) (*Product, error) {
	return c.Query().Where(product.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ProductClient) GetX(ctx context.Context, id int) *Product {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryTenant queries the tenant edge of a Product.
func (c *ProductClient) QueryTenant(_m *Product) *TenantQuery {
	query := (&TenantClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(product.Table, product.FieldID, id),
			sqlgraph.To(tenant.Table, tenant.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, product.TenantTable, product.TenantColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryMovements queries the movements edge of a Product.
func (c *ProductClient) QueryMovements(_m *Product) *StockMovementQuery {
	query := (&StockMovementClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(product.Table, product.FieldID, id),
			sqlgraph.To(stockmovement.Table, stockmovement.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, product.MovementsTable, product.MovementsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryReservations queries the reservations edge of a Product.
func (c *ProductClient) QueryReservations(_m *Product) *InventoryReservationQuery {
	query := (&InventoryReservationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(product.Table, product.FieldID, id),
			sqlgraph.To(inventoryreservation.Table, inventoryreservation.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, product.ReservationsTable, product.ReservationsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryVendor queries the vendor edge of a Product.
func (c *ProductClient) QueryVendor(_m *Product) *AccountQuery {
	query := (&AccountClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(product.Table, product.FieldID, id),
			sqlgraph.To(account.Table, account.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, product.VendorTable, product.VendorColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ProductClient) Hooks() []Hook {
	return c.hooks.Product
}

// Interceptors returns the client interceptors.
func (c *ProductClient) Interceptors() []Interceptor {
	return c.inters.Product
}

func (c *ProductClient) mutate(ctx context.Context, m *ProductMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ProductCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ProductUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ProductUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ProductDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Product mutation op: %q", m.Op())
	}
}

// RecordingClient is a client for the Recording schema.
type RecordingClient struct {
	config
}

// NewRecordingClient returns a client for the Recording from the given config.
func NewRecordingClient(c config) *RecordingClient {
	return &RecordingClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `recording.Hooks(f(g(h())))`.
func (c *RecordingClient) Use(hooks ...Hook) {
	c.hooks.Recording = append(c.hooks.Recording, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `recording.Intercept(f(g(h())))`.
func (c *RecordingClient) Intercept(interceptors ...Interceptor) {
	c.inters.Recording = append(c.inters.Recording, interceptors...)
}

// Create returns a builder for creating a Recording entity.
func (c *RecordingClient) Create() *RecordingCreate {
	mutation := newRecordingMutation(c.config, OpCreate)
	return &RecordingCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Recording entities.
func (c *RecordingClient) CreateBulk(builders ...*RecordingCreate) *RecordingCreateBulk {
	return &RecordingCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *RecordingClient) MapCreateBulk(slice any, setFunc func(*RecordingCreate, int)) *RecordingCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &RecordingCreateBulk{err: fmt.Errorf("calling to RecordingClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*RecordingCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &RecordingCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Recording.
func (c *RecordingClient) Update() *RecordingUpdate {
	mutation := newRecordingMutation(c.config, OpUpdate)
	return &RecordingUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *RecordingClient) UpdateOne(_m *Recording) *RecordingUpdateOne {
	mutation := newRecordingMutation(c.config, OpUpdateOne, withRecording(_m))
	return &RecordingUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *RecordingClient) UpdateOneID(id int) *RecordingUpdateOne {
	mutation := newRecordingMutation(c.config, OpUpdateOne, withRecordingID(id))
	return &RecordingUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Recording.
func (c *RecordingClient) Delete() *RecordingDelete {
	mutation := newRecordingMutation(c.config, OpDelete)
	return &RecordingDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *RecordingClient) DeleteOne(_m *Recording) *RecordingDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *RecordingClient) DeleteOneID(id int) *RecordingDeleteOne {
	builder := c.Delete().Where(recording.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &RecordingDeleteOne{builder}
}

// Query returns a query builder for Recording.
func (c *RecordingClient) Query() *RecordingQuery {
	return &RecordingQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeRecording},
		inters: c.Interceptors(),
	}
}

// Get returns a Recording entity by its id.
func (c *RecordingClient) Get(ctx context.Context, id int) (*Recording, error) {
	return c.Query().Where(recording.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *RecordingClient) GetX(ctx context.Context, id int) *Recording {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryCamera queries the camera edge of a Recording.
func (c *RecordingClient) QueryCamera(_m *Recording) *CameraQuery {
	query := (&CameraClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(recording.Table, recording.FieldID, id),
			sqlgraph.To(camera.Table, camera.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, recording.CameraTable, recording.CameraColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTenant queries the tenant edge of a Recording.
func (c *RecordingClient) QueryTenant(_m *Recording) *TenantQuery {
	query := (&TenantClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(recording.Table, recording.FieldID, id),
			sqlgraph.To(tenant.Table, tenant.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, recording.TenantTable, recording.TenantColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *RecordingClient) Hooks() []Hook {
	return c.hooks.Recording
}

// Interceptors returns the client interceptors.
func (c *RecordingClient) Interceptors() []Interceptor {
	return c.inters.Recording
}

func (c *RecordingClient) mutate(ctx context.Context, m *RecordingMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&RecordingCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&RecordingUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&RecordingUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&RecordingDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Recording mutation op: %q", m.Op())
	}
}

// RecurringInvoiceClient is a client for the RecurringInvoice schema.
type RecurringInvoiceClient struct {
	config
}

// NewRecurringInvoiceClient returns a client for the RecurringInvoice from the given config.
func NewRecurringInvoiceClient(c config) *RecurringInvoiceClient {
	return &RecurringInvoiceClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `recurringinvoice.Hooks(f(g(h())))`.
func (c *RecurringInvoiceClient) Use(hooks ...Hook) {
	c.hooks.RecurringInvoice = append(c.hooks.RecurringInvoice, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `recurringinvoice.Intercept(f(g(h())))`.
func (c *RecurringInvoiceClient) Intercept(interceptors ...Interceptor) {
	c.inters.RecurringInvoice = append(c.inters.RecurringInvoice, interceptors...)
}

// Create returns a builder for creating a RecurringInvoice entity.
func (c *RecurringInvoiceClient) Create() *RecurringInvoiceCreate {
	mutation := newRecurringInvoiceMutation(c.config, OpCreate)
	return &RecurringInvoiceCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of RecurringInvoice entities.
func (c *RecurringInvoiceClient) CreateBulk(builders ...*RecurringInvoiceCreate) *RecurringInvoiceCreateBulk {
	return &RecurringInvoiceCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *RecurringInvoiceClient) MapCreateBulk(slice any, setFunc func(*RecurringInvoiceCreate, int)) *RecurringInvoiceCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &RecurringInvoiceCreateBulk{err: fmt.Errorf("calling to RecurringInvoiceClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*RecurringInvoiceCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &RecurringInvoiceCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for RecurringInvoice.
func (c *RecurringInvoiceClient) Update() *RecurringInvoiceUpdate {
	mutation := newRecurringInvoiceMutation(c.config, OpUpdate)
	return &RecurringInvoiceUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *RecurringInvoiceClient) UpdateOne(_m *RecurringInvoice) *RecurringInvoiceUpdateOne {
	mutation := newRecurringInvoiceMutation(c.config, OpUpdateOne, withRecurringInvoice(_m))
	return &RecurringInvoiceUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *RecurringInvoiceClient) UpdateOneID(id int) *RecurringInvoiceUpdateOne {
	mutation := newRecurringInvoiceMutation(c.config, OpUpdateOne, withRecurringInvoiceID(id))
	return &RecurringInvoiceUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for RecurringInvoice.
func (c *RecurringInvoiceClient) Delete() *RecurringInvoiceDelete {
	mutation := newRecurringInvoiceMutation(c.config, OpDelete)
	return &RecurringInvoiceDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *RecurringInvoiceClient) DeleteOne(_m *RecurringInvoice) *RecurringInvoiceDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *RecurringInvoiceClient) DeleteOneID(id int) *RecurringInvoiceDeleteOne {
	builder := c.Delete().Where(recurringinvoice.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &RecurringInvoiceDeleteOne{builder}
}

// Query returns a query builder for RecurringInvoice.
func (c *RecurringInvoiceClient) Query() *RecurringInvoiceQuery {
	return &RecurringInvoiceQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeRecurringInvoice},
		inters: c.Interceptors(),
	}
}

// Get returns a RecurringInvoice entity by its id.
func (c *RecurringInvoiceClient) Get(ctx context.Context, id int) (*RecurringInvoice, error) {
	return c.Query().Where(recurringinvoice.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *RecurringInvoiceClient) GetX(ctx context.Context, id int) *RecurringInvoice {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryTenant queries the tenant edge of a RecurringInvoice.
func (c *RecurringInvoiceClient) QueryTenant(_m *RecurringInvoice) *TenantQuery {
	query := (&TenantClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(recurringinvoice.Table, recurringinvoice.FieldID, id),
			sqlgraph.To(tenant.Table, tenant.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, recurringinvoice.TenantTable, recurringinvoice.TenantColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryAccount queries the account edge of a RecurringInvoice.
func (c *RecurringInvoiceClient) QueryAccount(_m *RecurringInvoice) *AccountQuery {
	query := (&AccountClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(recurringinvoice.Table, recurringinvoice.FieldID, id),
			sqlgraph.To(account.Table, account.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, recurringinvoice.AccountTable, recurringinvoice.AccountColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *RecurringInvoiceClient) Hooks() []Hook {
	return c.hooks.RecurringInvoice
}

// Interceptors returns the client interceptors.
func (c *RecurringInvoiceClient) Interceptors() []Interceptor {
	return c.inters.RecurringInvoice
}

func (c *RecurringInvoiceClient) mutate(ctx context.Context, m *RecurringInvoiceMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&RecurringInvoiceCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&RecurringInvoiceUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&RecurringInvoiceUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&RecurringInvoiceDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown RecurringInvoice mutation op: %q", m.Op())
	}
}

// RemediationStepClient is a client for the RemediationStep schema.
type RemediationStepClient struct {
	config
}

// NewRemediationStepClient returns a client for the RemediationStep from the given config.
func NewRemediationStepClient(c config) *RemediationStepClient {
	return &RemediationStepClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `remediationstep.Hooks(f(g(h())))`.
func (c *RemediationStepClient) Use(hooks ...Hook) {
	c.hooks.RemediationStep = append(c.hooks.RemediationStep, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `remediationstep.Intercept(f(g(h())))`.
func (c *RemediationStepClient) Intercept(interceptors ...Interceptor) {
	c.inters.RemediationStep = append(c.inters.RemediationStep, interceptors...)
}

// Create returns a builder for creating a RemediationStep entity.
func (c *RemediationStepClient) Create() *RemediationStepCreate {
	mutation := newRemediationStepMutation(c.config, OpCreate)
	return &RemediationStepCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of RemediationStep entities.
func (c *RemediationStepClient) CreateBulk(builders ...*RemediationStepCreate) *RemediationStepCreateBulk {
	return &RemediationStepCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *RemediationStepClient) MapCreateBulk(slice any, setFunc func(*RemediationStepCreate, int)) *RemediationStepCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &RemediationStepCreateBulk{err: fmt.Errorf("calling to RemediationStepClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*RemediationStepCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &RemediationStepCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for RemediationStep.
func (c *RemediationStepClient) Update() *RemediationStepUpdate {
	mutation := newRemediationStepMutation(c.config, OpUpdate)
	return &RemediationStepUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *RemediationStepClient) UpdateOne(_m *RemediationStep) *RemediationStepUpdateOne {
	mutation := newRemediationStepMutation(c.config, OpUpdateOne, withRemediationStep(_m))
	return &RemediationStepUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *RemediationStepClient) UpdateOneID(id int) *RemediationStepUpdateOne {
	mutation := newRemediationStepMutation(c.config, OpUpdateOne, withRemediationStepID(id))
	return &RemediationStepUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for RemediationStep.
func (c *RemediationStepClient) Delete() *RemediationStepDelete {
	mutation := newRemediationStepMutation(c.config, OpDelete)
	return &RemediationStepDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *RemediationStepClient) DeleteOne(_m *RemediationStep) *RemediationStepDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *RemediationStepClient) DeleteOneID(id int) *RemediationStepDeleteOne {
	builder := c.Delete().Where(remediationstep.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &RemediationStepDeleteOne{builder}
}

// Query returns a query builder for RemediationStep.
func (c *RemediationStepClient) Query() *RemediationStepQuery {
	return &RemediationStepQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeRemediationStep},
		inters: c.Interceptors(),
	}
}

// Get returns a RemediationStep entity by its id.
func (c *RemediationStepClient) Get(ctx context.Context, id int) (*RemediationStep, error) {
	return c.Query().Where(remediationstep.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *RemediationStepClient) GetX(ctx context.Context, id int) *RemediationStep {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryTicket queries the ticket edge of a RemediationStep.
func (c *RemediationStepClient) QueryTicket(_m *RemediationStep) *TicketQuery {
	query := (&TicketClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(remediationstep.Table, remediationstep.FieldID, id),
			sqlgraph.To(ticket.Table, ticket.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, remediationstep.TicketTable, remediationstep.TicketColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *RemediationStepClient) Hooks() []Hook {
	return c.hooks.RemediationStep
}

// Interceptors returns the client interceptors.
func (c *RemediationStepClient) Interceptors() []Interceptor {
	return c.inters.RemediationStep
}

func (c *RemediationStepClient) mutate(ctx context.Context, m *RemediationStepMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&RemediationStepCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&RemediationStepUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&RemediationStepUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&RemediationStepDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown RemediationStep mutation op: %q", m.Op())
	}
}

// ReviewCycleClient is a client for the ReviewCycle schema.
type ReviewCycleClient struct {
	config
}

// NewReviewCycleClient returns a client for the ReviewCycle from the given config.
func NewReviewCycleClient(c config) *ReviewCycleClient {
	return &ReviewCycleClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `reviewcycle.Hooks(f(g(h())))`.
func (c *ReviewCycleClient) Use(hooks ...Hook) {
	c.hooks.ReviewCycle = append(c.hooks.ReviewCycle, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `reviewcycle.Intercept(f(g(h())))`.
func (c *ReviewCycleClient) Intercept(interceptors ...Interceptor) {
	c.inters.ReviewCycle = append(c.inters.ReviewCycle, interceptors...)
}

// Create returns a builder for creating a ReviewCycle entity.
func (c *ReviewCycleClient) Create() *ReviewCycleCreate {
	mutation := newReviewCycleMutation(c.config, OpCreate)
	return &ReviewCycleCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of ReviewCycle entities.
func (c *ReviewCycleClient) CreateBulk(builders ...*ReviewCycleCreate) *ReviewCycleCreateBulk {
	return &ReviewCycleCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ReviewCycleClient) MapCreateBulk(slice any, setFunc func(*ReviewCycleCreate, int)) *ReviewCycleCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ReviewCycleCreateBulk{err: fmt.Errorf("calling to ReviewCycleClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ReviewCycleCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ReviewCycleCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for ReviewCycle.
func (c *ReviewCycleClient) Update() *ReviewCycleUpdate {
	mutation := newReviewCycleMutation(c.config, OpUpdate)
	return &ReviewCycleUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ReviewCycleClient) UpdateOne(_m *ReviewCycle) *ReviewCycleUpdateOne {
	mutation := newReviewCycleMutation(c.config, OpUpdateOne, withReviewCycle(_m))
	return &ReviewCycleUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ReviewCycleClient) UpdateOneID(id int) *ReviewCycleUpdateOne {
	mutation := newReviewCycleMutation(c.config, OpUpdateOne, withReviewCycleID(id))
	return &ReviewCycleUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for ReviewCycle.
func (c *ReviewCycleClient) Delete() *ReviewCycleDelete {
	mutation := newReviewCycleMutation(c.config, OpDelete)
	return &ReviewCycleDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ReviewCycleClient) DeleteOne(_m *ReviewCycle) *ReviewCycleDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ReviewCycleClient) DeleteOneID(id int) *ReviewCycleDeleteOne {
	builder := c.Delete().Where(reviewcycle.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ReviewCycleDeleteOne{builder}
}

// Query returns a query builder for ReviewCycle.
func (c *ReviewCycleClient) Query() *ReviewCycleQuery {
	return &ReviewCycleQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeReviewCycle},
		inters: c.Interceptors(),
	}
}

// Get returns a ReviewCycle entity by its id.
func (c *ReviewCycleClient) Get(ctx context.Context, id int) (*ReviewCycle, error) {
	return c.Query().Where(reviewcycle.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ReviewCycleClient) GetX(ctx context.Context, id int) *ReviewCycle {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryTenant queries the tenant edge of a ReviewCycle.
func (c *ReviewCycleClient) QueryTenant(_m *ReviewCycle) *TenantQuery {
	query := (&TenantClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(reviewcycle.Table, reviewcycle.FieldID, id),
			sqlgraph.To(tenant.Table, tenant.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, reviewcycle.TenantTable, reviewcycle.TenantColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryReviews queries the reviews edge of a ReviewCycle.
func (c *ReviewCycleClient) QueryReviews(_m *ReviewCycle) *PerformanceReviewQuery {
	query := (&PerformanceReviewClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(reviewcycle.Table, reviewcycle.FieldID, id),
			sqlgraph.To(performancereview.Table, performancereview.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, reviewcycle.ReviewsTable, reviewcycle.ReviewsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ReviewCycleClient) Hooks() []Hook {
	return c.hooks.ReviewCycle
}

// Interceptors returns the client interceptors.
func (c *ReviewCycleClient) Interceptors() []Interceptor {
	return c.inters.ReviewCycle
}

func (c *ReviewCycleClient) mutate(ctx context.Context, m *ReviewCycleMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ReviewCycleCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ReviewCycleUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ReviewCycleUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ReviewCycleDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown ReviewCycle mutation op: %q", m.Op())
	}
}

// SOPClient is a client for the SOP schema.
type SOPClient struct {
	config
}

// NewSOPClient returns a client for the SOP from the given config.
func NewSOPClient(c config) *SOPClient {
	return &SOPClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `sop.Hooks(f(g(h())))`.
func (c *SOPClient) Use(hooks ...Hook) {
	c.hooks.SOP = append(c.hooks.SOP, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `sop.Intercept(f(g(h())))`.
func (c *SOPClient) Intercept(interceptors ...Interceptor) {
	c.inters.SOP = append(c.inters.SOP, interceptors...)
}

// Create returns a builder for creating a SOP entity.
func (c *SOPClient) Create() *SOPCreate {
	mutation := newSOPMutation(c.config, OpCreate)
	return &SOPCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of SOP entities.
func (c *SOPClient) CreateBulk(builders ...*SOPCreate) *SOPCreateBulk {
	return &SOPCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *SOPClient) MapCreateBulk(slice any, setFunc func(*SOPCreate, int)) *SOPCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &SOPCreateBulk{err: fmt.Errorf("calling to SOPClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*SOPCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &SOPCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for SOP.
func (c *SOPClient) Update() *SOPUpdate {
	mutation := newSOPMutation(c.config, OpUpdate)
	return &SOPUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *SOPClient) UpdateOne(_m *SOP) *SOPUpdateOne {
	mutation := newSOPMutation(c.config, OpUpdateOne, withSOP(_m))
	return &SOPUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *SOPClient) UpdateOneID(id int) *SOPUpdateOne {
	mutation := newSOPMutation(c.config, OpUpdateOne, withSOPID(id))
	return &SOPUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for SOP.
func (c *SOPClient) Delete() *SOPDelete {
	mutation := newSOPMutation(c.config, OpDelete)
	return &SOPDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *SOPClient) DeleteOne(_m *SOP) *SOPDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *SOPClient) DeleteOneID(id int) *SOPDeleteOne {
	builder := c.Delete().Where(sop.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &SOPDeleteOne{builder}
}

// Query returns a query builder for SOP.
func (c *SOPClient) Query() *SOPQuery {
	return &SOPQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeSOP},
		inters: c.Interceptors(),
	}
}

// Get returns a SOP entity by its id.
func (c *SOPClient) Get(ctx context.Context, id int) (*SOP, error) {
	return c.Query().Where(sop.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *SOPClient) GetX(ctx context.Context, id int) *SOP {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryTenant queries the tenant edge of a SOP.
func (c *SOPClient) QueryTenant(_m *SOP) *TenantQuery {
	query := (&TenantClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(sop.Table, sop.FieldID, id),
			sqlgraph.To(tenant.Table, tenant.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, sop.TenantTable, sop.TenantColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryAsset queries the asset edge of a SOP.
func (c *SOPClient) QueryAsset(_m *SOP) *AssetQuery {
	query := (&AssetClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(sop.Table, sop.FieldID, id),
			sqlgraph.To(asset.Table, asset.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, sop.AssetTable, sop.AssetColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryAuthor queries the author edge of a SOP.
func (c *SOPClient) QueryAuthor(_m *SOP) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(sop.Table, sop.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, sop.AuthorTable, sop.AuthorColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *SOPClient) Hooks() []Hook {
	return c.hooks.SOP
}

// Interceptors returns the client interceptors.
func (c *SOPClient) Interceptors() []Interceptor {
	return c.inters.SOP
}

func (c *SOPClient) mutate(ctx context.Context, m *SOPMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&SOPCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&SOPUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&SOPUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&SOPDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown SOP mutation op: %q", m.Op())
	}
}

// SaaSAppClient is a client for the SaaSApp schema.
type SaaSAppClient struct {
	config
}

// NewSaaSAppClient returns a client for the SaaSApp from the given config.
func NewSaaSAppClient(c config) *SaaSAppClient {
	return &SaaSAppClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `saasapp.Hooks(f(g(h())))`.
func (c *SaaSAppClient) Use(hooks ...Hook) {
	c.hooks.SaaSApp = append(c.hooks.SaaSApp, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `saasapp.Intercept(f(g(h())))`.
func (c *SaaSAppClient) Intercept(interceptors ...Interceptor) {
	c.inters.SaaSApp = append(c.inters.SaaSApp, interceptors...)
}

// Create returns a builder for creating a SaaSApp entity.
func (c *SaaSAppClient) Create() *SaaSAppCreate {
	mutation := newSaaSAppMutation(c.config, OpCreate)
	return &SaaSAppCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of SaaSApp entities.
func (c *SaaSAppClient) CreateBulk(builders ...*SaaSAppCreate) *SaaSAppCreateBulk {
	return &SaaSAppCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *SaaSAppClient) MapCreateBulk(slice any, setFunc func(*SaaSAppCreate, int)) *SaaSAppCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &SaaSAppCreateBulk{err: fmt.Errorf("calling to SaaSAppClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*SaaSAppCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &SaaSAppCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for SaaSApp.
func (c *SaaSAppClient) Update() *SaaSAppUpdate {
	mutation := newSaaSAppMutation(c.config, OpUpdate)
	return &SaaSAppUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *SaaSAppClient) UpdateOne(_m *SaaSApp) *SaaSAppUpdateOne {
	mutation := newSaaSAppMutation(c.config, OpUpdateOne, withSaaSApp(_m))
	return &SaaSAppUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *SaaSAppClient) UpdateOneID(id int) *SaaSAppUpdateOne {
	mutation := newSaaSAppMutation(c.config, OpUpdateOne, withSaaSAppID(id))
	return &SaaSAppUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for SaaSApp.
func (c *SaaSAppClient) Delete() *SaaSAppDelete {
	mutation := newSaaSAppMutation(c.config, OpDelete)
	return &SaaSAppDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *SaaSAppClient) DeleteOne(_m *SaaSApp) *SaaSAppDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *SaaSAppClient) DeleteOneID(id int) *SaaSAppDeleteOne {
	builder := c.Delete().Where(saasapp.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &SaaSAppDeleteOne{builder}
}

// Query returns a query builder for SaaSApp.
func (c *SaaSAppClient) Query() *SaaSAppQuery {
	return &SaaSAppQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeSaaSApp},
		inters: c.Interceptors(),
	}
}

// Get returns a SaaSApp entity by its id.
func (c *SaaSAppClient) Get(ctx context.Context, id int) (*SaaSApp, error) {
	return c.Query().Where(saasapp.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *SaaSAppClient) GetX(ctx context.Context, id int) *SaaSApp {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryIdentities queries the identities edge of a SaaSApp.
func (c *SaaSAppClient) QueryIdentities(_m *SaaSApp) *SaaSIdentityQuery {
	query := (&SaaSIdentityClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(saasapp.Table, saasapp.FieldID, id),
			sqlgraph.To(saasidentity.Table, saasidentity.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, saasapp.IdentitiesTable, saasapp.IdentitiesColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryFilters queries the filters edge of a SaaSApp.
func (c *SaaSAppClient) QueryFilters(_m *SaaSApp) *SaaSFilterQuery {
	query := (&SaaSFilterClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(saasapp.Table, saasapp.FieldID, id),
			sqlgraph.To(saasfilter.Table, saasfilter.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, saasapp.FiltersTable, saasapp.FiltersColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTenant queries the tenant edge of a SaaSApp.
func (c *SaaSAppClient) QueryTenant(_m *SaaSApp) *TenantQuery {
	query := (&TenantClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(saasapp.Table, saasapp.FieldID, id),
			sqlgraph.To(tenant.Table, tenant.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, saasapp.TenantTable, saasapp.TenantColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *SaaSAppClient) Hooks() []Hook {
	return c.hooks.SaaSApp
}

// Interceptors returns the client interceptors.
func (c *SaaSAppClient) Interceptors() []Interceptor {
	return c.inters.SaaSApp
}

func (c *SaaSAppClient) mutate(ctx context.Context, m *SaaSAppMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&SaaSAppCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&SaaSAppUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&SaaSAppUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&SaaSAppDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown SaaSApp mutation op: %q", m.Op())
	}
}

// SaaSFilterClient is a client for the SaaSFilter schema.
type SaaSFilterClient struct {
	config
}

// NewSaaSFilterClient returns a client for the SaaSFilter from the given config.
func NewSaaSFilterClient(c config) *SaaSFilterClient {
	return &SaaSFilterClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `saasfilter.Hooks(f(g(h())))`.
func (c *SaaSFilterClient) Use(hooks ...Hook) {
	c.hooks.SaaSFilter = append(c.hooks.SaaSFilter, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `saasfilter.Intercept(f(g(h())))`.
func (c *SaaSFilterClient) Intercept(interceptors ...Interceptor) {
	c.inters.SaaSFilter = append(c.inters.SaaSFilter, interceptors...)
}

// Create returns a builder for creating a SaaSFilter entity.
func (c *SaaSFilterClient) Create() *SaaSFilterCreate {
	mutation := newSaaSFilterMutation(c.config, OpCreate)
	return &SaaSFilterCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of SaaSFilter entities.
func (c *SaaSFilterClient) CreateBulk(builders ...*SaaSFilterCreate) *SaaSFilterCreateBulk {
	return &SaaSFilterCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *SaaSFilterClient) MapCreateBulk(slice any, setFunc func(*SaaSFilterCreate, int)) *SaaSFilterCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &SaaSFilterCreateBulk{err: fmt.Errorf("calling to SaaSFilterClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*SaaSFilterCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &SaaSFilterCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for SaaSFilter.
func (c *SaaSFilterClient) Update() *SaaSFilterUpdate {
	mutation := newSaaSFilterMutation(c.config, OpUpdate)
	return &SaaSFilterUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *SaaSFilterClient) UpdateOne(_m *SaaSFilter) *SaaSFilterUpdateOne {
	mutation := newSaaSFilterMutation(c.config, OpUpdateOne, withSaaSFilter(_m))
	return &SaaSFilterUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *SaaSFilterClient) UpdateOneID(id int) *SaaSFilterUpdateOne {
	mutation := newSaaSFilterMutation(c.config, OpUpdateOne, withSaaSFilterID(id))
	return &SaaSFilterUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for SaaSFilter.
func (c *SaaSFilterClient) Delete() *SaaSFilterDelete {
	mutation := newSaaSFilterMutation(c.config, OpDelete)
	return &SaaSFilterDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *SaaSFilterClient) DeleteOne(_m *SaaSFilter) *SaaSFilterDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *SaaSFilterClient) DeleteOneID(id int) *SaaSFilterDeleteOne {
	builder := c.Delete().Where(saasfilter.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &SaaSFilterDeleteOne{builder}
}

// Query returns a query builder for SaaSFilter.
func (c *SaaSFilterClient) Query() *SaaSFilterQuery {
	return &SaaSFilterQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeSaaSFilter},
		inters: c.Interceptors(),
	}
}

// Get returns a SaaSFilter entity by its id.
func (c *SaaSFilterClient) Get(ctx context.Context, id int) (*SaaSFilter, error) {
	return c.Query().Where(saasfilter.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *SaaSFilterClient) GetX(ctx context.Context, id int) *SaaSFilter {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryApp queries the app edge of a SaaSFilter.
func (c *SaaSFilterClient) QueryApp(_m *SaaSFilter) *SaaSAppQuery {
	query := (&SaaSAppClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(saasfilter.Table, saasfilter.FieldID, id),
			sqlgraph.To(saasapp.Table, saasapp.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, saasfilter.AppTable, saasfilter.AppColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTenant queries the tenant edge of a SaaSFilter.
func (c *SaaSFilterClient) QueryTenant(_m *SaaSFilter) *TenantQuery {
	query := (&TenantClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(saasfilter.Table, saasfilter.FieldID, id),
			sqlgraph.To(tenant.Table, tenant.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, saasfilter.TenantTable, saasfilter.TenantColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *SaaSFilterClient) Hooks() []Hook {
	return c.hooks.SaaSFilter
}

// Interceptors returns the client interceptors.
func (c *SaaSFilterClient) Interceptors() []Interceptor {
	return c.inters.SaaSFilter
}

func (c *SaaSFilterClient) mutate(ctx context.Context, m *SaaSFilterMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&SaaSFilterCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&SaaSFilterUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&SaaSFilterUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&SaaSFilterDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown SaaSFilter mutation op: %q", m.Op())
	}
}

// SaaSIdentityClient is a client for the SaaSIdentity schema.
type SaaSIdentityClient struct {
	config
}

// NewSaaSIdentityClient returns a client for the SaaSIdentity from the given config.
func NewSaaSIdentityClient(c config) *SaaSIdentityClient {
	return &SaaSIdentityClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `saasidentity.Hooks(f(g(h())))`.
func (c *SaaSIdentityClient) Use(hooks ...Hook) {
	c.hooks.SaaSIdentity = append(c.hooks.SaaSIdentity, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `saasidentity.Intercept(f(g(h())))`.
func (c *SaaSIdentityClient) Intercept(interceptors ...Interceptor) {
	c.inters.SaaSIdentity = append(c.inters.SaaSIdentity, interceptors...)
}

// Create returns a builder for creating a SaaSIdentity entity.
func (c *SaaSIdentityClient) Create() *SaaSIdentityCreate {
	mutation := newSaaSIdentityMutation(c.config, OpCreate)
	return &SaaSIdentityCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of SaaSIdentity entities.
func (c *SaaSIdentityClient) CreateBulk(builders ...*SaaSIdentityCreate) *SaaSIdentityCreateBulk {
	return &SaaSIdentityCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *SaaSIdentityClient) MapCreateBulk(slice any, setFunc func(*SaaSIdentityCreate, int)) *SaaSIdentityCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &SaaSIdentityCreateBulk{err: fmt.Errorf("calling to SaaSIdentityClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*SaaSIdentityCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &SaaSIdentityCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for SaaSIdentity.
func (c *SaaSIdentityClient) Update() *SaaSIdentityUpdate {
	mutation := newSaaSIdentityMutation(c.config, OpUpdate)
	return &SaaSIdentityUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *SaaSIdentityClient) UpdateOne(_m *SaaSIdentity) *SaaSIdentityUpdateOne {
	mutation := newSaaSIdentityMutation(c.config, OpUpdateOne, withSaaSIdentity(_m))
	return &SaaSIdentityUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *SaaSIdentityClient) UpdateOneID(id int) *SaaSIdentityUpdateOne {
	mutation := newSaaSIdentityMutation(c.config, OpUpdateOne, withSaaSIdentityID(id))
	return &SaaSIdentityUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for SaaSIdentity.
func (c *SaaSIdentityClient) Delete() *SaaSIdentityDelete {
	mutation := newSaaSIdentityMutation(c.config, OpDelete)
	return &SaaSIdentityDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *SaaSIdentityClient) DeleteOne(_m *SaaSIdentity) *SaaSIdentityDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *SaaSIdentityClient) DeleteOneID(id int) *SaaSIdentityDeleteOne {
	builder := c.Delete().Where(saasidentity.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &SaaSIdentityDeleteOne{builder}
}

// Query returns a query builder for SaaSIdentity.
func (c *SaaSIdentityClient) Query() *SaaSIdentityQuery {
	return &SaaSIdentityQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeSaaSIdentity},
		inters: c.Interceptors(),
	}
}

// Get returns a SaaSIdentity entity by its id.
func (c *SaaSIdentityClient) Get(ctx context.Context, id int) (*SaaSIdentity, error) {
	return c.Query().Where(saasidentity.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *SaaSIdentityClient) GetX(ctx context.Context, id int) *SaaSIdentity {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryUser queries the user edge of a SaaSIdentity.
func (c *SaaSIdentityClient) QueryUser(_m *SaaSIdentity) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(saasidentity.Table, saasidentity.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, saasidentity.UserTable, saasidentity.UserColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryApp queries the app edge of a SaaSIdentity.
func (c *SaaSIdentityClient) QueryApp(_m *SaaSIdentity) *SaaSAppQuery {
	query := (&SaaSAppClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(saasidentity.Table, saasidentity.FieldID, id),
			sqlgraph.To(saasapp.Table, saasapp.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, saasidentity.AppTable, saasidentity.AppColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryUsages queries the usages edge of a SaaSIdentity.
func (c *SaaSIdentityClient) QueryUsages(_m *SaaSIdentity) *SaaSUsageQuery {
	query := (&SaaSUsageClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(saasidentity.Table, saasidentity.FieldID, id),
			sqlgraph.To(saasusage.Table, saasusage.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, saasidentity.UsagesTable, saasidentity.UsagesColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTenant queries the tenant edge of a SaaSIdentity.
func (c *SaaSIdentityClient) QueryTenant(_m *SaaSIdentity) *TenantQuery {
	query := (&TenantClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(saasidentity.Table, saasidentity.FieldID, id),
			sqlgraph.To(tenant.Table, tenant.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, saasidentity.TenantTable, saasidentity.TenantColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *SaaSIdentityClient) Hooks() []Hook {
	return c.hooks.SaaSIdentity
}

// Interceptors returns the client interceptors.
func (c *SaaSIdentityClient) Interceptors() []Interceptor {
	return c.inters.SaaSIdentity
}

func (c *SaaSIdentityClient) mutate(ctx context.Context, m *SaaSIdentityMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&SaaSIdentityCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&SaaSIdentityUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&SaaSIdentityUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&SaaSIdentityDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown SaaSIdentity mutation op: %q", m.Op())
	}
}

// SaaSUsageClient is a client for the SaaSUsage schema.
type SaaSUsageClient struct {
	config
}

// NewSaaSUsageClient returns a client for the SaaSUsage from the given config.
func NewSaaSUsageClient(c config) *SaaSUsageClient {
	return &SaaSUsageClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `saasusage.Hooks(f(g(h())))`.
func (c *SaaSUsageClient) Use(hooks ...Hook) {
	c.hooks.SaaSUsage = append(c.hooks.SaaSUsage, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `saasusage.Intercept(f(g(h())))`.
func (c *SaaSUsageClient) Intercept(interceptors ...Interceptor) {
	c.inters.SaaSUsage = append(c.inters.SaaSUsage, interceptors...)
}

// Create returns a builder for creating a SaaSUsage entity.
func (c *SaaSUsageClient) Create() *SaaSUsageCreate {
	mutation := newSaaSUsageMutation(c.config, OpCreate)
	return &SaaSUsageCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of SaaSUsage entities.
func (c *SaaSUsageClient) CreateBulk(builders ...*SaaSUsageCreate) *SaaSUsageCreateBulk {
	return &SaaSUsageCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *SaaSUsageClient) MapCreateBulk(slice any, setFunc func(*SaaSUsageCreate, int)) *SaaSUsageCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &SaaSUsageCreateBulk{err: fmt.Errorf("calling to SaaSUsageClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*SaaSUsageCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &SaaSUsageCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for SaaSUsage.
func (c *SaaSUsageClient) Update() *SaaSUsageUpdate {
	mutation := newSaaSUsageMutation(c.config, OpUpdate)
	return &SaaSUsageUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *SaaSUsageClient) UpdateOne(_m *SaaSUsage) *SaaSUsageUpdateOne {
	mutation := newSaaSUsageMutation(c.config, OpUpdateOne, withSaaSUsage(_m))
	return &SaaSUsageUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *SaaSUsageClient) UpdateOneID(id int) *SaaSUsageUpdateOne {
	mutation := newSaaSUsageMutation(c.config, OpUpdateOne, withSaaSUsageID(id))
	return &SaaSUsageUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for SaaSUsage.
func (c *SaaSUsageClient) Delete() *SaaSUsageDelete {
	mutation := newSaaSUsageMutation(c.config, OpDelete)
	return &SaaSUsageDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *SaaSUsageClient) DeleteOne(_m *SaaSUsage) *SaaSUsageDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *SaaSUsageClient) DeleteOneID(id int) *SaaSUsageDeleteOne {
	builder := c.Delete().Where(saasusage.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &SaaSUsageDeleteOne{builder}
}

// Query returns a query builder for SaaSUsage.
func (c *SaaSUsageClient) Query() *SaaSUsageQuery {
	return &SaaSUsageQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeSaaSUsage},
		inters: c.Interceptors(),
	}
}

// Get returns a SaaSUsage entity by its id.
func (c *SaaSUsageClient) Get(ctx context.Context, id int) (*SaaSUsage, error) {
	return c.Query().Where(saasusage.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *SaaSUsageClient) GetX(ctx context.Context, id int) *SaaSUsage {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryIdentity queries the identity edge of a SaaSUsage.
func (c *SaaSUsageClient) QueryIdentity(_m *SaaSUsage) *SaaSIdentityQuery {
	query := (&SaaSIdentityClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(saasusage.Table, saasusage.FieldID, id),
			sqlgraph.To(saasidentity.Table, saasidentity.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, saasusage.IdentityTable, saasusage.IdentityColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTenant queries the tenant edge of a SaaSUsage.
func (c *SaaSUsageClient) QueryTenant(_m *SaaSUsage) *TenantQuery {
	query := (&TenantClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(saasusage.Table, saasusage.FieldID, id),
			sqlgraph.To(tenant.Table, tenant.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, saasusage.TenantTable, saasusage.TenantColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *SaaSUsageClient) Hooks() []Hook {
	return c.hooks.SaaSUsage
}

// Interceptors returns the client interceptors.
func (c *SaaSUsageClient) Interceptors() []Interceptor {
	return c.inters.SaaSUsage
}

func (c *SaaSUsageClient) mutate(ctx context.Context, m *SaaSUsageMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&SaaSUsageCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&SaaSUsageUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&SaaSUsageUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&SaaSUsageDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown SaaSUsage mutation op: %q", m.Op())
	}
}

// ScriptClient is a client for the Script schema.
type ScriptClient struct {
	config
}

// NewScriptClient returns a client for the Script from the given config.
func NewScriptClient(c config) *ScriptClient {
	return &ScriptClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `script.Hooks(f(g(h())))`.
func (c *ScriptClient) Use(hooks ...Hook) {
	c.hooks.Script = append(c.hooks.Script, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `script.Intercept(f(g(h())))`.
func (c *ScriptClient) Intercept(interceptors ...Interceptor) {
	c.inters.Script = append(c.inters.Script, interceptors...)
}

// Create returns a builder for creating a Script entity.
func (c *ScriptClient) Create() *ScriptCreate {
	mutation := newScriptMutation(c.config, OpCreate)
	return &ScriptCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Script entities.
func (c *ScriptClient) CreateBulk(builders ...*ScriptCreate) *ScriptCreateBulk {
	return &ScriptCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ScriptClient) MapCreateBulk(slice any, setFunc func(*ScriptCreate, int)) *ScriptCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ScriptCreateBulk{err: fmt.Errorf("calling to ScriptClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ScriptCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ScriptCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Script.
func (c *ScriptClient) Update() *ScriptUpdate {
	mutation := newScriptMutation(c.config, OpUpdate)
	return &ScriptUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ScriptClient) UpdateOne(_m *Script) *ScriptUpdateOne {
	mutation := newScriptMutation(c.config, OpUpdateOne, withScript(_m))
	return &ScriptUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ScriptClient) UpdateOneID(id int) *ScriptUpdateOne {
	mutation := newScriptMutation(c.config, OpUpdateOne, withScriptID(id))
	return &ScriptUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Script.
func (c *ScriptClient) Delete() *ScriptDelete {
	mutation := newScriptMutation(c.config, OpDelete)
	return &ScriptDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ScriptClient) DeleteOne(_m *Script) *ScriptDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ScriptClient) DeleteOneID(id int) *ScriptDeleteOne {
	builder := c.Delete().Where(script.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ScriptDeleteOne{builder}
}

// Query returns a query builder for Script.
func (c *ScriptClient) Query() *ScriptQuery {
	return &ScriptQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeScript},
		inters: c.Interceptors(),
	}
}

// Get returns a Script entity by its id.
func (c *ScriptClient) Get(ctx context.Context, id int) (*Script, error) {
	return c.Query().Where(script.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ScriptClient) GetX(ctx context.Context, id int) *Script {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryTenant queries the tenant edge of a Script.
func (c *ScriptClient) QueryTenant(_m *Script) *TenantQuery {
	query := (&TenantClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(script.Table, script.FieldID, id),
			sqlgraph.To(tenant.Table, tenant.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, script.TenantTable, script.TenantColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryJobs queries the jobs edge of a Script.
func (c *ScriptClient) QueryJobs(_m *Script) *JobQuery {
	query := (&JobClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(script.Table, script.FieldID, id),
			sqlgraph.To(job.Table, job.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, script.JobsTable, script.JobsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ScriptClient) Hooks() []Hook {
	return c.hooks.Script
}

// Interceptors returns the client interceptors.
func (c *ScriptClient) Interceptors() []Interceptor {
	return c.inters.Script
}

func (c *ScriptClient) mutate(ctx context.Context, m *ScriptMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ScriptCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ScriptUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ScriptUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ScriptDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Script mutation op: %q", m.Op())
	}
}

// ServiceRateClient is a client for the ServiceRate schema.
type ServiceRateClient struct {
	config
}

// NewServiceRateClient returns a client for the ServiceRate from the given config.
func NewServiceRateClient(c config) *ServiceRateClient {
	return &ServiceRateClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `servicerate.Hooks(f(g(h())))`.
func (c *ServiceRateClient) Use(hooks ...Hook) {
	c.hooks.ServiceRate = append(c.hooks.ServiceRate, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `servicerate.Intercept(f(g(h())))`.
func (c *ServiceRateClient) Intercept(interceptors ...Interceptor) {
	c.inters.ServiceRate = append(c.inters.ServiceRate, interceptors...)
}

// Create returns a builder for creating a ServiceRate entity.
func (c *ServiceRateClient) Create() *ServiceRateCreate {
	mutation := newServiceRateMutation(c.config, OpCreate)
	return &ServiceRateCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of ServiceRate entities.
func (c *ServiceRateClient) CreateBulk(builders ...*ServiceRateCreate) *ServiceRateCreateBulk {
	return &ServiceRateCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ServiceRateClient) MapCreateBulk(slice any, setFunc func(*ServiceRateCreate, int)) *ServiceRateCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ServiceRateCreateBulk{err: fmt.Errorf("calling to ServiceRateClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ServiceRateCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ServiceRateCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for ServiceRate.
func (c *ServiceRateClient) Update() *ServiceRateUpdate {
	mutation := newServiceRateMutation(c.config, OpUpdate)
	return &ServiceRateUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ServiceRateClient) UpdateOne(_m *ServiceRate) *ServiceRateUpdateOne {
	mutation := newServiceRateMutation(c.config, OpUpdateOne, withServiceRate(_m))
	return &ServiceRateUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ServiceRateClient) UpdateOneID(id int) *ServiceRateUpdateOne {
	mutation := newServiceRateMutation(c.config, OpUpdateOne, withServiceRateID(id))
	return &ServiceRateUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for ServiceRate.
func (c *ServiceRateClient) Delete() *ServiceRateDelete {
	mutation := newServiceRateMutation(c.config, OpDelete)
	return &ServiceRateDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ServiceRateClient) DeleteOne(_m *ServiceRate) *ServiceRateDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ServiceRateClient) DeleteOneID(id int) *ServiceRateDeleteOne {
	builder := c.Delete().Where(servicerate.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ServiceRateDeleteOne{builder}
}

// Query returns a query builder for ServiceRate.
func (c *ServiceRateClient) Query() *ServiceRateQuery {
	return &ServiceRateQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeServiceRate},
		inters: c.Interceptors(),
	}
}

// Get returns a ServiceRate entity by its id.
func (c *ServiceRateClient) Get(ctx context.Context, id int) (*ServiceRate, error) {
	return c.Query().Where(servicerate.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ServiceRateClient) GetX(ctx context.Context, id int) *ServiceRate {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryTenant queries the tenant edge of a ServiceRate.
func (c *ServiceRateClient) QueryTenant(_m *ServiceRate) *TenantQuery {
	query := (&TenantClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(servicerate.Table, servicerate.FieldID, id),
			sqlgraph.To(tenant.Table, tenant.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, servicerate.TenantTable, servicerate.TenantColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ServiceRateClient) Hooks() []Hook {
	return c.hooks.ServiceRate
}

// Interceptors returns the client interceptors.
func (c *ServiceRateClient) Interceptors() []Interceptor {
	return c.inters.ServiceRate
}

func (c *ServiceRateClient) mutate(ctx context.Context, m *ServiceRateMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ServiceRateCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ServiceRateUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ServiceRateUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ServiceRateDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown ServiceRate mutation op: %q", m.Op())
	}
}

// StockMovementClient is a client for the StockMovement schema.
type StockMovementClient struct {
	config
}

// NewStockMovementClient returns a client for the StockMovement from the given config.
func NewStockMovementClient(c config) *StockMovementClient {
	return &StockMovementClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `stockmovement.Hooks(f(g(h())))`.
func (c *StockMovementClient) Use(hooks ...Hook) {
	c.hooks.StockMovement = append(c.hooks.StockMovement, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `stockmovement.Intercept(f(g(h())))`.
func (c *StockMovementClient) Intercept(interceptors ...Interceptor) {
	c.inters.StockMovement = append(c.inters.StockMovement, interceptors...)
}

// Create returns a builder for creating a StockMovement entity.
func (c *StockMovementClient) Create() *StockMovementCreate {
	mutation := newStockMovementMutation(c.config, OpCreate)
	return &StockMovementCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of StockMovement entities.
func (c *StockMovementClient) CreateBulk(builders ...*StockMovementCreate) *StockMovementCreateBulk {
	return &StockMovementCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *StockMovementClient) MapCreateBulk(slice any, setFunc func(*StockMovementCreate, int)) *StockMovementCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &StockMovementCreateBulk{err: fmt.Errorf("calling to StockMovementClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*StockMovementCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &StockMovementCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for StockMovement.
func (c *StockMovementClient) Update() *StockMovementUpdate {
	mutation := newStockMovementMutation(c.config, OpUpdate)
	return &StockMovementUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *StockMovementClient) UpdateOne(_m *StockMovement) *StockMovementUpdateOne {
	mutation := newStockMovementMutation(c.config, OpUpdateOne, withStockMovement(_m))
	return &StockMovementUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *StockMovementClient) UpdateOneID(id int) *StockMovementUpdateOne {
	mutation := newStockMovementMutation(c.config, OpUpdateOne, withStockMovementID(id))
	return &StockMovementUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for StockMovement.
func (c *StockMovementClient) Delete() *StockMovementDelete {
	mutation := newStockMovementMutation(c.config, OpDelete)
	return &StockMovementDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *StockMovementClient) DeleteOne(_m *StockMovement) *StockMovementDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *StockMovementClient) DeleteOneID(id int) *StockMovementDeleteOne {
	builder := c.Delete().Where(stockmovement.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &StockMovementDeleteOne{builder}
}

// Query returns a query builder for StockMovement.
func (c *StockMovementClient) Query() *StockMovementQuery {
	return &StockMovementQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeStockMovement},
		inters: c.Interceptors(),
	}
}

// Get returns a StockMovement entity by its id.
func (c *StockMovementClient) Get(ctx context.Context, id int) (*StockMovement, error) {
	return c.Query().Where(stockmovement.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *StockMovementClient) GetX(ctx context.Context, id int) *StockMovement {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryProduct queries the product edge of a StockMovement.
func (c *StockMovementClient) QueryProduct(_m *StockMovement) *ProductQuery {
	query := (&ProductClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(stockmovement.Table, stockmovement.FieldID, id),
			sqlgraph.To(product.Table, product.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, stockmovement.ProductTable, stockmovement.ProductColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTenant queries the tenant edge of a StockMovement.
func (c *StockMovementClient) QueryTenant(_m *StockMovement) *TenantQuery {
	query := (&TenantClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(stockmovement.Table, stockmovement.FieldID, id),
			sqlgraph.To(tenant.Table, tenant.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, stockmovement.TenantTable, stockmovement.TenantColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *StockMovementClient) Hooks() []Hook {
	return c.hooks.StockMovement
}

// Interceptors returns the client interceptors.
func (c *StockMovementClient) Interceptors() []Interceptor {
	return c.inters.StockMovement
}

func (c *StockMovementClient) mutate(ctx context.Context, m *StockMovementMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&StockMovementCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&StockMovementUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&StockMovementUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&StockMovementDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown StockMovement mutation op: %q", m.Op())
	}
}

// StrategicRoadmapClient is a client for the StrategicRoadmap schema.
type StrategicRoadmapClient struct {
	config
}

// NewStrategicRoadmapClient returns a client for the StrategicRoadmap from the given config.
func NewStrategicRoadmapClient(c config) *StrategicRoadmapClient {
	return &StrategicRoadmapClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `strategicroadmap.Hooks(f(g(h())))`.
func (c *StrategicRoadmapClient) Use(hooks ...Hook) {
	c.hooks.StrategicRoadmap = append(c.hooks.StrategicRoadmap, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `strategicroadmap.Intercept(f(g(h())))`.
func (c *StrategicRoadmapClient) Intercept(interceptors ...Interceptor) {
	c.inters.StrategicRoadmap = append(c.inters.StrategicRoadmap, interceptors...)
}

// Create returns a builder for creating a StrategicRoadmap entity.
func (c *StrategicRoadmapClient) Create() *StrategicRoadmapCreate {
	mutation := newStrategicRoadmapMutation(c.config, OpCreate)
	return &StrategicRoadmapCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of StrategicRoadmap entities.
func (c *StrategicRoadmapClient) CreateBulk(builders ...*StrategicRoadmapCreate) *StrategicRoadmapCreateBulk {
	return &StrategicRoadmapCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *StrategicRoadmapClient) MapCreateBulk(slice any, setFunc func(*StrategicRoadmapCreate, int)) *StrategicRoadmapCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &StrategicRoadmapCreateBulk{err: fmt.Errorf("calling to StrategicRoadmapClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*StrategicRoadmapCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &StrategicRoadmapCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for StrategicRoadmap.
func (c *StrategicRoadmapClient) Update() *StrategicRoadmapUpdate {
	mutation := newStrategicRoadmapMutation(c.config, OpUpdate)
	return &StrategicRoadmapUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *StrategicRoadmapClient) UpdateOne(_m *StrategicRoadmap) *StrategicRoadmapUpdateOne {
	mutation := newStrategicRoadmapMutation(c.config, OpUpdateOne, withStrategicRoadmap(_m))
	return &StrategicRoadmapUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *StrategicRoadmapClient) UpdateOneID(id int) *StrategicRoadmapUpdateOne {
	mutation := newStrategicRoadmapMutation(c.config, OpUpdateOne, withStrategicRoadmapID(id))
	return &StrategicRoadmapUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for StrategicRoadmap.
func (c *StrategicRoadmapClient) Delete() *StrategicRoadmapDelete {
	mutation := newStrategicRoadmapMutation(c.config, OpDelete)
	return &StrategicRoadmapDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *StrategicRoadmapClient) DeleteOne(_m *StrategicRoadmap) *StrategicRoadmapDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *StrategicRoadmapClient) DeleteOneID(id int) *StrategicRoadmapDeleteOne {
	builder := c.Delete().Where(strategicroadmap.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &StrategicRoadmapDeleteOne{builder}
}

// Query returns a query builder for StrategicRoadmap.
func (c *StrategicRoadmapClient) Query() *StrategicRoadmapQuery {
	return &StrategicRoadmapQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeStrategicRoadmap},
		inters: c.Interceptors(),
	}
}

// Get returns a StrategicRoadmap entity by its id.
func (c *StrategicRoadmapClient) Get(ctx context.Context, id int) (*StrategicRoadmap, error) {
	return c.Query().Where(strategicroadmap.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *StrategicRoadmapClient) GetX(ctx context.Context, id int) *StrategicRoadmap {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryTenant queries the tenant edge of a StrategicRoadmap.
func (c *StrategicRoadmapClient) QueryTenant(_m *StrategicRoadmap) *TenantQuery {
	query := (&TenantClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(strategicroadmap.Table, strategicroadmap.FieldID, id),
			sqlgraph.To(tenant.Table, tenant.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, strategicroadmap.TenantTable, strategicroadmap.TenantColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *StrategicRoadmapClient) Hooks() []Hook {
	return c.hooks.StrategicRoadmap
}

// Interceptors returns the client interceptors.
func (c *StrategicRoadmapClient) Interceptors() []Interceptor {
	return c.inters.StrategicRoadmap
}

func (c *StrategicRoadmapClient) mutate(ctx context.Context, m *StrategicRoadmapMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&StrategicRoadmapCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&StrategicRoadmapUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&StrategicRoadmapUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&StrategicRoadmapDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown StrategicRoadmap mutation op: %q", m.Op())
	}
}

// SuccessionMapClient is a client for the SuccessionMap schema.
type SuccessionMapClient struct {
	config
}

// NewSuccessionMapClient returns a client for the SuccessionMap from the given config.
func NewSuccessionMapClient(c config) *SuccessionMapClient {
	return &SuccessionMapClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `successionmap.Hooks(f(g(h())))`.
func (c *SuccessionMapClient) Use(hooks ...Hook) {
	c.hooks.SuccessionMap = append(c.hooks.SuccessionMap, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `successionmap.Intercept(f(g(h())))`.
func (c *SuccessionMapClient) Intercept(interceptors ...Interceptor) {
	c.inters.SuccessionMap = append(c.inters.SuccessionMap, interceptors...)
}

// Create returns a builder for creating a SuccessionMap entity.
func (c *SuccessionMapClient) Create() *SuccessionMapCreate {
	mutation := newSuccessionMapMutation(c.config, OpCreate)
	return &SuccessionMapCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of SuccessionMap entities.
func (c *SuccessionMapClient) CreateBulk(builders ...*SuccessionMapCreate) *SuccessionMapCreateBulk {
	return &SuccessionMapCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *SuccessionMapClient) MapCreateBulk(slice any, setFunc func(*SuccessionMapCreate, int)) *SuccessionMapCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &SuccessionMapCreateBulk{err: fmt.Errorf("calling to SuccessionMapClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*SuccessionMapCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &SuccessionMapCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for SuccessionMap.
func (c *SuccessionMapClient) Update() *SuccessionMapUpdate {
	mutation := newSuccessionMapMutation(c.config, OpUpdate)
	return &SuccessionMapUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *SuccessionMapClient) UpdateOne(_m *SuccessionMap) *SuccessionMapUpdateOne {
	mutation := newSuccessionMapMutation(c.config, OpUpdateOne, withSuccessionMap(_m))
	return &SuccessionMapUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *SuccessionMapClient) UpdateOneID(id int) *SuccessionMapUpdateOne {
	mutation := newSuccessionMapMutation(c.config, OpUpdateOne, withSuccessionMapID(id))
	return &SuccessionMapUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for SuccessionMap.
func (c *SuccessionMapClient) Delete() *SuccessionMapDelete {
	mutation := newSuccessionMapMutation(c.config, OpDelete)
	return &SuccessionMapDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *SuccessionMapClient) DeleteOne(_m *SuccessionMap) *SuccessionMapDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *SuccessionMapClient) DeleteOneID(id int) *SuccessionMapDeleteOne {
	builder := c.Delete().Where(successionmap.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &SuccessionMapDeleteOne{builder}
}

// Query returns a query builder for SuccessionMap.
func (c *SuccessionMapClient) Query() *SuccessionMapQuery {
	return &SuccessionMapQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeSuccessionMap},
		inters: c.Interceptors(),
	}
}

// Get returns a SuccessionMap entity by its id.
func (c *SuccessionMapClient) Get(ctx context.Context, id int) (*SuccessionMap, error) {
	return c.Query().Where(successionmap.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *SuccessionMapClient) GetX(ctx context.Context, id int) *SuccessionMap {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryEmployee queries the employee edge of a SuccessionMap.
func (c *SuccessionMapClient) QueryEmployee(_m *SuccessionMap) *EmployeeQuery {
	query := (&EmployeeClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(successionmap.Table, successionmap.FieldID, id),
			sqlgraph.To(employee.Table, employee.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, successionmap.EmployeeTable, successionmap.EmployeeColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryBackupCandidate queries the backup_candidate edge of a SuccessionMap.
func (c *SuccessionMapClient) QueryBackupCandidate(_m *SuccessionMap) *EmployeeQuery {
	query := (&EmployeeClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(successionmap.Table, successionmap.FieldID, id),
			sqlgraph.To(employee.Table, employee.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, successionmap.BackupCandidateTable, successionmap.BackupCandidateColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTenant queries the tenant edge of a SuccessionMap.
func (c *SuccessionMapClient) QueryTenant(_m *SuccessionMap) *TenantQuery {
	query := (&TenantClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(successionmap.Table, successionmap.FieldID, id),
			sqlgraph.To(tenant.Table, tenant.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, successionmap.TenantTable, successionmap.TenantColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *SuccessionMapClient) Hooks() []Hook {
	return c.hooks.SuccessionMap
}

// Interceptors returns the client interceptors.
func (c *SuccessionMapClient) Interceptors() []Interceptor {
	return c.inters.SuccessionMap
}

func (c *SuccessionMapClient) mutate(ctx context.Context, m *SuccessionMapMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&SuccessionMapCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&SuccessionMapUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&SuccessionMapUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&SuccessionMapDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown SuccessionMap mutation op: %q", m.Op())
	}
}

// TenantClient is a client for the Tenant schema.
type TenantClient struct {
	config
}

// NewTenantClient returns a client for the Tenant from the given config.
func NewTenantClient(c config) *TenantClient {
	return &TenantClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `tenant.Hooks(f(g(h())))`.
func (c *TenantClient) Use(hooks ...Hook) {
	c.hooks.Tenant = append(c.hooks.Tenant, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `tenant.Intercept(f(g(h())))`.
func (c *TenantClient) Intercept(interceptors ...Interceptor) {
	c.inters.Tenant = append(c.inters.Tenant, interceptors...)
}

// Create returns a builder for creating a Tenant entity.
func (c *TenantClient) Create() *TenantCreate {
	mutation := newTenantMutation(c.config, OpCreate)
	return &TenantCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Tenant entities.
func (c *TenantClient) CreateBulk(builders ...*TenantCreate) *TenantCreateBulk {
	return &TenantCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *TenantClient) MapCreateBulk(slice any, setFunc func(*TenantCreate, int)) *TenantCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &TenantCreateBulk{err: fmt.Errorf("calling to TenantClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*TenantCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &TenantCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Tenant.
func (c *TenantClient) Update() *TenantUpdate {
	mutation := newTenantMutation(c.config, OpUpdate)
	return &TenantUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *TenantClient) UpdateOne(_m *Tenant) *TenantUpdateOne {
	mutation := newTenantMutation(c.config, OpUpdateOne, withTenant(_m))
	return &TenantUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *TenantClient) UpdateOneID(id int) *TenantUpdateOne {
	mutation := newTenantMutation(c.config, OpUpdateOne, withTenantID(id))
	return &TenantUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Tenant.
func (c *TenantClient) Delete() *TenantDelete {
	mutation := newTenantMutation(c.config, OpDelete)
	return &TenantDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *TenantClient) DeleteOne(_m *Tenant) *TenantDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *TenantClient) DeleteOneID(id int) *TenantDeleteOne {
	builder := c.Delete().Where(tenant.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &TenantDeleteOne{builder}
}

// Query returns a query builder for Tenant.
func (c *TenantClient) Query() *TenantQuery {
	return &TenantQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeTenant},
		inters: c.Interceptors(),
	}
}

// Get returns a Tenant entity by its id.
func (c *TenantClient) Get(ctx context.Context, id int) (*Tenant, error) {
	return c.Query().Where(tenant.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *TenantClient) GetX(ctx context.Context, id int) *Tenant {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryParent queries the parent edge of a Tenant.
func (c *TenantClient) QueryParent(_m *Tenant) *TenantQuery {
	query := (&TenantClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(tenant.Table, tenant.FieldID, id),
			sqlgraph.To(tenant.Table, tenant.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, tenant.ParentTable, tenant.ParentColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryChildren queries the children edge of a Tenant.
func (c *TenantClient) QueryChildren(_m *Tenant) *TenantQuery {
	query := (&TenantClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(tenant.Table, tenant.FieldID, id),
			sqlgraph.To(tenant.Table, tenant.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, tenant.ChildrenTable, tenant.ChildrenColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryUsers queries the users edge of a Tenant.
func (c *TenantClient) QueryUsers(_m *Tenant) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(tenant.Table, tenant.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, tenant.UsersTable, tenant.UsersColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryAccounts queries the accounts edge of a Tenant.
func (c *TenantClient) QueryAccounts(_m *Tenant) *AccountQuery {
	query := (&AccountClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(tenant.Table, tenant.FieldID, id),
			sqlgraph.To(account.Table, account.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, tenant.AccountsTable, tenant.AccountsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTransactions queries the transactions edge of a Tenant.
func (c *TenantClient) QueryTransactions(_m *Tenant) *TransactionQuery {
	query := (&TransactionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(tenant.Table, tenant.FieldID, id),
			sqlgraph.To(transaction.Table, transaction.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, tenant.TransactionsTable, tenant.TransactionsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryLedgerEntries queries the ledger_entries edge of a Tenant.
func (c *TenantClient) QueryLedgerEntries(_m *Tenant) *LedgerEntryQuery {
	query := (&LedgerEntryClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(tenant.Table, tenant.FieldID, id),
			sqlgraph.To(ledgerentry.Table, ledgerentry.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, tenant.LedgerEntriesTable, tenant.LedgerEntriesColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryProducts queries the products edge of a Tenant.
func (c *TenantClient) QueryProducts(_m *Tenant) *ProductQuery {
	query := (&ProductClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(tenant.Table, tenant.FieldID, id),
			sqlgraph.To(product.Table, product.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, tenant.ProductsTable, tenant.ProductsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryStockMovements queries the stock_movements edge of a Tenant.
func (c *TenantClient) QueryStockMovements(_m *Tenant) *StockMovementQuery {
	query := (&StockMovementClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(tenant.Table, tenant.FieldID, id),
			sqlgraph.To(stockmovement.Table, stockmovement.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, tenant.StockMovementsTable, tenant.StockMovementsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryAuditLogs queries the audit_logs edge of a Tenant.
func (c *TenantClient) QueryAuditLogs(_m *Tenant) *AuditLogQuery {
	query := (&AuditLogClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(tenant.Table, tenant.FieldID, id),
			sqlgraph.To(auditlog.Table, auditlog.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, tenant.AuditLogsTable, tenant.AuditLogsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryAgents queries the agents edge of a Tenant.
func (c *TenantClient) QueryAgents(_m *Tenant) *AgentQuery {
	query := (&AgentClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(tenant.Table, tenant.FieldID, id),
			sqlgraph.To(agent.Table, agent.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, tenant.AgentsTable, tenant.AgentsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryDiscoveryEntries queries the discovery_entries edge of a Tenant.
func (c *TenantClient) QueryDiscoveryEntries(_m *Tenant) *DiscoveryEntryQuery {
	query := (&DiscoveryEntryClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(tenant.Table, tenant.FieldID, id),
			sqlgraph.To(discoveryentry.Table, discoveryentry.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, tenant.DiscoveryEntriesTable, tenant.DiscoveryEntriesColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryAssets queries the assets edge of a Tenant.
func (c *TenantClient) QueryAssets(_m *Tenant) *AssetQuery {
	query := (&AssetClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(tenant.Table, tenant.FieldID, id),
			sqlgraph.To(asset.Table, asset.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, tenant.AssetsTable, tenant.AssetsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCredentials queries the credentials edge of a Tenant.
func (c *TenantClient) QueryCredentials(_m *Tenant) *CredentialQuery {
	query := (&CredentialClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(tenant.Table, tenant.FieldID, id),
			sqlgraph.To(credential.Table, credential.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, tenant.CredentialsTable, tenant.CredentialsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryOneTimeLinks queries the one_time_links edge of a Tenant.
func (c *TenantClient) QueryOneTimeLinks(_m *Tenant) *OneTimeLinkQuery {
	query := (&OneTimeLinkClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(tenant.Table, tenant.FieldID, id),
			sqlgraph.To(onetimelink.Table, onetimelink.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, tenant.OneTimeLinksTable, tenant.OneTimeLinksColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QuerySops queries the sops edge of a Tenant.
func (c *TenantClient) QuerySops(_m *Tenant) *SOPQuery {
	query := (&SOPClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(tenant.Table, tenant.FieldID, id),
			sqlgraph.To(sop.Table, sop.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, tenant.SopsTable, tenant.SopsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCameras queries the cameras edge of a Tenant.
func (c *TenantClient) QueryCameras(_m *Tenant) *CameraQuery {
	query := (&CameraClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(tenant.Table, tenant.FieldID, id),
			sqlgraph.To(camera.Table, camera.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, tenant.CamerasTable, tenant.CamerasColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTickets queries the tickets edge of a Tenant.
func (c *TenantClient) QueryTickets(_m *Tenant) *TicketQuery {
	query := (&TicketClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(tenant.Table, tenant.FieldID, id),
			sqlgraph.To(ticket.Table, ticket.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, tenant.TicketsTable, tenant.TicketsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryContracts queries the contracts edge of a Tenant.
func (c *TenantClient) QueryContracts(_m *Tenant) *ContractQuery {
	query := (&ContractClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(tenant.Table, tenant.FieldID, id),
			sqlgraph.To(contract.Table, contract.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, tenant.ContractsTable, tenant.ContractsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QuerySaasApps queries the saas_apps edge of a Tenant.
func (c *TenantClient) QuerySaasApps(_m *Tenant) *SaaSAppQuery {
	query := (&SaaSAppClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(tenant.Table, tenant.FieldID, id),
			sqlgraph.To(saasapp.Table, saasapp.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, tenant.SaasAppsTable, tenant.SaasAppsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QuerySaasFilters queries the saas_filters edge of a Tenant.
func (c *TenantClient) QuerySaasFilters(_m *Tenant) *SaaSFilterQuery {
	query := (&SaaSFilterClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(tenant.Table, tenant.FieldID, id),
			sqlgraph.To(saasfilter.Table, saasfilter.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, tenant.SaasFiltersTable, tenant.SaasFiltersColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCallLogs queries the call_logs edge of a Tenant.
func (c *TenantClient) QueryCallLogs(_m *Tenant) *CallLogQuery {
	query := (&CallLogClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(tenant.Table, tenant.FieldID, id),
			sqlgraph.To(calllog.Table, calllog.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, tenant.CallLogsTable, tenant.CallLogsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryIvrFlows queries the ivr_flows edge of a Tenant.
func (c *TenantClient) QueryIvrFlows(_m *Tenant) *IVRFlowQuery {
	query := (&IVRFlowClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(tenant.Table, tenant.FieldID, id),
			sqlgraph.To(ivrflow.Table, ivrflow.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, tenant.IvrFlowsTable, tenant.IvrFlowsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryVoicemails queries the voicemails edge of a Tenant.
func (c *TenantClient) QueryVoicemails(_m *Tenant) *VoicemailQuery {
	query := (&VoicemailClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(tenant.Table, tenant.FieldID, id),
			sqlgraph.To(voicemail.Table, voicemail.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, tenant.VoicemailsTable, tenant.VoicemailsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryHealthSnapshots queries the health_snapshots edge of a Tenant.
func (c *TenantClient) QueryHealthSnapshots(_m *Tenant) *HealthScoreSnapshotQuery {
	query := (&HealthScoreSnapshotClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(tenant.Table, tenant.FieldID, id),
			sqlgraph.To(healthscoresnapshot.Table, healthscoresnapshot.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, tenant.HealthSnapshotsTable, tenant.HealthSnapshotsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryRoadmaps queries the roadmaps edge of a Tenant.
func (c *TenantClient) QueryRoadmaps(_m *Tenant) *StrategicRoadmapQuery {
	query := (&StrategicRoadmapClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(tenant.Table, tenant.FieldID, id),
			sqlgraph.To(strategicroadmap.Table, strategicroadmap.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, tenant.RoadmapsTable, tenant.RoadmapsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryServiceRates queries the service_rates edge of a Tenant.
func (c *TenantClient) QueryServiceRates(_m *Tenant) *ServiceRateQuery {
	query := (&ServiceRateClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(tenant.Table, tenant.FieldID, id),
			sqlgraph.To(servicerate.Table, servicerate.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, tenant.ServiceRatesTable, tenant.ServiceRatesColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryNetworkDevices queries the network_devices edge of a Tenant.
func (c *TenantClient) QueryNetworkDevices(_m *Tenant) *NetworkDeviceQuery {
	query := (&NetworkDeviceClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(tenant.Table, tenant.FieldID, id),
			sqlgraph.To(networkdevice.Table, networkdevice.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, tenant.NetworkDevicesTable, tenant.NetworkDevicesColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryNetworkBackups queries the network_backups edge of a Tenant.
func (c *TenantClient) QueryNetworkBackups(_m *Tenant) *NetworkBackupQuery {
	query := (&NetworkBackupClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(tenant.Table, tenant.FieldID, id),
			sqlgraph.To(networkbackup.Table, networkbackup.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, tenant.NetworkBackupsTable, tenant.NetworkBackupsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryBudgetForecasts queries the budget_forecasts edge of a Tenant.
func (c *TenantClient) QueryBudgetForecasts(_m *Tenant) *BudgetForecastQuery {
	query := (&BudgetForecastClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(tenant.Table, tenant.FieldID, id),
			sqlgraph.To(budgetforecast.Table, budgetforecast.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, tenant.BudgetForecastsTable, tenant.BudgetForecastsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryEmployees queries the employees edge of a Tenant.
func (c *TenantClient) QueryEmployees(_m *Tenant) *EmployeeQuery {
	query := (&EmployeeClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(tenant.Table, tenant.FieldID, id),
			sqlgraph.To(employee.Table, employee.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, tenant.EmployeesTable, tenant.EmployeesColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCompensationAgreements queries the compensation_agreements edge of a Tenant.
func (c *TenantClient) QueryCompensationAgreements(_m *Tenant) *CompensationAgreementQuery {
	query := (&CompensationAgreementClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(tenant.Table, tenant.FieldID, id),
			sqlgraph.To(compensationagreement.Table, compensationagreement.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, tenant.CompensationAgreementsTable, tenant.CompensationAgreementsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryVaultItems queries the vault_items edge of a Tenant.
func (c *TenantClient) QueryVaultItems(_m *Tenant) *VaultItemQuery {
	query := (&VaultItemClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(tenant.Table, tenant.FieldID, id),
			sqlgraph.To(vaultitem.Table, vaultitem.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, tenant.VaultItemsTable, tenant.VaultItemsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryJournalEntries queries the journal_entries edge of a Tenant.
func (c *TenantClient) QueryJournalEntries(_m *Tenant) *JournalEntryQuery {
	query := (&JournalEntryClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(tenant.Table, tenant.FieldID, id),
			sqlgraph.To(journalentry.Table, journalentry.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, tenant.JournalEntriesTable, tenant.JournalEntriesColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryRecurringInvoices queries the recurring_invoices edge of a Tenant.
func (c *TenantClient) QueryRecurringInvoices(_m *Tenant) *RecurringInvoiceQuery {
	query := (&RecurringInvoiceClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(tenant.Table, tenant.FieldID, id),
			sqlgraph.To(recurringinvoice.Table, recurringinvoice.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, tenant.RecurringInvoicesTable, tenant.RecurringInvoicesColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryInventoryReservations queries the inventory_reservations edge of a Tenant.
func (c *TenantClient) QueryInventoryReservations(_m *Tenant) *InventoryReservationQuery {
	query := (&InventoryReservationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(tenant.Table, tenant.FieldID, id),
			sqlgraph.To(inventoryreservation.Table, inventoryreservation.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, tenant.InventoryReservationsTable, tenant.InventoryReservationsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryDepartments queries the departments edge of a Tenant.
func (c *TenantClient) QueryDepartments(_m *Tenant) *DepartmentQuery {
	query := (&DepartmentClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(tenant.Table, tenant.FieldID, id),
			sqlgraph.To(department.Table, department.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, tenant.DepartmentsTable, tenant.DepartmentsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryPermissions queries the permissions edge of a Tenant.
func (c *TenantClient) QueryPermissions(_m *Tenant) *PermissionQuery {
	query := (&PermissionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(tenant.Table, tenant.FieldID, id),
			sqlgraph.To(permission.Table, permission.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, tenant.PermissionsTable, tenant.PermissionsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryAssetTypes queries the asset_types edge of a Tenant.
func (c *TenantClient) QueryAssetTypes(_m *Tenant) *AssetTypeQuery {
	query := (&AssetTypeClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(tenant.Table, tenant.FieldID, id),
			sqlgraph.To(assettype.Table, assettype.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, tenant.AssetTypesTable, tenant.AssetTypesColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryDetectionEvents queries the detection_events edge of a Tenant.
func (c *TenantClient) QueryDetectionEvents(_m *Tenant) *DetectionEventQuery {
	query := (&DetectionEventClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(tenant.Table, tenant.FieldID, id),
			sqlgraph.To(detectionevent.Table, detectionevent.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, tenant.DetectionEventsTable, tenant.DetectionEventsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QuerySaasIdentities queries the saas_identities edge of a Tenant.
func (c *TenantClient) QuerySaasIdentities(_m *Tenant) *SaaSIdentityQuery {
	query := (&SaaSIdentityClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(tenant.Table, tenant.FieldID, id),
			sqlgraph.To(saasidentity.Table, saasidentity.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, tenant.SaasIdentitiesTable, tenant.SaasIdentitiesColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QuerySaasUsages queries the saas_usages edge of a Tenant.
func (c *TenantClient) QuerySaasUsages(_m *Tenant) *SaaSUsageQuery {
	query := (&SaaSUsageClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(tenant.Table, tenant.FieldID, id),
			sqlgraph.To(saasusage.Table, saasusage.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, tenant.SaasUsagesTable, tenant.SaasUsagesColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryRecordings queries the recordings edge of a Tenant.
func (c *TenantClient) QueryRecordings(_m *Tenant) *RecordingQuery {
	query := (&RecordingClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(tenant.Table, tenant.FieldID, id),
			sqlgraph.To(recording.Table, recording.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, tenant.RecordingsTable, tenant.RecordingsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryNetworkLinks queries the network_links edge of a Tenant.
func (c *TenantClient) QueryNetworkLinks(_m *Tenant) *NetworkLinkQuery {
	query := (&NetworkLinkClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(tenant.Table, tenant.FieldID, id),
			sqlgraph.To(networklink.Table, networklink.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, tenant.NetworkLinksTable, tenant.NetworkLinksColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryNetworkPorts queries the network_ports edge of a Tenant.
func (c *TenantClient) QueryNetworkPorts(_m *Tenant) *NetworkPortQuery {
	query := (&NetworkPortClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(tenant.Table, tenant.FieldID, id),
			sqlgraph.To(networkport.Table, networkport.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, tenant.NetworkPortsTable, tenant.NetworkPortsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryNexusAudits queries the nexus_audits edge of a Tenant.
func (c *TenantClient) QueryNexusAudits(_m *Tenant) *NexusAuditQuery {
	query := (&NexusAuditClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(tenant.Table, tenant.FieldID, id),
			sqlgraph.To(nexusaudit.Table, nexusaudit.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, tenant.NexusAuditsTable, tenant.NexusAuditsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QuerySuccessionMaps queries the succession_maps edge of a Tenant.
func (c *TenantClient) QuerySuccessionMaps(_m *Tenant) *SuccessionMapQuery {
	query := (&SuccessionMapClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(tenant.Table, tenant.FieldID, id),
			sqlgraph.To(successionmap.Table, successionmap.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, tenant.SuccessionMapsTable, tenant.SuccessionMapsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCustomerAccount queries the customer_account edge of a Tenant.
func (c *TenantClient) QueryCustomerAccount(_m *Tenant) *AccountQuery {
	query := (&AccountClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(tenant.Table, tenant.FieldID, id),
			sqlgraph.To(account.Table, account.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, tenant.CustomerAccountTable, tenant.CustomerAccountColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryScripts queries the scripts edge of a Tenant.
func (c *TenantClient) QueryScripts(_m *Tenant) *ScriptQuery {
	query := (&ScriptClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(tenant.Table, tenant.FieldID, id),
			sqlgraph.To(script.Table, script.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, tenant.ScriptsTable, tenant.ScriptsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryJobs queries the jobs edge of a Tenant.
func (c *TenantClient) QueryJobs(_m *Tenant) *JobQuery {
	query := (&JobClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(tenant.Table, tenant.FieldID, id),
			sqlgraph.To(job.Table, job.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, tenant.JobsTable, tenant.JobsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTimeOffRequests queries the time_off_requests edge of a Tenant.
func (c *TenantClient) QueryTimeOffRequests(_m *Tenant) *TimeOffRequestQuery {
	query := (&TimeOffRequestClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(tenant.Table, tenant.FieldID, id),
			sqlgraph.To(timeoffrequest.Table, timeoffrequest.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, tenant.TimeOffRequestsTable, tenant.TimeOffRequestsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTimeOffPolicies queries the time_off_policies edge of a Tenant.
func (c *TenantClient) QueryTimeOffPolicies(_m *Tenant) *TimeOffPolicyQuery {
	query := (&TimeOffPolicyClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(tenant.Table, tenant.FieldID, id),
			sqlgraph.To(timeoffpolicy.Table, timeoffpolicy.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, tenant.TimeOffPoliciesTable, tenant.TimeOffPoliciesColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTimeOffBalances queries the time_off_balances edge of a Tenant.
func (c *TenantClient) QueryTimeOffBalances(_m *Tenant) *TimeOffBalanceQuery {
	query := (&TimeOffBalanceClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(tenant.Table, tenant.FieldID, id),
			sqlgraph.To(timeoffbalance.Table, timeoffbalance.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, tenant.TimeOffBalancesTable, tenant.TimeOffBalancesColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryReviewCycles queries the review_cycles edge of a Tenant.
func (c *TenantClient) QueryReviewCycles(_m *Tenant) *ReviewCycleQuery {
	query := (&ReviewCycleClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(tenant.Table, tenant.FieldID, id),
			sqlgraph.To(reviewcycle.Table, reviewcycle.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, tenant.ReviewCyclesTable, tenant.ReviewCyclesColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryPerformanceReviews queries the performance_reviews edge of a Tenant.
func (c *TenantClient) QueryPerformanceReviews(_m *Tenant) *PerformanceReviewQuery {
	query := (&PerformanceReviewClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(tenant.Table, tenant.FieldID, id),
			sqlgraph.To(performancereview.Table, performancereview.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, tenant.PerformanceReviewsTable, tenant.PerformanceReviewsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryGoals queries the goals edge of a Tenant.
func (c *TenantClient) QueryGoals(_m *Tenant) *GoalQuery {
	query := (&GoalClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(tenant.Table, tenant.FieldID, id),
			sqlgraph.To(goal.Table, goal.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, tenant.GoalsTable, tenant.GoalsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *TenantClient) Hooks() []Hook {
	return c.hooks.Tenant
}

// Interceptors returns the client interceptors.
func (c *TenantClient) Interceptors() []Interceptor {
	return c.inters.Tenant
}

func (c *TenantClient) mutate(ctx context.Context, m *TenantMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&TenantCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&TenantUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&TenantUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&TenantDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Tenant mutation op: %q", m.Op())
	}
}

// TicketClient is a client for the Ticket schema.
type TicketClient struct {
	config
}

// NewTicketClient returns a client for the Ticket from the given config.
func NewTicketClient(c config) *TicketClient {
	return &TicketClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `ticket.Hooks(f(g(h())))`.
func (c *TicketClient) Use(hooks ...Hook) {
	c.hooks.Ticket = append(c.hooks.Ticket, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `ticket.Intercept(f(g(h())))`.
func (c *TicketClient) Intercept(interceptors ...Interceptor) {
	c.inters.Ticket = append(c.inters.Ticket, interceptors...)
}

// Create returns a builder for creating a Ticket entity.
func (c *TicketClient) Create() *TicketCreate {
	mutation := newTicketMutation(c.config, OpCreate)
	return &TicketCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Ticket entities.
func (c *TicketClient) CreateBulk(builders ...*TicketCreate) *TicketCreateBulk {
	return &TicketCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *TicketClient) MapCreateBulk(slice any, setFunc func(*TicketCreate, int)) *TicketCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &TicketCreateBulk{err: fmt.Errorf("calling to TicketClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*TicketCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &TicketCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Ticket.
func (c *TicketClient) Update() *TicketUpdate {
	mutation := newTicketMutation(c.config, OpUpdate)
	return &TicketUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *TicketClient) UpdateOne(_m *Ticket) *TicketUpdateOne {
	mutation := newTicketMutation(c.config, OpUpdateOne, withTicket(_m))
	return &TicketUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *TicketClient) UpdateOneID(id int) *TicketUpdateOne {
	mutation := newTicketMutation(c.config, OpUpdateOne, withTicketID(id))
	return &TicketUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Ticket.
func (c *TicketClient) Delete() *TicketDelete {
	mutation := newTicketMutation(c.config, OpDelete)
	return &TicketDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *TicketClient) DeleteOne(_m *Ticket) *TicketDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *TicketClient) DeleteOneID(id int) *TicketDeleteOne {
	builder := c.Delete().Where(ticket.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &TicketDeleteOne{builder}
}

// Query returns a query builder for Ticket.
func (c *TicketClient) Query() *TicketQuery {
	return &TicketQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeTicket},
		inters: c.Interceptors(),
	}
}

// Get returns a Ticket entity by its id.
func (c *TicketClient) Get(ctx context.Context, id int) (*Ticket, error) {
	return c.Query().Where(ticket.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *TicketClient) GetX(ctx context.Context, id int) *Ticket {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryTenant queries the tenant edge of a Ticket.
func (c *TicketClient) QueryTenant(_m *Ticket) *TenantQuery {
	query := (&TenantClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(ticket.Table, ticket.FieldID, id),
			sqlgraph.To(tenant.Table, tenant.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, ticket.TenantTable, ticket.TenantColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryRequester queries the requester edge of a Ticket.
func (c *TicketClient) QueryRequester(_m *Ticket) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(ticket.Table, ticket.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, ticket.RequesterTable, ticket.RequesterColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryAssignee queries the assignee edge of a Ticket.
func (c *TicketClient) QueryAssignee(_m *Ticket) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(ticket.Table, ticket.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, ticket.AssigneeTable, ticket.AssigneeColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryAsset queries the asset edge of a Ticket.
func (c *TicketClient) QueryAsset(_m *Ticket) *AssetQuery {
	query := (&AssetClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(ticket.Table, ticket.FieldID, id),
			sqlgraph.To(asset.Table, asset.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, ticket.AssetTable, ticket.AssetColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTimeEntries queries the time_entries edge of a Ticket.
func (c *TicketClient) QueryTimeEntries(_m *Ticket) *TimeEntryQuery {
	query := (&TimeEntryClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(ticket.Table, ticket.FieldID, id),
			sqlgraph.To(timeentry.Table, timeentry.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, ticket.TimeEntriesTable, ticket.TimeEntriesColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryRemediationSteps queries the remediation_steps edge of a Ticket.
func (c *TicketClient) QueryRemediationSteps(_m *Ticket) *RemediationStepQuery {
	query := (&RemediationStepClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(ticket.Table, ticket.FieldID, id),
			sqlgraph.To(remediationstep.Table, remediationstep.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, ticket.RemediationStepsTable, ticket.RemediationStepsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *TicketClient) Hooks() []Hook {
	return c.hooks.Ticket
}

// Interceptors returns the client interceptors.
func (c *TicketClient) Interceptors() []Interceptor {
	return c.inters.Ticket
}

func (c *TicketClient) mutate(ctx context.Context, m *TicketMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&TicketCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&TicketUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&TicketUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&TicketDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Ticket mutation op: %q", m.Op())
	}
}

// TimeEntryClient is a client for the TimeEntry schema.
type TimeEntryClient struct {
	config
}

// NewTimeEntryClient returns a client for the TimeEntry from the given config.
func NewTimeEntryClient(c config) *TimeEntryClient {
	return &TimeEntryClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `timeentry.Hooks(f(g(h())))`.
func (c *TimeEntryClient) Use(hooks ...Hook) {
	c.hooks.TimeEntry = append(c.hooks.TimeEntry, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `timeentry.Intercept(f(g(h())))`.
func (c *TimeEntryClient) Intercept(interceptors ...Interceptor) {
	c.inters.TimeEntry = append(c.inters.TimeEntry, interceptors...)
}

// Create returns a builder for creating a TimeEntry entity.
func (c *TimeEntryClient) Create() *TimeEntryCreate {
	mutation := newTimeEntryMutation(c.config, OpCreate)
	return &TimeEntryCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of TimeEntry entities.
func (c *TimeEntryClient) CreateBulk(builders ...*TimeEntryCreate) *TimeEntryCreateBulk {
	return &TimeEntryCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *TimeEntryClient) MapCreateBulk(slice any, setFunc func(*TimeEntryCreate, int)) *TimeEntryCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &TimeEntryCreateBulk{err: fmt.Errorf("calling to TimeEntryClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*TimeEntryCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &TimeEntryCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for TimeEntry.
func (c *TimeEntryClient) Update() *TimeEntryUpdate {
	mutation := newTimeEntryMutation(c.config, OpUpdate)
	return &TimeEntryUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *TimeEntryClient) UpdateOne(_m *TimeEntry) *TimeEntryUpdateOne {
	mutation := newTimeEntryMutation(c.config, OpUpdateOne, withTimeEntry(_m))
	return &TimeEntryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *TimeEntryClient) UpdateOneID(id int) *TimeEntryUpdateOne {
	mutation := newTimeEntryMutation(c.config, OpUpdateOne, withTimeEntryID(id))
	return &TimeEntryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for TimeEntry.
func (c *TimeEntryClient) Delete() *TimeEntryDelete {
	mutation := newTimeEntryMutation(c.config, OpDelete)
	return &TimeEntryDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *TimeEntryClient) DeleteOne(_m *TimeEntry) *TimeEntryDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *TimeEntryClient) DeleteOneID(id int) *TimeEntryDeleteOne {
	builder := c.Delete().Where(timeentry.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &TimeEntryDeleteOne{builder}
}

// Query returns a query builder for TimeEntry.
func (c *TimeEntryClient) Query() *TimeEntryQuery {
	return &TimeEntryQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeTimeEntry},
		inters: c.Interceptors(),
	}
}

// Get returns a TimeEntry entity by its id.
func (c *TimeEntryClient) Get(ctx context.Context, id int) (*TimeEntry, error) {
	return c.Query().Where(timeentry.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *TimeEntryClient) GetX(ctx context.Context, id int) *TimeEntry {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryTicket queries the ticket edge of a TimeEntry.
func (c *TimeEntryClient) QueryTicket(_m *TimeEntry) *TicketQuery {
	query := (&TicketClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(timeentry.Table, timeentry.FieldID, id),
			sqlgraph.To(ticket.Table, ticket.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, timeentry.TicketTable, timeentry.TicketColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTechnician queries the technician edge of a TimeEntry.
func (c *TimeEntryClient) QueryTechnician(_m *TimeEntry) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(timeentry.Table, timeentry.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, timeentry.TechnicianTable, timeentry.TechnicianColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *TimeEntryClient) Hooks() []Hook {
	return c.hooks.TimeEntry
}

// Interceptors returns the client interceptors.
func (c *TimeEntryClient) Interceptors() []Interceptor {
	return c.inters.TimeEntry
}

func (c *TimeEntryClient) mutate(ctx context.Context, m *TimeEntryMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&TimeEntryCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&TimeEntryUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&TimeEntryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&TimeEntryDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown TimeEntry mutation op: %q", m.Op())
	}
}

// TimeOffBalanceClient is a client for the TimeOffBalance schema.
type TimeOffBalanceClient struct {
	config
}

// NewTimeOffBalanceClient returns a client for the TimeOffBalance from the given config.
func NewTimeOffBalanceClient(c config) *TimeOffBalanceClient {
	return &TimeOffBalanceClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `timeoffbalance.Hooks(f(g(h())))`.
func (c *TimeOffBalanceClient) Use(hooks ...Hook) {
	c.hooks.TimeOffBalance = append(c.hooks.TimeOffBalance, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `timeoffbalance.Intercept(f(g(h())))`.
func (c *TimeOffBalanceClient) Intercept(interceptors ...Interceptor) {
	c.inters.TimeOffBalance = append(c.inters.TimeOffBalance, interceptors...)
}

// Create returns a builder for creating a TimeOffBalance entity.
func (c *TimeOffBalanceClient) Create() *TimeOffBalanceCreate {
	mutation := newTimeOffBalanceMutation(c.config, OpCreate)
	return &TimeOffBalanceCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of TimeOffBalance entities.
func (c *TimeOffBalanceClient) CreateBulk(builders ...*TimeOffBalanceCreate) *TimeOffBalanceCreateBulk {
	return &TimeOffBalanceCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *TimeOffBalanceClient) MapCreateBulk(slice any, setFunc func(*TimeOffBalanceCreate, int)) *TimeOffBalanceCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &TimeOffBalanceCreateBulk{err: fmt.Errorf("calling to TimeOffBalanceClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*TimeOffBalanceCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &TimeOffBalanceCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for TimeOffBalance.
func (c *TimeOffBalanceClient) Update() *TimeOffBalanceUpdate {
	mutation := newTimeOffBalanceMutation(c.config, OpUpdate)
	return &TimeOffBalanceUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *TimeOffBalanceClient) UpdateOne(_m *TimeOffBalance) *TimeOffBalanceUpdateOne {
	mutation := newTimeOffBalanceMutation(c.config, OpUpdateOne, withTimeOffBalance(_m))
	return &TimeOffBalanceUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *TimeOffBalanceClient) UpdateOneID(id int) *TimeOffBalanceUpdateOne {
	mutation := newTimeOffBalanceMutation(c.config, OpUpdateOne, withTimeOffBalanceID(id))
	return &TimeOffBalanceUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for TimeOffBalance.
func (c *TimeOffBalanceClient) Delete() *TimeOffBalanceDelete {
	mutation := newTimeOffBalanceMutation(c.config, OpDelete)
	return &TimeOffBalanceDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *TimeOffBalanceClient) DeleteOne(_m *TimeOffBalance) *TimeOffBalanceDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *TimeOffBalanceClient) DeleteOneID(id int) *TimeOffBalanceDeleteOne {
	builder := c.Delete().Where(timeoffbalance.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &TimeOffBalanceDeleteOne{builder}
}

// Query returns a query builder for TimeOffBalance.
func (c *TimeOffBalanceClient) Query() *TimeOffBalanceQuery {
	return &TimeOffBalanceQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeTimeOffBalance},
		inters: c.Interceptors(),
	}
}

// Get returns a TimeOffBalance entity by its id.
func (c *TimeOffBalanceClient) Get(ctx context.Context, id int) (*TimeOffBalance, error) {
	return c.Query().Where(timeoffbalance.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *TimeOffBalanceClient) GetX(ctx context.Context, id int) *TimeOffBalance {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryTenant queries the tenant edge of a TimeOffBalance.
func (c *TimeOffBalanceClient) QueryTenant(_m *TimeOffBalance) *TenantQuery {
	query := (&TenantClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(timeoffbalance.Table, timeoffbalance.FieldID, id),
			sqlgraph.To(tenant.Table, tenant.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, timeoffbalance.TenantTable, timeoffbalance.TenantColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryEmployee queries the employee edge of a TimeOffBalance.
func (c *TimeOffBalanceClient) QueryEmployee(_m *TimeOffBalance) *EmployeeQuery {
	query := (&EmployeeClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(timeoffbalance.Table, timeoffbalance.FieldID, id),
			sqlgraph.To(employee.Table, employee.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, timeoffbalance.EmployeeTable, timeoffbalance.EmployeeColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryPolicy queries the policy edge of a TimeOffBalance.
func (c *TimeOffBalanceClient) QueryPolicy(_m *TimeOffBalance) *TimeOffPolicyQuery {
	query := (&TimeOffPolicyClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(timeoffbalance.Table, timeoffbalance.FieldID, id),
			sqlgraph.To(timeoffpolicy.Table, timeoffpolicy.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, timeoffbalance.PolicyTable, timeoffbalance.PolicyColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *TimeOffBalanceClient) Hooks() []Hook {
	return c.hooks.TimeOffBalance
}

// Interceptors returns the client interceptors.
func (c *TimeOffBalanceClient) Interceptors() []Interceptor {
	return c.inters.TimeOffBalance
}

func (c *TimeOffBalanceClient) mutate(ctx context.Context, m *TimeOffBalanceMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&TimeOffBalanceCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&TimeOffBalanceUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&TimeOffBalanceUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&TimeOffBalanceDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown TimeOffBalance mutation op: %q", m.Op())
	}
}

// TimeOffPolicyClient is a client for the TimeOffPolicy schema.
type TimeOffPolicyClient struct {
	config
}

// NewTimeOffPolicyClient returns a client for the TimeOffPolicy from the given config.
func NewTimeOffPolicyClient(c config) *TimeOffPolicyClient {
	return &TimeOffPolicyClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `timeoffpolicy.Hooks(f(g(h())))`.
func (c *TimeOffPolicyClient) Use(hooks ...Hook) {
	c.hooks.TimeOffPolicy = append(c.hooks.TimeOffPolicy, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `timeoffpolicy.Intercept(f(g(h())))`.
func (c *TimeOffPolicyClient) Intercept(interceptors ...Interceptor) {
	c.inters.TimeOffPolicy = append(c.inters.TimeOffPolicy, interceptors...)
}

// Create returns a builder for creating a TimeOffPolicy entity.
func (c *TimeOffPolicyClient) Create() *TimeOffPolicyCreate {
	mutation := newTimeOffPolicyMutation(c.config, OpCreate)
	return &TimeOffPolicyCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of TimeOffPolicy entities.
func (c *TimeOffPolicyClient) CreateBulk(builders ...*TimeOffPolicyCreate) *TimeOffPolicyCreateBulk {
	return &TimeOffPolicyCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *TimeOffPolicyClient) MapCreateBulk(slice any, setFunc func(*TimeOffPolicyCreate, int)) *TimeOffPolicyCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &TimeOffPolicyCreateBulk{err: fmt.Errorf("calling to TimeOffPolicyClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*TimeOffPolicyCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &TimeOffPolicyCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for TimeOffPolicy.
func (c *TimeOffPolicyClient) Update() *TimeOffPolicyUpdate {
	mutation := newTimeOffPolicyMutation(c.config, OpUpdate)
	return &TimeOffPolicyUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *TimeOffPolicyClient) UpdateOne(_m *TimeOffPolicy) *TimeOffPolicyUpdateOne {
	mutation := newTimeOffPolicyMutation(c.config, OpUpdateOne, withTimeOffPolicy(_m))
	return &TimeOffPolicyUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *TimeOffPolicyClient) UpdateOneID(id int) *TimeOffPolicyUpdateOne {
	mutation := newTimeOffPolicyMutation(c.config, OpUpdateOne, withTimeOffPolicyID(id))
	return &TimeOffPolicyUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for TimeOffPolicy.
func (c *TimeOffPolicyClient) Delete() *TimeOffPolicyDelete {
	mutation := newTimeOffPolicyMutation(c.config, OpDelete)
	return &TimeOffPolicyDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *TimeOffPolicyClient) DeleteOne(_m *TimeOffPolicy) *TimeOffPolicyDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *TimeOffPolicyClient) DeleteOneID(id int) *TimeOffPolicyDeleteOne {
	builder := c.Delete().Where(timeoffpolicy.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &TimeOffPolicyDeleteOne{builder}
}

// Query returns a query builder for TimeOffPolicy.
func (c *TimeOffPolicyClient) Query() *TimeOffPolicyQuery {
	return &TimeOffPolicyQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeTimeOffPolicy},
		inters: c.Interceptors(),
	}
}

// Get returns a TimeOffPolicy entity by its id.
func (c *TimeOffPolicyClient) Get(ctx context.Context, id int) (*TimeOffPolicy, error) {
	return c.Query().Where(timeoffpolicy.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *TimeOffPolicyClient) GetX(ctx context.Context, id int) *TimeOffPolicy {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryTenant queries the tenant edge of a TimeOffPolicy.
func (c *TimeOffPolicyClient) QueryTenant(_m *TimeOffPolicy) *TenantQuery {
	query := (&TenantClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(timeoffpolicy.Table, timeoffpolicy.FieldID, id),
			sqlgraph.To(tenant.Table, tenant.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, timeoffpolicy.TenantTable, timeoffpolicy.TenantColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryBalances queries the balances edge of a TimeOffPolicy.
func (c *TimeOffPolicyClient) QueryBalances(_m *TimeOffPolicy) *TimeOffBalanceQuery {
	query := (&TimeOffBalanceClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(timeoffpolicy.Table, timeoffpolicy.FieldID, id),
			sqlgraph.To(timeoffbalance.Table, timeoffbalance.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, timeoffpolicy.BalancesTable, timeoffpolicy.BalancesColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *TimeOffPolicyClient) Hooks() []Hook {
	return c.hooks.TimeOffPolicy
}

// Interceptors returns the client interceptors.
func (c *TimeOffPolicyClient) Interceptors() []Interceptor {
	return c.inters.TimeOffPolicy
}

func (c *TimeOffPolicyClient) mutate(ctx context.Context, m *TimeOffPolicyMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&TimeOffPolicyCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&TimeOffPolicyUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&TimeOffPolicyUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&TimeOffPolicyDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown TimeOffPolicy mutation op: %q", m.Op())
	}
}

// TimeOffRequestClient is a client for the TimeOffRequest schema.
type TimeOffRequestClient struct {
	config
}

// NewTimeOffRequestClient returns a client for the TimeOffRequest from the given config.
func NewTimeOffRequestClient(c config) *TimeOffRequestClient {
	return &TimeOffRequestClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `timeoffrequest.Hooks(f(g(h())))`.
func (c *TimeOffRequestClient) Use(hooks ...Hook) {
	c.hooks.TimeOffRequest = append(c.hooks.TimeOffRequest, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `timeoffrequest.Intercept(f(g(h())))`.
func (c *TimeOffRequestClient) Intercept(interceptors ...Interceptor) {
	c.inters.TimeOffRequest = append(c.inters.TimeOffRequest, interceptors...)
}

// Create returns a builder for creating a TimeOffRequest entity.
func (c *TimeOffRequestClient) Create() *TimeOffRequestCreate {
	mutation := newTimeOffRequestMutation(c.config, OpCreate)
	return &TimeOffRequestCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of TimeOffRequest entities.
func (c *TimeOffRequestClient) CreateBulk(builders ...*TimeOffRequestCreate) *TimeOffRequestCreateBulk {
	return &TimeOffRequestCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *TimeOffRequestClient) MapCreateBulk(slice any, setFunc func(*TimeOffRequestCreate, int)) *TimeOffRequestCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &TimeOffRequestCreateBulk{err: fmt.Errorf("calling to TimeOffRequestClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*TimeOffRequestCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &TimeOffRequestCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for TimeOffRequest.
func (c *TimeOffRequestClient) Update() *TimeOffRequestUpdate {
	mutation := newTimeOffRequestMutation(c.config, OpUpdate)
	return &TimeOffRequestUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *TimeOffRequestClient) UpdateOne(_m *TimeOffRequest) *TimeOffRequestUpdateOne {
	mutation := newTimeOffRequestMutation(c.config, OpUpdateOne, withTimeOffRequest(_m))
	return &TimeOffRequestUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *TimeOffRequestClient) UpdateOneID(id int) *TimeOffRequestUpdateOne {
	mutation := newTimeOffRequestMutation(c.config, OpUpdateOne, withTimeOffRequestID(id))
	return &TimeOffRequestUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for TimeOffRequest.
func (c *TimeOffRequestClient) Delete() *TimeOffRequestDelete {
	mutation := newTimeOffRequestMutation(c.config, OpDelete)
	return &TimeOffRequestDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *TimeOffRequestClient) DeleteOne(_m *TimeOffRequest) *TimeOffRequestDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *TimeOffRequestClient) DeleteOneID(id int) *TimeOffRequestDeleteOne {
	builder := c.Delete().Where(timeoffrequest.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &TimeOffRequestDeleteOne{builder}
}

// Query returns a query builder for TimeOffRequest.
func (c *TimeOffRequestClient) Query() *TimeOffRequestQuery {
	return &TimeOffRequestQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeTimeOffRequest},
		inters: c.Interceptors(),
	}
}

// Get returns a TimeOffRequest entity by its id.
func (c *TimeOffRequestClient) Get(ctx context.Context, id int) (*TimeOffRequest, error) {
	return c.Query().Where(timeoffrequest.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *TimeOffRequestClient) GetX(ctx context.Context, id int) *TimeOffRequest {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryTenant queries the tenant edge of a TimeOffRequest.
func (c *TimeOffRequestClient) QueryTenant(_m *TimeOffRequest) *TenantQuery {
	query := (&TenantClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(timeoffrequest.Table, timeoffrequest.FieldID, id),
			sqlgraph.To(tenant.Table, tenant.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, timeoffrequest.TenantTable, timeoffrequest.TenantColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryEmployee queries the employee edge of a TimeOffRequest.
func (c *TimeOffRequestClient) QueryEmployee(_m *TimeOffRequest) *EmployeeQuery {
	query := (&EmployeeClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(timeoffrequest.Table, timeoffrequest.FieldID, id),
			sqlgraph.To(employee.Table, employee.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, timeoffrequest.EmployeeTable, timeoffrequest.EmployeeColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryApprovedBy queries the approved_by edge of a TimeOffRequest.
func (c *TimeOffRequestClient) QueryApprovedBy(_m *TimeOffRequest) *EmployeeQuery {
	query := (&EmployeeClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(timeoffrequest.Table, timeoffrequest.FieldID, id),
			sqlgraph.To(employee.Table, employee.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, timeoffrequest.ApprovedByTable, timeoffrequest.ApprovedByColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *TimeOffRequestClient) Hooks() []Hook {
	return c.hooks.TimeOffRequest
}

// Interceptors returns the client interceptors.
func (c *TimeOffRequestClient) Interceptors() []Interceptor {
	return c.inters.TimeOffRequest
}

func (c *TimeOffRequestClient) mutate(ctx context.Context, m *TimeOffRequestMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&TimeOffRequestCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&TimeOffRequestUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&TimeOffRequestUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&TimeOffRequestDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown TimeOffRequest mutation op: %q", m.Op())
	}
}

// TransactionClient is a client for the Transaction schema.
type TransactionClient struct {
	config
}

// NewTransactionClient returns a client for the Transaction from the given config.
func NewTransactionClient(c config) *TransactionClient {
	return &TransactionClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `transaction.Hooks(f(g(h())))`.
func (c *TransactionClient) Use(hooks ...Hook) {
	c.hooks.Transaction = append(c.hooks.Transaction, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `transaction.Intercept(f(g(h())))`.
func (c *TransactionClient) Intercept(interceptors ...Interceptor) {
	c.inters.Transaction = append(c.inters.Transaction, interceptors...)
}

// Create returns a builder for creating a Transaction entity.
func (c *TransactionClient) Create() *TransactionCreate {
	mutation := newTransactionMutation(c.config, OpCreate)
	return &TransactionCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Transaction entities.
func (c *TransactionClient) CreateBulk(builders ...*TransactionCreate) *TransactionCreateBulk {
	return &TransactionCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *TransactionClient) MapCreateBulk(slice any, setFunc func(*TransactionCreate, int)) *TransactionCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &TransactionCreateBulk{err: fmt.Errorf("calling to TransactionClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*TransactionCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &TransactionCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Transaction.
func (c *TransactionClient) Update() *TransactionUpdate {
	mutation := newTransactionMutation(c.config, OpUpdate)
	return &TransactionUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *TransactionClient) UpdateOne(_m *Transaction) *TransactionUpdateOne {
	mutation := newTransactionMutation(c.config, OpUpdateOne, withTransaction(_m))
	return &TransactionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *TransactionClient) UpdateOneID(id int) *TransactionUpdateOne {
	mutation := newTransactionMutation(c.config, OpUpdateOne, withTransactionID(id))
	return &TransactionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Transaction.
func (c *TransactionClient) Delete() *TransactionDelete {
	mutation := newTransactionMutation(c.config, OpDelete)
	return &TransactionDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *TransactionClient) DeleteOne(_m *Transaction) *TransactionDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *TransactionClient) DeleteOneID(id int) *TransactionDeleteOne {
	builder := c.Delete().Where(transaction.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &TransactionDeleteOne{builder}
}

// Query returns a query builder for Transaction.
func (c *TransactionClient) Query() *TransactionQuery {
	return &TransactionQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeTransaction},
		inters: c.Interceptors(),
	}
}

// Get returns a Transaction entity by its id.
func (c *TransactionClient) Get(ctx context.Context, id int) (*Transaction, error) {
	return c.Query().Where(transaction.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *TransactionClient) GetX(ctx context.Context, id int) *Transaction {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryTenant queries the tenant edge of a Transaction.
func (c *TransactionClient) QueryTenant(_m *Transaction) *TenantQuery {
	query := (&TenantClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(transaction.Table, transaction.FieldID, id),
			sqlgraph.To(tenant.Table, tenant.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, transaction.TenantTable, transaction.TenantColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryLedgerEntries queries the ledger_entries edge of a Transaction.
func (c *TransactionClient) QueryLedgerEntries(_m *Transaction) *LedgerEntryQuery {
	query := (&LedgerEntryClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(transaction.Table, transaction.FieldID, id),
			sqlgraph.To(ledgerentry.Table, ledgerentry.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, transaction.LedgerEntriesTable, transaction.LedgerEntriesColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryJournalEntries queries the journal_entries edge of a Transaction.
func (c *TransactionClient) QueryJournalEntries(_m *Transaction) *JournalEntryQuery {
	query := (&JournalEntryClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(transaction.Table, transaction.FieldID, id),
			sqlgraph.To(journalentry.Table, journalentry.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, transaction.JournalEntriesTable, transaction.JournalEntriesColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryRecording queries the recording edge of a Transaction.
func (c *TransactionClient) QueryRecording(_m *Transaction) *RecordingQuery {
	query := (&RecordingClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(transaction.Table, transaction.FieldID, id),
			sqlgraph.To(recording.Table, recording.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, transaction.RecordingTable, transaction.RecordingColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryApprovedBy queries the approved_by edge of a Transaction.
func (c *TransactionClient) QueryApprovedBy(_m *Transaction) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(transaction.Table, transaction.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, transaction.ApprovedByTable, transaction.ApprovedByColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *TransactionClient) Hooks() []Hook {
	return c.hooks.Transaction
}

// Interceptors returns the client interceptors.
func (c *TransactionClient) Interceptors() []Interceptor {
	return c.inters.Transaction
}

func (c *TransactionClient) mutate(ctx context.Context, m *TransactionMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&TransactionCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&TransactionUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&TransactionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&TransactionDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Transaction mutation op: %q", m.Op())
	}
}

// UserClient is a client for the User schema.
type UserClient struct {
	config
}

// NewUserClient returns a client for the User from the given config.
func NewUserClient(c config) *UserClient {
	return &UserClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `user.Hooks(f(g(h())))`.
func (c *UserClient) Use(hooks ...Hook) {
	c.hooks.User = append(c.hooks.User, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `user.Intercept(f(g(h())))`.
func (c *UserClient) Intercept(interceptors ...Interceptor) {
	c.inters.User = append(c.inters.User, interceptors...)
}

// Create returns a builder for creating a User entity.
func (c *UserClient) Create() *UserCreate {
	mutation := newUserMutation(c.config, OpCreate)
	return &UserCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of User entities.
func (c *UserClient) CreateBulk(builders ...*UserCreate) *UserCreateBulk {
	return &UserCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *UserClient) MapCreateBulk(slice any, setFunc func(*UserCreate, int)) *UserCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &UserCreateBulk{err: fmt.Errorf("calling to UserClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*UserCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &UserCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for User.
func (c *UserClient) Update() *UserUpdate {
	mutation := newUserMutation(c.config, OpUpdate)
	return &UserUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *UserClient) UpdateOne(_m *User) *UserUpdateOne {
	mutation := newUserMutation(c.config, OpUpdateOne, withUser(_m))
	return &UserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *UserClient) UpdateOneID(id int) *UserUpdateOne {
	mutation := newUserMutation(c.config, OpUpdateOne, withUserID(id))
	return &UserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for User.
func (c *UserClient) Delete() *UserDelete {
	mutation := newUserMutation(c.config, OpDelete)
	return &UserDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *UserClient) DeleteOne(_m *User) *UserDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *UserClient) DeleteOneID(id int) *UserDeleteOne {
	builder := c.Delete().Where(user.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &UserDeleteOne{builder}
}

// Query returns a query builder for User.
func (c *UserClient) Query() *UserQuery {
	return &UserQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeUser},
		inters: c.Interceptors(),
	}
}

// Get returns a User entity by its id.
func (c *UserClient) Get(ctx context.Context, id int) (*User, error) {
	return c.Query().Where(user.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *UserClient) GetX(ctx context.Context, id int) *User {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryTenant queries the tenant edge of a User.
func (c *UserClient) QueryTenant(_m *User) *TenantQuery {
	query := (&TenantClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(tenant.Table, tenant.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, user.TenantTable, user.TenantColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryPermissions queries the permissions edge of a User.
func (c *UserClient) QueryPermissions(_m *User) *PermissionQuery {
	query := (&PermissionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(permission.Table, permission.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, user.PermissionsTable, user.PermissionsPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryRequestedTickets queries the requested_tickets edge of a User.
func (c *UserClient) QueryRequestedTickets(_m *User) *TicketQuery {
	query := (&TicketClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(ticket.Table, ticket.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.RequestedTicketsTable, user.RequestedTicketsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryAssignedTickets queries the assigned_tickets edge of a User.
func (c *UserClient) QueryAssignedTickets(_m *User) *TicketQuery {
	query := (&TicketClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(ticket.Table, ticket.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.AssignedTicketsTable, user.AssignedTicketsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTimeEntries queries the time_entries edge of a User.
func (c *UserClient) QueryTimeEntries(_m *User) *TimeEntryQuery {
	query := (&TimeEntryClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(timeentry.Table, timeentry.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.TimeEntriesTable, user.TimeEntriesColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryOwnedAssets queries the owned_assets edge of a User.
func (c *UserClient) QueryOwnedAssets(_m *User) *AssetQuery {
	query := (&AssetClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(asset.Table, asset.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.OwnedAssetsTable, user.OwnedAssetsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryAuthoredSops queries the authored_sops edge of a User.
func (c *UserClient) QueryAuthoredSops(_m *User) *SOPQuery {
	query := (&SOPClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(sop.Table, sop.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.AuthoredSopsTable, user.AuthoredSopsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCallLogs queries the call_logs edge of a User.
func (c *UserClient) QueryCallLogs(_m *User) *CallLogQuery {
	query := (&CallLogClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(calllog.Table, calllog.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.CallLogsTable, user.CallLogsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryVoicemails queries the voicemails edge of a User.
func (c *UserClient) QueryVoicemails(_m *User) *VoicemailQuery {
	query := (&VoicemailClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(voicemail.Table, voicemail.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.VoicemailsTable, user.VoicemailsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QuerySaasIdentities queries the saas_identities edge of a User.
func (c *UserClient) QuerySaasIdentities(_m *User) *SaaSIdentityQuery {
	query := (&SaaSIdentityClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(saasidentity.Table, saasidentity.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.SaasIdentitiesTable, user.SaasIdentitiesColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *UserClient) Hooks() []Hook {
	return c.hooks.User
}

// Interceptors returns the client interceptors.
func (c *UserClient) Interceptors() []Interceptor {
	return c.inters.User
}

func (c *UserClient) mutate(ctx context.Context, m *UserMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&UserCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&UserUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&UserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&UserDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown User mutation op: %q", m.Op())
	}
}

// VaultItemClient is a client for the VaultItem schema.
type VaultItemClient struct {
	config
}

// NewVaultItemClient returns a client for the VaultItem from the given config.
func NewVaultItemClient(c config) *VaultItemClient {
	return &VaultItemClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `vaultitem.Hooks(f(g(h())))`.
func (c *VaultItemClient) Use(hooks ...Hook) {
	c.hooks.VaultItem = append(c.hooks.VaultItem, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `vaultitem.Intercept(f(g(h())))`.
func (c *VaultItemClient) Intercept(interceptors ...Interceptor) {
	c.inters.VaultItem = append(c.inters.VaultItem, interceptors...)
}

// Create returns a builder for creating a VaultItem entity.
func (c *VaultItemClient) Create() *VaultItemCreate {
	mutation := newVaultItemMutation(c.config, OpCreate)
	return &VaultItemCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of VaultItem entities.
func (c *VaultItemClient) CreateBulk(builders ...*VaultItemCreate) *VaultItemCreateBulk {
	return &VaultItemCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *VaultItemClient) MapCreateBulk(slice any, setFunc func(*VaultItemCreate, int)) *VaultItemCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &VaultItemCreateBulk{err: fmt.Errorf("calling to VaultItemClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*VaultItemCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &VaultItemCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for VaultItem.
func (c *VaultItemClient) Update() *VaultItemUpdate {
	mutation := newVaultItemMutation(c.config, OpUpdate)
	return &VaultItemUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *VaultItemClient) UpdateOne(_m *VaultItem) *VaultItemUpdateOne {
	mutation := newVaultItemMutation(c.config, OpUpdateOne, withVaultItem(_m))
	return &VaultItemUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *VaultItemClient) UpdateOneID(id int) *VaultItemUpdateOne {
	mutation := newVaultItemMutation(c.config, OpUpdateOne, withVaultItemID(id))
	return &VaultItemUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for VaultItem.
func (c *VaultItemClient) Delete() *VaultItemDelete {
	mutation := newVaultItemMutation(c.config, OpDelete)
	return &VaultItemDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *VaultItemClient) DeleteOne(_m *VaultItem) *VaultItemDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *VaultItemClient) DeleteOneID(id int) *VaultItemDeleteOne {
	builder := c.Delete().Where(vaultitem.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &VaultItemDeleteOne{builder}
}

// Query returns a query builder for VaultItem.
func (c *VaultItemClient) Query() *VaultItemQuery {
	return &VaultItemQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeVaultItem},
		inters: c.Interceptors(),
	}
}

// Get returns a VaultItem entity by its id.
func (c *VaultItemClient) Get(ctx context.Context, id int) (*VaultItem, error) {
	return c.Query().Where(vaultitem.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *VaultItemClient) GetX(ctx context.Context, id int) *VaultItem {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryTenant queries the tenant edge of a VaultItem.
func (c *VaultItemClient) QueryTenant(_m *VaultItem) *TenantQuery {
	query := (&TenantClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(vaultitem.Table, vaultitem.FieldID, id),
			sqlgraph.To(tenant.Table, tenant.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, vaultitem.TenantTable, vaultitem.TenantColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *VaultItemClient) Hooks() []Hook {
	return c.hooks.VaultItem
}

// Interceptors returns the client interceptors.
func (c *VaultItemClient) Interceptors() []Interceptor {
	return c.inters.VaultItem
}

func (c *VaultItemClient) mutate(ctx context.Context, m *VaultItemMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&VaultItemCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&VaultItemUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&VaultItemUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&VaultItemDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown VaultItem mutation op: %q", m.Op())
	}
}

// VoicemailClient is a client for the Voicemail schema.
type VoicemailClient struct {
	config
}

// NewVoicemailClient returns a client for the Voicemail from the given config.
func NewVoicemailClient(c config) *VoicemailClient {
	return &VoicemailClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `voicemail.Hooks(f(g(h())))`.
func (c *VoicemailClient) Use(hooks ...Hook) {
	c.hooks.Voicemail = append(c.hooks.Voicemail, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `voicemail.Intercept(f(g(h())))`.
func (c *VoicemailClient) Intercept(interceptors ...Interceptor) {
	c.inters.Voicemail = append(c.inters.Voicemail, interceptors...)
}

// Create returns a builder for creating a Voicemail entity.
func (c *VoicemailClient) Create() *VoicemailCreate {
	mutation := newVoicemailMutation(c.config, OpCreate)
	return &VoicemailCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Voicemail entities.
func (c *VoicemailClient) CreateBulk(builders ...*VoicemailCreate) *VoicemailCreateBulk {
	return &VoicemailCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *VoicemailClient) MapCreateBulk(slice any, setFunc func(*VoicemailCreate, int)) *VoicemailCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &VoicemailCreateBulk{err: fmt.Errorf("calling to VoicemailClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*VoicemailCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &VoicemailCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Voicemail.
func (c *VoicemailClient) Update() *VoicemailUpdate {
	mutation := newVoicemailMutation(c.config, OpUpdate)
	return &VoicemailUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *VoicemailClient) UpdateOne(_m *Voicemail) *VoicemailUpdateOne {
	mutation := newVoicemailMutation(c.config, OpUpdateOne, withVoicemail(_m))
	return &VoicemailUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *VoicemailClient) UpdateOneID(id int) *VoicemailUpdateOne {
	mutation := newVoicemailMutation(c.config, OpUpdateOne, withVoicemailID(id))
	return &VoicemailUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Voicemail.
func (c *VoicemailClient) Delete() *VoicemailDelete {
	mutation := newVoicemailMutation(c.config, OpDelete)
	return &VoicemailDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *VoicemailClient) DeleteOne(_m *Voicemail) *VoicemailDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *VoicemailClient) DeleteOneID(id int) *VoicemailDeleteOne {
	builder := c.Delete().Where(voicemail.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &VoicemailDeleteOne{builder}
}

// Query returns a query builder for Voicemail.
func (c *VoicemailClient) Query() *VoicemailQuery {
	return &VoicemailQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeVoicemail},
		inters: c.Interceptors(),
	}
}

// Get returns a Voicemail entity by its id.
func (c *VoicemailClient) Get(ctx context.Context, id int) (*Voicemail, error) {
	return c.Query().Where(voicemail.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *VoicemailClient) GetX(ctx context.Context, id int) *Voicemail {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryTenant queries the tenant edge of a Voicemail.
func (c *VoicemailClient) QueryTenant(_m *Voicemail) *TenantQuery {
	query := (&TenantClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(voicemail.Table, voicemail.FieldID, id),
			sqlgraph.To(tenant.Table, tenant.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, voicemail.TenantTable, voicemail.TenantColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryUser queries the user edge of a Voicemail.
func (c *VoicemailClient) QueryUser(_m *Voicemail) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(voicemail.Table, voicemail.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, voicemail.UserTable, voicemail.UserColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *VoicemailClient) Hooks() []Hook {
	return c.hooks.Voicemail
}

// Interceptors returns the client interceptors.
func (c *VoicemailClient) Interceptors() []Interceptor {
	return c.inters.Voicemail
}

func (c *VoicemailClient) mutate(ctx context.Context, m *VoicemailMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&VoicemailCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&VoicemailUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&VoicemailUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&VoicemailDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Voicemail mutation op: %q", m.Op())
	}
}

// hooks and interceptors per client, for fast access.
type (
	hooks struct {
		Account, Agent, Asset, AssetType, AuditLog, BudgetForecast, CallLog, Camera,
		CompensationAgreement, Contract, Credential, Department, DetectionEvent,
		DiscoveryEntry, Employee, Goal, HealthScoreSnapshot, IVRFlow,
		InventoryReservation, Job, JobExecution, JournalEntry, LedgerEntry,
		NetworkBackup, NetworkDevice, NetworkLink, NetworkPort, NexusAudit,
		OneTimeLink, PerformanceReview, Permission, Product, Recording,
		RecurringInvoice, RemediationStep, ReviewCycle, SOP, SaaSApp, SaaSFilter,
		SaaSIdentity, SaaSUsage, Script, ServiceRate, StockMovement, StrategicRoadmap,
		SuccessionMap, Tenant, Ticket, TimeEntry, TimeOffBalance, TimeOffPolicy,
		TimeOffRequest, Transaction, User, VaultItem, Voicemail []ent.Hook
	}
	inters struct {
		Account, Agent, Asset, AssetType, AuditLog, BudgetForecast, CallLog, Camera,
		CompensationAgreement, Contract, Credential, Department, DetectionEvent,
		DiscoveryEntry, Employee, Goal, HealthScoreSnapshot, IVRFlow,
		InventoryReservation, Job, JobExecution, JournalEntry, LedgerEntry,
		NetworkBackup, NetworkDevice, NetworkLink, NetworkPort, NexusAudit,
		OneTimeLink, PerformanceReview, Permission, Product, Recording,
		RecurringInvoice, RemediationStep, ReviewCycle, SOP, SaaSApp, SaaSFilter,
		SaaSIdentity, SaaSUsage, Script, ServiceRate, StockMovement, StrategicRoadmap,
		SuccessionMap, Tenant, Ticket, TimeEntry, TimeOffBalance, TimeOffPolicy,
		TimeOffRequest, Transaction, User, VaultItem, Voicemail []ent.Interceptor
	}
)
