// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: list_tickets.sql

package pilotdb

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const listTickets = `-- name: ListTickets :many
SELECT
    t.id,
    t.subject,
    t.description,
    t.status,
    t.priority,
    t.created_at,
    t.deep_link,
    t.execution_plan,
    u1.email as requester_email,
    u2.email as assignee_email,
    a.name as asset_name
FROM
    tickets t
    LEFT JOIN users u1 ON t.requester_id = u1.id
    LEFT JOIN users u2 ON t.assignee_id = u2.id
    LEFT JOIN assets a ON t.asset_id = a.id
WHERE
    t.tenant_id = $1
ORDER BY
    CASE t.priority
        WHEN 'P1' THEN 1
        WHEN 'P2' THEN 2
        WHEN 'P3' THEN 3
        ELSE 4
    END
`

type ListTicketsRow struct {
	ID             int32              `json:"id"`
	Subject        string             `json:"subject"`
	Description    pgtype.Text        `json:"description"`
	Status         pgtype.Text        `json:"status"`
	Priority       pgtype.Text        `json:"priority"`
	CreatedAt      pgtype.Timestamptz `json:"created_at"`
	DeepLink       pgtype.Text        `json:"deep_link"`
	ExecutionPlan  []byte             `json:"execution_plan"`
	RequesterEmail pgtype.Text        `json:"requester_email"`
	AssigneeEmail  pgtype.Text        `json:"assignee_email"`
	AssetName      pgtype.Text        `json:"asset_name"`
}

func (q *Queries) ListTickets(ctx context.Context, tenantID int32) ([]ListTicketsRow, error) {
	rows, err := q.db.Query(ctx, listTickets, tenantID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListTicketsRow
	for rows.Next() {
		var i ListTicketsRow
		if err := rows.Scan(
			&i.ID,
			&i.Subject,
			&i.Description,
			&i.Status,
			&i.Priority,
			&i.CreatedAt,
			&i.DeepLink,
			&i.ExecutionPlan,
			&i.RequesterEmail,
			&i.AssigneeEmail,
			&i.AssetName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
