// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: list_jobs.sql

package pulsedb

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const listJobs = `-- name: ListJobs :many
SELECT j.id, j.tenant_id, j.name, j.script_id, j.targets, j.cron_schedule, j.next_run, j.created_at, j.updated_at, s.name as script_name
FROM jobs j
    JOIN scripts s ON j.script_id = s.id
ORDER BY j.created_at DESC
`

type ListJobsRow struct {
	ID           int32              `json:"id"`
	TenantID     int32              `json:"tenant_id"`
	Name         string             `json:"name"`
	ScriptID     int32              `json:"script_id"`
	Targets      []string           `json:"targets"`
	CronSchedule pgtype.Text        `json:"cron_schedule"`
	NextRun      pgtype.Timestamptz `json:"next_run"`
	CreatedAt    pgtype.Timestamptz `json:"created_at"`
	UpdatedAt    pgtype.Timestamptz `json:"updated_at"`
	ScriptName   string             `json:"script_name"`
}

func (q *Queries) ListJobs(ctx context.Context) ([]ListJobsRow, error) {
	rows, err := q.db.Query(ctx, listJobs)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListJobsRow
	for rows.Next() {
		var i ListJobsRow
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.Name,
			&i.ScriptID,
			&i.Targets,
			&i.CronSchedule,
			&i.NextRun,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ScriptName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
